---
title: Visual Basic における配列
ms.date: 12/06/2017
f1_keywords:
- vb.Array
helpviewer_keywords:
- arrays [Visual Basic]
- Visual Basic, arrays
ms.assetid: dbf29737-b589-4443-bee6-a27588d9c67e
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 3b6c1db0131f2a150dc1b00dd5e6dafc3a418f05
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/04/2018
---
# <a name="arrays-in-visual-basic"></a><span data-ttu-id="7c364-102">Visual Basic における配列</span><span class="sxs-lookup"><span data-stu-id="7c364-102">Arrays in Visual Basic</span></span>
<span data-ttu-id="7c364-103">配列と呼ばれるものの値のセットとは、*要素*、互いに論理的に関連します。</span><span class="sxs-lookup"><span data-stu-id="7c364-103">An array is a set of values, which are termed *elements*, that are logically related to each other.</span></span> <span data-ttu-id="7c364-104">たとえば、配列で構成されます; 学校の各学年の生徒の数配列の各要素は、1 つ学年の生徒の数です。</span><span class="sxs-lookup"><span data-stu-id="7c364-104">For example, an array may consist of the number of students in each grade in a grammar school; each element of the array is the number of students in a single grade.</span></span> <span data-ttu-id="7c364-105">同様に、配列が、クラスの学生の成績のあります。配列の各要素は、1 つのレベルです。</span><span class="sxs-lookup"><span data-stu-id="7c364-105">Similarly, an array may consist of a student's grades for a class; each element of the array is a single grade.</span></span>    

<span data-ttu-id="7c364-106">各データ項目を格納するそれぞれの変数は可能です。</span><span class="sxs-lookup"><span data-stu-id="7c364-106">It is possible individual variables to store each of our data items.</span></span> <span data-ttu-id="7c364-107">たとえば、アプリケーションは、学生の成績を分析し場合、お個別の変数付け、学生の成績のなど、使用できる`englishGrade1`、 `englishGrade2`, などです。この方法では、次の 3 つの主要な制限があります。</span><span class="sxs-lookup"><span data-stu-id="7c364-107">For example, if our application analyzes student grades, we can use a separate variable for each student's grade, such as `englishGrade1`, `englishGrade2`, etc. This approach has three major limitations:</span></span>
- <span data-ttu-id="7c364-108">成績の数だけを処理する必要はデザイン時に把握お必要があります。</span><span class="sxs-lookup"><span data-stu-id="7c364-108">We have to know at design time exactly how many grades we have to handle.</span></span>
- <span data-ttu-id="7c364-109">多数の成績をすばやく処理は、扱いにくくなります。</span><span class="sxs-lookup"><span data-stu-id="7c364-109">Handling large numbers of grades quickly becomes unwieldy.</span></span> <span data-ttu-id="7c364-110">これは、結果、アプリケーションが深刻なバグが存在する可能性が高くなります。</span><span class="sxs-lookup"><span data-stu-id="7c364-110">This in turn makes an application much more likely to have serious bugs.</span></span>
- <span data-ttu-id="7c364-111">維持するために困難です。</span><span class="sxs-lookup"><span data-stu-id="7c364-111">It is difficult to maintain.</span></span> <span data-ttu-id="7c364-112">新しい各学年を追加するには、こと、アプリケーションを変更が再コンパイルして再展開が必要です。</span><span class="sxs-lookup"><span data-stu-id="7c364-112">Each new grade that we add requires that the application be modified, recompiled, and redeployed.</span></span>  
 
 <span data-ttu-id="7c364-113">配列を使用すると、これらの関連する値を同じ名前で参照およびと呼ばれる番号を使用して、*インデックス*または*添字*を配列内の位置に基づいて、個々 の要素を識別します。</span><span class="sxs-lookup"><span data-stu-id="7c364-113">By using an array, you can refer to these related values by the same name, and use a number that’s called an *index* or *subscript* to identify an individual element based on its position in the array.</span></span> <span data-ttu-id="7c364-114">配列内の要素の合計数より 1 小さい値に 0 の配列範囲のインデックス。</span><span class="sxs-lookup"><span data-stu-id="7c364-114">The indexes of an array range from 0 to one less than the total number of elements in the array.</span></span> <span data-ttu-id="7c364-115">配列のサイズを定義する Visual Basic 構文を使用する場合は、最高のインデックス、配列内の要素の合計数されませんを指定します。</span><span class="sxs-lookup"><span data-stu-id="7c364-115">When you use Visual Basic syntax to define the size of an array, you specify its highest index, not the total number of elements in the array.</span></span> <span data-ttu-id="7c364-116">単位として配列を使用することができ、その要素を反復処理する機能を正確にデザイン時に含まれている数の要素を把握しておかなくてから解放します。</span><span class="sxs-lookup"><span data-stu-id="7c364-116">You can work with the array as a unit, and the ability to iterate its elements frees you from needing to know exactly how many elements it contains at design time.</span></span>
  
 <span data-ttu-id="7c364-117">説明する前に、簡単な例をいくつか紹介します。</span><span class="sxs-lookup"><span data-stu-id="7c364-117">Some quick examples before explanation:</span></span>  
  
```vb  
' Declare a single-dimension array of 5 numbers.  
Dim numbers(4) As Integer   
  
'Declare a single-dimension array and set its 4 values.  
Dim numbers = New Integer() {1, 2, 4, 8}  
  
' Change the size of an existing array to 16 elements and retain the current values.
ReDim Preserve numbers(15)
  
' Redefine the size of an existing array and reset the values.
ReDim numbers(15)  
  
' Declare a 6 x 6 multidimensional array.
Dim matrix(5, 5) As Double  
  
' Declare a 4 x 3 multidimensional array and set array element values.  
Dim matrix = New Integer(3, 2) {{1, 2, 3}, {2, 3, 4}, {3, 4, 5}, {4, 5, 6}}  
  
' Declare a jagged array  
Dim sales()() As Double = New Double(11)() {}  
```  
  
 ## <a name="in-this-article"></a><span data-ttu-id="7c364-118">この記事の内容</span><span class="sxs-lookup"><span data-stu-id="7c364-118">In this article</span></span>
  
- [<span data-ttu-id="7c364-119">単純な配列の配列要素</span><span class="sxs-lookup"><span data-stu-id="7c364-119">Array elements in a simple array</span></span>](#array-elements-in-a-simple-array)  
  
- [<span data-ttu-id="7c364-120">配列の作成</span><span class="sxs-lookup"><span data-stu-id="7c364-120">Creating an array</span></span>](#creating-an-array)  
  
- [<span data-ttu-id="7c364-121">配列内の値を格納します。</span><span class="sxs-lookup"><span data-stu-id="7c364-121">Storing values in an array</span></span>](#storing-values-in-an-array)  
  
- [<span data-ttu-id="7c364-122">配列リテラルを含む配列を設定します。</span><span class="sxs-lookup"><span data-stu-id="7c364-122">Populating an array with array literals</span></span>](#populating-an-array-with-array-literals)  
  
- [<span data-ttu-id="7c364-123">配列を反復処理します。</span><span class="sxs-lookup"><span data-stu-id="7c364-123">Iterating through an array</span></span>](#iterating-through-an-array)  
  
- [<span data-ttu-id="7c364-124">配列のサイズ</span><span class="sxs-lookup"><span data-stu-id="7c364-124">Array size</span></span>](#BKMK_ArraySize)  

- [<span data-ttu-id="7c364-125">配列の型</span><span class="sxs-lookup"><span data-stu-id="7c364-125">The array type</span></span>](#the-array-type)  
  
- [<span data-ttu-id="7c364-126">戻り値およびパラメーターとしての配列</span><span class="sxs-lookup"><span data-stu-id="7c364-126">Arrays as return values and parameters</span></span>](#arrays-as-return-values-and-parameters)  
- [<span data-ttu-id="7c364-127">ジャグ配列</span><span class="sxs-lookup"><span data-stu-id="7c364-127">Jagged arrays</span></span>](#jagged-arrays)  
  
- [<span data-ttu-id="7c364-128">長さ 0 の配列</span><span class="sxs-lookup"><span data-stu-id="7c364-128">Zero-length arrays</span></span>](#zero-length-arrays)  

- [<span data-ttu-id="7c364-129">配列の分割</span><span class="sxs-lookup"><span data-stu-id="7c364-129">Splitting an array</span></span>](#splitting-an-array)
  
- [<span data-ttu-id="7c364-130">配列の代わりとしてのコレクション</span><span class="sxs-lookup"><span data-stu-id="7c364-130">Collections as an alternative to arrays</span></span>](#collections-as-an-alternative-to-arrays)  
  
##  <a name="array-elements-in-a-simple-array"></a><span data-ttu-id="7c364-131">単純な配列の配列要素</span><span class="sxs-lookup"><span data-stu-id="7c364-131">Array elements in a simple array</span></span>  

<span data-ttu-id="7c364-132">という名前の配列を作成しましょう`students`学校の各学年の生徒の数を格納します。</span><span class="sxs-lookup"><span data-stu-id="7c364-132">Let's create an array named `students` to store the number of students in each grade in a grammar school.</span></span> <span data-ttu-id="7c364-133">要素のインデックスの範囲は 0 から 6 までです。</span><span class="sxs-lookup"><span data-stu-id="7c364-133">The indexes of the elements range from 0 through 6.</span></span> <span data-ttu-id="7c364-134">この配列を使用することは、7 つの変数を宣言するよりも簡単です。</span><span class="sxs-lookup"><span data-stu-id="7c364-134">Using this array is simpler than declaring seven variables.</span></span>

<span data-ttu-id="7c364-135">次の図は、`students`配列。</span><span class="sxs-lookup"><span data-stu-id="7c364-135">The following illustration shows the `students` array.</span></span> <span data-ttu-id="7c364-136">配列の各要素は、次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="7c364-136">For each element of the array:</span></span>  
  
-   <span data-ttu-id="7c364-137">要素のインデックスは、学年を表します (インデックス 0 は幼稚園を表します)。</span><span class="sxs-lookup"><span data-stu-id="7c364-137">The index of the element represents the grade (index 0 represents kindergarten).</span></span>
  
-   <span data-ttu-id="7c364-138">要素に含まれている値は、その学年の生徒の数を表します。</span><span class="sxs-lookup"><span data-stu-id="7c364-138">The value that’s contained in the element represents the number of students in that grade.</span></span>
  
 <span data-ttu-id="7c364-139">![生徒数を示す配列の図](../../../../visual-basic/programming-guide/language-features/arrays/media/arrayexampleschool.gif "ArrayExampleSchool")</span><span class="sxs-lookup"><span data-stu-id="7c364-139">![Picture of array showing numbers of students](../../../../visual-basic/programming-guide/language-features/arrays/media/arrayexampleschool.gif "ArrayExampleSchool")</span></span>  
<span data-ttu-id="7c364-140">"生徒" 配列の要素</span><span class="sxs-lookup"><span data-stu-id="7c364-140">Elements of the "students" array</span></span>  
 
<span data-ttu-id="7c364-141">次の例には、作成し、配列を使用している Visual Basic コードが含まれています。</span><span class="sxs-lookup"><span data-stu-id="7c364-141">The following example contains the Visual Basic code that creates and uses the array:</span></span>

 [!code-vb[simple-array](../../../../../samples/snippets/visualbasic/programming-guide/language-features/arrays/simple-array.vb)]  

<span data-ttu-id="7c364-142">この例では、次の 3 つをは。</span><span class="sxs-lookup"><span data-stu-id="7c364-142">The example does three things:</span></span>

- <span data-ttu-id="7c364-143">宣言して、 `students` 7 つの要素を持つ配列です。</span><span class="sxs-lookup"><span data-stu-id="7c364-143">It declares a `students` array with seven elements.</span></span> <span data-ttu-id="7c364-144">数`6`配列では、宣言は、配列内の最後のインデックスをことを示します。 これは 1 つの配列内の要素数よりも小さいです。</span><span class="sxs-lookup"><span data-stu-id="7c364-144">The number `6` in the array declaration indicates the last index in the array; it is one less than the number of elements in the array.</span></span>
- <span data-ttu-id="7c364-145">配列内の各要素に値を割り当てます。</span><span class="sxs-lookup"><span data-stu-id="7c364-145">It assigns values to each element in the array.</span></span> <span data-ttu-id="7c364-146">配列要素にはかっこで囲まれた個々 の要素のインデックスを含むを配列の名前を使用してアクセスします。</span><span class="sxs-lookup"><span data-stu-id="7c364-146">Array elements are accessed by using the array name and including the index of the individual element in parentheses.</span></span>
- <span data-ttu-id="7c364-147">これには、配列の各値が表示されます。</span><span class="sxs-lookup"><span data-stu-id="7c364-147">It lists each value of the array.</span></span> <span data-ttu-id="7c364-148">この例では、 [ `For` ](../../../language-reference/statements/for-next-statement.md)インデックス番号で、配列の各要素にアクセスするステートメント。</span><span class="sxs-lookup"><span data-stu-id="7c364-148">The example uses a [`For`](../../../language-reference/statements/for-next-statement.md) statement to access each element of the array by its index number.</span></span>
  
 <span data-ttu-id="7c364-149">`students` 1 つのインデックスを使用しているために、前の例での配列は 1 次元配列。</span><span class="sxs-lookup"><span data-stu-id="7c364-149">The `students` array in the preceding example is a one-dimensional array because it uses one index.</span></span> <span data-ttu-id="7c364-150">1 つ以上のインデックスまたは添字を使用する配列と呼びます*多次元*です。</span><span class="sxs-lookup"><span data-stu-id="7c364-150">An array that uses more than one index or subscript is called *multidimensional*.</span></span> <span data-ttu-id="7c364-151">詳細については、この記事の残りを表示および[Visual Basic における配列の次元](../../../../visual-basic/programming-guide/language-features/arrays/array-dimensions.md)です。</span><span class="sxs-lookup"><span data-stu-id="7c364-151">For more information, see the rest of this article and [Array Dimensions in Visual Basic](../../../../visual-basic/programming-guide/language-features/arrays/array-dimensions.md).</span></span>  
  
##  <a name="creating-an-array"></a><span data-ttu-id="7c364-152">配列の作成</span><span class="sxs-lookup"><span data-stu-id="7c364-152">Creating an Array</span></span>  
 
<span data-ttu-id="7c364-153">いくつかの方法では、配列のサイズを定義できます。</span><span class="sxs-lookup"><span data-stu-id="7c364-153">You can define the size of an array in several ways:</span></span> 

- <span data-ttu-id="7c364-154">配列が宣言されている場合は、サイズを指定できます。</span><span class="sxs-lookup"><span data-stu-id="7c364-154">You can specify the size when the array is declared:</span></span>
  
    [!code-vb[creating1](../../../../../samples/snippets/visualbasic/programming-guide/language-features/arrays/create-array.vb#1)]  
  
 - <span data-ttu-id="7c364-155">使用することができます、`New`句を作成するときに、配列のサイズを指定します。</span><span class="sxs-lookup"><span data-stu-id="7c364-155">You can use a `New` clause to supply the size of an array when it’s created:</span></span>  
  
    [!code-vb[creating2](../../../../../samples/snippets/visualbasic/programming-guide/language-features/arrays/create-array.vb#2)]  
  
 <span data-ttu-id="7c364-156">使用してサイズを再定義できる既存の配列があれば、 [ `Redim` ](../../../../visual-basic/language-reference/statements/redim-statement.md)ステートメントです。</span><span class="sxs-lookup"><span data-stu-id="7c364-156">If you have an existing array, you can redefine its size by using the [`Redim`](../../../../visual-basic/language-reference/statements/redim-statement.md) statement.</span></span> <span data-ttu-id="7c364-157">指定することができます、`Redim`ステートメントは、配列内に値を保持または空の配列を作成するを指定することができます。</span><span class="sxs-lookup"><span data-stu-id="7c364-157">You can specify that the `Redim` statement keep the values that are in the array, or you can specify that it create an empty array.</span></span> <span data-ttu-id="7c364-158">次に、 `Redim` ステートメントを使用して既存の配列のサイズを変更する例をいくつか示します。</span><span class="sxs-lookup"><span data-stu-id="7c364-158">The following example shows different uses of the `Redim` statement to modify the size of an existing array.</span></span>  
  
 [!code-vb[redimensioning](../../../../../samples/snippets/visualbasic/programming-guide/language-features/arrays/create-array.vb#3)]  
  
 <span data-ttu-id="7c364-159">詳細については、次を参照してください。、 [ReDim ステートメント](../../../../visual-basic/language-reference/statements/redim-statement.md)です。</span><span class="sxs-lookup"><span data-stu-id="7c364-159">For more information, see the [ReDim Statement](../../../../visual-basic/language-reference/statements/redim-statement.md).</span></span>  
  
##  <a name="storing-values-in-an-array"></a><span data-ttu-id="7c364-160">配列への値の格納</span><span class="sxs-lookup"><span data-stu-id="7c364-160">Storing Values in an Array</span></span>
 
 <span data-ttu-id="7c364-161">配列のそれぞれの位置には、`Integer` 型のインデックスを使用してアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="7c364-161">You can access each location in an array by using an index of type `Integer`.</span></span> <span data-ttu-id="7c364-162">かっこで囲まれたインデックスを使用して配列のそれぞれの位置を参照することで、配列の値を格納および取得することができます。</span><span class="sxs-lookup"><span data-stu-id="7c364-162">You can store and retrieve values in an array by referencing each array location by using its index enclosed in parentheses.</span></span> <span data-ttu-id="7c364-163">多次元配列のインデックスは、コンマ (,) で区切られます。</span><span class="sxs-lookup"><span data-stu-id="7c364-163">Indexes for multidimensional arrays are separated by commas (,).</span></span> <span data-ttu-id="7c364-164">配列の次元ごとに 1 つのインデックスが必要です。</span><span class="sxs-lookup"><span data-stu-id="7c364-164">You need one index for each array dimension.</span></span> 

<span data-ttu-id="7c364-165">次の例では、格納および配列の値を取得するステートメントを示します。</span><span class="sxs-lookup"><span data-stu-id="7c364-165">The following example shows some statements that store and retrieve values in arrays.</span></span>
  
 [!code-vb[store-and-retrieve](../../../../../samples/snippets/visualbasic/programming-guide/language-features/arrays/store-and-retrieve.vb)]  
  
## <a name="populating-an-array-with-array-literals"></a><span data-ttu-id="7c364-166">配列リテラルを含む配列を設定します。</span><span class="sxs-lookup"><span data-stu-id="7c364-166">Populating an array with array literals</span></span>
 <span data-ttu-id="7c364-167">配列リテラルを使用すると、同時に作成すること、初期値のセットを含む配列を設定できます。</span><span class="sxs-lookup"><span data-stu-id="7c364-167">By using an array literal, you can populate an array with an initial set of values at the same time that you create it.</span></span> <span data-ttu-id="7c364-168">配列リテラルは、中かっこ (`{}`) で囲んだ値のコンマ区切りの一覧で構成されます。</span><span class="sxs-lookup"><span data-stu-id="7c364-168">An array literal consists of a list of comma-separated values that are enclosed in braces (`{}`).</span></span>  
  
 <span data-ttu-id="7c364-169">配列リテラルを使用して配列を作成する場合、配列の型を指定するか、型の推定を使用して配列の型を決定することができます。</span><span class="sxs-lookup"><span data-stu-id="7c364-169">When you create an array by using an array literal, you can either supply the array type or use type inference to determine the array type.</span></span> <span data-ttu-id="7c364-170">次の例では、両方のオプションを示します。</span><span class="sxs-lookup"><span data-stu-id="7c364-170">The following example shows both options.</span></span>  
  
 [!code-vb[create-with-literals](../../../../../samples/snippets/visualbasic/programming-guide/language-features/arrays/create-array.vb#4)]  
  
 <span data-ttu-id="7c364-171">型推論を使用する場合、配列の型はによって決まります、*基準となる型*リテラル値の一覧にします。</span><span class="sxs-lookup"><span data-stu-id="7c364-171">When you use type inference, the type of the array is determined by the *dominant type* in the list of literal values.</span></span> <span data-ttu-id="7c364-172">主要な型を配列内の他のすべての型から拡大変換できる型です。</span><span class="sxs-lookup"><span data-stu-id="7c364-172">The dominant type is the type to which all other types in the array can widen.</span></span> <span data-ttu-id="7c364-173">この一意の型を特定できない場合、最も優先度の高い型は、配列内の他のすべての型から縮小変換できる一意の型になります。</span><span class="sxs-lookup"><span data-stu-id="7c364-173">If this unique type can’t be determined, the dominant type is the unique type to which all other types in the array can narrow.</span></span> <span data-ttu-id="7c364-174">これらの一意の型をどちらも特定できない場合は、 `Object`が最も優先度の高い型になります。</span><span class="sxs-lookup"><span data-stu-id="7c364-174">If neither of these unique types can be determined, the dominant type is `Object`.</span></span> <span data-ttu-id="7c364-175">たとえば、配列リテラルに指定された値の一覧に `Integer`型、 `Long`型、および `Double`型の値が含まれている場合、結果の配列の型は `Double`です。</span><span class="sxs-lookup"><span data-stu-id="7c364-175">For example, if the list of values that’s supplied to the array literal contains values of type `Integer`, `Long`, and `Double`, the resulting array is of type `Double`.</span></span> <span data-ttu-id="7c364-176">`Integer`と`Long`にのみ拡大変換`Double`、`Double`は、主要な型です。</span><span class="sxs-lookup"><span data-stu-id="7c364-176">Because `Integer` and `Long` widen only to `Double`, `Double` is the dominant type.</span></span> <span data-ttu-id="7c364-177">詳細については、「 [Widening and Narrowing Conversions](../../../../visual-basic/programming-guide/language-features/data-types/widening-and-narrowing-conversions.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="7c364-177">For more information, see [Widening and Narrowing Conversions](../../../../visual-basic/programming-guide/language-features/data-types/widening-and-narrowing-conversions.md).</span></span> 
 
> [!NOTE] 
> <span data-ttu-id="7c364-178">型のメンバーのローカル変数として定義されている配列に対してのみ型の推定を使用することができます。</span><span class="sxs-lookup"><span data-stu-id="7c364-178">You can use type inference only for arrays that are defined as local variables in a type member.</span></span> <span data-ttu-id="7c364-179">クラス レベルの配列リテラルで定義されている配列は型の場合は、明示的な型定義がない場合、`Object[]`です。</span><span class="sxs-lookup"><span data-stu-id="7c364-179">If an explicit type definition is absent, arrays defined with array literals at the class level are of type `Object[]`.</span></span> <span data-ttu-id="7c364-180">詳細については、次を参照してください。[ローカル型推論](../variables/local-type-inference.md)です。</span><span class="sxs-lookup"><span data-stu-id="7c364-180">For more information, see [Local type inference](../variables/local-type-inference.md).</span></span> 

<span data-ttu-id="7c364-181">前の例を定義する注`values`型の配列として`Double`場合でも、すべての配列リテラルが型`Integer`です。</span><span class="sxs-lookup"><span data-stu-id="7c364-181">Note that the previous example defines `values` as an array of type `Double` even though all the array literals are of type `Integer`.</span></span> <span data-ttu-id="7c364-182">この配列を作成するには、配列リテラル内の値に拡大変換することができますので`Double`値。</span><span class="sxs-lookup"><span data-stu-id="7c364-182">You can create this array because the values in the array literal can widen to `Double` values.</span></span> 
  
 <span data-ttu-id="7c364-183">作成しを使用して多次元配列を設定できます*配列リテラルを入れ子になった*です。</span><span class="sxs-lookup"><span data-stu-id="7c364-183">You can also create and populate a multidimensional array by using *nested array literals*.</span></span> <span data-ttu-id="7c364-184">入れ子になった配列リテラルには、次元数が、結果の配列と一致する必要があります。</span><span class="sxs-lookup"><span data-stu-id="7c364-184">Nested array literals must have a number of dimensions that’s consistent with the resulting array.</span></span> <span data-ttu-id="7c364-185">次の例では、入れ子になった配列リテラルを使用して整数の 2 次元配列を作成します。</span><span class="sxs-lookup"><span data-stu-id="7c364-185">The following example creates a two-dimensional array of integers by using nested array literals.</span></span>  
  
 [!code-vb[nested-array-literals](../../../../../samples/snippets/visualbasic/programming-guide/language-features/arrays/create-array.vb#5)]  
  
<span data-ttu-id="7c364-186">配列を作成し、入れ子になった配列リテラルを使用している場合は、入れ子になった配列リテラル内の要素の数が一致しない場合にエラーが発生します。</span><span class="sxs-lookup"><span data-stu-id="7c364-186">When using nested array literals to create and populate an array, an error occurs if the number of elements in the nested array literals don't match.</span></span> <span data-ttu-id="7c364-187">エラーは、明示的により、配列リテラルのディメンションの数が異なるを持つ配列変数を宣言する場合にも発生します。</span><span class="sxs-lookup"><span data-stu-id="7c364-187">An error also occurs if you explicitly declare the array variable to have a different number of dimensions than the array literals.</span></span> 
  
<span data-ttu-id="7c364-188">1 次元配列にすることができますと同様、入れ子になった配列リテラルに多次元配列を作成するときに型の推定に依存することができます。</span><span class="sxs-lookup"><span data-stu-id="7c364-188">Just as you can for one-dimensional arrays, you can rely on type inference when creating a multidimensional array with nested array literals.</span></span> <span data-ttu-id="7c364-189">推論された型は、主要な型のすべての入れ子レベルのすべての配列リテラル内のすべての値です。</span><span class="sxs-lookup"><span data-stu-id="7c364-189">The inferred type is the dominant type for all the values in all the array literals for all nesting level.</span></span> <span data-ttu-id="7c364-190">次の例では、型の 2 次元配列`Double[,]`は型の値から`Integer`と`Double`です。</span><span class="sxs-lookup"><span data-stu-id="7c364-190">The following example creates a two-dimensional array of type `Double[,]` from values that are of type `Integer` and `Double`.</span></span>  
  
 [!code-vb[nested-type-inference](../../../../../samples/snippets/visualbasic/programming-guide/language-features/arrays/create-array.vb#6)]  
  
 <span data-ttu-id="7c364-191">他の例については、「[方法: Visual Basic で配列変数を初期化する](../../../../visual-basic/programming-guide/language-features/arrays/how-to-initialize-an-array-variable.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="7c364-191">For additional examples, see [How to: Initialize an Array Variable in Visual Basic](../../../../visual-basic/programming-guide/language-features/arrays/how-to-initialize-an-array-variable.md).</span></span>  
  
##  <a name="iterating-through-an-array"></a><span data-ttu-id="7c364-192">配列を反復処理します。</span><span class="sxs-lookup"><span data-stu-id="7c364-192">Iterating through an array</span></span>  
 <span data-ttu-id="7c364-193">配列内の各要素にアクセスするまたは最高の値から最高の値を最小のインデックスから配列を反復処理するときに、最下位までです。</span><span class="sxs-lookup"><span data-stu-id="7c364-193">When you iterate through an array, you access each element in the array from the lowest index to the highest or from the highest to the lowest.</span></span> <span data-ttu-id="7c364-194">通常、使用をいずれも使用、[をしています.次のステートメントの](../../../../visual-basic/language-reference/statements/for-next-statement.md)または[ごとにしています.次のステートメントの](../../../../visual-basic/language-reference/statements/for-each-next-statement.md)配列の要素を反復処理します。</span><span class="sxs-lookup"><span data-stu-id="7c364-194">Typically, use use either the [For...Next Statement](../../../../visual-basic/language-reference/statements/for-next-statement.md) or the [For Each...Next Statement](../../../../visual-basic/language-reference/statements/for-each-next-statement.md) to iterate through the elements of an array.</span></span> <span data-ttu-id="7c364-195">配列の上限がわからない場合は、呼び出すことができます、<xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType>インデックスの最高値を取得します。</span><span class="sxs-lookup"><span data-stu-id="7c364-195">When you don't know the upper bounds of the array, you can call the <xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType> method to get the highest value of the index.</span></span> <span data-ttu-id="7c364-196">一番低いインデックス値がほとんど常に 0 を呼び出すことができます、<xref:System.Array.GetLowerBound%2A?displayProperty=nameWithType>インデックスの最小値を取得します。</span><span class="sxs-lookup"><span data-stu-id="7c364-196">Although lowest index value is almost always 0, you can call the <xref:System.Array.GetLowerBound%2A?displayProperty=nameWithType> method to get the lowest value of the index.</span></span>   
  
 <span data-ttu-id="7c364-197">次の例を使用して、1 次元配列を反復処理、 [ `For...Next` ](../../../../visual-basic/language-reference/statements/for-next-statement.md)ステートメントです。</span><span class="sxs-lookup"><span data-stu-id="7c364-197">The following example iterates through a one-dimensional array by using the [`For...Next`](../../../../visual-basic/language-reference/statements/for-next-statement.md) statement.</span></span> 
  
 [!code-vb[iterate-one-dimensional-array](../../../../../samples/snippets/visualbasic/programming-guide/language-features/arrays/iterate1d.vb)]  
  
 <span data-ttu-id="7c364-198">次の例を使用して、多次元配列を反復処理する[ `For...Next` ](../../../../visual-basic/language-reference/statements/for-next-statement.md)ステートメントです。</span><span class="sxs-lookup"><span data-stu-id="7c364-198">The following example iterates through a multidimensional array by using a [`For...Next`](../../../../visual-basic/language-reference/statements/for-next-statement.md) statement.</span></span> <span data-ttu-id="7c364-199"><xref:System.Array.GetUpperBound%2A> メソッドには、次元を指定するパラメーターがあります。</span><span class="sxs-lookup"><span data-stu-id="7c364-199">The <xref:System.Array.GetUpperBound%2A> method has a parameter that specifies the dimension.</span></span> <span data-ttu-id="7c364-200">`GetUpperBound(0)` 最初の次元のインデックスの最大値を返しますと`GetUpperBound(1)`2 番目の次元のインデックスの最大値を返します。</span><span class="sxs-lookup"><span data-stu-id="7c364-200">`GetUpperBound(0)` returns the highest index of the first dimension, and `GetUpperBound(1)` returns the highest index of the second dimension.</span></span>
  
 [!code-vb[iterate-two-dimensional-array](../../../../../samples/snippets/visualbasic/programming-guide/language-features/arrays/iterate2d.vb)]  
  
 <span data-ttu-id="7c364-201">次の例では、[ごとにしています.次のステートメントの](../../../../visual-basic/language-reference/statements/for-each-next-statement.md)1 次元配列と、2 次元の配列を反復処理します。</span><span class="sxs-lookup"><span data-stu-id="7c364-201">The following example uses a [For Each...Next Statement](../../../../visual-basic/language-reference/statements/for-each-next-statement.md)to iterate through a one-dimensional array and a two-dimensional array.</span></span>  
  
 [!code-vb[iterate-for-each-next](../../../../../samples/snippets/visualbasic/programming-guide/language-features/arrays/iterate-for-each-next.vb)]  
  
## <a name="array-size"></a><span data-ttu-id="7c364-202">配列のサイズ</span><span class="sxs-lookup"><span data-stu-id="7c364-202">Array Size</span></span>  

 <span data-ttu-id="7c364-203">配列のサイズは、そのすべての次元の長さの積です。</span><span class="sxs-lookup"><span data-stu-id="7c364-203">The size of an array is the product of the lengths of all its dimensions.</span></span> <span data-ttu-id="7c364-204">これは、現在配列に含まれている要素の総数を表します。</span><span class="sxs-lookup"><span data-stu-id="7c364-204">It represents the total number of elements currently contained in the array.</span></span>  <span data-ttu-id="7c364-205">たとえば、次の例では、各ディメンション内の 4 つの要素を持つ 2 次元配列を宣言します。</span><span class="sxs-lookup"><span data-stu-id="7c364-205">For example, the following example declares a 2-dimensional array with four elements in each dimension.</span></span> <span data-ttu-id="7c364-206">例の出力を示しています、配列のサイズは 16 (または (3 + 1) \* (3 + 1)。</span><span class="sxs-lookup"><span data-stu-id="7c364-206">As the output from the example shows, the array's size is 16 (or (3 + 1) \* (3 + 1).</span></span>

 [!code-vb[array-size](../../../../../samples/snippets/visualbasic/programming-guide/language-features/arrays/array-size.vb)]  

> [!NOTE] 
> <span data-ttu-id="7c364-207">配列のサイズには、この説明は、ジャグ配列には適用されません。</span><span class="sxs-lookup"><span data-stu-id="7c364-207">This discussion of array size does not apply to jagged arrays.</span></span> <span data-ttu-id="7c364-208">ジャグ配列およびジャグ配列のサイズを決定については、次を参照してください。、[ジャグ配列](#jagged-arrays)セクションです。</span><span class="sxs-lookup"><span data-stu-id="7c364-208">For information on jagged arrays and determining the size of a jagged array, see the [Jagged arrays](#jagged-arrays) section.</span></span>
  
  <span data-ttu-id="7c364-209">配列のサイズは、<xref:System.Array.Length%2A?displayProperty=nameWithType> プロパティを使用して確認できます。</span><span class="sxs-lookup"><span data-stu-id="7c364-209">You can find the size of an array by using the <xref:System.Array.Length%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="7c364-210">使用して多次元配列の各次元の長さを見つけることができます、<xref:System.Array.GetLength%2A?displayProperty=nameWithType>メソッドです。</span><span class="sxs-lookup"><span data-stu-id="7c364-210">You can find the length of each dimension of a multidimensional array by using the <xref:System.Array.GetLength%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="7c364-211">新しい配列オブジェクトを割り当てるかを使用して配列変数のサイズ変更できます、 [ `ReDim`ステートメント](../../../../visual-basic/language-reference/statements/redim-statement.md)ステートメントです。</span><span class="sxs-lookup"><span data-stu-id="7c364-211">You can resize an array variable by assigning a new array object to it or by using the [`ReDim` Statement](../../../../visual-basic/language-reference/statements/redim-statement.md) statement.</span></span> <span data-ttu-id="7c364-212">次の例では、 `ReDim` 51 要素を配列に 100 要素を含む配列を変更するステートメント。</span><span class="sxs-lookup"><span data-stu-id="7c364-212">The following example uses the `ReDim` statement to change a 100-element array to a 51-element array.</span></span>

 [!code-vb[resize-an-array](../../../../../samples/snippets/visualbasic/programming-guide/language-features/arrays/array-size2.vb)]  
  
 <span data-ttu-id="7c364-213">配列のサイズを扱う際に考慮する必要がある点がいくつかあります。</span><span class="sxs-lookup"><span data-stu-id="7c364-213">There are several things to keep in mind when dealing with the size of an array.</span></span>  
  
|||  
|---|---|  
|<span data-ttu-id="7c364-214">次元の長さ</span><span class="sxs-lookup"><span data-stu-id="7c364-214">Dimension Length</span></span>|<span data-ttu-id="7c364-215">各次元のインデックスには、上限を範囲は 0 からつまり、0 から始まります。</span><span class="sxs-lookup"><span data-stu-id="7c364-215">The index of each dimension is 0-based, which means it ranges from 0 to its upper bound.</span></span> <span data-ttu-id="7c364-216">したがって、指定した次元の長さは、そのディメンションの宣言された上限より小さい値のいずれかです。</span><span class="sxs-lookup"><span data-stu-id="7c364-216">Therefore, the length of a given dimension is one greater than the declared upper bound of that dimension.</span></span>|  
|<span data-ttu-id="7c364-217">長さの制限</span><span class="sxs-lookup"><span data-stu-id="7c364-217">Length Limits</span></span>|<span data-ttu-id="7c364-218">配列のすべての次元の長さの最大値に制限されて、`Integer`はこのデータ型は<xref:System.Int32.MaxValue?displayProperty=nameWithType>または (2 ^31) - 1。</span><span class="sxs-lookup"><span data-stu-id="7c364-218">The length of every dimension of an array is limited to the maximum value of the `Integer` data type, which is <xref:System.Int32.MaxValue?displayProperty=nameWithType> or (2 ^ 31) - 1.</span></span> <span data-ttu-id="7c364-219">しかし、配列のサイズの総数も、システムで利用できるメモリによって制限されます。</span><span class="sxs-lookup"><span data-stu-id="7c364-219">However, the total size of an array is also limited by the memory available on your system.</span></span> <span data-ttu-id="7c364-220">使用可能なメモリの容量を超える配列を初期化しようとする場合、ランタイムは、スロー、<xref:System.OutOfMemoryException>です。</span><span class="sxs-lookup"><span data-stu-id="7c364-220">If you attempt to initialize an array that exceeds the amount of available memory, the runtime throws an <xref:System.OutOfMemoryException>.</span></span>|  
|<span data-ttu-id="7c364-221">サイズおよび要素のサイズ</span><span class="sxs-lookup"><span data-stu-id="7c364-221">Size and Element Size</span></span>|<span data-ttu-id="7c364-222">配列のサイズは、その要素のデータ型には依存しません。</span><span class="sxs-lookup"><span data-stu-id="7c364-222">An array's size is independent of the data type of its elements.</span></span> <span data-ttu-id="7c364-223">サイズは、常にメモリ内に消費するバイト数ではなく、要素の合計数を表します。</span><span class="sxs-lookup"><span data-stu-id="7c364-223">The size always represents the total number of elements, not the number of bytes that they consume in memory.</span></span>|  
|<span data-ttu-id="7c364-224">メモリの使用量</span><span class="sxs-lookup"><span data-stu-id="7c364-224">Memory Consumption</span></span>|<span data-ttu-id="7c364-225">配列がどのようにメモリに格納されるかに関して、前提を置くことは安全ではありません。</span><span class="sxs-lookup"><span data-stu-id="7c364-225">It is not safe to make any assumptions regarding how an array is stored in memory.</span></span> <span data-ttu-id="7c364-226">ストレージは、プラットフォームのデータ幅が異なると変わります。したがって、同じ配列でも、32 ビットのシステムよりも 64 ビットのシステムの方が多くのメモリを使用します。</span><span class="sxs-lookup"><span data-stu-id="7c364-226">Storage varies on platforms of different data widths, so the same array can consume more memory on a 64-bit system than on a 32-bit system.</span></span> <span data-ttu-id="7c364-227">配列を初期化すると、システム構成に応じて、要素をできるだけ近くに集めるように、またはすべてがハードウェア自体の境界に合致するように、共通言語ランタイム (CLR: Common Language Runtime) によってストレージが割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="7c364-227">Depending on system configuration when you initialize an array, the common language runtime (CLR) can assign storage either to pack elements as close together as possible, or to align them all on natural hardware boundaries.</span></span> <span data-ttu-id="7c364-228">また、配列は制御情報のためにストレージのオーバーヘッドを必要とします。このオーバーヘッドは、次元が追加されるごとに増加します。</span><span class="sxs-lookup"><span data-stu-id="7c364-228">Also, an array requires a storage overhead for its control information, and this overhead increases with each added dimension.</span></span>|  

## <a name="the-array-type"></a><span data-ttu-id="7c364-229">配列の型</span><span class="sxs-lookup"><span data-stu-id="7c364-229">The array type</span></span> 
 <span data-ttu-id="7c364-230">すべての配列には、その要素のデータ型と異なるデータ型があります。</span><span class="sxs-lookup"><span data-stu-id="7c364-230">Every array has a data type, which differs from the data type of its elements.</span></span> <span data-ttu-id="7c364-231">すべての配列を包括する 1 つのデータ型はありません。</span><span class="sxs-lookup"><span data-stu-id="7c364-231">There is no single data type for all arrays.</span></span> <span data-ttu-id="7c364-232">代わりに、配列のデータ型は、配列の次元数 ( *ランク*) と配列の要素のデータ型によって決まります。</span><span class="sxs-lookup"><span data-stu-id="7c364-232">Instead, the data type of an array is determined by the number of dimensions, or *rank*, of the array, and the data type of the elements in the array.</span></span> <span data-ttu-id="7c364-233">2 つの配列変数は、同じランクである、ときにのみを入力し、その要素が同じデータ型を持つは、同じデータです。</span><span class="sxs-lookup"><span data-stu-id="7c364-233">Two array variables are of the same data type only when they have the same rank and their elements have the same data type.</span></span> <span data-ttu-id="7c364-234">配列の次元の長さは、配列のデータ型には影響しません。</span><span class="sxs-lookup"><span data-stu-id="7c364-234">The lengths of the dimensions of an array do not influence the array data type.</span></span>  
  
 <span data-ttu-id="7c364-235">すべての配列は、<xref:System.Array?displayProperty=nameWithType> クラスから継承しています。また、`Array` 型として変数を宣言できますが、`Array` 型の配列は作成できません。</span><span class="sxs-lookup"><span data-stu-id="7c364-235">Every array inherits from the <xref:System.Array?displayProperty=nameWithType> class, and you can declare a variable to be of type `Array`, but you cannot create an array of type `Array`.</span></span> <span data-ttu-id="7c364-236">たとえば、次のコードを宣言していますが、`arr`型の変数`Array`を呼び出すと、 <xref:System.Array.CreateInstance%2A?displayProperty=nameWithType> object[] をこと、配列、配列の型のインスタンスを作成する方法がわかったです。</span><span class="sxs-lookup"><span data-stu-id="7c364-236">For example, although the following code declares the `arr` variable to be of type `Array` and calls the <xref:System.Array.CreateInstance%2A?displayProperty=nameWithType> method to instantiate the array, the array's type proves to be Object[].</span></span>

 [!code-vb[array-class](../../../../../samples/snippets/visualbasic/programming-guide/language-features/arrays/array-class.vb)] 

<span data-ttu-id="7c364-237">また、[ReDim ステートメント](../../../../visual-basic/language-reference/statements/redim-statement.md) は、`Array` 型として宣言された変数上では使用できません。</span><span class="sxs-lookup"><span data-stu-id="7c364-237">Also, the [ReDim Statement](../../../../visual-basic/language-reference/statements/redim-statement.md) cannot operate on a variable declared as type `Array`.</span></span> <span data-ttu-id="7c364-238">これらの理由やタイプ セーフでは、特定の型としてすべての配列を宣言することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="7c364-238">For these reasons, and for type safety, it is advisable to declare every array as a specific type.</span></span>  
  
 <span data-ttu-id="7c364-239">いくつかの方法で、配列またはその要素のいずれかのデータ型を知ることができます。</span><span class="sxs-lookup"><span data-stu-id="7c364-239">You can find out the data type of either an array or its elements in several ways.</span></span> 
  
-   <span data-ttu-id="7c364-240">呼び出すことができます、<xref:System.Object.GetType%2A>メソッドを取得する変数を<xref:System.Type>変数の実行時の型を表すオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="7c364-240">You can call the <xref:System.Object.GetType%2A> method on the variable to get a <xref:System.Type> object that represents the run-time type of the variable.</span></span> <span data-ttu-id="7c364-241"><xref:System.Type> オブジェクトでは、プロパティおよびメソッドに詳細情報が保持されます。</span><span class="sxs-lookup"><span data-stu-id="7c364-241">The <xref:System.Type> object holds extensive information in its properties and methods.</span></span>  
  
-   <span data-ttu-id="7c364-242">変数を渡すことができます、<xref:Microsoft.VisualBasic.Information.TypeName%2A>を取得する関数、`String`実行時の型の名前に置き換えます。</span><span class="sxs-lookup"><span data-stu-id="7c364-242">You can pass the variable to the <xref:Microsoft.VisualBasic.Information.TypeName%2A> function to get a `String` with the name of run-time type.</span></span>  
  
 <span data-ttu-id="7c364-243">次の例では、どちらも、`GetType`メソッドおよび`TypeName`配列の型を判断する関数。</span><span class="sxs-lookup"><span data-stu-id="7c364-243">The following example calls the both the `GetType` method and the `TypeName` function to determine the type of an array.</span></span> <span data-ttu-id="7c364-244">配列の型は`Byte(,)`します。</span><span class="sxs-lookup"><span data-stu-id="7c364-244">The array type is `Byte(,)`.</span></span> <span data-ttu-id="7c364-245">なお、<xref:System.Type.BaseType%2A?displayProperty=nameWithType>もプロパティでは、バイト配列の基本の種類があることを示します、<xref:System.Array>クラスです。</span><span class="sxs-lookup"><span data-stu-id="7c364-245">Note that the <xref:System.Type.BaseType%2A?displayProperty=nameWithType> property also indicates that the base type of the byte array is the <xref:System.Array> class.</span></span>  
  
 [!code-vb[array-type](../../../../../samples/snippets/visualbasic/programming-guide/language-features/arrays/array-type.vb)]  
  
##  <a name="arrays-as-return-values-and-parameters"></a><span data-ttu-id="7c364-246">戻り値およびパラメーターとしての配列</span><span class="sxs-lookup"><span data-stu-id="7c364-246">Arrays as return values and parameters</span></span>  
 <span data-ttu-id="7c364-247">`Function` プロシージャから配列を返すには、[Function ステートメント](../../../../visual-basic/language-reference/statements/function-statement.md)の戻り値の型として配列のデータ型と次元数を指定します。</span><span class="sxs-lookup"><span data-stu-id="7c364-247">To return an array from a `Function` procedure, specify the array data type and the number of dimensions as the return type of the [Function Statement](../../../../visual-basic/language-reference/statements/function-statement.md).</span></span> <span data-ttu-id="7c364-248">関数内で、同じデータ型と次元数を持つローカルの配列変数を宣言します。</span><span class="sxs-lookup"><span data-stu-id="7c364-248">Within the function, declare a local array variable with same data type and number of dimensions.</span></span> <span data-ttu-id="7c364-249">[Return ステートメント](../../../../visual-basic/language-reference/statements/return-statement.md)には、かっこを使用せずにローカルの配列変数を含めます。</span><span class="sxs-lookup"><span data-stu-id="7c364-249">In the [Return Statement](../../../../visual-basic/language-reference/statements/return-statement.md), include the local array variable without parentheses.</span></span>  
  
 <span data-ttu-id="7c364-250">配列を `Sub` プロシージャまたは `Function` プロシージャのパラメーターとして指定するには、パラメーターを配列として定義して、データ型と次元数を指定します。</span><span class="sxs-lookup"><span data-stu-id="7c364-250">To specify an array as a parameter to a `Sub` or `Function` procedure, define the parameter as an array with a specified data type and number of dimensions.</span></span> <span data-ttu-id="7c364-251">プロシージャの呼び出しでは、同じデータ型と次元数で配列変数を渡します。</span><span class="sxs-lookup"><span data-stu-id="7c364-251">In the call to the procedure, pass an array variable with the same data type and number of dimensions.</span></span>  
  
 <span data-ttu-id="7c364-252">次の例で、`GetNumbers`関数が返される、 `Integer()`、型の 1 次元配列`Integer`です。</span><span class="sxs-lookup"><span data-stu-id="7c364-252">In the following example, the `GetNumbers` function returns an `Integer()`, a one-dimensional array of type `Integer`.</span></span> <span data-ttu-id="7c364-253">`ShowNumbers` プロシージャは、 `Integer()` の引数を受け取ります。</span><span class="sxs-lookup"><span data-stu-id="7c364-253">The `ShowNumbers` procedure accepts an `Integer()` argument.</span></span> 
  
 [!code-vb[return-value-and-params](../../../../../samples/snippets/visualbasic/programming-guide/language-features/arrays/return-values-and-params.vb)]  
  
 <span data-ttu-id="7c364-254">次の例で、`GetNumbersMultiDim`関数が返される、 `Integer(,)`、型の 2 次元配列`Integer`です。</span><span class="sxs-lookup"><span data-stu-id="7c364-254">In the following example, the `GetNumbersMultiDim` function returns an `Integer(,)`, a two-dimensional array of type `Integer`.</span></span>  <span data-ttu-id="7c364-255">`ShowNumbersMultiDim` プロシージャは、 `Integer(,)` の引数を受け取ります。</span><span class="sxs-lookup"><span data-stu-id="7c364-255">The `ShowNumbersMultiDim` procedure accepts an `Integer(,)` argument.</span></span>  
  
 [!code-vb[multidimensional-return-value](../../../../../samples/snippets/visualbasic/programming-guide/language-features/arrays/return-values-and-params-2d.vb)]  
  
## <a name="jagged-arrays"></a><span data-ttu-id="7c364-256">ジャグ配列</span><span class="sxs-lookup"><span data-stu-id="7c364-256">Jagged Arrays</span></span>  
 
<span data-ttu-id="7c364-257">アプリケーションのデータ構造は、2 次元の配列であっても四角形の 2 次元配列ではない場合があります。</span><span class="sxs-lookup"><span data-stu-id="7c364-257">Sometimes the data structure in your application is two-dimensional but not rectangular.</span></span> <span data-ttu-id="7c364-258">たとえば、月の日の最高気温に関するデータを格納するのに配列を使用する場合があります。</span><span class="sxs-lookup"><span data-stu-id="7c364-258">For example, you might use an array to store data about the high temperature of each day of the month.</span></span> <span data-ttu-id="7c364-259">配列の最初の次元が、月を表すが、2 番目の次元数日間を表し、1 か月の日数が固定されていません。</span><span class="sxs-lookup"><span data-stu-id="7c364-259">The first dimension of the array represents the month, but the second dimension represents the number of days, and the number of days in a month is not uniform.</span></span> <span data-ttu-id="7c364-260">A*ジャグ配列*もと呼ばれる、*配列の配列*、このようなシナリオに適しています。</span><span class="sxs-lookup"><span data-stu-id="7c364-260">A *jagged array*, which is also called an *array of arrays*, is designed for such scenarios.</span></span> <span data-ttu-id="7c364-261">ジャグ配列とは、配列要素も配列です。</span><span class="sxs-lookup"><span data-stu-id="7c364-261">A jagged array is an array whose elements are also arrays.</span></span> <span data-ttu-id="7c364-262">ジャグ配列と、ジャグ配列の各要素は、1 次元でも多次元でもかまいません。</span><span class="sxs-lookup"><span data-stu-id="7c364-262">A jagged array and each element in a jagged array can have one or more dimensions.</span></span>  
  
 <span data-ttu-id="7c364-263">次の例では、数か月の各要素が日の配列の配列を使用します。</span><span class="sxs-lookup"><span data-stu-id="7c364-263">The following example uses an array of months, each element of which is an array of days.</span></span> <span data-ttu-id="7c364-264">異なる月の日数の数が異なるため、ジャグ配列を使用します。</span><span class="sxs-lookup"><span data-stu-id="7c364-264">The example uses a jagged array because different months have different numbers of days.</span></span>  <span data-ttu-id="7c364-265">この例では、ジャグ配列を作成し、値を割り当てる、取得、およびその値を表示する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="7c364-265">The example shows how to create a jagged array, assign values to it, and retrieve and display its values.</span></span>
  
 [!code-vb[jagged-arrays](../../../../../samples/snippets/visualbasic/programming-guide/language-features/arrays/jagged.vb)]  

<span data-ttu-id="7c364-266">前の例では、要素単位ごとにジャグ配列に値を割り当てますを使用して、`For...Next`ループします。</span><span class="sxs-lookup"><span data-stu-id="7c364-266">The previous example assigns values to the jagged array on an element-by-element basis by using a `For...Next` loop.</span></span> <span data-ttu-id="7c364-267">入れ子になった配列リテラルを使用してジャグ配列の要素に値を割り当てることもできます。</span><span class="sxs-lookup"><span data-stu-id="7c364-267">You can also assign values to the elements of a jagged array by using nested array literals.</span></span> <span data-ttu-id="7c364-268">ただし、使用しようとすると、入れ子になった配列リテラル (たとえば、 ```Dim valuesjagged = {{1, 2}, {2, 3, 4}}```) コンパイラ エラーが発生[BC30568](../../../,,/../misc/bc30568.md)です。</span><span class="sxs-lookup"><span data-stu-id="7c364-268">However, the attempt to use nested array literals (for example, ```Dim valuesjagged = {{1, 2}, {2, 3, 4}}```) generates compiler error [BC30568](../../../,,/../misc/bc30568.md).</span></span> <span data-ttu-id="7c364-269">エラーを修正するには、内部の配列リテラルをかっこで囲みます。</span><span class="sxs-lookup"><span data-stu-id="7c364-269">To correct the error, enclose the inner array literals in parentheses.</span></span> <span data-ttu-id="7c364-270">かっこは、強制的に、配列リテラルに評価される式、され、次の例のように、外側の配列リテラルで結果の値が使用されます。</span><span class="sxs-lookup"><span data-stu-id="7c364-270">The parentheses force the array literal expression to be evaluated, and the resulting values are used with the outer array literal, as the following example shows.</span></span>  
  
 [!code-vb[jagged-array-initialization](../../../../../samples/snippets/visualbasic/programming-guide/language-features/arrays/jagged-assign.vb)] 

<span data-ttu-id="7c364-271">ジャグ配列とは、1 次元配列の配列の要素を格納します。</span><span class="sxs-lookup"><span data-stu-id="7c364-271">A jagged array is a one-dimensional array whose elements contain arrays.</span></span> <span data-ttu-id="7c364-272">したがって、<xref:System.Array.Length%2A?displayProperty=nameWithType>プロパティおよび`Array.GetLength(0)`メソッドは、1 次元の配列要素の数を返すと`Array.GetLength(1)`をスロー、<xref:System.IndexOutOfRangeException>ジャグ配列が多次元ではないためです。</span><span class="sxs-lookup"><span data-stu-id="7c364-272">Therefore, the <xref:System.Array.Length%2A?displayProperty=nameWithType> property and the `Array.GetLength(0)` method return the number of elements in the one-dimensional array, and `Array.GetLength(1)` throws an <xref:System.IndexOutOfRangeException> because a jagged array is not multidimensional.</span></span> <span data-ttu-id="7c364-273">各サブ配列の値を取得することによって各サブ配列の要素の数を決定する<xref:System.Array.Length%2A?displayProperty=nameWithType>プロパティです。</span><span class="sxs-lookup"><span data-stu-id="7c364-273">You determine the number of elements in each subarray by retrieving the value of each subarray's <xref:System.Array.Length%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="7c364-274">次の例では、ジャグ配列の要素の数を決定する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="7c364-274">The following example illustrates how to determine the number of elements in a jagged array.</span></span>

[!code-vb[jagged-array-size](../../../../../samples/snippets/visualbasic/programming-guide/language-features/arrays/jagged-length.vb)] 

## <a name="zero-length-arrays"></a><span data-ttu-id="7c364-275">長さ 0 の配列</span><span class="sxs-lookup"><span data-stu-id="7c364-275">Zero-length arrays</span></span>  
<span data-ttu-id="7c364-276">Visual Basic が初期化されていない配列間で区別 (値が配列`Nothing`) および*長さ 0 の配列*または空の配列 (配列要素が存在しないことです)。初期化されていない配列である多次元化されていないか、任意の値がそれに割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="7c364-276">Visual Basic differentiates between a uninitialized array (an array whose value is `Nothing`) and a *zero-length array* or empty array (an array that has no elements.) An uninitialized array is one that has not been dimensioned or had any values assigned to it.</span></span> <span data-ttu-id="7c364-277">例えば:</span><span class="sxs-lookup"><span data-stu-id="7c364-277">For example:</span></span>

```vb
Dim arr() As String
```
<span data-ttu-id="7c364-278">長さ 0 の配列は、-1 のディメンションと宣言されます。</span><span class="sxs-lookup"><span data-stu-id="7c364-278">A zero-length array is declared with a dimension of -1.</span></span> <span data-ttu-id="7c364-279">例えば:</span><span class="sxs-lookup"><span data-stu-id="7c364-279">For example:</span></span>

```vb
Dim arrZ(-1) As String
```
<span data-ttu-id="7c364-280">次のような場合に、長さ 0 の配列を作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="7c364-280">You might need to create a zero-length array under the following circumstances:</span></span>  
  
-   <span data-ttu-id="7c364-281">危険にさらす、<xref:System.NullReferenceException>例外、コードのメンバーにアクセスする必要があります、<xref:System.Array>クラスなど<xref:System.Array.Length%2A>または<xref:System.Array.Rank%2A>、または Visual Basic の関数を呼び出すなど<xref:Microsoft.VisualBasic.Information.UBound%2A>です。</span><span class="sxs-lookup"><span data-stu-id="7c364-281">Without risking a <xref:System.NullReferenceException> exception, your code must access members of the <xref:System.Array> class, such as <xref:System.Array.Length%2A> or <xref:System.Array.Rank%2A>, or call a Visual Basic function such as <xref:Microsoft.VisualBasic.Information.UBound%2A>.</span></span>  
  
-   <span data-ttu-id="7c364-282">保持する、コードを確認する必要がない単純な`Nothing`特殊なケースとして。</span><span class="sxs-lookup"><span data-stu-id="7c364-282">You want to keep the your code simple by not having to check for `Nothing` as a special case.</span></span>  
  
-   <span data-ttu-id="7c364-283">コードで、長さ 0 の配列を 1 つ以上のプロシージャに渡す必要があるアプリケーション プログラミング インターフェイス (API: Application Programming Interface) とやり取りする場合、または API の 1 つ以上のプロシージャから長さ 0 の配列が返される場合。</span><span class="sxs-lookup"><span data-stu-id="7c364-283">Your code interacts with an application programming interface (API) that either requires you to pass a zero-length array to one or more procedures or returns a zero-length array from one or more procedures.</span></span>

## <a name="splitting-an-array"></a><span data-ttu-id="7c364-284">配列の分割</span><span class="sxs-lookup"><span data-stu-id="7c364-284">Splitting an array</span></span>

<span data-ttu-id="7c364-285">場合によっては、1 つの配列を複数の配列に分割する必要があります。</span><span class="sxs-lookup"><span data-stu-id="7c364-285">In some cases, you may need to split a single array into multiple arrays.</span></span> <span data-ttu-id="7c364-286">これには、配列を分割するにはポイントを特定し、2 つ以上の独立した配列に配列を送信が含まれます。</span><span class="sxs-lookup"><span data-stu-id="7c364-286">This involves identifying the point or points at which the array is to be split, and then spitting the array into two or more separate arrays.</span></span> 

> [!NOTE] 
> <span data-ttu-id="7c364-287">このセクションでは、1 つの文字列を分割していくつかの区切り記号に基づいて文字列配列には説明しません。</span><span class="sxs-lookup"><span data-stu-id="7c364-287">This section does not discuss splitting a single string into a string array based on some delimiter.</span></span> <span data-ttu-id="7c364-288">文字列の分割方法の詳細については、次を参照してください。、<xref:System.String.Split%2A?displayProperty=nameWithType>メソッドです。</span><span class="sxs-lookup"><span data-stu-id="7c364-288">For information on splitting a string, see the <xref:System.String.Split%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="7c364-289">分割して配列の最も一般的な条件は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="7c364-289">The most common criteria for splitting an array are:</span></span>

- <span data-ttu-id="7c364-290">配列の要素数。</span><span class="sxs-lookup"><span data-stu-id="7c364-290">The number of elements in the array.</span></span> <span data-ttu-id="7c364-291">たとえば、約と同等の部分の数の指定した要素数を超える配列に分割することができます。</span><span class="sxs-lookup"><span data-stu-id="7c364-291">For example, you might want to split an array of more than a specified number of elements into a number of approximately equal parts.</span></span> <span data-ttu-id="7c364-292">このため、いずれかによって返される値を使用することができます、<xref:System.Array.Length%2A?displayProperty=nameWithType>または<xref:System.Array.GetLength%2A?displayProperty=nameWithType>メソッドです。</span><span class="sxs-lookup"><span data-stu-id="7c364-292">For this purpose, you can use the value returned by either the <xref:System.Array.Length%2A?displayProperty=nameWithType> or <xref:System.Array.GetLength%2A?displayProperty=nameWithType> method.</span></span>

- <span data-ttu-id="7c364-293">配列の位置を示す区切り記号として機能する要素の値を分割する必要があります。</span><span class="sxs-lookup"><span data-stu-id="7c364-293">The value of an element, which serves as a delimiter that indicates where the array should be split.</span></span> <span data-ttu-id="7c364-294">呼び出して、特定の値を検索することができます、<xref:System.Array.FindIndex%2A?displayProperty=nameWithType>と<xref:System.Array.FindLastIndex%2A?displayProperty=nameWithType>メソッドです。</span><span class="sxs-lookup"><span data-stu-id="7c364-294">You can search for a specific value by calling the <xref:System.Array.FindIndex%2A?displayProperty=nameWithType> and <xref:System.Array.FindLastIndex%2A?displayProperty=nameWithType> methods.</span></span>
 
<span data-ttu-id="7c364-295">呼び出して個々 の配列を作成できますし、インデックスまたはインデックスの配列に分割する必要がありますを特定した後、<xref:System.Array.Copy%2A?displayProperty=nameWithType>メソッドです。</span><span class="sxs-lookup"><span data-stu-id="7c364-295">Once you've determined the index or indexes at which the array should be split, you can then create the individual arrays by calling the <xref:System.Array.Copy%2A?displayProperty=nameWithType> method.</span></span> 

<span data-ttu-id="7c364-296">次の例では、ほぼ等しいサイズの 2 つの配列に配列を分割します。</span><span class="sxs-lookup"><span data-stu-id="7c364-296">The following example splits an array into two arrays of approximately equal size.</span></span> <span data-ttu-id="7c364-297">(配列の要素の合計数が奇数の場合は、最初の配列が 2 番目の要素が 1 つです。)</span><span class="sxs-lookup"><span data-stu-id="7c364-297">(If the total number of array elements is odd, the first array has one more element than the second.)</span></span> 

[!code-vb[splitting-an-array-by-length](../../../../../samples/snippets/visualbasic/programming-guide/language-features/arrays/split1.vb)] 

<span data-ttu-id="7c364-298">次の例では、文字列の配列をその値は"zzz"配列の区切り記号として機能する要素の有無に基づいて 2 つの配列に分割します。</span><span class="sxs-lookup"><span data-stu-id="7c364-298">The following example splits a string array into two arrays based on the presence of an element whose value is "zzz", which serves as the array delimiter.</span></span> <span data-ttu-id="7c364-299">新しい配列には、区切り記号を格納する要素を含めないでください。</span><span class="sxs-lookup"><span data-stu-id="7c364-299">The new arrays do not include the element that contains the delimiter.</span></span>

[!code-vb[splitting-an-array-by-delimiter](../../../../../samples/snippets/visualbasic/programming-guide/language-features/arrays/split2.vb)] 

## <a name="joining-arrays"></a><span data-ttu-id="7c364-300">配列への参加</span><span class="sxs-lookup"><span data-stu-id="7c364-300">Joining arrays</span></span>

<span data-ttu-id="7c364-301">単一の大きな配列に配列の番号を組み合わせることもできます。</span><span class="sxs-lookup"><span data-stu-id="7c364-301">You can also combine a number of arrays into a single larger array.</span></span> <span data-ttu-id="7c364-302">これを行うには、使用することも、<xref:System.Array.Copy%2A?displayProperty=nameWithType>メソッドです。</span><span class="sxs-lookup"><span data-stu-id="7c364-302">To do this, you also use the <xref:System.Array.Copy%2A?displayProperty=nameWithType> method.</span></span> 

> [!NOTE] 
> <span data-ttu-id="7c364-303">このセクションでは、1 つの文字列に文字列の配列を結合するには説明しません。</span><span class="sxs-lookup"><span data-stu-id="7c364-303">This section does not discuss joining a string array into a single string.</span></span> <span data-ttu-id="7c364-304">文字列の配列を結合する方法については、次を参照してください。、<xref:System.String.Join%2A?displayProperty=nameWithType>メソッドです。</span><span class="sxs-lookup"><span data-stu-id="7c364-304">For information on joining a string array, see the <xref:System.String.Join%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="7c364-305">新しい配列に各配列の要素をコピーする前にまず accompodate 新しい配列に十分な大きさがよう、配列を初期化することを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="7c364-305">Before copying the elements of each array into the new array, you must first ensure that you have initialized the array so that it is large enough to accompodate the new array.</span></span> <span data-ttu-id="7c364-306">2 つの方法のいずれかでこれを行うことができます。</span><span class="sxs-lookup"><span data-stu-id="7c364-306">You can do this in one of two ways:</span></span>

- <span data-ttu-id="7c364-307">使用して、 [ `ReDim Preserve` ](../../../../visual-basic/language-reference/statements/redim-statement.md)ステートメントを動的に新しい要素を追加する前に、配列を展開します。</span><span class="sxs-lookup"><span data-stu-id="7c364-307">Use the [`ReDim Preserve`](../../../../visual-basic/language-reference/statements/redim-statement.md) statement to dynamically expand the array before adding new elements to it.</span></span> <span data-ttu-id="7c364-308">これは、最も簡単な手法が大きな配列をコピーするときにパフォーマンスが低下したり大量のメモリ消費量になります。</span><span class="sxs-lookup"><span data-stu-id="7c364-308">This is the easiest technique, but it can result in performance degradation and excessive memory consumption when you are copying large arrays.</span></span>
- <span data-ttu-id="7c364-309">新しいの大きな配列の必要な要素の合計数を計算し、各ソース配列の要素を追加します。</span><span class="sxs-lookup"><span data-stu-id="7c364-309">Calculate the total number of elements needed for the new large array, then add the elements of each source array to it.</span></span>

<span data-ttu-id="7c364-310">次の例では、2 番目の方法を使用して、1 つの配列に 10 個の要素を持つ 4 つの配列を追加します。</span><span class="sxs-lookup"><span data-stu-id="7c364-310">The following example uses the second approach to add four arrays with ten elements each to a single array.</span></span>  

[!code-vb[joining-an-array](../../../../../samples/snippets/visualbasic/programming-guide/language-features/arrays/join.vb)] 

<span data-ttu-id="7c364-311">ソース配列が小さすべてここでは、以降おも動的に拡大する可能性が配列に各新しい配列の要素を追加しました。</span><span class="sxs-lookup"><span data-stu-id="7c364-311">Since in this case the source arrays are all small, we can also dynamically expand the array as we add the elements of each new array to it.</span></span> <span data-ttu-id="7c364-312">次の例でこれを確認できます。</span><span class="sxs-lookup"><span data-stu-id="7c364-312">The following example does that.</span></span>

[!code-vb[joining-an-array-dynamically](../../../../../samples/snippets/visualbasic/programming-guide/language-features/arrays/join2.vb)] 

##  <a name="collections-as-an-alternative-to-arrays"></a><span data-ttu-id="7c364-313">配列の代わりとしてのコレクション</span><span class="sxs-lookup"><span data-stu-id="7c364-313">Collections as an alternative to arrays</span></span>  
 <span data-ttu-id="7c364-314">配列は、数が固定されている厳密に型指定されたオブジェクトの作成および処理に最も適しています。</span><span class="sxs-lookup"><span data-stu-id="7c364-314">Arrays are most useful for creating and working with a fixed number of strongly typed objects.</span></span> <span data-ttu-id="7c364-315">コレクションは、オブジェクトのグループをより柔軟に処理できます。</span><span class="sxs-lookup"><span data-stu-id="7c364-315">Collections provide a more flexible way to work with groups of objects.</span></span> <span data-ttu-id="7c364-316">配列とは異なりを必要とする格納された配列のサイズを明示的に変更すること、 [ `ReDim`ステートメント](../../../../visual-basic/language-reference/statements/redim-statement.md)コレクションの拡大し、アプリケーションの変更の必要に応じて動的に縮小します。</span><span class="sxs-lookup"><span data-stu-id="7c364-316">Unlike arrays, which require that you explicitly change the size of an array with the [`ReDim` Statement](../../../../visual-basic/language-reference/statements/redim-statement.md), collections grow and shrink dynamically as the needs of an application change.</span></span>  
  
 <span data-ttu-id="7c364-317">使用すると`ReDim`配列の次元を変更する Visual Basic が新しい配列を作成し、前の 1 つを解放します。</span><span class="sxs-lookup"><span data-stu-id="7c364-317">When you use `ReDim` to redimension an array, Visual Basic creates a new array and releases the previous one.</span></span> <span data-ttu-id="7c364-318">これには、実行時間がかかります。</span><span class="sxs-lookup"><span data-stu-id="7c364-318">This takes execution time.</span></span> <span data-ttu-id="7c364-319">そのため、頻繁に変更するかを使用するアイテムの数は、必要な項目の最大数を予測できない場合、するを通常パフォーマンスを向上コレクションを使用しています。</span><span class="sxs-lookup"><span data-stu-id="7c364-319">Therefore, if the number of items you are working with changes frequently, or you cannot predict the maximum number of items you need, you'll usually obtain better performance by using a collection.</span></span>  
  
 <span data-ttu-id="7c364-320">コレクションによっては、コレクションに含まれるオブジェクトのキーを割り当てると、そのキーを使用してオブジェクトを迅速に取り出すことができます。</span><span class="sxs-lookup"><span data-stu-id="7c364-320">For some collections, you can assign a key to any object that you put into the collection so that you can quickly retrieve the object by using the key.</span></span>  
  
 <span data-ttu-id="7c364-321">含まれる要素が 1 つのデータ型だけのコレクションの場合は、 <xref:System.Collections.Generic?displayProperty=nameWithType> 名前空間のクラスのいずれかを使用できます。</span><span class="sxs-lookup"><span data-stu-id="7c364-321">If your collection contains elements of only one data type, you can use one of the classes in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="7c364-322">ジェネリック コレクションでは、タイプ セーフが強制されるため、他のデータ型を追加することはできません。</span><span class="sxs-lookup"><span data-stu-id="7c364-322">A generic collection enforces type safety so that no other data type can be added to it.</span></span>  
  
 <span data-ttu-id="7c364-323">コレクションの詳細については、「[コレクション](../../concepts/collections.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="7c364-323">For more information about collections, see [Collections](../../concepts/collections.md).</span></span>
  
## <a name="related-topics"></a><span data-ttu-id="7c364-324">関連トピック</span><span class="sxs-lookup"><span data-stu-id="7c364-324">Related Topics</span></span>  
  
|<span data-ttu-id="7c364-325">用語</span><span class="sxs-lookup"><span data-stu-id="7c364-325">Term</span></span>|<span data-ttu-id="7c364-326">定義</span><span class="sxs-lookup"><span data-stu-id="7c364-326">Definition</span></span>|  
|----------|----------------|  
|[<span data-ttu-id="7c364-327">Array Dimensions in Visual Basic</span><span class="sxs-lookup"><span data-stu-id="7c364-327">Array Dimensions in Visual Basic</span></span>](../../../../visual-basic/programming-guide/language-features/arrays/array-dimensions.md)|<span data-ttu-id="7c364-328">配列のランクと次元について説明します。</span><span class="sxs-lookup"><span data-stu-id="7c364-328">Explains rank and dimensions in arrays.</span></span>|  
|[<span data-ttu-id="7c364-329">方法: Visual Basic で配列変数を初期化する</span><span class="sxs-lookup"><span data-stu-id="7c364-329">How to: Initialize an Array Variable in Visual Basic</span></span>](../../../../visual-basic/programming-guide/language-features/arrays/how-to-initialize-an-array-variable.md)|<span data-ttu-id="7c364-330">配列に初期値を設定する方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="7c364-330">Describes how to populate arrays with initial values.</span></span>|  
|[<span data-ttu-id="7c364-331">方法: 配列を並べ替える (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="7c364-331">How to: Sort An Array in Visual Basic</span></span>](../../../../visual-basic/programming-guide/language-features/arrays/how-to-sort-an-array.md)|<span data-ttu-id="7c364-332">配列の要素をアルファベット順に並べ替える方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="7c364-332">Shows how to sort the elements of an array alphabetically.</span></span>|  
|[<span data-ttu-id="7c364-333">方法 : 配列を別の配列に代入する</span><span class="sxs-lookup"><span data-stu-id="7c364-333">How to: Assign One Array to Another Array</span></span>](../../../../visual-basic/programming-guide/language-features/arrays/how-to-assign-one-array-to-another-array.md)|<span data-ttu-id="7c364-334">配列を別の配列変数に代入するときの手順と規則を説明します。</span><span class="sxs-lookup"><span data-stu-id="7c364-334">Describes the rules and steps for assigning an array to another array variable.</span></span>|  
|[<span data-ttu-id="7c364-335">配列のトラブルシューティング</span><span class="sxs-lookup"><span data-stu-id="7c364-335">Troubleshooting Arrays</span></span>](../../../../visual-basic/programming-guide/language-features/arrays/troubleshooting-arrays.md)|<span data-ttu-id="7c364-336">配列を使用しているときに発生する一般的な問題について説明します。</span><span class="sxs-lookup"><span data-stu-id="7c364-336">Discusses some common problems that arise when working with arrays.</span></span>|  
  
## <a name="see-also"></a><span data-ttu-id="7c364-337">関連項目</span><span class="sxs-lookup"><span data-stu-id="7c364-337">See Also</span></span>  
 <xref:System.Array?displayProperty=nameWithType>  
 [<span data-ttu-id="7c364-338">Dim ステートメント</span><span class="sxs-lookup"><span data-stu-id="7c364-338">Dim Statement</span></span>](../../../../visual-basic/language-reference/statements/dim-statement.md)  
 [<span data-ttu-id="7c364-339">ReDim ステートメント</span><span class="sxs-lookup"><span data-stu-id="7c364-339">ReDim Statement</span></span>](../../../../visual-basic/language-reference/statements/redim-statement.md)
