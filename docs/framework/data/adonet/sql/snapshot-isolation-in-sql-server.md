---
title: SQL Server でのスナップショット分離
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 43ae5dd3-50f5-43a8-8d01-e37a61664176
ms.openlocfilehash: 6d85cc041850300d1d079b227dcb8ed9201a0502
ms.sourcegitcommit: 3094dcd17141b32a570a82ae3f62a331616e2c9c
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/01/2019
ms.locfileid: "71699069"
---
# <a name="snapshot-isolation-in-sql-server"></a><span data-ttu-id="c35c0-102">SQL Server でのスナップショット分離</span><span class="sxs-lookup"><span data-stu-id="c35c0-102">Snapshot Isolation in SQL Server</span></span>
<span data-ttu-id="c35c0-103">スナップショット分離により、OLTP アプリケーションのコンカレンシーが向上しています。</span><span class="sxs-lookup"><span data-stu-id="c35c0-103">Snapshot isolation enhances concurrency for OLTP applications.</span></span>  
  
## <a name="understanding-snapshot-isolation-and-row-versioning"></a><span data-ttu-id="c35c0-104">スナップショット分離と行バージョン管理について</span><span class="sxs-lookup"><span data-stu-id="c35c0-104">Understanding Snapshot Isolation and Row Versioning</span></span>  
 <span data-ttu-id="c35c0-105">スナップショット分離が有効になったら、各トランザクションの更新された行バージョンを保持する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c35c0-105">Once snapshot isolation is enabled, updated row versions for each transaction must be maintained.</span></span>  <span data-ttu-id="c35c0-106">SQL Server 2019 より前では、これらのバージョンは**tempdb**に格納されていました。</span><span class="sxs-lookup"><span data-stu-id="c35c0-106">Prior to SQL Server 2019, these versions were stored in **tempdb**.</span></span> <span data-ttu-id="c35c0-107">SQL Server 2019 では、新しい機能である、高速データベース復旧 (ADR) が導入されています。これには、独自の行バージョンのセットが必要です。</span><span class="sxs-lookup"><span data-stu-id="c35c0-107">SQL Server 2019 introduces a new feature, Accelerated Database Recovery (ADR) which requires its own set of row versions.</span></span>  <span data-ttu-id="c35c0-108">そのため、SQL Server 2019 では、ADR が有効になっていない場合、行バージョンは常に**tempdb**に保持されます。</span><span class="sxs-lookup"><span data-stu-id="c35c0-108">So, as of SQL Server 2019, if ADR is not enabled, row versions are kept in **tempdb** as always.</span></span>  <span data-ttu-id="c35c0-109">ADR が有効になっている場合、スナップショット分離と ADR に関連するすべての行バージョンは、ユーザーが指定したファイルグループ内のユーザーデータベースにある ADR の永続的なバージョンストア (PVS) に保持されます。</span><span class="sxs-lookup"><span data-stu-id="c35c0-109">If ADR is enabled, then all row versions, both related to snapshot isolation and ADR, are kept in ADR's Persistent Version Store (PVS), which is located in the user database in a filegroup which the user specifies.</span></span> <span data-ttu-id="c35c0-110">一意のトランザクション シーケンス番号が各トランザクションを識別し、これらの一意の番号がそれぞれの行バージョン用に記録されます。</span><span class="sxs-lookup"><span data-stu-id="c35c0-110">A unique transaction sequence number identifies each transaction, and these unique numbers are recorded for each row version.</span></span> <span data-ttu-id="c35c0-111">トランザクションは、シーケンス番号がトランザクションのシーケンス番号よりも前にある、最新の行バージョンを処理します。</span><span class="sxs-lookup"><span data-stu-id="c35c0-111">The transaction works with the most recent row versions having a sequence number before the sequence number of the transaction.</span></span> <span data-ttu-id="c35c0-112">トランザクションが開始された後で作成された最新の行バーションは、トランザクションにより無視されます。</span><span class="sxs-lookup"><span data-stu-id="c35c0-112">Newer row versions created after the transaction has begun are ignored by the transaction.</span></span>  
  
 <span data-ttu-id="c35c0-113">"スナップショット" という用語は、トランザクション内のすべてのクエリが、トランザクションの開始時点のデータベースの状態に基づいて、データベースの同じバージョン、つまりスナップショットを参照するという事実を表しています。</span><span class="sxs-lookup"><span data-stu-id="c35c0-113">The term "snapshot" reflects the fact that all queries in the transaction see the same version, or snapshot, of the database, based on the state of the database at the moment in time when the transaction begins.</span></span> <span data-ttu-id="c35c0-114">ロックは、スナップショット トランザクション内の基になるデータ行やデータ ページでは取得されません。スナップショット トランザクションでは、先に開始されてまだ完了していないトランザクションによりブロックされることなく、他のトランザクションを実行できます。</span><span class="sxs-lookup"><span data-stu-id="c35c0-114">No locks are acquired on the underlying data rows or data pages in a snapshot transaction, which permits other transactions to execute without being blocked by a prior uncompleted transaction.</span></span> <span data-ttu-id="c35c0-115">データを変更するトランザクションは、データを読み取るトランザクションをブロックしません。また、データを読み取るトランザクションは、データを書き込むトランザクションをブロックしません。この理由は、通常、これらのトランザクションは SQL Server の既定の READ COMMITTED 分離レベルにあるためです。</span><span class="sxs-lookup"><span data-stu-id="c35c0-115">Transactions that modify data do not block transactions that read data, and transactions that read data do not block transactions that write data, as they normally would under the default READ COMMITTED isolation level in SQL Server.</span></span> <span data-ttu-id="c35c0-116">また、ブロック不可の動作は、複雑なトランザクションのデッドロックの可能性を大幅に軽減します。</span><span class="sxs-lookup"><span data-stu-id="c35c0-116">This non-blocking behavior also significantly reduces the likelihood of deadlocks for complex transactions.</span></span>  
  
 <span data-ttu-id="c35c0-117">スナップショット分離では、オプティミスティック コンカレンシー モデルを使用します。</span><span class="sxs-lookup"><span data-stu-id="c35c0-117">Snapshot isolation uses an optimistic concurrency model.</span></span> <span data-ttu-id="c35c0-118">スナップショット トランザクションは、トランザクションの開始後に変更されたデータに対して変更をコミットしようとすると、このトランザクションがロールバックし、エラーになります。</span><span class="sxs-lookup"><span data-stu-id="c35c0-118">If a snapshot transaction attempts to commit modifications to data that has changed since the transaction began, the transaction will roll back and an error will be raised.</span></span> <span data-ttu-id="c35c0-119">このエラーは、変更されるデータにアクセスする、SELECT ステートメントの UPDLOCK ヒントを使用することにより回避できます。</span><span class="sxs-lookup"><span data-stu-id="c35c0-119">You can avoid this by using UPDLOCK hints for SELECT statements that access data to be modified.</span></span> <span data-ttu-id="c35c0-120">詳細については、SQL Server オンライン ブックの「ロックのヒント」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c35c0-120">See "Locking Hints" in SQL Server Books Online for more information.</span></span>  
  
 <span data-ttu-id="c35c0-121">スナップショット分離は、トランザクション内で使用する前に、ALLOW_SNAPSHOT_ISOLATION ON データベース オプションを設定して有効にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="c35c0-121">Snapshot isolation must be enabled by setting the ALLOW_SNAPSHOT_ISOLATION ON database option before it is used in transactions.</span></span> <span data-ttu-id="c35c0-122">これにより、一時データベース (**tempdb**) に行バージョンを格納するためのメカニズムがアクティブになります。</span><span class="sxs-lookup"><span data-stu-id="c35c0-122">This activates the mechanism for storing row versions in the temporary database (**tempdb**).</span></span> <span data-ttu-id="c35c0-123">Transact-SQL ALTER DATABASE ステートメントで使用する、各データベース内のスナップショット分離を有効にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="c35c0-123">You must enable snapshot isolation in each database that uses it with the Transact-SQL ALTER DATABASE statement.</span></span> <span data-ttu-id="c35c0-124">この点では、スナップショット分離は、構成を必要としない READ COMMITTED、REPEATABLE READ、SERIALIZABLE、および READ UNCOMMITTED の従来の分離レベルとは異なります。</span><span class="sxs-lookup"><span data-stu-id="c35c0-124">In this respect, snapshot isolation differs from the traditional isolation levels of READ COMMITTED, REPEATABLE READ, SERIALIZABLE, and READ UNCOMMITTED, which require no configuration.</span></span> <span data-ttu-id="c35c0-125">次のステートメントは、スナップショット分離をアクティブにして、既定の READ COMMITTED 動作を SNAPSHOT で置き換えます。</span><span class="sxs-lookup"><span data-stu-id="c35c0-125">The following statements activate snapshot isolation and replace the default READ COMMITTED behavior with SNAPSHOT:</span></span>  
  
```sql  
ALTER DATABASE MyDatabase  
SET ALLOW_SNAPSHOT_ISOLATION ON  
  
ALTER DATABASE MyDatabase  
SET READ_COMMITTED_SNAPSHOT ON  
```  
  
 <span data-ttu-id="c35c0-126">READ_COMMITTED_SNAPSHOT ON オプションを設定すると、既定の READ COMMITTED 分離レベルの下にあるバージョン管理された行にアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="c35c0-126">Setting the READ_COMMITTED_SNAPSHOT ON option allows access to versioned rows under the default READ COMMITTED isolation level.</span></span> <span data-ttu-id="c35c0-127">READ_COMMITTED_SNAPSHOT オプションが OFF に設定されている場合、バージョン管理された行にアクセスするためには、各セッションのスナップショット分離レベルを明示的に設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c35c0-127">If the READ_COMMITTED_SNAPSHOT option is set to OFF, you must explicitly set the Snapshot isolation level for each session in order to access versioned rows.</span></span>  
  
## <a name="managing-concurrency-with-isolation-levels"></a><span data-ttu-id="c35c0-128">分離レベルによるコンカレンシーの管理</span><span class="sxs-lookup"><span data-stu-id="c35c0-128">Managing Concurrency with Isolation Levels</span></span>  
 <span data-ttu-id="c35c0-129">Transact-SQL ステートメントを実行する分離レベルは、ロック動作と行バージョン管理動作を決定します。</span><span class="sxs-lookup"><span data-stu-id="c35c0-129">The isolation level under which a Transact-SQL statement executes determines its locking and row versioning behavior.</span></span> <span data-ttu-id="c35c0-130">分離レベルには接続全体のスコープがあり、SET TRANSACTION ISOLATION LEVEL ステートメントで接続に設定されると、その接続が閉じられるか、別の分離レベルが設定されるまでは有効になります。</span><span class="sxs-lookup"><span data-stu-id="c35c0-130">An isolation level has connection-wide scope, and once set for a connection with the SET TRANSACTION ISOLATION LEVEL statement, it remains in effect until the connection is closed or another isolation level is set.</span></span> <span data-ttu-id="c35c0-131">接続が閉じられてプールに返されると、最後の SET TRANSACTION ISOLATION LEVEL ステートメントからの分離レベルが保持されます。</span><span class="sxs-lookup"><span data-stu-id="c35c0-131">When a connection is closed and returned to the pool, the isolation level from the last SET TRANSACTION ISOLATION LEVEL statement is retained.</span></span> <span data-ttu-id="c35c0-132">それ以降、プールされた接続を再利用する接続では、その接続がプールされた時点で有効にされた分離レベルが使用されます。</span><span class="sxs-lookup"><span data-stu-id="c35c0-132">Subsequent connections reusing a pooled connection use the isolation level that was in effect at the time the connection is pooled.</span></span>  
  
 <span data-ttu-id="c35c0-133">接続内で発行される個別のクエリには、接続の分離レベルに影響を与えることなく、1 つのステートメントまたはトランザクションの分離を変更するロック ヒントを含めることができます。</span><span class="sxs-lookup"><span data-stu-id="c35c0-133">Individual queries issued within a connection can contain lock hints that modify the isolation for a single statement or transaction but do not affect the isolation level of the connection.</span></span> <span data-ttu-id="c35c0-134">ストアド プロシージャまたは関数内で設定される分離レベルまたはロック ヒントは、これらを呼び出す接続の分離レベルを変更しません。また、分離レベルまたはロック ヒントは、ストアド プロシージャまたは関数呼び出しの間だけ有効になります。</span><span class="sxs-lookup"><span data-stu-id="c35c0-134">Isolation levels or lock hints set in stored procedures or functions do not change the isolation level of the connection that calls them and are in effect only for the duration of the stored procedure or function call.</span></span>  
  
 <span data-ttu-id="c35c0-135">SQL-92 標準で定義された 4 つの分離レベルが、初期のバージョンの SQL Server ではサポートされていました。</span><span class="sxs-lookup"><span data-stu-id="c35c0-135">Four isolation levels defined in the SQL-92 standard were supported in early versions of SQL Server:</span></span>  
  
- <span data-ttu-id="c35c0-136">READ UNCOMMITTED は、他のトランザクションにより配置されたロックを無視するため、最も限定度が低い分離レベルです。</span><span class="sxs-lookup"><span data-stu-id="c35c0-136">READ UNCOMMITTED is the least restrictive isolation level because it ignores locks placed by other transactions.</span></span> <span data-ttu-id="c35c0-137">READ UNCOMMITTED の下で実行するトランザクションは、他のトランザクションによりまだコミットされていない、変更されたデータ値を読み取ることができます。これは "ダーティ" リードと呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="c35c0-137">Transactions executing under READ UNCOMMITTED can read modified data values that have not yet been committed by other transactions; these are called "dirty" reads.</span></span>  
  
- <span data-ttu-id="c35c0-138">READ COMMITTED は、SQL Server の既定の分離レベルです。</span><span class="sxs-lookup"><span data-stu-id="c35c0-138">READ COMMITTED is the default isolation level for SQL Server.</span></span> <span data-ttu-id="c35c0-139">この分離レベルは、別のトランザクションによりまだコミットされていない、変更されたデータ値を読み取れないようにステートメントを指定することにより、ダーティ リードを防ぎます。</span><span class="sxs-lookup"><span data-stu-id="c35c0-139">It prevents dirty reads by specifying that statements cannot read data values that have been modified but not yet committed by other transactions.</span></span> <span data-ttu-id="c35c0-140">その他のトランザクションは、現在のトランザクション内で各ステートメントが実行される合間にデータを変更、挿入、削除できますが、反復不可能読み取りや "ファントム" データになります。</span><span class="sxs-lookup"><span data-stu-id="c35c0-140">Other transactions can still modify, insert, or delete data between executions of individual statements within the current transaction, resulting in non-repeatable reads, or "phantom" data.</span></span>  
  
- <span data-ttu-id="c35c0-141">REPEATABLE READ は、READ COMMITTED よりも限定度が高い分離レベルです。</span><span class="sxs-lookup"><span data-stu-id="c35c0-141">REPEATABLE READ is a more restrictive isolation level than READ COMMITTED.</span></span> <span data-ttu-id="c35c0-142">この分離レベルは、READ COMMITTED を含みます。さらに、現在のトランザクションをコミットするまでは、現在のトランザクションにより読み取られているデータを、他のトランザクションによって変更したり削除されたりしないようにします。</span><span class="sxs-lookup"><span data-stu-id="c35c0-142">It encompasses READ COMMITTED and additionally specifies that no other transactions can modify or delete data that has been read by the current transaction until the current transaction commits.</span></span> <span data-ttu-id="c35c0-143">コンカレンシーは、READ COMMITTED の場合よりも低くなります。この理由は、読み取りデータ上で共有されるロックが、各ステートメントが終了するごとに解放されず、トランザクションが完了するまで保持されるためです。</span><span class="sxs-lookup"><span data-stu-id="c35c0-143">Concurrency is lower than for READ COMMITTED because shared locks on read data are held for the duration of the transaction instead of being released at the end of each statement.</span></span>  
  
- <span data-ttu-id="c35c0-144">SERIALIZABLE は、最も限定度の高い分離レベルで、トランザクションが完了するまで全範囲のキーをロックし、そのロックを保持します。</span><span class="sxs-lookup"><span data-stu-id="c35c0-144">SERIALIZABLE is the most restrictive isolation level, because it locks entire ranges of keys and holds the locks until the transaction is complete.</span></span> <span data-ttu-id="c35c0-145">この分離レベルは、REPEATABLE READ を含みます。また、トランザクションが完了するまでは、トランザクションにより読み取られる範囲内に、他のトランザクションによって新しい行が挿入されないようにする制限を追加します。</span><span class="sxs-lookup"><span data-stu-id="c35c0-145">It encompasses REPEATABLE READ and adds the restriction that other transactions cannot insert new rows into ranges that have been read by the transaction until the transaction is complete.</span></span>  
  
 <span data-ttu-id="c35c0-146">詳細については、「[トランザクションのロックおよび行のバージョン管理ガイド」](/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide)を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c35c0-146">For more information, refer to the [Transaction Locking and Row Versioning Guide](/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide).</span></span>  
  
### <a name="snapshot-isolation-level-extensions"></a><span data-ttu-id="c35c0-147">スナップショット分離レベルの拡張機能</span><span class="sxs-lookup"><span data-stu-id="c35c0-147">Snapshot Isolation Level Extensions</span></span>  
 <span data-ttu-id="c35c0-148">SQL Server では、SNAPSHOT 分離レベルの導入および READ COMMITTED の追加実装と共に、SQL-92 分離レベルの拡張機能が導入されました。</span><span class="sxs-lookup"><span data-stu-id="c35c0-148">SQL Server introduced extensions to the SQL-92 isolation levels with the introduction of the SNAPSHOT isolation level and an additional implementation of READ COMMITTED.</span></span> <span data-ttu-id="c35c0-149">READ_COMMITTED_SNAPSHOT 分離レベルは、すべてのトランザクションの READ COMMITTED を自動的に置き換えることができます。</span><span class="sxs-lookup"><span data-stu-id="c35c0-149">The READ_COMMITTED_SNAPSHOT isolation level can transparently replace READ COMMITTED for all transactions.</span></span>  
  
- <span data-ttu-id="c35c0-150">SNAPSHOT 分離は、トランザクション内で読み取るデータに、他の同時トランザクションによって加えられた変更が反映されないようにします。</span><span class="sxs-lookup"><span data-stu-id="c35c0-150">SNAPSHOT isolation specifies that data read within a transaction will never reflect changes made by other simultaneous transactions.</span></span> <span data-ttu-id="c35c0-151">トランザクションでは、トランザクションの開始時に存在するデータの行バージョンを使用します。</span><span class="sxs-lookup"><span data-stu-id="c35c0-151">The transaction uses the data row versions that exist when the transaction begins.</span></span> <span data-ttu-id="c35c0-152">データの読み取り時にロックがデータに配置されないため、データを書き込まれないようにスナップショット トランザクションによって他のトランザクションがブロックされるというようなことはありません。</span><span class="sxs-lookup"><span data-stu-id="c35c0-152">No locks are placed on the data when it is read, so SNAPSHOT transactions do not block other transactions from writing data.</span></span> <span data-ttu-id="c35c0-153">データを書き込むトランザクションは、スナップショット トランザクションによるデータの読み取りをブロックしません。</span><span class="sxs-lookup"><span data-stu-id="c35c0-153">Transactions that write data do not block snapshot transactions from reading data.</span></span> <span data-ttu-id="c35c0-154">スナップショット分離を使用するには、ALLOW_SNAPSHOT_ISOLATION データベース オプションを設定してスナップショット分離を有効にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="c35c0-154">You need to enable snapshot isolation by setting the ALLOW_SNAPSHOT_ISOLATION database option in order to use it.</span></span>  
  
- <span data-ttu-id="c35c0-155">READ_COMMITTED_SNAPSHOT データベース オプションは、スナップショット分離がデータベース内で有効になっている場合に、既定の READ COMMITTED 分離レベルの動作を決定します。</span><span class="sxs-lookup"><span data-stu-id="c35c0-155">The READ_COMMITTED_SNAPSHOT database option determines the behavior of the default READ COMMITTED isolation level when snapshot isolation is enabled in a database.</span></span> <span data-ttu-id="c35c0-156">READ_COMMITTED_SNAPSHOT ON を明示的に指定していない場合、READ COMMITTED はすべての暗黙のトランザクションに適用されます。</span><span class="sxs-lookup"><span data-stu-id="c35c0-156">If you do not explicitly specify READ_COMMITTED_SNAPSHOT ON, READ COMMITTED is applied to all implicit transactions.</span></span> <span data-ttu-id="c35c0-157">これにより、READ_COMMITTED_SNAPSHOT OFF (既定) を設定した場合と同じ動作が生成されます。</span><span class="sxs-lookup"><span data-stu-id="c35c0-157">This produces the same behavior as setting READ_COMMITTED_SNAPSHOT OFF (the default).</span></span> <span data-ttu-id="c35c0-158">READ_COMMITTED_SNAPSHOT OFF が有効になっている場合、データベース エンジンは共有ロックを使用して、既定の分離レベルを強制適用します。</span><span class="sxs-lookup"><span data-stu-id="c35c0-158">When READ_COMMITTED_SNAPSHOT OFF is in effect, the Database Engine uses shared locks to enforce the default isolation level.</span></span> <span data-ttu-id="c35c0-159">READ_COMMITTED_SNAPSHOT データベース オプションが ON に設定されている場合、データベース エンジンは、ロックを使用してデータを保護せずに、既定として行バージョン管理とスナップショット分離を使用します。</span><span class="sxs-lookup"><span data-stu-id="c35c0-159">If you set the READ_COMMITTED_SNAPSHOT database option to ON, the database engine uses row versioning and snapshot isolation as the default, instead of using locks to protect the data.</span></span>  
  
## <a name="how-snapshot-isolation-and-row-versioning-work"></a><span data-ttu-id="c35c0-160">スナップショット分離と行バージョン管理の機能について</span><span class="sxs-lookup"><span data-stu-id="c35c0-160">How Snapshot Isolation and Row Versioning Work</span></span>  
 <span data-ttu-id="c35c0-161">スナップショット分離レベルが有効になっている場合、行が更新されるたびに、SQL Server データベースエンジンによって、元の行のコピーが**tempdb**に格納され、その行にトランザクションシーケンス番号が追加されます。</span><span class="sxs-lookup"><span data-stu-id="c35c0-161">When the SNAPSHOT isolation level is enabled, each time a row is updated, the SQL Server Database Engine stores a copy of the original row in **tempdb**, and adds a transaction sequence number to the row.</span></span> <span data-ttu-id="c35c0-162">発生するイベントのシーケンスは次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="c35c0-162">The following is the sequence of events that occurs:</span></span>  
  
- <span data-ttu-id="c35c0-163">新しいトランザクションが開始され、トランザクション シーケンス番号が割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="c35c0-163">A new transaction is initiated, and it is assigned a transaction sequence number.</span></span>  
  
- <span data-ttu-id="c35c0-164">データベースエンジンは、トランザクション内の行を読み取り、その行バージョンを**tempdb**から取得します。この行のシーケンス番号は、トランザクションのシーケンス番号に最も近い、またはそれよりも小さい値に設定されています。</span><span class="sxs-lookup"><span data-stu-id="c35c0-164">The Database Engine reads a row within the transaction and retrieves the row version from **tempdb** whose sequence number is closest to, and lower than, the transaction sequence number.</span></span>  
  
- <span data-ttu-id="c35c0-165">データベース エンジンは、スナップショット トランザクションの開始時点でアクティブだったコミットされていないトランザクションのトランザクション シーケンス番号の一覧内に、トランザクション シーケンス番号があるかどうかを確認します。</span><span class="sxs-lookup"><span data-stu-id="c35c0-165">The Database Engine checks to see if the transaction sequence number is not in the list of transaction sequence numbers of the uncommitted transactions active when the snapshot transaction started.</span></span>  
  
- <span data-ttu-id="c35c0-166">トランザクションは、トランザクションの開始時点で現在の行のバージョンを**tempdb**から読み取ります。</span><span class="sxs-lookup"><span data-stu-id="c35c0-166">The transaction reads the version of the row from **tempdb** that was current as of the start of the transaction.</span></span> <span data-ttu-id="c35c0-167">トランザクションが開始された後で挿入された新しい行は、シーケンス番号の値がトランザクション シーケンス番号の値よりも大きくなるため確認されません。</span><span class="sxs-lookup"><span data-stu-id="c35c0-167">It will not see new rows inserted after the transaction was started because those sequence number values will be higher than the value of the transaction sequence number.</span></span>  
  
- <span data-ttu-id="c35c0-168">現在のトランザクションでは、トランザクションの開始後に削除された行が表示されます。これは、シーケンス番号の値が小さい**tempdb**に行バージョンが存在するためです。</span><span class="sxs-lookup"><span data-stu-id="c35c0-168">The current transaction will see rows that were deleted after the transaction began, because there will be a row version in **tempdb** with a lower sequence number value.</span></span>  
  
 <span data-ttu-id="c35c0-169">スナップショット分離の適用により、トランザクションは、基になるテーブル上でロックを受け付けたり配置したりすることなく、トランザクションの開始時に存在したすべてのデータを確認します。</span><span class="sxs-lookup"><span data-stu-id="c35c0-169">The net effect of snapshot isolation is that the transaction sees all of the data as it existed at the start of the transaction, without honoring or placing any locks on the underlying tables.</span></span> <span data-ttu-id="c35c0-170">その結果、競合がある状況でパフォーマンスが向上することになります。</span><span class="sxs-lookup"><span data-stu-id="c35c0-170">This can result in performance improvements in situations where there is contention.</span></span>  
  
 <span data-ttu-id="c35c0-171">スナップショット トランザクションでは、他のトランザクションによって行が更新されないようにするロックは使用せずに、常にオプティミスティック コンカレンシーを使用します。</span><span class="sxs-lookup"><span data-stu-id="c35c0-171">A snapshot transaction always uses optimistic concurrency control, withholding any locks that would prevent other transactions from updating rows.</span></span> <span data-ttu-id="c35c0-172">スナップショット トランザクションは、トランザクションの開始後に変更された行への更新をコミットしようとすると、このトランザクションがロールバックし、エラーになります。</span><span class="sxs-lookup"><span data-stu-id="c35c0-172">If a snapshot transaction attempts to commit an update to a row that was changed after the transaction began, the transaction is rolled back, and an error is raised.</span></span>  
  
## <a name="working-with-snapshot-isolation-in-adonet"></a><span data-ttu-id="c35c0-173">ADO.NET でのスナップショット分離の使用</span><span class="sxs-lookup"><span data-stu-id="c35c0-173">Working with Snapshot Isolation in ADO.NET</span></span>  
 <span data-ttu-id="c35c0-174">スナップショット分離は、<xref:System.Data.SqlClient.SqlTransaction> クラスによって ADO.NET 内でサポートされます。</span><span class="sxs-lookup"><span data-stu-id="c35c0-174">Snapshot isolation is supported in ADO.NET by the <xref:System.Data.SqlClient.SqlTransaction> class.</span></span> <span data-ttu-id="c35c0-175">データベースでスナップショット分離が有効になっているが、READ_COMMITTED_SNAPSHOT で構成されていない場合は、<xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A> メソッドを呼び出すときに、 **IsolationLevel**列挙値を使用して <xref:System.Data.SqlClient.SqlTransaction> を開始する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c35c0-175">If a database has been enabled for snapshot isolation but is not configured for READ_COMMITTED_SNAPSHOT ON, you must initiate a <xref:System.Data.SqlClient.SqlTransaction> using the **IsolationLevel.Snapshot** enumeration value when calling the <xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A> method.</span></span> <span data-ttu-id="c35c0-176">このコード フラグメントでは、接続は開かれている <xref:System.Data.SqlClient.SqlConnection> オブジェクトであることを前提としています。</span><span class="sxs-lookup"><span data-stu-id="c35c0-176">This code fragment assumes that connection is an open <xref:System.Data.SqlClient.SqlConnection> object.</span></span>  
  
```vb  
Dim sqlTran As SqlTransaction = _  
  connection.BeginTransaction(IsolationLevel.Snapshot)  
```  
  
```csharp  
SqlTransaction sqlTran =   
  connection.BeginTransaction(IsolationLevel.Snapshot);  
```  
  
### <a name="example"></a><span data-ttu-id="c35c0-177">例</span><span class="sxs-lookup"><span data-stu-id="c35c0-177">Example</span></span>  
 <span data-ttu-id="c35c0-178">ロックされたデータにアクセスしようとすることにより、分離レベルがそれぞれどのように動作するのかを、次の例に示します。このサンプルは、実行用のコードで使用されることは想定していません。</span><span class="sxs-lookup"><span data-stu-id="c35c0-178">The following example demonstrates how the different isolation levels behave by attempting to access locked data, and it is not intended to be used in production code.</span></span>  
  
 <span data-ttu-id="c35c0-179">このコードは、SQL Server の**AdventureWorks**サンプルデータベースに接続し、 **testsnapshot**という名前のテーブルを作成して、1行のデータを挿入します。</span><span class="sxs-lookup"><span data-stu-id="c35c0-179">The code connects to the **AdventureWorks** sample database in SQL Server and creates a table named **TestSnapshot** and inserts one row of data.</span></span> <span data-ttu-id="c35c0-180">コードには ALTER DATABASE Transact-SQL ステートメントを使用し、データベースのスナップショット分離を有効にします。このとき、既定の READ COMMITTED 分離レベルの動作を有効なままにし、READ_COMMITTED_SNAPSHOT オプションは設定しません。</span><span class="sxs-lookup"><span data-stu-id="c35c0-180">The code uses the ALTER DATABASE Transact-SQL statement to turn on snapshot isolation for the database, but it does not set the READ_COMMITTED_SNAPSHOT option, leaving the default READ COMMITTED isolation-level behavior in effect.</span></span> <span data-ttu-id="c35c0-181">続いてコードは、次のアクションを実行します。</span><span class="sxs-lookup"><span data-stu-id="c35c0-181">The code then performs the following actions:</span></span>  
  
- <span data-ttu-id="c35c0-182">更新トランザクションを開始するために、SERIALIZABLE 分離レベルを使用する sqlTransaction1 を開始し、完了しないようにします。</span><span class="sxs-lookup"><span data-stu-id="c35c0-182">It begins, but does not complete, sqlTransaction1, which uses the SERIALIZABLE isolation level to start an update transaction.</span></span> <span data-ttu-id="c35c0-183">これには、テーブルがロックするという効果があります。</span><span class="sxs-lookup"><span data-stu-id="c35c0-183">This has the effect of locking the table.</span></span>  
  
- <span data-ttu-id="c35c0-184">2番目の接続を開き、スナップショット分離レベルを使用して2番目のトランザクションを開始し、 **testsnapshot**テーブル内のデータを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="c35c0-184">It opens a second connection and initiates a second transaction using the SNAPSHOT isolation level to read the data in the **TestSnapshot** table.</span></span> <span data-ttu-id="c35c0-185">スナップショット分離が有効になっているため、このトランザクションは、sqlTransaction1 が開始する前に存在していたデータを読み取ることができます。</span><span class="sxs-lookup"><span data-stu-id="c35c0-185">Because snapshot isolation is enabled, this transaction can read the data that existed before sqlTransaction1 started.</span></span>  
  
- <span data-ttu-id="c35c0-186">3 つ目の接続を開いて、READ COMMITTED 分離レベルを使ってトランザクションを開始し、テーブル内のデータの読み取りを試みます。</span><span class="sxs-lookup"><span data-stu-id="c35c0-186">It opens a third connection and initiates a transaction using the READ COMMITTED isolation level to attempt to read the data in the table.</span></span> <span data-ttu-id="c35c0-187">この場合、コードはデータを読み取れません。コードは最初のトランザクション内のテーブルに置かれたロックを超えて読み取りを行うことができず、タイムアウトになるためです。REPEATABLE READ 分離レベルと SERIALIZABLE 分離レベルが使用されている場合は、これらの分離レベルも、最初のトランザクション内に置かれたロックを超えて読み取りを行うことができないため、同じ結果になります。</span><span class="sxs-lookup"><span data-stu-id="c35c0-187">In this case, the code cannot read the data because it cannot read past the locks placed on the table in the first transaction and times out. The same result would occur if the REPEATABLE READ and SERIALIZABLE isolation levels were used because these isolation levels also cannot read past the locks placed in the first transaction.</span></span>  
  
- <span data-ttu-id="c35c0-188">4 つ目の接続を開き、sqlTransaction1 内でコミットされていない値のダーティ リードを実行する READ UNCOMMITTED 分離レベルを使用し、トランザクションを開始します。</span><span class="sxs-lookup"><span data-stu-id="c35c0-188">It opens a fourth connection and initiates a transaction using the READ UNCOMMITTED isolation level, which performs a dirty read of the uncommitted value in sqlTransaction1.</span></span> <span data-ttu-id="c35c0-189">最初のトランザクションがコミットされていない場合、この値は実際にデータベース内には存在しません。</span><span class="sxs-lookup"><span data-stu-id="c35c0-189">This value may never actually exist in the database if the first transaction is not committed.</span></span>  
  
- <span data-ttu-id="c35c0-190">**Testsnapshot**テーブルを削除し、 **AdventureWorks**データベースのスナップショット分離をオフにすることで、最初のトランザクションをロールバックし、クリーンアップします。</span><span class="sxs-lookup"><span data-stu-id="c35c0-190">It rolls back the first transaction and cleans up by deleting the **TestSnapshot** table and turning off snapshot isolation for the **AdventureWorks** database.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="c35c0-191">次の例では、接続プールを無効にした状態で同じ接続文字列を使用します。</span><span class="sxs-lookup"><span data-stu-id="c35c0-191">The following examples use the same connection string with connection pooling turned off.</span></span> <span data-ttu-id="c35c0-192">接続をプールした場合、その分離レベルをリセットしても、サーバー側の分離レベルはリセットされません。</span><span class="sxs-lookup"><span data-stu-id="c35c0-192">If a connection is pooled, resetting its isolation level does not reset the isolation level at the server.</span></span> <span data-ttu-id="c35c0-193">その結果、同じプールされた内部接続を使用する後続の接続は、プールされた接続と同じ分離レベルで開始されることになります。</span><span class="sxs-lookup"><span data-stu-id="c35c0-193">As a result, subsequent connections that use the same pooled inner connection start with their isolation levels set to that of the pooled connection.</span></span> <span data-ttu-id="c35c0-194">接続プールを無効にする代わりに、各接続について分離レベルを明示的に設定することもできます。</span><span class="sxs-lookup"><span data-stu-id="c35c0-194">An alternative to turning off connection pooling is to set the isolation level explicitly for each connection.</span></span>  
  
 [!code-csharp[DataWorks SnapshotIsolation.Demo#1](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.Demo/CS/source.cs#1)]
 [!code-vb[DataWorks SnapshotIsolation.Demo#1](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.Demo/VB/source.vb#1)]  
  
### <a name="example"></a><span data-ttu-id="c35c0-195">例</span><span class="sxs-lookup"><span data-stu-id="c35c0-195">Example</span></span>  
 <span data-ttu-id="c35c0-196">データ変更が行われている間のスナップショット分離の動作の例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="c35c0-196">The following example demonstrates the behavior of snapshot isolation when data is being modified.</span></span> <span data-ttu-id="c35c0-197">コードは、次のアクションを実行します。</span><span class="sxs-lookup"><span data-stu-id="c35c0-197">The code performs the following actions:</span></span>  
  
- <span data-ttu-id="c35c0-198">**AdventureWorks**サンプルデータベースに接続し、スナップショット分離を有効にします。</span><span class="sxs-lookup"><span data-stu-id="c35c0-198">Connects to the **AdventureWorks** sample database and enables SNAPSHOT isolation.</span></span>  
  
- <span data-ttu-id="c35c0-199">**Testsnapshotupdate**という名前のテーブルを作成し、サンプルデータを3行挿入します。</span><span class="sxs-lookup"><span data-stu-id="c35c0-199">Creates a table named **TestSnapshotUpdate** and inserts three rows of sample data.</span></span>  
  
- <span data-ttu-id="c35c0-200">SNAPSHOT 分離を使って sqlTransaction1 を開始し、完了しないようにします。</span><span class="sxs-lookup"><span data-stu-id="c35c0-200">Begins, but does not complete, sqlTransaction1 using SNAPSHOT isolation.</span></span> <span data-ttu-id="c35c0-201">3 行のデータがトランザクション内で選択されます。</span><span class="sxs-lookup"><span data-stu-id="c35c0-201">Three rows of data are selected in the transaction.</span></span>  
  
- <span data-ttu-id="c35c0-202">**AdventureWorks**に対して2番目の**SqlConnection**を作成し、READ COMMITTED 分離レベルを使用して2番目のトランザクションを作成し、sqlTransaction1 で選択した行の1つの値を更新します。</span><span class="sxs-lookup"><span data-stu-id="c35c0-202">Creates a second **SqlConnection** to **AdventureWorks** and creates a second transaction using the READ COMMITTED isolation level that updates a value in one of the rows selected in sqlTransaction1.</span></span>  
  
- <span data-ttu-id="c35c0-203">sqlTransaction2 をコミットします。</span><span class="sxs-lookup"><span data-stu-id="c35c0-203">Commits sqlTransaction2.</span></span>  
  
- <span data-ttu-id="c35c0-204">sqlTransaction1 に戻り、sqlTransaction1 がコミットした行と同じ行の更新を試みます。</span><span class="sxs-lookup"><span data-stu-id="c35c0-204">Returns to sqlTransaction1 and attempts to update the same row that sqlTransaction1 already committed.</span></span> <span data-ttu-id="c35c0-205">エラー 3960 が発生し、sqlTransaction1 は自動的にロールバックされます。</span><span class="sxs-lookup"><span data-stu-id="c35c0-205">Error 3960 is raised, and sqlTransaction1 is rolled back automatically.</span></span> <span data-ttu-id="c35c0-206">**SqlException**と**SqlException**がコンソールウィンドウに表示されます。</span><span class="sxs-lookup"><span data-stu-id="c35c0-206">The **SqlException.Number** and **SqlException.Message** are displayed in the Console window.</span></span>  
  
- <span data-ttu-id="c35c0-207">**AdventureWorks**でスナップショット分離を無効にし、 **testsnapshotupdate**テーブルを削除するクリーンアップコードを実行します。</span><span class="sxs-lookup"><span data-stu-id="c35c0-207">Executes clean-up code to turn off snapshot isolation in **AdventureWorks** and delete the **TestSnapshotUpdate** table.</span></span>  
  
 [!code-csharp[DataWorks SnapshotIsolation.DemoUpdate#1](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.DemoUpdate/CS/source.cs#1)]
 [!code-vb[DataWorks SnapshotIsolation.DemoUpdate#1](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.DemoUpdate/VB/source.vb#1)]  
  
### <a name="using-lock-hints-with-snapshot-isolation"></a><span data-ttu-id="c35c0-208">スナップショット分離でのロック ヒントの使用</span><span class="sxs-lookup"><span data-stu-id="c35c0-208">Using Lock Hints with Snapshot Isolation</span></span>  
 <span data-ttu-id="c35c0-209">前の例では、最初のトランザクションがデータを選択し、このトランザクションが完了する前に 2 つ目のトランザクションがデータを更新しています。その結果、最初のトランザクションが同じ行を更新しようとすると、競合が発生します。</span><span class="sxs-lookup"><span data-stu-id="c35c0-209">In the previous example, the first transaction selects data, and a second transaction updates the data before the first transaction is able to complete, causing an update conflict when the first transaction tries to update the same row.</span></span> <span data-ttu-id="c35c0-210">トランザクションの先頭にロック ヒントを指定することにより、長時間にわたるスナップショット トランザクションにおいて更新競合が発生する可能性を軽減できます。</span><span class="sxs-lookup"><span data-stu-id="c35c0-210">You can reduce the chance of update conflicts in long-running snapshot transactions by supplying lock hints at the beginning of the transaction.</span></span> <span data-ttu-id="c35c0-211">次の SELECT ステートメントでは、選択した行をロックするために、UPDLOCK ヒントが使用されています。</span><span class="sxs-lookup"><span data-stu-id="c35c0-211">The following SELECT statement uses the UPDLOCK hint to lock the selected rows:</span></span>  
  
```sql  
SELECT * FROM TestSnapshotUpdate WITH (UPDLOCK)   
  WHERE PriKey BETWEEN 1 AND 3  
```  
  
 <span data-ttu-id="c35c0-212">UPDLOCK ロック ヒントを使用すると、最初のトランザクションが完了する前に行が更新されるのをブロックします。</span><span class="sxs-lookup"><span data-stu-id="c35c0-212">Using the UPDLOCK lock hint blocks any rows attempting to update the rows before the first transaction completes.</span></span> <span data-ttu-id="c35c0-213">これにより、選択した行が後にトランザクション内で更新されるときに、競合が発生しないことが保証されます。</span><span class="sxs-lookup"><span data-stu-id="c35c0-213">This guarantees that the selected rows have no conflicts when they are updated later in the transaction.</span></span> <span data-ttu-id="c35c0-214">SQL Server オンライン ブックの「ロックのヒント」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c35c0-214">See "Locking Hints" in SQL Server Books Online.</span></span>  
  
 <span data-ttu-id="c35c0-215">アプリケーションで競合が多数発生する場合、スナップショット分離は適切な選択肢ではない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c35c0-215">If your application has many conflicts, snapshot isolation may not be the best choice.</span></span> <span data-ttu-id="c35c0-216">ヒントの使用は、本当に必要な場合のみに制限する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c35c0-216">Hints should only be used when really needed.</span></span> <span data-ttu-id="c35c0-217">アプリケーションは、ロック ヒントに常に依存する操作にならないように設計されている必要があります。</span><span class="sxs-lookup"><span data-stu-id="c35c0-217">Your application should not be designed so that it constantly relies on lock hints for its operation.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="c35c0-218">関連項目</span><span class="sxs-lookup"><span data-stu-id="c35c0-218">See also</span></span>

- [<span data-ttu-id="c35c0-219">SQL Server と ADO.NET</span><span class="sxs-lookup"><span data-stu-id="c35c0-219">SQL Server and ADO.NET</span></span>](index.md)
- [<span data-ttu-id="c35c0-220">ADO.NET の概要</span><span class="sxs-lookup"><span data-stu-id="c35c0-220">ADO.NET Overview</span></span>](../ado-net-overview.md)
- [<span data-ttu-id="c35c0-221">トランザクションのロックおよび行のバージョン管理ガイド</span><span class="sxs-lookup"><span data-stu-id="c35c0-221">Transaction Locking and Row Versioning Guide</span></span>](/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide)
