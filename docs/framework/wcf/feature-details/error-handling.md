---
title: エラー処理
ms.date: 03/30/2017
ms.assetid: c948841a-7db9-40ae-9b78-587d216cbcaf
ms.openlocfilehash: ffcc817eb463a1787972bc9c4ae1434ff74f7bb4
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/04/2018
---
# <a name="error-handling"></a>エラー処理
## <a name="error-handling-in-windows-communication-foundation"></a>Windows Communication Foundation でのエラー処理  
 サービスで予期しない例外やエラーが発生した場合、例外処理ソリューションを設計する方法は複数あります。 ありませんが 1 つの「適切」または「最善」エラー処理ソリューションでは、考慮すべき 1 つの複数の有効なパスがあります。 未処理の性質と複雑さによっては、WCF 実装ではの種類と頻度、例外を処理されるは、下の一覧から複数の方法を組み合わせたハイブリッド ソリューションを実装するいずれかのことを通常お勧めします例外、および任意のトレース、ログ記録、またはポリシー要件に関連付けられています。  
  
 これらのソリューションについては、このセクションの残りの部分で詳しく説明します。  
  
### <a name="the-microsoft-enterprise-library"></a>Microsoft Enterprise Library  
 Microsoft Enterprise Library Exception Handling Application Block は、共通の設計パターンを実装し、エンタープライズ アプリケーションのすべてのアーキテクチャ レイヤーで発生する例外を処理するための一貫した戦略を策定するのに役立ちます。 これは、アプリケーション コンポーネントの catch ステートメントに含まれる一般的なコードをサポートするように設計されています。 開発者は、アプリケーション全体で同一の catch ブロックにこのコード (例外情報をログに記録するコードなど) を繰り返し使用する代わりに、Exception Handling Application Block を使用すると、このロジックを再利用可能な例外ハンドラーとしてカプセル化できます。  
  
 このライブラリには、すぐに使用できる Fault Contract Exception Handler が含まれています。 この例外ハンドラーは、Windows® Communication Foundation (WCF) のサービス境界で使用することを目的に設計されており、例外から新しいエラー コントラクトを生成します。  
  
 アプリケーション ブロックは、よく使用されるベスト プラクティスを組み込み、アプリケーション全体の例外処理に共通の方法を提供することを目的としています。 その一方で、独自に開発されたカスタム エラー ハンドラーやエラー コントラクトが非常に便利な場合もあります。 たとえば、カスタム エラー ハンドラーは、絶好のチャンスに自動的に FaultExceptions にすべての例外を昇格し、ログ記録機能をアプリケーションに追加を提供します。  
  
 詳細についてを参照してください[Microsoft Enterprise Library](http://msdn.microsoft.com/library/ff632023.aspx)です。  
  
### <a name="dealing-with-expected-exceptions"></a>予期される例外の処理  
 一連の適切な措置は操作または関連する機能拡張ポイントに予期される例外をキャッチから、回復することができ、FaultException で適切なカスタム エラーを返すかどうかを決定する\<T >  
  
### <a name="dealing-with-unexpected-exceptions-using-an-ierrorhandler"></a>IErrorHandler を使用した予期しない例外の処理  
 予期しない例外の処理をするには、推奨される一連の措置は、IErrorHandler を「フック」です。 エラー ハンドラーは、チャネル レイヤーではなく、WCF ランタイム レベル (「サービス モデル」層) でのみ例外をキャッチします。 チャネル レベルで IErrorHandler をフックする唯一の方法は、カスタム チャネルを作成することです。ただし、これはほとんどのシナリオで推奨されていません。  
  
 回復不可能な例外も処理例外は、「予期しない例外」は、通常、これは、代わりに、予期しないユーザー例外です。 回復不可能な例外 (メモリ不足の例外) – などいずれかの通常によって処理される、[サービス モデルの例外ハンドラー](http://msdn.microsoft.com/library/system.servicemodel.dispatcher.exceptionhandler.aspx)自動的に – 一般的に処理できない、およびそのような例外を処理する唯一の理由追加のログ記録がすべての可能性がありますまたは標準の例外をクライアントに返します。 処理例外は、シリアル化、エンコーダー、フォーマッタ レベルなどのメッセージの処理中に発生します。通常、この例外は IErrorHandler では処理できません。これは、一般的に、このような例外が発生するまでにエラー ハンドラーの介入が早すぎるか、遅すぎることが原因です。 同様に、トランスポート例外も IErrorHandler では処理できません。  
  
 IErrorHandler を使用すると、例外がスローされたときのアプリケーションの動作を明示的に制御できます。 次のような操作が可能です。  
  
1.  クライアントにエラーを送信するかどうかを決定する  
  
2.  例外をエラーに置き換える  
  
3.  エラーを別のエラーに置き換える  
  
4.  ログまたはトレースを実行する  
  
5.  他のカスタム アクティビティを実行する  
  
 カスタム エラー ハンドラーは、サービスのチャネル ディスパッチャーの ErrorHandlers プロパティに追加することでインストールできます。  複数のエラー ハンドラーを設定することができ、これらはこのコレクションに追加された順序で呼び出されます。  
  
 IErrorHandler.ProvideFault は、クライアントに送信されるエラー メッセージを制御します。 このメソッドは、サービスの操作によってスローされた例外の種類に関係なく呼び出されます。 ここで操作が実行されない場合、WCF は、その既定の動作を想定し、カスタム エラー ハンドラーが存在しないかのように続行します。  
  
 この方法を使用する可能性がある場合として、クライアントに送信される前の例外をエラーに変換するための一元的な場所を作成する場合があります (インスタンスが破棄されておらず、チャネルが Faulted 状態に移行していないことを確認します)。  
  
 通常、IErrorHandler.HandleError メソッドは、エラー ログ記録、システム通知、アプリケーションのシャットダウンなど、エラー関連の動作を実装するために使用されます。IErrorHandler.HandleError は、サービス内の複数の場所で呼び出すことができます。エラーがスローされた場所に応じて、HandleError メソッドは操作と同じスレッドから呼び出される場合と呼び出されない場合があります (この点について保証はありません)。  
  
### <a name="dealing-with-exceptions-outside-wcf"></a>WCF 外部での例外の処理  
 多くの場合、構成の例外、データベース接続文字列の例外、およびその他の同様の例外は、WCF アプリケーションのコンテキスト内で発生する可能性がありますが、これらの例外自体は、サービス モデルまたは Web サービス自体が原因で発生する例外ではありません。 これらの例外は、web サービス外部の「標準」の例外し、環境内の他の外部例外が処理されると同様に扱う必要があります。  
  
### <a name="tracing-exceptions"></a>例外のトレース  
 トレースは、いずれかの参照先を可能性のあるすべての例外のみ「キャッチ オール」場所です。 例外のトレースとログの詳細については、「トレースとログ」を参照してください。  
  
### <a name="uri-template-errors-when-using-webgetattribute-and-webinvokeattribute"></a>WebGetAttribute と WebInvokeAttribute を使用した場合の URI テンプレート エラー  
 WebGet 属性と WebInvoke 属性を使用すると、要求アドレスのコンポーネントを操作パラメーターにマップする URI テンプレートを指定できます。 たとえば、URI テンプレートが "weather/{state}/{city}" の場合は、要求アドレスがリテラル トークン、state という名前のパラメーター、および city という名前にマップされます。 その後、これらのパラメーターは、名前によって、操作の仮パラメーターの一部にバインドされる場合があります。  
  
 テンプレート パラメーターが URI 内の文字列の形式で表されるのに対し、型指定されたコントラクトの仮パラメーターは文字列以外の型である可能性があります。 そのため、操作が呼び出される前に変換を行う必要があります。 A[変換形式のテーブル](http://msdn.microsoft.com/library/bb412172.aspx)は使用できます。  
  
 ただし、変換に失敗した場合は、失敗したことを操作に認識させる方法はありません。 代わりに、型変換は、ディスパッチ エラーの形式で表示されます。  
  
 型変換のディスパッチ エラーは、エラー ハンドラーをインストールすることで、その他多くの種類のディスパッチ エラーと同様に調査できます。 IErrorHandler 機能拡張ポイントは、サービス レベルの例外を処理するために呼び出されます。 そこから、呼び出し元に返される応答を選択できます (カスタム タスクとレポートを実行することもできます)。  
  
## <a name="see-also"></a>関連項目  
 [基本的な WCF エラー処理](http://msdn.microsoft.com/library/gg281715.aspx)
