---
title: セッション、インスタンス化、およびコンカレンシー
ms.date: 03/30/2017
ms.assetid: 50797a3b-7678-44ed-8138-49ac1602f35b
ms.openlocfilehash: 52c9ed5d672ea05fec3333c9fece8b693143d6f3
ms.sourcegitcommit: 2701302a99cafbe0d86d53d540eb0fa7e9b46b36
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/28/2019
ms.locfileid: "64586110"
---
# <a name="sessions-instancing-and-concurrency"></a><span data-ttu-id="c63d3-102">セッション、インスタンス化、およびコンカレンシー</span><span class="sxs-lookup"><span data-stu-id="c63d3-102">Sessions, Instancing, and Concurrency</span></span>
<span data-ttu-id="c63d3-103">*"セッション"* とは、2 つのエンドポイント間で送信されるすべてのメッセージを相互に関連付けたものです。</span><span class="sxs-lookup"><span data-stu-id="c63d3-103">A *session* is a correlation of all messages sent between two endpoints.</span></span> <span data-ttu-id="c63d3-104">*"インスタンス化"* とは、ユーザー定義のサービス オブジェクトとこれらのオブジェクトに関連する <xref:System.ServiceModel.InstanceContext> オブジェクトの有効期間を制御することです。</span><span class="sxs-lookup"><span data-stu-id="c63d3-104">*Instancing* refers to controlling the lifetime of user-defined service objects and their related <xref:System.ServiceModel.InstanceContext> objects.</span></span> <span data-ttu-id="c63d3-105">また、*コンカレンシー*は、<xref:System.ServiceModel.InstanceContext> で同時に実行されるスレッドの数の制御を表す用語です。</span><span class="sxs-lookup"><span data-stu-id="c63d3-105">*Concurrency* is the term given to the control of the number of threads executing in an <xref:System.ServiceModel.InstanceContext> at the same time.</span></span>  
  
 <span data-ttu-id="c63d3-106">ここでは、これらの設定とその使用方法、各設定間のさまざまな相互作用について説明します。</span><span class="sxs-lookup"><span data-stu-id="c63d3-106">This topic describes these settings, how to use them, and the various interactions between them.</span></span>  
  
## <a name="sessions"></a><span data-ttu-id="c63d3-107">セッション</span><span class="sxs-lookup"><span data-stu-id="c63d3-107">Sessions</span></span>  
 <span data-ttu-id="c63d3-108">サービス コントラクトによって <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType> プロパティが <xref:System.ServiceModel.SessionMode.Required?displayProperty=nameWithType>に設定されている場合、すべての呼び出し (つまり、呼び出しをサポートする、基になるメッセージ交換) を同じメッセージ交換の一部にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="c63d3-108">When a service contract sets the <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType> property to <xref:System.ServiceModel.SessionMode.Required?displayProperty=nameWithType>, that contract is saying that all calls (that is, the underlying message exchanges that support the calls) must be part of the same conversation.</span></span> <span data-ttu-id="c63d3-109">セッションが許可されるが必須ではないコントラクトの場合、クライアントは、接続した後にセッションを確立できます。また、セッションを確立しないままにしておくこともできます。</span><span class="sxs-lookup"><span data-stu-id="c63d3-109">If a contract specifies that it allows sessions but does not require one, clients can connect and either establish a session or not.</span></span> <span data-ttu-id="c63d3-110">セッションが終了したのに、同じセッション ベースのチャネルでメッセージが送信されると、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="c63d3-110">If the session ends and a message is sent over the same session-based channel an exception is thrown.</span></span>  
  
 <span data-ttu-id="c63d3-111">WCF のセッションでは、次の主な概念の機能があります。</span><span class="sxs-lookup"><span data-stu-id="c63d3-111">WCF sessions have the following main conceptual features:</span></span>  
  
- <span data-ttu-id="c63d3-112">呼び出し側アプリケーションによって明示的に開始および終了される。</span><span class="sxs-lookup"><span data-stu-id="c63d3-112">They are explicitly initiated and terminated by the calling application.</span></span>  
  
- <span data-ttu-id="c63d3-113">セッション中に配信されたメッセージは、受信された順に処理される。</span><span class="sxs-lookup"><span data-stu-id="c63d3-113">Messages delivered during a session are processed in the order in which they are received.</span></span>  
  
- <span data-ttu-id="c63d3-114">セッションはメッセージのグループを相互に関連付けて通信を行う。</span><span class="sxs-lookup"><span data-stu-id="c63d3-114">Sessions correlate a group of messages into a conversation.</span></span> <span data-ttu-id="c63d3-115">ここで "相互に関連付ける" は、抽象的な意味を持ちます。</span><span class="sxs-lookup"><span data-stu-id="c63d3-115">The meaning of that correlation is an abstraction.</span></span> <span data-ttu-id="c63d3-116">たとえば、あるセッション ベースのチャネルでは、共有ネットワーク接続に基づいてメッセージが相互に関連付けられる一方、別のセッション ベースのチャネルでは、メッセージ本文にある共有タグに基づいてメッセージが相互に関連付けられます。</span><span class="sxs-lookup"><span data-stu-id="c63d3-116">For instance, one session-based channel may correlate messages based on a shared network connection while another session-based channel may correlate messages based on a shared tag in the message body.</span></span> <span data-ttu-id="c63d3-117">セッションから派生可能な機能は、相互関連付けの性質によって異なります。</span><span class="sxs-lookup"><span data-stu-id="c63d3-117">The features that can be derived from the session depend on the nature of the correlation.</span></span>  
  
- <span data-ttu-id="c63d3-118">WCF のセッションに関連付けられた一般的なデータ ストアはありません。</span><span class="sxs-lookup"><span data-stu-id="c63d3-118">There is no general data store associated with a WCF session.</span></span>  
  
 <span data-ttu-id="c63d3-119">慣れている場合、<xref:System.Web.SessionState.HttpSessionState?displayProperty=nameWithType>クラス[!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)]アプリケーションと機能を提供、可能性があります、その種のセッションと WCF のセッションの間の次の相違点に注意してください。</span><span class="sxs-lookup"><span data-stu-id="c63d3-119">If you are familiar with the <xref:System.Web.SessionState.HttpSessionState?displayProperty=nameWithType> class in [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] applications and the functionality it provides, you might notice the following differences between that kind of session and WCF sessions:</span></span>  
  
- [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] <span data-ttu-id="c63d3-120">セッションは、常にサーバーによって開始される。</span><span class="sxs-lookup"><span data-stu-id="c63d3-120">sessions are always server-initiated.</span></span>  
  
- [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] <span data-ttu-id="c63d3-121">セッションは、暗黙的に順序付けされない。</span><span class="sxs-lookup"><span data-stu-id="c63d3-121">sessions are implicitly unordered.</span></span>  
  
- [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] <span data-ttu-id="c63d3-122">セッションは、要求全体について一般的なデータ ストレージ機構を提供する。</span><span class="sxs-lookup"><span data-stu-id="c63d3-122">sessions provide a general data storage mechanism across requests.</span></span>  
  
 <span data-ttu-id="c63d3-123">クライアント アプリケーションとサービス アプリケーションでは、異なる方法でセッションと対話します。</span><span class="sxs-lookup"><span data-stu-id="c63d3-123">Client applications and service applications interact with sessions in different ways.</span></span> <span data-ttu-id="c63d3-124">クライアント アプリケーションはセッションを開始し、セッション内で送信されてきたメッセージの受信と処理を行います。</span><span class="sxs-lookup"><span data-stu-id="c63d3-124">Client applications initiate sessions and then receive and process the messages sent within the session.</span></span> <span data-ttu-id="c63d3-125">サービス アプリケーションでは、動作を追加するための機能拡張ポイントとしてセッションを使用できます。</span><span class="sxs-lookup"><span data-stu-id="c63d3-125">Service applications can use sessions as an extensibility point to add additional behavior.</span></span> <span data-ttu-id="c63d3-126">これは <xref:System.ServiceModel.InstanceContext> を直接操作する、またはカスタムのインスタンス コンテキスト プロバイダーを実装することで可能になります。</span><span class="sxs-lookup"><span data-stu-id="c63d3-126">This is done by working directly with the <xref:System.ServiceModel.InstanceContext> or implementing a custom instance context provider.</span></span>  
  
## <a name="instancing"></a><span data-ttu-id="c63d3-127">"インスタンス化"</span><span class="sxs-lookup"><span data-stu-id="c63d3-127">Instancing</span></span>  
 <span data-ttu-id="c63d3-128">インスタンス化動作 ( <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> プロパティを使用して設定します) は、受信メッセージに応答して <xref:System.ServiceModel.InstanceContext> を作成する方法を制御します。</span><span class="sxs-lookup"><span data-stu-id="c63d3-128">The instancing behavior (set by using the <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> property) controls how the <xref:System.ServiceModel.InstanceContext> is created in response to incoming messages.</span></span> <span data-ttu-id="c63d3-129">既定では、各 <xref:System.ServiceModel.InstanceContext> は 1 つのユーザー定義サービス オブジェクトに関連付けられています。したがって、(既定では) <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> プロパティを設定することによってもユーザー定義サービス オブジェクトのインスタンス化を制御できます。</span><span class="sxs-lookup"><span data-stu-id="c63d3-129">By default, each <xref:System.ServiceModel.InstanceContext> is associated with one user-defined service object, so (in the default case) setting the <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> property also controls the instancing of user-defined service objects.</span></span> <span data-ttu-id="c63d3-130">インスタンス化モードは <xref:System.ServiceModel.InstanceContextMode> 列挙体によって定義されます。</span><span class="sxs-lookup"><span data-stu-id="c63d3-130">The <xref:System.ServiceModel.InstanceContextMode> enumeration defines the instancing modes.</span></span>  
  
 <span data-ttu-id="c63d3-131">次のインスタンス化モードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="c63d3-131">The following instancing modes are available:</span></span>  
  
- <span data-ttu-id="c63d3-132"><xref:System.ServiceModel.InstanceContextMode.PerCall>:新しい<xref:System.ServiceModel.InstanceContext>(およびサービス オブジェクト) がクライアント要求ごとに作成されます。</span><span class="sxs-lookup"><span data-stu-id="c63d3-132"><xref:System.ServiceModel.InstanceContextMode.PerCall>: A new <xref:System.ServiceModel.InstanceContext> (and therefore service object) is created for each client request.</span></span>  
  
- <span data-ttu-id="c63d3-133"><xref:System.ServiceModel.InstanceContextMode.PerSession>:新しい<xref:System.ServiceModel.InstanceContext>(およびサービス オブジェクト) が新しいクライアント セッションごとに作成され、(セッションをサポートするバインディングが必要)、そのセッションの有効期間にわたって保持されます。</span><span class="sxs-lookup"><span data-stu-id="c63d3-133"><xref:System.ServiceModel.InstanceContextMode.PerSession>: A new <xref:System.ServiceModel.InstanceContext> (and therefore service object) is created for each new client session and maintained for the lifetime of that session (this requires a binding that supports sessions).</span></span>  
  
- <span data-ttu-id="c63d3-134"><xref:System.ServiceModel.InstanceContextMode.Single>:1 つ<xref:System.ServiceModel.InstanceContext>(およびサービス オブジェクト)、アプリケーションの有効期間のすべてのクライアント要求を処理します。</span><span class="sxs-lookup"><span data-stu-id="c63d3-134"><xref:System.ServiceModel.InstanceContextMode.Single>: A single <xref:System.ServiceModel.InstanceContext> (and therefore service object) handles all client requests for the lifetime of the application.</span></span>  
  
 <span data-ttu-id="c63d3-135">既定の <xref:System.ServiceModel.InstanceContextMode> 値 (サービス クラスで明示的に設定された <xref:System.ServiceModel.InstanceContextMode.PerSession> ) を次のコード例に示します。</span><span class="sxs-lookup"><span data-stu-id="c63d3-135">The following code example shows the default <xref:System.ServiceModel.InstanceContextMode> value, <xref:System.ServiceModel.InstanceContextMode.PerSession> being explicitly set on a service class.</span></span>  
  
```  
[ServiceBehavior(InstanceContextMode=InstanceContextMode.PerSession)]   
public class CalculatorService : ICalculatorInstance   
{   
    ...  
}  
```  
  
 <span data-ttu-id="c63d3-136">また、 <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> プロパティは <xref:System.ServiceModel.InstanceContext> の解放頻度を制御しますが、 <xref:System.ServiceModel.OperationBehaviorAttribute.ReleaseInstanceMode%2A?displayProperty=nameWithType> プロパティと <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A?displayProperty=nameWithType> プロパティはサービス オブジェクトの解放時期を制御します。</span><span class="sxs-lookup"><span data-stu-id="c63d3-136">And while the <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> property controls how often the <xref:System.ServiceModel.InstanceContext> is released, the <xref:System.ServiceModel.OperationBehaviorAttribute.ReleaseInstanceMode%2A?displayProperty=nameWithType> and <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A?displayProperty=nameWithType> properties control when the service object is released.</span></span>  
  
### <a name="well-known-singleton-services"></a><span data-ttu-id="c63d3-137">既知のシングルトン サービス</span><span class="sxs-lookup"><span data-stu-id="c63d3-137">Well-Known Singleton Services</span></span>  
 <span data-ttu-id="c63d3-138">単一インスタンス サービス オブジェクトの 1 つのバリエーションとして、サービス オブジェクトをユーザーが自分で作成し、このオブジェクトを使用してサービス ホストを作成すると有用な場合があります。</span><span class="sxs-lookup"><span data-stu-id="c63d3-138">One variation on single instance service objects is sometimes useful: you can create a service object yourself and create the service host using that object.</span></span> <span data-ttu-id="c63d3-139">そのためには、 <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> プロパティを <xref:System.ServiceModel.InstanceContextMode.Single> に設定するか、サービス ホストが開かれたときに例外をスローする必要があります。</span><span class="sxs-lookup"><span data-stu-id="c63d3-139">To do so, you must also set the <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> property to <xref:System.ServiceModel.InstanceContextMode.Single> or an exception is thrown when the service host is opened.</span></span>  
  
 <span data-ttu-id="c63d3-140">このようなサービスを作成するには、 <xref:System.ServiceModel.ServiceHost.%23ctor%28System.Object%2CSystem.Uri%5B%5D%29?displayProperty=nameWithType> コンストラクターを使用します。</span><span class="sxs-lookup"><span data-stu-id="c63d3-140">Use the <xref:System.ServiceModel.ServiceHost.%23ctor%28System.Object%2CSystem.Uri%5B%5D%29?displayProperty=nameWithType> constructor to create such a service.</span></span> <span data-ttu-id="c63d3-141">この方法は、シングルトン サービスが使用する特定のオブジェクト インスタンスを提供する場合に、カスタムの <xref:System.ServiceModel.Dispatcher.IInstanceContextInitializer?displayProperty=nameWithType> を実装する代わりに使用できます。</span><span class="sxs-lookup"><span data-stu-id="c63d3-141">It provides an alternative to implementing a custom <xref:System.ServiceModel.Dispatcher.IInstanceContextInitializer?displayProperty=nameWithType> when you wish to provide a specific object instance for use by a singleton service.</span></span> <span data-ttu-id="c63d3-142">サービス実装の型を作成することが困難な場合 (たとえば、既定のパラメーターなしのコンストラクターが作成されない場合) は、このオーバーロードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="c63d3-142">You can use this overload when your service implementation type is difficult to construct (for example, if it does not implement a default parameterless public constructor).</span></span>  
  
 <span data-ttu-id="c63d3-143">あるオブジェクトをこのコンス トラクターに指定するとと、いくつか機能の動作をインスタンス化 Windows Communication Foundation (WCF) に関連する動作が異なりますに注意してください。</span><span class="sxs-lookup"><span data-stu-id="c63d3-143">Note that when an object is provided to this constructor, some features related to the Windows Communication Foundation (WCF) instancing behavior work differently.</span></span> <span data-ttu-id="c63d3-144">たとえば、シングルトン オブジェクト インスタンスを指定しているときは、 <xref:System.ServiceModel.InstanceContext.ReleaseServiceInstance%2A?displayProperty=nameWithType> を呼び出しても効果はありません。</span><span class="sxs-lookup"><span data-stu-id="c63d3-144">For example, calling <xref:System.ServiceModel.InstanceContext.ReleaseServiceInstance%2A?displayProperty=nameWithType> has no effect when a singleton object instance is provided.</span></span> <span data-ttu-id="c63d3-145">他のインスタンス解放機構も、同様に無視されます。</span><span class="sxs-lookup"><span data-stu-id="c63d3-145">Similarly, any other instance-release mechanism is ignored.</span></span> <span data-ttu-id="c63d3-146"><xref:System.ServiceModel.ServiceHost> は常に、すべての操作について <xref:System.ServiceModel.OperationBehaviorAttribute.ReleaseInstanceMode%2A?displayProperty=nameWithType> プロパティが <xref:System.ServiceModel.ReleaseInstanceMode.None?displayProperty=nameWithType> に設定されているかのように動作します。</span><span class="sxs-lookup"><span data-stu-id="c63d3-146">The <xref:System.ServiceModel.ServiceHost> always behaves as if the <xref:System.ServiceModel.OperationBehaviorAttribute.ReleaseInstanceMode%2A?displayProperty=nameWithType> property is set to <xref:System.ServiceModel.ReleaseInstanceMode.None?displayProperty=nameWithType> for all operations.</span></span>  
  
### <a name="sharing-instancecontext-objects"></a><span data-ttu-id="c63d3-147">InstanceContext オブジェクトの共有</span><span class="sxs-lookup"><span data-stu-id="c63d3-147">Sharing InstanceContext Objects</span></span>  
 <span data-ttu-id="c63d3-148">ユーザーが自ら関連付けを行うことにより、どの <xref:System.ServiceModel.InstanceContext> オブジェクトに、どのセッションフル チャネルまたは呼び出しを関連付けるかを制御することもできます。</span><span class="sxs-lookup"><span data-stu-id="c63d3-148">You can also control which sessionful channel or call is associated with which <xref:System.ServiceModel.InstanceContext> object by performing that association yourself.</span></span>  
  
## <a name="concurrency"></a><span data-ttu-id="c63d3-149">コンカレンシー</span><span class="sxs-lookup"><span data-stu-id="c63d3-149">Concurrency</span></span>  
 <span data-ttu-id="c63d3-150">コンカレンシーは、<xref:System.ServiceModel.InstanceContext> 内で同時にアクティブになるスレッドの数を制御します。</span><span class="sxs-lookup"><span data-stu-id="c63d3-150">Concurrency is the control of the number of threads active in an <xref:System.ServiceModel.InstanceContext> at any one time.</span></span> <span data-ttu-id="c63d3-151">同時実行を制御するには、 <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A?displayProperty=nameWithType> と <xref:System.ServiceModel.ConcurrencyMode> 列挙値を使用します。</span><span class="sxs-lookup"><span data-stu-id="c63d3-151">This is controlled by using the <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A?displayProperty=nameWithType> with the <xref:System.ServiceModel.ConcurrencyMode> enumeration.</span></span>  
  
 <span data-ttu-id="c63d3-152">選択可能なコンカレンシー モードは次の 3 つです。</span><span class="sxs-lookup"><span data-stu-id="c63d3-152">The following three concurrency modes are available:</span></span>  
  
- <span data-ttu-id="c63d3-153"><xref:System.ServiceModel.ConcurrencyMode.Single>:各インスタンス コンテキストは、一度にインスタンス コンテキスト内でメッセージを処理する 1 つのスレッドの最大値で許可されています。</span><span class="sxs-lookup"><span data-stu-id="c63d3-153"><xref:System.ServiceModel.ConcurrencyMode.Single>: Each instance context is allowed to have a maximum of one thread processing messages in the instance context at a time.</span></span> <span data-ttu-id="c63d3-154">他のスレッドは、最初のスレッドがインスタンス コンテキストを使用し終えるまで、同じインスタンス コンテキストを使用できません。</span><span class="sxs-lookup"><span data-stu-id="c63d3-154">Other threads wishing to use the same instance context must block until the original thread exits the instance context.</span></span>  
  
- <span data-ttu-id="c63d3-155"><xref:System.ServiceModel.ConcurrencyMode.Multiple>:各サービス インスタンスは、メッセージの処理を同時に複数のスレッドを持つことができます。</span><span class="sxs-lookup"><span data-stu-id="c63d3-155"><xref:System.ServiceModel.ConcurrencyMode.Multiple>: Each service instance can have multiple threads processing messages concurrently.</span></span> <span data-ttu-id="c63d3-156">このコンカレンシー モードを使用するには、サービスの実装がスレッドセーフである必要があります。</span><span class="sxs-lookup"><span data-stu-id="c63d3-156">The service implementation must be thread-safe to use this concurrency mode.</span></span>  
  
- <span data-ttu-id="c63d3-157"><xref:System.ServiceModel.ConcurrencyMode.Reentrant>:各サービス インスタンスは、一度に 1 つのメッセージの処理が再入操作の呼び出しを受け入れます。</span><span class="sxs-lookup"><span data-stu-id="c63d3-157"><xref:System.ServiceModel.ConcurrencyMode.Reentrant>: Each service instance processes one message at a time, but accepts re-entrant operation calls.</span></span> <span data-ttu-id="c63d3-158">サービスは、WCF クライアント オブジェクトを通じて呼び出しが場合にのみ、これらの呼び出しを受け入れます。</span><span class="sxs-lookup"><span data-stu-id="c63d3-158">The service only accepts these calls when it is calling out through a WCF client object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c63d3-159">複数のスレッドを安全に使用するコードを理解し、適切に記述することが困難な場合もあります。</span><span class="sxs-lookup"><span data-stu-id="c63d3-159">Understanding and developing code that safely uses more than one thread can be difficult to write successfully.</span></span> <span data-ttu-id="c63d3-160"><xref:System.ServiceModel.ConcurrencyMode.Multiple> 値や <xref:System.ServiceModel.ConcurrencyMode.Reentrant> 値を使用する前に、これらのモード用にサービスが適切に設計されていることを確認してください。</span><span class="sxs-lookup"><span data-stu-id="c63d3-160">Before using <xref:System.ServiceModel.ConcurrencyMode.Multiple> or <xref:System.ServiceModel.ConcurrencyMode.Reentrant> values, ensure that your service is properly designed for these modes.</span></span> <span data-ttu-id="c63d3-161">詳細については、「 <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> 」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c63d3-161">For more information, see <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A>.</span></span>  
  
 <span data-ttu-id="c63d3-162">コンカレンシーの使用は、インスタンス化モードに関連します。</span><span class="sxs-lookup"><span data-stu-id="c63d3-162">The use of concurrency is related to the instancing mode.</span></span> <span data-ttu-id="c63d3-163"><xref:System.ServiceModel.InstanceContextMode.PerCall>インスタンス化すると、同時実行制御ですが、新しいによって各メッセージが処理されるため<xref:System.ServiceModel.InstanceContext>、そのため、何回も 1 つのスレッドがアクティブにし、<xref:System.ServiceModel.InstanceContext>します。</span><span class="sxs-lookup"><span data-stu-id="c63d3-163">In <xref:System.ServiceModel.InstanceContextMode.PerCall> instancing, concurrency is not relevant, because each message is processed by a new <xref:System.ServiceModel.InstanceContext> and, therefore, never more than one thread is active in the <xref:System.ServiceModel.InstanceContext>.</span></span>  
  
 <span data-ttu-id="c63d3-164"><xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> プロパティを <xref:System.ServiceModel.ConcurrencyMode.Multiple>に設定するコード例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="c63d3-164">The following code example demonstrates setting the <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> property to <xref:System.ServiceModel.ConcurrencyMode.Multiple>.</span></span>  
  
```  
[ServiceBehavior(ConcurrencyMode=ConcurrencyMode.Multiple, InstanceContextMode = InstanceContextMode.Single)]   
public class CalculatorService : ICalculatorConcurrency   
{   
    ...  
}  
```  
  
## <a name="sessions-interact-with-instancecontext-settings"></a><span data-ttu-id="c63d3-165">InstanceContext 設定と対話するセッション</span><span class="sxs-lookup"><span data-stu-id="c63d3-165">Sessions Interact with InstanceContext Settings</span></span>  
 <span data-ttu-id="c63d3-166">セッションと <xref:System.ServiceModel.InstanceContext> は、コントラクト内の <xref:System.ServiceModel.SessionMode> 列挙値と、チャネルと特定のサービス オブジェクト間の関連付けを制御するサービス実装の <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> プロパティ値の組み合わせに応じて、相互に作用します。</span><span class="sxs-lookup"><span data-stu-id="c63d3-166">Sessions and <xref:System.ServiceModel.InstanceContext> interact depending upon the combination of the value of the <xref:System.ServiceModel.SessionMode> enumeration in a contract and the <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> property on the service implementation, which controls the association between channels and specific service objects.</span></span>  
  
 <span data-ttu-id="c63d3-167">サービスの <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType> プロパティと <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> プロパティの値の組み合わせが指定されているという条件で、セッションをサポートしている受信チャネルまたはサポートしていない受信チャネルの結果を次の表に示します。</span><span class="sxs-lookup"><span data-stu-id="c63d3-167">The following table shows the result of an incoming channel either supporting sessions or not supporting sessions given a service's combination of the values of the <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType> property and the <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> property.</span></span>  
  
|<span data-ttu-id="c63d3-168">InstanceContextMode 値</span><span class="sxs-lookup"><span data-stu-id="c63d3-168">InstanceContextMode value</span></span>|<xref:System.ServiceModel.SessionMode.Required>|<xref:System.ServiceModel.SessionMode.Allowed>|<xref:System.ServiceModel.SessionMode.NotAllowed>|  
|-------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------|  
|<span data-ttu-id="c63d3-169">PerCall</span><span class="sxs-lookup"><span data-stu-id="c63d3-169">PerCall</span></span>|<span data-ttu-id="c63d3-170">-セッションフル チャネルでの動作:セッションと<xref:System.ServiceModel.InstanceContext>呼び出しごとにします。</span><span class="sxs-lookup"><span data-stu-id="c63d3-170">-   Behavior with sessionful channel: A session and <xref:System.ServiceModel.InstanceContext> for each call.</span></span><br /><span data-ttu-id="c63d3-171">-セッションレス チャネルでの動作:例外がスローされる。</span><span class="sxs-lookup"><span data-stu-id="c63d3-171">-   Behavior with sessionless channel: An exception is thrown.</span></span>|<span data-ttu-id="c63d3-172">-セッションフル チャネルでの動作:セッションと<xref:System.ServiceModel.InstanceContext>呼び出しごとにします。</span><span class="sxs-lookup"><span data-stu-id="c63d3-172">-   Behavior with sessionful channel: A session and <xref:System.ServiceModel.InstanceContext> for each call.</span></span><br /><span data-ttu-id="c63d3-173">-セッションレス チャネルでの動作:<xref:System.ServiceModel.InstanceContext>呼び出しごとにします。</span><span class="sxs-lookup"><span data-stu-id="c63d3-173">-   Behavior with sessionless channel: An <xref:System.ServiceModel.InstanceContext> for each call.</span></span>|<span data-ttu-id="c63d3-174">-セッションフル チャネルでの動作:例外がスローされる。</span><span class="sxs-lookup"><span data-stu-id="c63d3-174">-   Behavior with sessionful channel: An exception is thrown.</span></span><br /><span data-ttu-id="c63d3-175">-セッションレス チャネルでの動作:<xref:System.ServiceModel.InstanceContext>呼び出しごとにします。</span><span class="sxs-lookup"><span data-stu-id="c63d3-175">-   Behavior with sessionless channel: An <xref:System.ServiceModel.InstanceContext> for each call.</span></span>|  
|<span data-ttu-id="c63d3-176">PerSession</span><span class="sxs-lookup"><span data-stu-id="c63d3-176">PerSession</span></span>|<span data-ttu-id="c63d3-177">-セッションフル チャネルでの動作:セッションと<xref:System.ServiceModel.InstanceContext>各チャネルにします。</span><span class="sxs-lookup"><span data-stu-id="c63d3-177">-   Behavior with sessionful channel: A session and <xref:System.ServiceModel.InstanceContext> for each channel.</span></span><br /><span data-ttu-id="c63d3-178">-セッションレス チャネルでの動作:例外がスローされる。</span><span class="sxs-lookup"><span data-stu-id="c63d3-178">-   Behavior with sessionless channel: An exception is thrown.</span></span>|<span data-ttu-id="c63d3-179">-セッションフル チャネルでの動作:セッションと<xref:System.ServiceModel.InstanceContext>各チャネルにします。</span><span class="sxs-lookup"><span data-stu-id="c63d3-179">-   Behavior with sessionful channel: A session and <xref:System.ServiceModel.InstanceContext> for each channel.</span></span><br /><span data-ttu-id="c63d3-180">-セッションレス チャネルでの動作:<xref:System.ServiceModel.InstanceContext>呼び出しごとにします。</span><span class="sxs-lookup"><span data-stu-id="c63d3-180">-   Behavior with sessionless channel: An <xref:System.ServiceModel.InstanceContext> for each call.</span></span>|<span data-ttu-id="c63d3-181">-セッションフル チャネルでの動作:例外がスローされる。</span><span class="sxs-lookup"><span data-stu-id="c63d3-181">-   Behavior with sessionful channel: An exception is thrown.</span></span><br /><span data-ttu-id="c63d3-182">-セッションレス チャネルでの動作:<xref:System.ServiceModel.InstanceContext>呼び出しごとにします。</span><span class="sxs-lookup"><span data-stu-id="c63d3-182">-   Behavior with sessionless channel: An <xref:System.ServiceModel.InstanceContext> for each call.</span></span>|  
|<span data-ttu-id="c63d3-183">Single</span><span class="sxs-lookup"><span data-stu-id="c63d3-183">Single</span></span>|<span data-ttu-id="c63d3-184">-セッションフル チャネルでの動作:セッションと 1 つ<xref:System.ServiceModel.InstanceContext>すべての呼び出し。</span><span class="sxs-lookup"><span data-stu-id="c63d3-184">-   Behavior with sessionful channel: A session and one <xref:System.ServiceModel.InstanceContext> for all calls.</span></span><br /><span data-ttu-id="c63d3-185">-セッションレス チャネルでの動作:例外がスローされる。</span><span class="sxs-lookup"><span data-stu-id="c63d3-185">-   Behavior with sessionless channel: An exception is thrown.</span></span>|<span data-ttu-id="c63d3-186">-セッションフル チャネルでの動作:セッションと<xref:System.ServiceModel.InstanceContext>作成された、またはユーザー指定のシングルトン。</span><span class="sxs-lookup"><span data-stu-id="c63d3-186">-   Behavior with sessionful channel: A session and <xref:System.ServiceModel.InstanceContext> for the created or user-specified singleton.</span></span><br /><span data-ttu-id="c63d3-187">-セッションレス チャネルでの動作:<xref:System.ServiceModel.InstanceContext>作成された、またはユーザー指定のシングルトン。</span><span class="sxs-lookup"><span data-stu-id="c63d3-187">-   Behavior with sessionless channel: An <xref:System.ServiceModel.InstanceContext> for the created or user-specified singleton.</span></span>|<span data-ttu-id="c63d3-188">-セッションフル チャネルでの動作:例外がスローされる。</span><span class="sxs-lookup"><span data-stu-id="c63d3-188">-   Behavior with sessionful channel: An exception is thrown.</span></span><br /><span data-ttu-id="c63d3-189">-セッションレス チャネルでの動作:<xref:System.ServiceModel.InstanceContext>各作成したシングルトンまたはユーザー指定のシングルトン。</span><span class="sxs-lookup"><span data-stu-id="c63d3-189">-   Behavior with sessionless channel: An <xref:System.ServiceModel.InstanceContext> for each created singleton or for the user-specified singleton.</span></span>|  
  
## <a name="see-also"></a><span data-ttu-id="c63d3-190">関連項目</span><span class="sxs-lookup"><span data-stu-id="c63d3-190">See also</span></span>

- [<span data-ttu-id="c63d3-191">セッションの使用</span><span class="sxs-lookup"><span data-stu-id="c63d3-191">Using Sessions</span></span>](../../../../docs/framework/wcf/using-sessions.md)
- [<span data-ttu-id="c63d3-192">方法: セッションを必要とするサービスを作成します。</span><span class="sxs-lookup"><span data-stu-id="c63d3-192">How to: Create a Service That Requires Sessions</span></span>](../../../../docs/framework/wcf/feature-details/how-to-create-a-service-that-requires-sessions.md)
- [<span data-ttu-id="c63d3-193">方法: サービスのインスタンス化の制御します。</span><span class="sxs-lookup"><span data-stu-id="c63d3-193">How to: Control Service Instancing</span></span>](../../../../docs/framework/wcf/feature-details/how-to-control-service-instancing.md)
- [<span data-ttu-id="c63d3-194">コンカレンシー</span><span class="sxs-lookup"><span data-stu-id="c63d3-194">Concurrency</span></span>](../../../../docs/framework/wcf/samples/concurrency.md)
- [<span data-ttu-id="c63d3-195">インスタンス化</span><span class="sxs-lookup"><span data-stu-id="c63d3-195">Instancing</span></span>](../../../../docs/framework/wcf/samples/instancing.md)
- [<span data-ttu-id="c63d3-196">セッション</span><span class="sxs-lookup"><span data-stu-id="c63d3-196">Session</span></span>](../../../../docs/framework/wcf/samples/session.md)
