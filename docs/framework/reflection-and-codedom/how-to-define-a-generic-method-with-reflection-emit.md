---
title: "方法: リフレクション出力を使用してジェネリック メソッドを定義する"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology:
- dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- generics [.NET Framework], reflection emit
- reflection emit, generic methods
- generics [.NET Framework], dynamic types
ms.assetid: 93892fa4-90b3-4ec4-b147-4bec9880de2b
caps.latest.revision: 13
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.translationtype: HT
ms.sourcegitcommit: 306c608dc7f97594ef6f72ae0f5aaba596c936e1
ms.openlocfilehash: 655ec9d5c53de10e6044cacc0eb8239fefe36489
ms.contentlocale: ja-jp
ms.lasthandoff: 07/28/2017

---
# <a name="how-to-define-a-generic-method-with-reflection-emit"></a><span data-ttu-id="0c99c-102">方法: リフレクション出力を使用してジェネリック メソッドを定義する</span><span class="sxs-lookup"><span data-stu-id="0c99c-102">How to: Define a Generic Method with Reflection Emit</span></span>
<span data-ttu-id="0c99c-103">最初の手順では、2 つの型パラメーターを持つ単純なジェネリック メソッドを作成する方法と、クラスの制約、インターフェイスの制約、および特殊な制約を型パラメーターに適用する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="0c99c-103">The first procedure shows how to create a simple generic method with two type parameters, and how to apply class constraints, interface constraints, and special constraints to the type parameters.</span></span>  
  
 <span data-ttu-id="0c99c-104">2 番目の手順では、メソッド本体を出力する方法と、ジェネリック メソッドの型パラメーターを使用して、ジェネリック型のインスタンスを作成し、それらのメソッドを呼び出す方法を示します。</span><span class="sxs-lookup"><span data-stu-id="0c99c-104">The second procedure shows how to emit the method body, and how to use the type parameters of the generic method to create instances of generic types and to call their methods.</span></span>  
  
 <span data-ttu-id="0c99c-105">3 番目の手順では、ジェネリック メソッドを呼び出す方法を示します。</span><span class="sxs-lookup"><span data-stu-id="0c99c-105">The third procedure shows how to invoke the generic method.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="0c99c-106">メソッドはジェネリック型に属し、その型の型パラメーターを使用するだけであるため、ジェネリックではありません。</span><span class="sxs-lookup"><span data-stu-id="0c99c-106">A method is not generic just because it belongs to a generic type and uses the type parameters of that type.</span></span> <span data-ttu-id="0c99c-107">メソッドがジェネリックになるのは、そのメソッドが独自の型パラメーター リストを持つ場合だけです。</span><span class="sxs-lookup"><span data-stu-id="0c99c-107">A method is generic only if it has its own type parameter list.</span></span> <span data-ttu-id="0c99c-108">この例のように、ジェネリック メソッドは非ジェネリック型で表すことができます。</span><span class="sxs-lookup"><span data-stu-id="0c99c-108">A generic method can appear on a nongeneric type, as in this example.</span></span> <span data-ttu-id="0c99c-109">ジェネリック型の非ジェネリック メソッド例については、「[方法: リフレクション出力を使用してジェネリック型を定義する](../../../docs/framework/reflection-and-codedom/how-to-define-a-generic-type-with-reflection-emit.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="0c99c-109">For an example of a nongeneric method on a generic type, see [How to: Define a Generic Type with Reflection Emit](../../../docs/framework/reflection-and-codedom/how-to-define-a-generic-type-with-reflection-emit.md).</span></span>  
  
### <a name="to-define-a-generic-method"></a><span data-ttu-id="0c99c-110">ジェネリック メソッドを定義するには</span><span class="sxs-lookup"><span data-stu-id="0c99c-110">To define a generic method</span></span>  
  
1.  <span data-ttu-id="0c99c-111">作業を始める前に、高水準言語を使用して記述したときに、ジェネリック メソッドがどのように表されるかを確認しておくと役立ちます。</span><span class="sxs-lookup"><span data-stu-id="0c99c-111">Before beginning, it is useful to look at how the generic method appears when written using a high-level language.</span></span> <span data-ttu-id="0c99c-112">次のコードは、ジェネリック メソッドを呼び出すコードと共に、このトピックのプログラム例に含まれています。</span><span class="sxs-lookup"><span data-stu-id="0c99c-112">The following code is included in the example code for this topic, along with code to call the generic method.</span></span> <span data-ttu-id="0c99c-113">このメソッドは、`TInput` と `TOutput` の 2 つの型パラメーターを持ちます。2 つ目の型パラメーターは、参照型 (`class`) であることが必要です。さらに、パラメーターなしのコンストラクター (`new`) を持ち、`ICollection(Of TInput)` (C# では `ICollection<TInput>`) を実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0c99c-113">The method has two type parameters, `TInput` and `TOutput`, the second of which must be a reference type (`class`), must have a parameterless constructor (`new`), and must implement `ICollection(Of TInput)` (`ICollection<TInput>` in C#).</span></span> <span data-ttu-id="0c99c-114">このインターフェイスの制約によって、<xref:System.Collections.Generic.ICollection%601.Add%2A?displayProperty=fullName> メソッドを使用して、メソッドによって作成される `TOutput` コレクションに要素を確実に追加できるようになります。</span><span class="sxs-lookup"><span data-stu-id="0c99c-114">This interface constraint ensures that the <xref:System.Collections.Generic.ICollection%601.Add%2A?displayProperty=fullName> method can be used to add elements to the `TOutput` collection that the method creates.</span></span> <span data-ttu-id="0c99c-115">メソッドは、`input` の配列である仮パラメーター `TInput` を 1 つ持ちます。</span><span class="sxs-lookup"><span data-stu-id="0c99c-115">The method has one formal parameter, `input`, which is an array of `TInput`.</span></span> <span data-ttu-id="0c99c-116">メソッドは、`TOutput` 型のコレクションを作成し、`input` の要素をコレクションにコピーします。</span><span class="sxs-lookup"><span data-stu-id="0c99c-116">The method creates a collection of type `TOutput` and copies the elements of `input` to the collection.</span></span>  
  
     <span data-ttu-id="0c99c-117">[!code-csharp[GenericMethodHowTo#20](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#20)]  [!code-vb[GenericMethodHowTo#20](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#20)]</span><span class="sxs-lookup"><span data-stu-id="0c99c-117">[!code-csharp[GenericMethodHowTo#20](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#20)]  [!code-vb[GenericMethodHowTo#20](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#20)]</span></span>  
  
2.  <span data-ttu-id="0c99c-118">動的アセンブリと動的モジュールを定義して、ジェネリック メソッドが属する型を格納します。</span><span class="sxs-lookup"><span data-stu-id="0c99c-118">Define a dynamic assembly and a dynamic module to contain the type the generic method belongs to.</span></span> <span data-ttu-id="0c99c-119">この場合、アセンブリには `DemoMethodBuilder1` という名前のモジュールが 1 つだけ含まれます。モジュール名はアセンブリ名に拡張子が付いたものです。</span><span class="sxs-lookup"><span data-stu-id="0c99c-119">In this case, the assembly has only one module, named `DemoMethodBuilder1`, and the module name is the same as the assembly name plus an extension.</span></span> <span data-ttu-id="0c99c-120">この例では、アセンブリをディスクに保存したうえで実行するため、<xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave?displayProperty=fullName> を指定します。</span><span class="sxs-lookup"><span data-stu-id="0c99c-120">In this example, the assembly is saved to disk and also executed, so <xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave?displayProperty=fullName> is specified.</span></span> <span data-ttu-id="0c99c-121">[Ildasm.exe (IL Disassembler)](../../../docs/framework/tools/ildasm-exe-il-disassembler.md) を使用すると、DemoMethodBuilder1.dll をチェックし、手順 1. に示すメソッドの Microsoft Intermediate Language (MSIL) と比較できます。</span><span class="sxs-lookup"><span data-stu-id="0c99c-121">You can use the [Ildasm.exe (IL Disassembler)](../../../docs/framework/tools/ildasm-exe-il-disassembler.md) to examine DemoMethodBuilder1.dll and to compare it to the Microsoft intermediate language (MSIL) for the method shown in step 1.</span></span>  
  
     <span data-ttu-id="0c99c-122">[!code-csharp[GenericMethodHowTo#2](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#2)]  [!code-vb[GenericMethodHowTo#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#2)]</span><span class="sxs-lookup"><span data-stu-id="0c99c-122">[!code-csharp[GenericMethodHowTo#2](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#2)]  [!code-vb[GenericMethodHowTo#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#2)]</span></span>  
  
3.  <span data-ttu-id="0c99c-123">ジェネリック メソッドが属する型を定義します。</span><span class="sxs-lookup"><span data-stu-id="0c99c-123">Define the type the generic method belongs to.</span></span> <span data-ttu-id="0c99c-124">型はジェネリックである必要はありません。</span><span class="sxs-lookup"><span data-stu-id="0c99c-124">The type does not have to be generic.</span></span> <span data-ttu-id="0c99c-125">ジェネリック メソッドは、ジェネリック型と非ジェネリック型のどちらにでも属することができます。</span><span class="sxs-lookup"><span data-stu-id="0c99c-125">A generic method can belong to either a generic or nongeneric type.</span></span> <span data-ttu-id="0c99c-126">この例では、型はクラスであり、ジェネリックではありません。型の名前は `DemoType` です。</span><span class="sxs-lookup"><span data-stu-id="0c99c-126">In this example, the type is a class, is not generic, and is named `DemoType`.</span></span>  
  
     <span data-ttu-id="0c99c-127">[!code-csharp[GenericMethodHowTo#3](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#3)]  [!code-vb[GenericMethodHowTo#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#3)]</span><span class="sxs-lookup"><span data-stu-id="0c99c-127">[!code-csharp[GenericMethodHowTo#3](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#3)]  [!code-vb[GenericMethodHowTo#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#3)]</span></span>  
  
4.  <span data-ttu-id="0c99c-128">ジェネリック メソッドを定義します。</span><span class="sxs-lookup"><span data-stu-id="0c99c-128">Define the generic method.</span></span> <span data-ttu-id="0c99c-129">ジェネリック メソッドの仮パラメーターの型が、ジェネリック メソッドのジェネリック型パラメーターで指定されている場合は、<xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%29> メソッド オーバーロードを使用してメソッドを定義します。</span><span class="sxs-lookup"><span data-stu-id="0c99c-129">If the types of a generic method's formal parameters are specified by generic type parameters of the generic method, use the <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%29> method overload to define the method.</span></span> <span data-ttu-id="0c99c-130">メソッドのジェネリック型パラメーターはまだ定義されていないため、<xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A> の呼び出しでメソッドの仮パラメーターの型を指定することはできません。</span><span class="sxs-lookup"><span data-stu-id="0c99c-130">The generic type parameters of the method are not yet defined, so you cannot specify the types of the method's formal parameters in the call to <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A>.</span></span> <span data-ttu-id="0c99c-131">この例では、メソッドの名前は `Factory` です。</span><span class="sxs-lookup"><span data-stu-id="0c99c-131">In this example, the method is named `Factory`.</span></span> <span data-ttu-id="0c99c-132">メソッドは、パブリックかつ `static` (Visual Basic では `Shared`) です。</span><span class="sxs-lookup"><span data-stu-id="0c99c-132">The method is public and `static` (`Shared` in Visual Basic).</span></span>  
  
     <span data-ttu-id="0c99c-133">[!code-csharp[GenericMethodHowTo#4](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#4)]  [!code-vb[GenericMethodHowTo#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#4)]</span><span class="sxs-lookup"><span data-stu-id="0c99c-133">[!code-csharp[GenericMethodHowTo#4](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#4)]  [!code-vb[GenericMethodHowTo#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#4)]</span></span>  
  
5.  <span data-ttu-id="0c99c-134">パラメーターの名前を格納している文字列の配列を `DemoMethod` メソッドに渡して、<xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=fullName> のジェネリック型パラメーターを定義します。</span><span class="sxs-lookup"><span data-stu-id="0c99c-134">Define the generic type parameters of `DemoMethod` by passing an array of strings containing the names of the parameters to the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=fullName> method.</span></span> <span data-ttu-id="0c99c-135">これにより、メソッドはジェネリック メソッドになります。</span><span class="sxs-lookup"><span data-stu-id="0c99c-135">This makes the method a generic method.</span></span> <span data-ttu-id="0c99c-136">次のコードによって、`Factory` を型パラメーター `TInput` と `TOutput` を持つジェネリック メソッドにします。</span><span class="sxs-lookup"><span data-stu-id="0c99c-136">The following code makes `Factory` a generic method with type parameters `TInput` and `TOutput`.</span></span> <span data-ttu-id="0c99c-137">コードを読みやすくするために、これらの名前の変数を作成し、2 つの型パラメーターを表す <xref:System.Reflection.Emit.GenericTypeParameterBuilder> オブジェクトを保持します。</span><span class="sxs-lookup"><span data-stu-id="0c99c-137">To make the code easier to read, variables with these names are created to hold the <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objects representing the two type parameters.</span></span>  
  
     <span data-ttu-id="0c99c-138">[!code-csharp[GenericMethodHowTo#5](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#5)]  [!code-vb[GenericMethodHowTo#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#5)]</span><span class="sxs-lookup"><span data-stu-id="0c99c-138">[!code-csharp[GenericMethodHowTo#5](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#5)]  [!code-vb[GenericMethodHowTo#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#5)]</span></span>  
  
6.  <span data-ttu-id="0c99c-139">オプションで、型パラメーターに特殊な制約を追加します。</span><span class="sxs-lookup"><span data-stu-id="0c99c-139">Optionally add special constraints to the type parameters.</span></span> <span data-ttu-id="0c99c-140">特殊な制約は、<xref:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes%2A> メソッドを使用して追加します。</span><span class="sxs-lookup"><span data-stu-id="0c99c-140">Special constraints are added using the <xref:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes%2A> method.</span></span> <span data-ttu-id="0c99c-141">この例では、`TOutput` は参照型であり、パラメーターなしのコンストラクターを持つように制約されます。</span><span class="sxs-lookup"><span data-stu-id="0c99c-141">In this example, `TOutput` is constrained to be a reference type and to have a parameterless constructor.</span></span>  
  
     <span data-ttu-id="0c99c-142">[!code-csharp[GenericMethodHowTo#6](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#6)]  [!code-vb[GenericMethodHowTo#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#6)]</span><span class="sxs-lookup"><span data-stu-id="0c99c-142">[!code-csharp[GenericMethodHowTo#6](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#6)]  [!code-vb[GenericMethodHowTo#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#6)]</span></span>  
  
7.  <span data-ttu-id="0c99c-143">オプションで、型パラメーターにクラスの制約とインターフェイスの制約を追加します。</span><span class="sxs-lookup"><span data-stu-id="0c99c-143">Optionally add class and interface constraints to the type parameters.</span></span> <span data-ttu-id="0c99c-144">この例では、型パラメーター `TOutput` は、`ICollection(Of TInput)` (C# では `ICollection<TInput>`) インターフェイスを実装する型に制約されます。</span><span class="sxs-lookup"><span data-stu-id="0c99c-144">In this example, type parameter `TOutput` is constrained to types that implement the `ICollection(Of TInput)` (`ICollection<TInput>` in C#) interface.</span></span> <span data-ttu-id="0c99c-145">これにより、<xref:System.Collections.Generic.ICollection%601.Add%2A> メソッドを使用して要素を確実に追加できます。</span><span class="sxs-lookup"><span data-stu-id="0c99c-145">This ensures that the <xref:System.Collections.Generic.ICollection%601.Add%2A> method can be used to add elements.</span></span>  
  
     <span data-ttu-id="0c99c-146">[!code-csharp[GenericMethodHowTo#7](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#7)]  [!code-vb[GenericMethodHowTo#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#7)]</span><span class="sxs-lookup"><span data-stu-id="0c99c-146">[!code-csharp[GenericMethodHowTo#7](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#7)]  [!code-vb[GenericMethodHowTo#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#7)]</span></span>  
  
8.  <span data-ttu-id="0c99c-147"><xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A> メソッドを使用して、メソッドの仮パラメーターを定義します。</span><span class="sxs-lookup"><span data-stu-id="0c99c-147">Define the formal parameters of the method, using the <xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A> method.</span></span> <span data-ttu-id="0c99c-148">この例では、`Factory` メソッドは、`TInput` の配列であるパラメーターを 1 つ持ちます。</span><span class="sxs-lookup"><span data-stu-id="0c99c-148">In this example, the `Factory` method has one parameter, an array of `TInput`.</span></span> <span data-ttu-id="0c99c-149">この型は、<xref:System.Type.MakeArrayType%2A> を表す <xref:System.Reflection.Emit.GenericTypeParameterBuilder> で `TInput` メソッドを呼び出すことによって作成されます。</span><span class="sxs-lookup"><span data-stu-id="0c99c-149">This type is created by calling the <xref:System.Type.MakeArrayType%2A> method on the <xref:System.Reflection.Emit.GenericTypeParameterBuilder> that represents `TInput`.</span></span> <span data-ttu-id="0c99c-150"><xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A> の引数は、<xref:System.Type> オブジェクトの配列です。</span><span class="sxs-lookup"><span data-stu-id="0c99c-150">The argument of <xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A> is an array of <xref:System.Type> objects.</span></span>  
  
     <span data-ttu-id="0c99c-151">[!code-csharp[GenericMethodHowTo#8](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#8)]  [!code-vb[GenericMethodHowTo#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#8)]</span><span class="sxs-lookup"><span data-stu-id="0c99c-151">[!code-csharp[GenericMethodHowTo#8](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#8)]  [!code-vb[GenericMethodHowTo#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#8)]</span></span>  
  
9. <span data-ttu-id="0c99c-152"><xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A> メソッドを使用して、メソッドの戻り値の型を定義します。</span><span class="sxs-lookup"><span data-stu-id="0c99c-152">Define the return type for the method, using the <xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A> method.</span></span> <span data-ttu-id="0c99c-153">この例では、`TOutput` のインスタンスが返されます。</span><span class="sxs-lookup"><span data-stu-id="0c99c-153">In this example, an instance of `TOutput` is returned.</span></span>  
  
     <span data-ttu-id="0c99c-154">[!code-csharp[GenericMethodHowTo#9](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#9)]   [!code-vb[GenericMethodHowTo#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#9)]</span><span class="sxs-lookup"><span data-stu-id="0c99c-154">[!code-csharp[GenericMethodHowTo#9](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#9)]   [!code-vb[GenericMethodHowTo#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#9)]</span></span>  
  
10. <span data-ttu-id="0c99c-155"><xref:System.Reflection.Emit.ILGenerator> を使用して、メソッド本体を出力します。</span><span class="sxs-lookup"><span data-stu-id="0c99c-155">Emit the method body, using <xref:System.Reflection.Emit.ILGenerator>.</span></span> <span data-ttu-id="0c99c-156">詳細については、メソッド本体を出力する際の手順を参照してください。</span><span class="sxs-lookup"><span data-stu-id="0c99c-156">For details, see the accompanying procedure for emitting the method body.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="0c99c-157">ジェネリック型のメソッド呼び出しを出力し、それらの型の型引数がジェネリック メソッドの型パラメーターである場合、`static` クラスの <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%28System.Type%2CSystem.Reflection.ConstructorInfo%29><xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29>、<xref:System.Reflection.Emit.TypeBuilder.GetField%28System.Type%2CSystem.Reflection.FieldInfo%29>、<xref:System.Reflection.Emit.TypeBuilder> の各メソッド オーバーロードを使用して、メソッドの構築された形式を取得します。</span><span class="sxs-lookup"><span data-stu-id="0c99c-157">When you emit calls to methods of generic types, and the type arguments of those types are type parameters of the generic method, you must use the `static`<xref:System.Reflection.Emit.TypeBuilder.GetConstructor%28System.Type%2CSystem.Reflection.ConstructorInfo%29>, <xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29>, and <xref:System.Reflection.Emit.TypeBuilder.GetField%28System.Type%2CSystem.Reflection.FieldInfo%29> method overloads of the <xref:System.Reflection.Emit.TypeBuilder> class to obtain constructed forms of the methods.</span></span> <span data-ttu-id="0c99c-158">メソッド本体を出力する手順にこの例が示されています。</span><span class="sxs-lookup"><span data-stu-id="0c99c-158">The accompanying procedure for emitting the method body demonstrates this.</span></span>  
  
11. <span data-ttu-id="0c99c-159">メソッドを格納する型を完成させ、アセンブリを保存します。</span><span class="sxs-lookup"><span data-stu-id="0c99c-159">Complete the type that contains the method and save the assembly.</span></span> <span data-ttu-id="0c99c-160">ジェネリック メソッドを呼び出すための手順には、完成したメソッドを呼び出す 2 とおりの方法が示されています。</span><span class="sxs-lookup"><span data-stu-id="0c99c-160">The accompanying procedure for invoking the generic method shows two ways to invoke the completed method.</span></span>  
  
     <span data-ttu-id="0c99c-161">[!code-csharp[GenericMethodHowTo#14](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#14)]  [!code-vb[GenericMethodHowTo#14](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#14)]</span><span class="sxs-lookup"><span data-stu-id="0c99c-161">[!code-csharp[GenericMethodHowTo#14](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#14)]  [!code-vb[GenericMethodHowTo#14](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#14)]</span></span>  
  
<a name="procedureSection1"></a>   
### <a name="to-emit-the-method-body"></a><span data-ttu-id="0c99c-162">メソッド本体を出力するには</span><span class="sxs-lookup"><span data-stu-id="0c99c-162">To emit the method body</span></span>  
  
1.  <span data-ttu-id="0c99c-163">コード ジェネレーターを取得し、ローカル変数とラベルを宣言します。</span><span class="sxs-lookup"><span data-stu-id="0c99c-163">Get a code generator and declare local variables and labels.</span></span> <span data-ttu-id="0c99c-164">ローカル変数を宣言するには、<xref:System.Reflection.Emit.ILGenerator.DeclareLocal%2A> メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="0c99c-164">The <xref:System.Reflection.Emit.ILGenerator.DeclareLocal%2A> method is used to declare local variables.</span></span> <span data-ttu-id="0c99c-165">`Factory` メソッドには、4 つのローカル変数があります。メソッドによって返される新しい `retVal` を保持する `TOutput`、`ic` (C# では `TOutput`) にキャストされた `ICollection(Of TInput)` を保持する `ICollection<TInput>`、`input` オブジェクトの入力配列を保持する `TInput`、および配列を反復処理するための `index` です。</span><span class="sxs-lookup"><span data-stu-id="0c99c-165">The `Factory` method has four local variables: `retVal` to hold the new `TOutput` that is returned by the method, `ic` to hold the `TOutput` when it is cast to `ICollection(Of TInput)` (`ICollection<TInput>` in C#), `input` to hold the input array of `TInput` objects, and `index` to iterate through the array.</span></span> <span data-ttu-id="0c99c-166">また、ラベルも 2 つあります。ループに入るためのラベル (`enterLoop`) およびループの先頭に使用するラベル (`loopAgain`) であり、<xref:System.Reflection.Emit.ILGenerator.DefineLabel%2A> メソッドを使用して定義されます。</span><span class="sxs-lookup"><span data-stu-id="0c99c-166">The method also has two labels, one to enter the loop (`enterLoop`) and one for the top of the loop (`loopAgain`), defined using the <xref:System.Reflection.Emit.ILGenerator.DefineLabel%2A> method.</span></span>  
  
     <span data-ttu-id="0c99c-167">メソッドは、まず、<xref:System.Reflection.Emit.OpCodes.Ldarg_0> オペコードを使用して引数を読み込み、`input` オペコードを使用してローカル変数 <xref:System.Reflection.Emit.OpCodes.Stloc_S> に格納します。</span><span class="sxs-lookup"><span data-stu-id="0c99c-167">The first thing the method does is to load its argument using <xref:System.Reflection.Emit.OpCodes.Ldarg_0> opcode and to store it in the local variable `input` using <xref:System.Reflection.Emit.OpCodes.Stloc_S> opcode.</span></span>  
  
     <span data-ttu-id="0c99c-168">[!code-csharp[GenericMethodHowTo#10](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#10)]  [!code-vb[GenericMethodHowTo#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#10)]</span><span class="sxs-lookup"><span data-stu-id="0c99c-168">[!code-csharp[GenericMethodHowTo#10](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#10)]  [!code-vb[GenericMethodHowTo#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#10)]</span></span>  
  
2.  <span data-ttu-id="0c99c-169">`TOutput` メソッドのジェネリック メソッド オーバーロードを使用して、<xref:System.Activator.CreateInstance%2A?displayProperty=fullName> のインスタンスを作成するコードを出力します。</span><span class="sxs-lookup"><span data-stu-id="0c99c-169">Emit code to create an instance of `TOutput`, using the generic method overload of the <xref:System.Activator.CreateInstance%2A?displayProperty=fullName> method.</span></span> <span data-ttu-id="0c99c-170">このオーバーロードを使用する場合、指定した型はパラメーターなしのコンストラクターを持つ必要があります。`TOutput` にこの制約を追加したのはこのためです。</span><span class="sxs-lookup"><span data-stu-id="0c99c-170">Using this overload requires the specified type to have a parameterless constructor, which is the reason for adding that constraint to `TOutput`.</span></span> <span data-ttu-id="0c99c-171">`TOutput` を <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> に渡して、構築されたジェネリック メソッドを作成します。</span><span class="sxs-lookup"><span data-stu-id="0c99c-171">Create the constructed generic method by passing `TOutput` to <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A>.</span></span> <span data-ttu-id="0c99c-172">メソッドを呼び出すコードを出力したら、`retVal` を使用してローカル変数 <xref:System.Reflection.Emit.OpCodes.Stloc_S> に格納するコードを出力します。</span><span class="sxs-lookup"><span data-stu-id="0c99c-172">After emitting code to call the method, emit code to store it in the local variable `retVal` using <xref:System.Reflection.Emit.OpCodes.Stloc_S></span></span>  
  
     <span data-ttu-id="0c99c-173">[!code-csharp[GenericMethodHowTo#11](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#11)]  [!code-vb[GenericMethodHowTo#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#11)]</span><span class="sxs-lookup"><span data-stu-id="0c99c-173">[!code-csharp[GenericMethodHowTo#11](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#11)]  [!code-vb[GenericMethodHowTo#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#11)]</span></span>  
  
3.  <span data-ttu-id="0c99c-174">新しい `TOutput` オブジェクトを `ICollection(Of TInput)` にキャストし、ローカル変数 `ic` に格納するコードを出力します。</span><span class="sxs-lookup"><span data-stu-id="0c99c-174">Emit code to cast the new `TOutput` object to `ICollection(Of TInput)` and store it in the local variable `ic`.</span></span>  
  
     <span data-ttu-id="0c99c-175">[!code-csharp[GenericMethodHowTo#31](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#31)]  [!code-vb[GenericMethodHowTo#31](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#31)]</span><span class="sxs-lookup"><span data-stu-id="0c99c-175">[!code-csharp[GenericMethodHowTo#31](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#31)]  [!code-vb[GenericMethodHowTo#31](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#31)]</span></span>  
  
4.  <span data-ttu-id="0c99c-176"><xref:System.Reflection.MethodInfo> メソッドを表す <xref:System.Collections.Generic.ICollection%601.Add%2A?displayProperty=fullName> を取得します。</span><span class="sxs-lookup"><span data-stu-id="0c99c-176">Get a <xref:System.Reflection.MethodInfo> representing the <xref:System.Collections.Generic.ICollection%601.Add%2A?displayProperty=fullName> method.</span></span> <span data-ttu-id="0c99c-177">このメソッドは、`ICollection(Of TInput)` (C# では `ICollection<TInput>`) で動作するため、この構築された型に固有の `Add` メソッドを取得する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0c99c-177">The method is acting on an `ICollection(Of TInput)` (`ICollection<TInput>` in C#), so it is necessary to get the `Add` method specific to that constructed type.</span></span> <span data-ttu-id="0c99c-178"><xref:System.Type.GetMethod%2A> は、<xref:System.Reflection.MethodInfo> で構築された型ではサポートされていないため、`icollOfTInput` メソッドを使用して、<xref:System.Type.GetMethod%2A> からこの <xref:System.Reflection.Emit.GenericTypeParameterBuilder> を直接取得することはできません。</span><span class="sxs-lookup"><span data-stu-id="0c99c-178">You cannot use the <xref:System.Type.GetMethod%2A> method to get this <xref:System.Reflection.MethodInfo> directly from `icollOfTInput`, because <xref:System.Type.GetMethod%2A> is not supported on a type that has been constructed with a <xref:System.Reflection.Emit.GenericTypeParameterBuilder>.</span></span> <span data-ttu-id="0c99c-179">代わりに、<xref:System.Type.GetMethod%2A> ジェネリック インターフェイスのジェネリック型の定義を格納する `icoll` で、<xref:System.Collections.Generic.ICollection%601> を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="0c99c-179">Instead, call <xref:System.Type.GetMethod%2A> on `icoll`, which contains the generic type definition for the <xref:System.Collections.Generic.ICollection%601> generic interface.</span></span> <span data-ttu-id="0c99c-180">次に、<xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29>`static` メソッドを使用して、構築された型の <xref:System.Reflection.MethodInfo> を作成します。</span><span class="sxs-lookup"><span data-stu-id="0c99c-180">Then use the <xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29>`static` method to produce the <xref:System.Reflection.MethodInfo> for the constructed type.</span></span> <span data-ttu-id="0c99c-181">次のコードでこれを示します。</span><span class="sxs-lookup"><span data-stu-id="0c99c-181">The following code demonstrates this.</span></span>  
  
     <span data-ttu-id="0c99c-182">[!code-csharp[GenericMethodHowTo#12](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#12)]  [!code-vb[GenericMethodHowTo#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#12)]</span><span class="sxs-lookup"><span data-stu-id="0c99c-182">[!code-csharp[GenericMethodHowTo#12](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#12)]  [!code-vb[GenericMethodHowTo#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#12)]</span></span>  
  
5.  <span data-ttu-id="0c99c-183">32 ビット整数 0 を読み込み、変数に格納することにより、変数 `index` を初期化するコードを出力します。</span><span class="sxs-lookup"><span data-stu-id="0c99c-183">Emit code to initialize the `index` variable, by loading a 32-bit integer 0 and storing it in the variable.</span></span> <span data-ttu-id="0c99c-184">`enterLoop` ラベルに分岐するコードを出力します。</span><span class="sxs-lookup"><span data-stu-id="0c99c-184">Emit code to branch to the label `enterLoop`.</span></span> <span data-ttu-id="0c99c-185">このラベルはループ内部にあるため、まだマークされていません。</span><span class="sxs-lookup"><span data-stu-id="0c99c-185">This label has not yet been marked, because it is inside the loop.</span></span> <span data-ttu-id="0c99c-186">ループのコードは、次の手順で出力されます。</span><span class="sxs-lookup"><span data-stu-id="0c99c-186">Code for the loop is emitted in the next step.</span></span>  
  
     <span data-ttu-id="0c99c-187">[!code-csharp[GenericMethodHowTo#32](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#32)]  [!code-vb[GenericMethodHowTo#32](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#32)]</span><span class="sxs-lookup"><span data-stu-id="0c99c-187">[!code-csharp[GenericMethodHowTo#32](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#32)]  [!code-vb[GenericMethodHowTo#32](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#32)]</span></span>  
  
6.  <span data-ttu-id="0c99c-188">ループのコードを出力します。</span><span class="sxs-lookup"><span data-stu-id="0c99c-188">Emit code for the loop.</span></span> <span data-ttu-id="0c99c-189">まず、<xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A> ラベルを使用して `loopAgain` を呼び出し、ループの先頭をマークします。</span><span class="sxs-lookup"><span data-stu-id="0c99c-189">The first step is to mark the top of the loop, by calling <xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A> with the `loopAgain` label.</span></span> <span data-ttu-id="0c99c-190">これで、このラベルを使用する分岐ステートメントは、コードのこのポイントに分岐するようになります。</span><span class="sxs-lookup"><span data-stu-id="0c99c-190">Branch statements that use the label will now branch to this point in the code.</span></span> <span data-ttu-id="0c99c-191">次の手順では、`TOutput` にキャストされた `ICollection(Of TInput)` オブジェクトをスタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="0c99c-191">The next step is to push the `TOutput` object, cast to `ICollection(Of TInput)`, onto the stack.</span></span> <span data-ttu-id="0c99c-192">このオブジェクトはすぐに必要なわけではありませんが、`Add` メソッドを呼び出すための適切な位置にあることが必要です。</span><span class="sxs-lookup"><span data-stu-id="0c99c-192">It is not needed immediately, but needs to be in position for calling the `Add` method.</span></span> <span data-ttu-id="0c99c-193">次に、入力配列がスタックにプッシュされ、現在のインデックスを格納する変数 `index` が配列にプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="0c99c-193">Next the input array is pushed onto the stack, then the `index` variable containing the current index into the array.</span></span> <span data-ttu-id="0c99c-194"><xref:System.Reflection.Emit.OpCodes.Ldelem> オペコードによってインデックスと配列がスタックからポップされ、インデックスが付けられた配列要素がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="0c99c-194">The <xref:System.Reflection.Emit.OpCodes.Ldelem> opcode pops the index and the array off the stack and pushes the indexed array element onto the stack.</span></span> <span data-ttu-id="0c99c-195">これで、スタックは <xref:System.Collections.Generic.ICollection%601.Add%2A?displayProperty=fullName> メソッドの呼び出しに対応できるようになりました。このメソッドは、スタックからコレクションと新しい要素をポップし、その要素をコレクションに追加します。</span><span class="sxs-lookup"><span data-stu-id="0c99c-195">The stack is now ready for the call to the <xref:System.Collections.Generic.ICollection%601.Add%2A?displayProperty=fullName> method, which pops the collection and the new element off the stack and adds the element to the collection.</span></span>  
  
     <span data-ttu-id="0c99c-196">ループのコードの残りの部分では、インデックスをインクリメントし、ループが終了したかどうかを確認するテストを行います。インデックスと 32 ビット整数 1 がスタックにプッシュされて加算され、その合計がスタックに残されます。合計は `index` に格納されます。</span><span class="sxs-lookup"><span data-stu-id="0c99c-196">The rest of the code in the loop increments the index and tests to see whether the loop is finished: The index and a 32-bit integer 1 are pushed onto the stack and added, leaving the sum on the stack; the sum is stored in `index`.</span></span> <span data-ttu-id="0c99c-197"><xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A> を呼び出して、このポイントをループのエントリ ポイントとして設定します。</span><span class="sxs-lookup"><span data-stu-id="0c99c-197"><xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A> is called to set this point as the entry point for the loop.</span></span> <span data-ttu-id="0c99c-198">インデックスが再び読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="0c99c-198">The index is loaded again.</span></span> <span data-ttu-id="0c99c-199">入力配列がスタックにプッシュされ、その長さを取得するために <xref:System.Reflection.Emit.OpCodes.Ldlen> が出力されます。</span><span class="sxs-lookup"><span data-stu-id="0c99c-199">The input array is pushed on the stack, and <xref:System.Reflection.Emit.OpCodes.Ldlen> is emitted to get its length.</span></span> <span data-ttu-id="0c99c-200">現在、インデックスと長さはスタックにあります。<xref:System.Reflection.Emit.OpCodes.Clt> を出力してこれらを比較します。</span><span class="sxs-lookup"><span data-stu-id="0c99c-200">The index and the length are now on the stack, and <xref:System.Reflection.Emit.OpCodes.Clt> is emitted to compare them.</span></span> <span data-ttu-id="0c99c-201">インデックスが長さ未満の場合、<xref:System.Reflection.Emit.OpCodes.Brtrue_S> はループの先頭に分岐して戻ります。</span><span class="sxs-lookup"><span data-stu-id="0c99c-201">If the index is less than the length, <xref:System.Reflection.Emit.OpCodes.Brtrue_S> branches back to the beginning of the loop.</span></span>  
  
     <span data-ttu-id="0c99c-202">[!code-csharp[GenericMethodHowTo#13](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#13)]  [!code-vb[GenericMethodHowTo#13](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#13)]</span><span class="sxs-lookup"><span data-stu-id="0c99c-202">[!code-csharp[GenericMethodHowTo#13](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#13)]  [!code-vb[GenericMethodHowTo#13](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#13)]</span></span>  
  
7.  <span data-ttu-id="0c99c-203">`TOutput` オブジェクトをスタックにプッシュし、メソッドから返すコードを出力します。</span><span class="sxs-lookup"><span data-stu-id="0c99c-203">Emit code to push the `TOutput` object onto the stack and return from the method.</span></span> <span data-ttu-id="0c99c-204">ローカル変数 `retVal` と `ic` には、新しい `TOutput` への参照が格納されます。`ic` は、<xref:System.Collections.Generic.ICollection%601.Add%2A?displayProperty=fullName> メソッドにアクセスする目的でのみ使用されます。</span><span class="sxs-lookup"><span data-stu-id="0c99c-204">The local variables `retVal` and `ic` both contain references to the new `TOutput`; `ic` is used only to access the <xref:System.Collections.Generic.ICollection%601.Add%2A?displayProperty=fullName> method.</span></span>  
  
     <span data-ttu-id="0c99c-205">[!code-csharp[GenericMethodHowTo#33](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#33)]  [!code-vb[GenericMethodHowTo#33](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#33)]</span><span class="sxs-lookup"><span data-stu-id="0c99c-205">[!code-csharp[GenericMethodHowTo#33](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#33)]  [!code-vb[GenericMethodHowTo#33](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#33)]</span></span>  
  
<a name="procedureSection2"></a>   
### <a name="to-invoke-the-generic-method"></a><span data-ttu-id="0c99c-206">ジェネリック メソッドを呼び出すには</span><span class="sxs-lookup"><span data-stu-id="0c99c-206">To invoke the generic method</span></span>  
  
1.  <span data-ttu-id="0c99c-207">`Factory` は、ジェネリック メソッドの定義です。</span><span class="sxs-lookup"><span data-stu-id="0c99c-207">`Factory` is a generic method definition.</span></span> <span data-ttu-id="0c99c-208">これを呼び出すには、ジェネリック型パラメーターに型を割り当てる必要があります。</span><span class="sxs-lookup"><span data-stu-id="0c99c-208">In order to invoke it, you must assign types to its generic type parameters.</span></span> <span data-ttu-id="0c99c-209">これを行うには、<xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="0c99c-209">Use the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> method to do this.</span></span> <span data-ttu-id="0c99c-210">次のコードでは、<xref:System.String> に `TInput`、`List(Of String)` に `List<string>` (C# では `TOutput`) を指定して、構築されたジェネリック メソッドを作成し、メソッドの文字列形式を表示します。</span><span class="sxs-lookup"><span data-stu-id="0c99c-210">The following code creates a constructed generic method, specifying <xref:System.String> for `TInput` and `List(Of String)` (`List<string>` in C#) for `TOutput`, and displays a string representation of the method.</span></span>  
  
     <span data-ttu-id="0c99c-211">[!code-csharp[GenericMethodHowTo#21](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#21)]  [!code-vb[GenericMethodHowTo#21](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#21)]</span><span class="sxs-lookup"><span data-stu-id="0c99c-211">[!code-csharp[GenericMethodHowTo#21](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#21)]  [!code-vb[GenericMethodHowTo#21](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#21)]</span></span>  
  
2.  <span data-ttu-id="0c99c-212">遅延バインディングによってメソッドを呼び出すには、<xref:System.Reflection.MethodBase.Invoke%2A> メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="0c99c-212">To invoke the method late-bound, use the <xref:System.Reflection.MethodBase.Invoke%2A> method.</span></span> <span data-ttu-id="0c99c-213">次のコードでは、唯一の要素として文字列の配列を格納する <xref:System.Object> の配列を作成し、ジェネリック メソッドの引数リストとして渡します。</span><span class="sxs-lookup"><span data-stu-id="0c99c-213">The following code creates an array of <xref:System.Object>, containing as its only element an array of strings, and passes it as the argument list for the generic method.</span></span> <span data-ttu-id="0c99c-214">このメソッドは <xref:System.Reflection.MethodBase.Invoke%2A> であるため、`static` の 1 つ目のパラメーターは null 参照です。</span><span class="sxs-lookup"><span data-stu-id="0c99c-214">The first parameter of <xref:System.Reflection.MethodBase.Invoke%2A> is a null reference because the method is `static`.</span></span> <span data-ttu-id="0c99c-215">戻り値は `List(Of String)` にキャストされ、最初の要素が表示されます。</span><span class="sxs-lookup"><span data-stu-id="0c99c-215">The return value is cast to `List(Of String)`, and its first element is displayed.</span></span>  
  
     <span data-ttu-id="0c99c-216">[!code-csharp[GenericMethodHowTo#22](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#22)]  [!code-vb[GenericMethodHowTo#22](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#22)]</span><span class="sxs-lookup"><span data-stu-id="0c99c-216">[!code-csharp[GenericMethodHowTo#22](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#22)]  [!code-vb[GenericMethodHowTo#22](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#22)]</span></span>  
  
3.  <span data-ttu-id="0c99c-217">デリゲートを使用してメソッドを呼び出すには、構築されたジェネリック メソッドのシグネチャと一致するデリゲートを用意する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0c99c-217">To invoke the method using a delegate, you must have a delegate that matches the signature of the constructed generic method.</span></span> <span data-ttu-id="0c99c-218">汎用デリゲートを作成すると、これを簡単に行うことができます。</span><span class="sxs-lookup"><span data-stu-id="0c99c-218">An easy way to do this is to create a generic delegate.</span></span> <span data-ttu-id="0c99c-219">次のコードでは、`D` メソッド オーバーロードを使用して、プログラム例で定義した <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29?displayProperty=fullName> 汎用デリゲートのインスタンスを作成し、デリゲートを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="0c99c-219">The following code creates an instance of the generic delegate `D` defined in the example code, using the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29?displayProperty=fullName> method overload, and invokes the delegate.</span></span> <span data-ttu-id="0c99c-220">デリゲートは、遅延バインディングによる呼び出しよりもパフォーマンスが優れています。</span><span class="sxs-lookup"><span data-stu-id="0c99c-220">Delegates perform better than late-bound calls.</span></span>  
  
     <span data-ttu-id="0c99c-221">[!code-csharp[GenericMethodHowTo#23](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#23)]  [!code-vb[GenericMethodHowTo#23](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#23)]</span><span class="sxs-lookup"><span data-stu-id="0c99c-221">[!code-csharp[GenericMethodHowTo#23](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#23)]  [!code-vb[GenericMethodHowTo#23](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#23)]</span></span>  
  
4.  <span data-ttu-id="0c99c-222">出力されたメソッドは、保存されたアセンブリを参照するプログラムから呼び出すこともできます。</span><span class="sxs-lookup"><span data-stu-id="0c99c-222">The emitted method can also be called from a program that refers to the saved assembly.</span></span>  
  
## <a name="example"></a><span data-ttu-id="0c99c-223">例</span><span class="sxs-lookup"><span data-stu-id="0c99c-223">Example</span></span>  
 <span data-ttu-id="0c99c-224">ジェネリック メソッド `DemoType` と共に、非ジェネリック型 `Factory` を作成するコード例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="0c99c-224">The following code example creates a nongeneric type, `DemoType`, with a generic method, `Factory`.</span></span> <span data-ttu-id="0c99c-225">このメソッドは、入力の種類を指定する `TInput` と、出力の種類を指定する `TOutput` の 2 つのジェネリック型パラメーターを持ちます。</span><span class="sxs-lookup"><span data-stu-id="0c99c-225">This method has two generic type parameters, `TInput` to specify an input type and `TOutput` to specify an output type.</span></span> <span data-ttu-id="0c99c-226">型パラメーター `TOutput` は、`ICollection<TInput>` (Visual Basic では `ICollection(Of TInput)`) を実装し、参照型であり、パラメーターなしのコンストラクターを持つように制約されています。</span><span class="sxs-lookup"><span data-stu-id="0c99c-226">The `TOutput` type parameter is constrained to implement `ICollection<TInput>` (`ICollection(Of TInput)` in Visual Basic), to be a reference type, and to have a parameterless constructor.</span></span>  
  
 <span data-ttu-id="0c99c-227">メソッドは、`TInput` の配列である仮パラメーターを 1 つ持ちます。</span><span class="sxs-lookup"><span data-stu-id="0c99c-227">The method has one formal parameter, which is an array of `TInput`.</span></span> <span data-ttu-id="0c99c-228">メソッドは、入力配列のすべての要素を格納する `TOutput` のインスタンスを返します。</span><span class="sxs-lookup"><span data-stu-id="0c99c-228">The method returns an instance of `TOutput` that contains all the elements of the input array.</span></span> <span data-ttu-id="0c99c-229">`TOutput` は <xref:System.Collections.Generic.ICollection%601> ジェネリック インターフェイスを実装するジェネリック コレクション型に指定できます。</span><span class="sxs-lookup"><span data-stu-id="0c99c-229">`TOutput` can be any generic collection type that implements the <xref:System.Collections.Generic.ICollection%601> generic interface.</span></span>  
  
 <span data-ttu-id="0c99c-230">コードを実行すると、動的アセンブリが DemoGenericMethod1.dll という名前で保存され、[Ildasm.exe (IL Disassembler)](../../../docs/framework/tools/ildasm-exe-il-disassembler.md) を使用してチェックできます。</span><span class="sxs-lookup"><span data-stu-id="0c99c-230">When the code is executed, the dynamic assembly is saved as DemoGenericMethod1.dll, and can be examined using the [Ildasm.exe (IL Disassembler)](../../../docs/framework/tools/ildasm-exe-il-disassembler.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0c99c-231">コードを出力する方法を習得するためのよい方法は、出力しようとしているタスクを実行するプログラムを Visual Basic、C#、または Visual C++ で記述し、逆アセンブラーを使用して、コンパイラによって生成された MSIL をチェックすることです。</span><span class="sxs-lookup"><span data-stu-id="0c99c-231">A good way to learn how to emit code is to write a Visual Basic, C#, or Visual C++ program that performs the task you are trying to emit, and use the disassembler to examine the MSIL produced by the compiler.</span></span>  
  
 <span data-ttu-id="0c99c-232">このコード例には、出力されたメソッドに相当するソース コードが含まれています。</span><span class="sxs-lookup"><span data-stu-id="0c99c-232">The code example includes source code that is equivalent to the emitted method.</span></span> <span data-ttu-id="0c99c-233">出力されたメソッドは、遅延バインディングによって呼び出されます。また、このコード例で宣言された汎用デリゲートを使用することによっても呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="0c99c-233">The emitted method is invoked late-bound and also by using a generic delegate declared in the code example.</span></span>  
  
 <span data-ttu-id="0c99c-234">[!code-csharp[GenericMethodHowTo#1](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#1)] [!code-vb[GenericMethodHowTo#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#1)]</span><span class="sxs-lookup"><span data-stu-id="0c99c-234">[!code-csharp[GenericMethodHowTo#1](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#1)] [!code-vb[GenericMethodHowTo#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#1)]</span></span>  
  
## <a name="compiling-the-code"></a><span data-ttu-id="0c99c-235">コードのコンパイル</span><span class="sxs-lookup"><span data-stu-id="0c99c-235">Compiling the Code</span></span>  
  
-   <span data-ttu-id="0c99c-236">このコードには、コンパイルに必要な C# の `using` ステートメント (Visual Basic では `Imports`) が含まれています。</span><span class="sxs-lookup"><span data-stu-id="0c99c-236">The code contains the C# `using` statements (`Imports` in Visual Basic) necessary for compilation.</span></span>  
  
-   <span data-ttu-id="0c99c-237">追加のアセンブリ参照は不要です。</span><span class="sxs-lookup"><span data-stu-id="0c99c-237">No additional assembly references are required.</span></span>  
  
-   <span data-ttu-id="0c99c-238">コマンド ラインで csc.exe、vbc.exe、または cl.exe を使用して、コードをコンパイルします。</span><span class="sxs-lookup"><span data-stu-id="0c99c-238">Compile the code at the command line using csc.exe, vbc.exe, or cl.exe.</span></span> <span data-ttu-id="0c99c-239">Visual Studio でコードをコンパイルするには、コンソール アプリケーション プロジェクト テンプレートの中にコードを配置します。</span><span class="sxs-lookup"><span data-stu-id="0c99c-239">To compile the code in Visual Studio, place it in a console application project template.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="0c99c-240">関連項目</span><span class="sxs-lookup"><span data-stu-id="0c99c-240">See Also</span></span>  
 <span data-ttu-id="0c99c-241"><xref:System.Reflection.Emit.MethodBuilder></span><span class="sxs-lookup"><span data-stu-id="0c99c-241"><xref:System.Reflection.Emit.MethodBuilder></span></span>   
 [<span data-ttu-id="0c99c-242">方法: リフレクション出力を使用してジェネリック型を定義する</span><span class="sxs-lookup"><span data-stu-id="0c99c-242">How to: Define a Generic Type with Reflection Emit</span></span>](../../../docs/framework/reflection-and-codedom/how-to-define-a-generic-type-with-reflection-emit.md)

