---
title: コントロールの作成の概要
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- controls [WPF], authoring overview
- authoring overview for controls [WPF]
ms.assetid: 3d864748-cff0-4e63-9b23-d8e5a635b28f
ms.openlocfilehash: ca11a5787dfd3e5f3089d44689d96ec64c75e4f3
ms.sourcegitcommit: efff8f331fd9467f093f8ab8d23a203d6ecb5b60
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 09/01/2018
ms.locfileid: "43394069"
---
# <a name="control-authoring-overview"></a><span data-ttu-id="d55c6-102">コントロールの作成の概要</span><span class="sxs-lookup"><span data-stu-id="d55c6-102">Control Authoring Overview</span></span>
<span data-ttu-id="d55c6-103">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] コントロール モデルの機能拡張により、新しいコントロールを作成する必要性が大幅に削減されます。</span><span class="sxs-lookup"><span data-stu-id="d55c6-103">The extensibility of the [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] control model greatly reduces the need to create a new control.</span></span> <span data-ttu-id="d55c6-104">ただし、場合によっては、カスタム コントロールを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d55c6-104">However, in certain cases you may still need to create a custom control.</span></span> <span data-ttu-id="d55c6-105">このトピックでは、カスタム コントロールを作成する必要性を最小限に抑える機能と、[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] のさまざまなコントロール作成モデルについて説明します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-105">This topic discusses the features that minimize your need to create a custom control and the different control authoring models in [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)].</span></span> <span data-ttu-id="d55c6-106">また、新しいコントロールを作成する方法も示します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-106">This topic also demonstrates how to create a new control.</span></span>  
  
 
  
<a name="when_to_write_a_new_control"></a>   
## <a name="alternatives-to-writing-a-new-control"></a><span data-ttu-id="d55c6-107">新しいコントロールの作成に代わる方法</span><span class="sxs-lookup"><span data-stu-id="d55c6-107">Alternatives to Writing a New Control</span></span>  
 <span data-ttu-id="d55c6-108">従来は、既存のコントロールをカスタマイズする場合、背景色、境界線の幅、フォントのサイズなど、コントロールの標準プロパティを変更するなどの範囲に制限されていました。</span><span class="sxs-lookup"><span data-stu-id="d55c6-108">Historically, if you wanted to get a customized experience from an existing control, you were limited to changing the standard properties of the control, such as background color, border width, and font size.</span></span> <span data-ttu-id="d55c6-109">これらの定義済みのパラメーター以外に、コントロールの外観や動作にまでカスタマイズを拡張しようとすると、通常、既存のコントロールを継承し、コントロールを描画するメソッドをオーバーライドして、新しいコントロールを作成する必要がありました。</span><span class="sxs-lookup"><span data-stu-id="d55c6-109">If you wished to extend the appearance or behavior of a control beyond these predefined parameters, you would need to create a new control, usually by inheriting from an existing control and overriding the method responsible for drawing the control.</span></span>  <span data-ttu-id="d55c6-110">その方法は今でも選択できますが、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] の場合、リッチ コンテンツ モデル、スタイル、テンプレート、トリガーを使用して、既存のコントロールをカスタマイズできます。</span><span class="sxs-lookup"><span data-stu-id="d55c6-110">Although that is still an option, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] enables to you customize existing controls by using its rich content model, styles, templates, and triggers.</span></span> <span data-ttu-id="d55c6-111">新しいコントロールを作成しなくても、これらの機能を使用して、カスタマイズされた一貫性のあるエクスペリエンスを得られる方法としては、次のような例が挙げられます。</span><span class="sxs-lookup"><span data-stu-id="d55c6-111">The following list gives examples of how these features can be used to create custom and consistent experiences without having to create a new control.</span></span>  
  
-   <span data-ttu-id="d55c6-112">**リッチ コンテンツ。**</span><span class="sxs-lookup"><span data-stu-id="d55c6-112">**Rich Content.**</span></span> <span data-ttu-id="d55c6-113">標準の [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] コントロールの多くがリッチ コンテンツをサポートしています。</span><span class="sxs-lookup"><span data-stu-id="d55c6-113">Many of the standard [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] controls support rich content.</span></span> <span data-ttu-id="d55c6-114">コンテンツのプロパティなど、<xref:System.Windows.Controls.Button>の種類は<xref:System.Object>、理論上何も表示できます、<xref:System.Windows.Controls.Button>します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-114">For example, the content property of a <xref:System.Windows.Controls.Button> is of type <xref:System.Object>, so theoretically anything can be displayed on a <xref:System.Windows.Controls.Button>.</span></span>  <span data-ttu-id="d55c6-115">イメージとテキストの表示 ボタンを表示するには、イメージを追加することができます、<xref:System.Windows.Controls.TextBlock>を<xref:System.Windows.Controls.StackPanel>を割り当てると、<xref:System.Windows.Controls.StackPanel>を<xref:System.Windows.Controls.ContentControl.Content%2A>プロパティ。</span><span class="sxs-lookup"><span data-stu-id="d55c6-115">To have a button display an image and text, you can add an image and a <xref:System.Windows.Controls.TextBlock> to a <xref:System.Windows.Controls.StackPanel> and assign the <xref:System.Windows.Controls.StackPanel> to the <xref:System.Windows.Controls.ContentControl.Content%2A> property.</span></span> <span data-ttu-id="d55c6-116">コントロールには、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] の視覚的要素と任意のデータを表示できるため、複雑な視覚化をサポートするために、新しいコントロールを作成したり、既存のコントロールを変更したりする必要性が少なくなります。</span><span class="sxs-lookup"><span data-stu-id="d55c6-116">Because the controls can display [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] visual elements and arbitrary data, there is less need to create a new control or to modify an existing control to support a complex visualization.</span></span> <span data-ttu-id="d55c6-117">コンテンツ モデルの詳細については<xref:System.Windows.Controls.Button>での他のコンテンツ モデルと[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]を参照してください[WPF コンテンツ モデル](../../../../docs/framework/wpf/controls/wpf-content-model.md)します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-117">For more information about the content model for <xref:System.Windows.Controls.Button> and other content models in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], see [WPF Content Model](../../../../docs/framework/wpf/controls/wpf-content-model.md).</span></span>  
  
-   <span data-ttu-id="d55c6-118">**スタイル**</span><span class="sxs-lookup"><span data-stu-id="d55c6-118">**Styles.**</span></span> <span data-ttu-id="d55c6-119">A<xref:System.Windows.Style>はコントロールのプロパティを表す値のコレクションです。</span><span class="sxs-lookup"><span data-stu-id="d55c6-119">A <xref:System.Windows.Style> is a collection of values that represent properties for a control.</span></span> <span data-ttu-id="d55c6-120">スタイルを使用すると、新しいコントロールを作成しなくても、必要なコントロールの外観と動作を備えた再利用可能な表現を作成できます。</span><span class="sxs-lookup"><span data-stu-id="d55c6-120">By using styles, you can create a reusable representation of a desired control appearance and behavior without writing a new control.</span></span> <span data-ttu-id="d55c6-121">たとえば、すべての必要な<xref:System.Windows.Controls.TextBlock>コントロールにフォント サイズ 14 の赤、Arial フォント。</span><span class="sxs-lookup"><span data-stu-id="d55c6-121">For example, assume that you want all of your <xref:System.Windows.Controls.TextBlock> controls to have red, Arial font with a font size of 14.</span></span> <span data-ttu-id="d55c6-122">そこで、リソースとしてスタイルを作成し、それに応じて、適切なプロパティを設定します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-122">You can create a style as a resource and set the appropriate properties accordingly.</span></span> <span data-ttu-id="d55c6-123">すべてし<xref:System.Windows.Controls.TextBlock>同じ外観をアプリケーションに追加する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d55c6-123">Then every <xref:System.Windows.Controls.TextBlock> that you add to your application will have the same appearance.</span></span>  
  
-   <span data-ttu-id="d55c6-124">**データ テンプレート。**</span><span class="sxs-lookup"><span data-stu-id="d55c6-124">**Data Templates.**</span></span> <span data-ttu-id="d55c6-125">A<xref:System.Windows.DataTemplate>コントロールにデータを表示する方法をカスタマイズすることができます。</span><span class="sxs-lookup"><span data-stu-id="d55c6-125">A <xref:System.Windows.DataTemplate> enables you to customize how data is displayed on a control.</span></span> <span data-ttu-id="d55c6-126">たとえば、<xref:System.Windows.DataTemplate>にデータを表示する方法を指定するために使用できる、 <xref:System.Windows.Controls.ListBox>。</span><span class="sxs-lookup"><span data-stu-id="d55c6-126">For example, a <xref:System.Windows.DataTemplate> can be used to specify how data is displayed in a <xref:System.Windows.Controls.ListBox>.</span></span>  <span data-ttu-id="d55c6-127">この例については、「[データ テンプレートの概要](../../../../docs/framework/wpf/data/data-templating-overview.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="d55c6-127">For an example of this, see [Data Templating Overview](../../../../docs/framework/wpf/data/data-templating-overview.md).</span></span>  <span data-ttu-id="d55c6-128">データの外観のカスタマイズに加え、<xref:System.Windows.DataTemplate>これにより、高度な柔軟性ではカスタム Ui の UI 要素を含めることができます。</span><span class="sxs-lookup"><span data-stu-id="d55c6-128">In addition to customizing the appearance of data, a <xref:System.Windows.DataTemplate> can include UI elements, which gives you a lot of flexibility in custom UIs.</span></span>  <span data-ttu-id="d55c6-129">などを使用して、 <xref:System.Windows.DataTemplate>、作成することができます、<xref:System.Windows.Controls.ComboBox>でその各項目には、チェック ボックスが含まれています。</span><span class="sxs-lookup"><span data-stu-id="d55c6-129">For example, by using a <xref:System.Windows.DataTemplate>, you can create a <xref:System.Windows.Controls.ComboBox> in which each item contains a check box.</span></span>  
  
-   <span data-ttu-id="d55c6-130">**コントロール テンプレート。**</span><span class="sxs-lookup"><span data-stu-id="d55c6-130">**Control Templates.**</span></span> <span data-ttu-id="d55c6-131">コントロールの多く[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]を使用して、<xref:System.Windows.Controls.ControlTemplate>コントロールの構造とコントロールの外観では、コントロールの機能から分離の外観を定義します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-131">Many controls in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] use a <xref:System.Windows.Controls.ControlTemplate> to define the control's structure and appearance, which separates the appearance of a control from the functionality of the control.</span></span> <span data-ttu-id="d55c6-132">再定義コントロールの外観を大幅に変更することができます、<xref:System.Windows.Controls.ControlTemplate>します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-132">You can drastically change the appearance of a control by redefining its <xref:System.Windows.Controls.ControlTemplate>.</span></span>  <span data-ttu-id="d55c6-133">たとえば、信号機のような外観のコントロールが必要だとします。</span><span class="sxs-lookup"><span data-stu-id="d55c6-133">For example, suppose you want a control that looks like a stoplight.</span></span> <span data-ttu-id="d55c6-134">このコントロールのユーザー インターフェイスと機能は単純です。</span><span class="sxs-lookup"><span data-stu-id="d55c6-134">This control has a simple user interface and functionality.</span></span>  <span data-ttu-id="d55c6-135">コントロールは 3 つの円で構成され、一度に点灯するのはそのうちの 1 つだけです。</span><span class="sxs-lookup"><span data-stu-id="d55c6-135">The control is three circles, only one of which can be lit up at a time.</span></span> <span data-ttu-id="d55c6-136">いくつかのリフレクションの後を実現可能性があります、<xref:System.Windows.Controls.RadioButton>の 1 つだけが、時刻の既定の外観に選択されている機能を提供、<xref:System.Windows.Controls.RadioButton>信号機のライトとは何も検索します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-136">After some reflection, you might realize that a <xref:System.Windows.Controls.RadioButton> offers the functionality of only one being selected at a time, but the default appearance of the <xref:System.Windows.Controls.RadioButton> looks nothing like the lights on a stoplight.</span></span>  <span data-ttu-id="d55c6-137"><xref:System.Windows.Controls.RadioButton> 、外観を定義して、コントロール テンプレートを使用して再定義するは簡単、<xref:System.Windows.Controls.ControlTemplate>コントロールの要件に合わせておよびラジオ ボタンを使用して、信号機を作成します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-137">Because the <xref:System.Windows.Controls.RadioButton> uses a control template to define its appearance, it is easy to redefine the <xref:System.Windows.Controls.ControlTemplate> to fit the requirements of the control, and use radio buttons to make your stoplight.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="d55c6-138">ですが、<xref:System.Windows.Controls.RadioButton>使用できる、 <xref:System.Windows.DataTemplate>、<xref:System.Windows.DataTemplate>はこの例では不十分です。</span><span class="sxs-lookup"><span data-stu-id="d55c6-138">Although a <xref:System.Windows.Controls.RadioButton> can use a <xref:System.Windows.DataTemplate>, a <xref:System.Windows.DataTemplate> is not sufficient in this example.</span></span>  <span data-ttu-id="d55c6-139"><xref:System.Windows.DataTemplate>コントロールのコンテンツの外観を定義します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-139">The <xref:System.Windows.DataTemplate> defines the appearance of the content of a control.</span></span> <span data-ttu-id="d55c6-140">場合、 <xref:System.Windows.Controls.RadioButton>、コンテンツがその分岐点の円の右側に表示されるかどうか、<xref:System.Windows.Controls.RadioButton>が選択されています。</span><span class="sxs-lookup"><span data-stu-id="d55c6-140">In the case of a <xref:System.Windows.Controls.RadioButton>, the content is whatever appears to the right of the circle that indicates whether the <xref:System.Windows.Controls.RadioButton> is selected.</span></span>  <span data-ttu-id="d55c6-141">信号機の例では、オプション ボタンに必要なのは "点灯" する円だけです。</span><span class="sxs-lookup"><span data-stu-id="d55c6-141">In the example of the stoplight, the radio button needs just be a circle that can "light up."</span></span> <span data-ttu-id="d55c6-142">信号機の外観の要件は、既定の外観の異なるため、 <xref:System.Windows.Controls.RadioButton>、再定義する必要がある、<xref:System.Windows.Controls.ControlTemplate>します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-142">Because the appearance requirement for the stoplight is so different than the default appearance of the <xref:System.Windows.Controls.RadioButton>, it is necessary to redefine the <xref:System.Windows.Controls.ControlTemplate>.</span></span>  <span data-ttu-id="d55c6-143">一般に、<xref:System.Windows.DataTemplate>コントロール、およびのコンテンツ (またはデータ) を定義するために使用<xref:System.Windows.Controls.ControlTemplate>コントロールを構成する方法を定義するために使用します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-143">In general a <xref:System.Windows.DataTemplate> is used for defining the content (or data) of a control, and a <xref:System.Windows.Controls.ControlTemplate> is used for defining how a control is structured.</span></span>  
  
-   <span data-ttu-id="d55c6-144">**トリガー。**</span><span class="sxs-lookup"><span data-stu-id="d55c6-144">**Triggers.**</span></span> <span data-ttu-id="d55c6-145">A<xref:System.Windows.Trigger>新しいコントロールを作成せず、コントロールの動作と外観を動的に変更することができます。</span><span class="sxs-lookup"><span data-stu-id="d55c6-145">A <xref:System.Windows.Trigger> allows you to dynamically change the appearance and behavior of a control without creating a new control.</span></span> <span data-ttu-id="d55c6-146">たとえば、複数<xref:System.Windows.Controls.ListBox>アプリケーションではコントロールに各項目を追加および<xref:System.Windows.Controls.ListBox>太字、色を赤を選択すると、あります。</span><span class="sxs-lookup"><span data-stu-id="d55c6-146">For example, suppose you have multiple <xref:System.Windows.Controls.ListBox> controls in your application and want the items in each <xref:System.Windows.Controls.ListBox> to be bold and red when they are selected.</span></span> <span data-ttu-id="d55c6-147">まず思いつくが継承するクラスを作成することがあります<xref:System.Windows.Controls.ListBox>をオーバーライドし、<xref:System.Windows.Controls.Primitives.Selector.OnSelectionChanged%2A>選択した項目がより優れたアプローチの外観を変更する方法は、トリガーのスタイルを追加する、<xref:System.Windows.Controls.ListBoxItem>の外観を変更します。選択された項目。</span><span class="sxs-lookup"><span data-stu-id="d55c6-147">Your first instinct might be to create a class that inherits from <xref:System.Windows.Controls.ListBox> and override the <xref:System.Windows.Controls.Primitives.Selector.OnSelectionChanged%2A> method to change the appearance of the selected item, but a better approach is to add a trigger to a style of a <xref:System.Windows.Controls.ListBoxItem> that changes the appearance of the selected item.</span></span> <span data-ttu-id="d55c6-148">トリガーを使用すると、プロパティ値を変更したり、プロパティ値に基づいた処理を実行したりできます。</span><span class="sxs-lookup"><span data-stu-id="d55c6-148">A trigger enables you to change property values or take actions based on the value of a property.</span></span> <span data-ttu-id="d55c6-149"><xref:System.Windows.EventTrigger>イベントが発生したときにアクションを実行することができます。</span><span class="sxs-lookup"><span data-stu-id="d55c6-149">An <xref:System.Windows.EventTrigger> enables you to take actions when an event occurs.</span></span>  
  
 <span data-ttu-id="d55c6-150">スタイル、テンプレート、トリガーの詳細については、「[スタイルとテンプレート](../../../../docs/framework/wpf/controls/styling-and-templating.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="d55c6-150">For more information about styles, templates, and triggers, see [Styling and Templating](../../../../docs/framework/wpf/controls/styling-and-templating.md).</span></span>  
  
 <span data-ttu-id="d55c6-151">一般に、既存のコントロールと同じ機能を持ち、外観が異なるコントロールが必要な場合は、このセクションで説明した方法のいずれかを使用して、既存のコントロールの外観を変更できないかどうかをまず検討することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="d55c6-151">In general, if your control mirrors the functionality of an existing control, but you want the control to look different, you should first consider whether you can use any of the methods discussed in this section to change the existing control's appearance.</span></span>  
  
<a name="models_for_control_authoring"></a>   
## <a name="models-for-control-authoring"></a><span data-ttu-id="d55c6-152">コントロール作成モデル</span><span class="sxs-lookup"><span data-stu-id="d55c6-152">Models for Control Authoring</span></span>  
 <span data-ttu-id="d55c6-153">リッチ コンテンツ モデル、スタイル、テンプレート、トリガーを使用すると、新しいコントロールを作成する必要性が最小限に抑えられます。</span><span class="sxs-lookup"><span data-stu-id="d55c6-153">The rich content model, styles, templates, and triggers minimize the need for you to create a new control.</span></span> <span data-ttu-id="d55c6-154">ただし、新しいコントロールを作成する必要がある場合は、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] の各種のコントロール作成モデルを理解することが重要です。</span><span class="sxs-lookup"><span data-stu-id="d55c6-154">However, if you do need to create a new control, it is important to understand the different control authoring models in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="d55c6-155"> には、コントロールを作成するための一般的なモデルが 3 つあり、各モデルはそれぞれ異なる機能と柔軟性レベルを備えています。</span><span class="sxs-lookup"><span data-stu-id="d55c6-155"> provides three general models for creating a control, each of which provides a different set of features and level of flexibility.</span></span> <span data-ttu-id="d55c6-156">基本クラスの 3 つのモデルは<xref:System.Windows.Controls.UserControl>、 <xref:System.Windows.Controls.Control>、および<xref:System.Windows.FrameworkElement>します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-156">The base classes for the three models are <xref:System.Windows.Controls.UserControl>, <xref:System.Windows.Controls.Control>, and <xref:System.Windows.FrameworkElement>.</span></span>  
  
### <a name="deriving-from-usercontrol"></a><span data-ttu-id="d55c6-157">UserControl からの派生</span><span class="sxs-lookup"><span data-stu-id="d55c6-157">Deriving from UserControl</span></span>  
 <span data-ttu-id="d55c6-158">コントロールを作成する最も簡単な方法は、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]から派生するは<xref:System.Windows.Controls.UserControl>します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-158">The simplest way to create a control in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is to derive from <xref:System.Windows.Controls.UserControl>.</span></span> <span data-ttu-id="d55c6-159">継承するコントロールを作成するときに<xref:System.Windows.Controls.UserControl>に既存のコンポーネントを追加する、<xref:System.Windows.Controls.UserControl>でイベント ハンドラーを参照し、コンポーネントという名前を[!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)]します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-159">When you build a control that inherits from <xref:System.Windows.Controls.UserControl>, you add existing components to the <xref:System.Windows.Controls.UserControl>, name the components, and reference event handlers in [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)].</span></span> <span data-ttu-id="d55c6-160">次に、指定の要素を参照し、コードでイベント ハンドラーを定義します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-160">You can then reference the named elements and define the event handlers in code.</span></span> <span data-ttu-id="d55c6-161">この開発モデルは、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] でのアプリケーション開発に使用されるモデルとよく似ています。</span><span class="sxs-lookup"><span data-stu-id="d55c6-161">This development model is very similar to the model used for application development in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].</span></span>  
  
 <span data-ttu-id="d55c6-162">正しくビルドされている場合、<xref:System.Windows.Controls.UserControl>リッチ コンテンツ、スタイル、およびトリガーの利点を利用できます。</span><span class="sxs-lookup"><span data-stu-id="d55c6-162">If built correctly, a <xref:System.Windows.Controls.UserControl> can take advantage of the benefits of rich content, styles, and triggers.</span></span> <span data-ttu-id="d55c6-163">ただしから継承したコントロールの場合<xref:System.Windows.Controls.UserControl>、コントロールを使用するユーザーは使用できません、<xref:System.Windows.DataTemplate>または<xref:System.Windows.Controls.ControlTemplate>その外観をカスタマイズします。</span><span class="sxs-lookup"><span data-stu-id="d55c6-163">However, if your control inherits from <xref:System.Windows.Controls.UserControl>, people who use your control will not be able to use a <xref:System.Windows.DataTemplate> or <xref:System.Windows.Controls.ControlTemplate> to customize its appearance.</span></span>  <span data-ttu-id="d55c6-164">派生する必要があります、<xref:System.Windows.Controls.Control>クラスまたはその派生クラスのいずれか (他にも<xref:System.Windows.Controls.UserControl>) テンプレートをサポートするカスタム コントロールを作成します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-164">It is necessary to derive from the <xref:System.Windows.Controls.Control> class or one of its derived classes (other than <xref:System.Windows.Controls.UserControl>) to create a custom control that supports templates.</span></span>  
  
#### <a name="benefits-of-deriving-from-usercontrol"></a><span data-ttu-id="d55c6-165">UserControl からの派生の利点</span><span class="sxs-lookup"><span data-stu-id="d55c6-165">Benefits of Deriving from UserControl</span></span>  
 <span data-ttu-id="d55c6-166">派生することを検討してください<xref:System.Windows.Controls.UserControl>すべて、次の該当する場合。</span><span class="sxs-lookup"><span data-stu-id="d55c6-166">Consider deriving from <xref:System.Windows.Controls.UserControl> if all of the following apply:</span></span>  
  
-   <span data-ttu-id="d55c6-167">アプリケーションの構築と同じ方法でコントロールをビルドする必要がある場合。</span><span class="sxs-lookup"><span data-stu-id="d55c6-167">You want to build your control similarly to how you build an application.</span></span>  
  
-   <span data-ttu-id="d55c6-168">コントロールが既存のコンポーネントのみで構成されている場合。</span><span class="sxs-lookup"><span data-stu-id="d55c6-168">Your control consists only of existing components.</span></span>  
  
-   <span data-ttu-id="d55c6-169">複雑なカスタマイズをサポートする必要がない場合。</span><span class="sxs-lookup"><span data-stu-id="d55c6-169">You don't need to support complex customization.</span></span>  
  
### <a name="deriving-from-control"></a><span data-ttu-id="d55c6-170">Control からの派生</span><span class="sxs-lookup"><span data-stu-id="d55c6-170">Deriving from Control</span></span>  
 <span data-ttu-id="d55c6-171">派生する、<xref:System.Windows.Controls.Control>クラスは、既存のほとんどで使用されるモデル[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]コントロール。</span><span class="sxs-lookup"><span data-stu-id="d55c6-171">Deriving from the <xref:System.Windows.Controls.Control> class is the model used by most of the existing [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] controls.</span></span> <span data-ttu-id="d55c6-172">継承するコントロールを作成する場合、<xref:System.Windows.Controls.Control>クラス テンプレートを使用してその外観を定義します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-172">When you create a control that inherits from the <xref:System.Windows.Controls.Control> class, you define its appearance by using templates.</span></span> <span data-ttu-id="d55c6-173">これにより、操作ロジックと視覚的表現とが分離されます。</span><span class="sxs-lookup"><span data-stu-id="d55c6-173">By doing so, you separate the operational logic from the visual representation.</span></span> <span data-ttu-id="d55c6-174">イベントと回避の参照元要素ではなく、コマンドとバインディングを使用して、UI とロジックの分離も確認できます、<xref:System.Windows.Controls.ControlTemplate>可能な場合。</span><span class="sxs-lookup"><span data-stu-id="d55c6-174">You can also ensure the decoupling of the UI and logic by using commands and bindings instead of events and avoiding referencing elements in the <xref:System.Windows.Controls.ControlTemplate> whenever possible.</span></span>  <span data-ttu-id="d55c6-175">コントロールのユーザーがコントロールの再定義できます、UI と、コントロールのロジックが適切に分離された場合は、<xref:System.Windows.Controls.ControlTemplate>その外観をカスタマイズします。</span><span class="sxs-lookup"><span data-stu-id="d55c6-175">If the UI and logic of your control are properly decoupled, a user of your control can redefine the control's <xref:System.Windows.Controls.ControlTemplate> to customize its appearance.</span></span> <span data-ttu-id="d55c6-176">カスタムのビルドが<xref:System.Windows.Controls.Control>ビルドとして単純ではありませんが、 <xref:System.Windows.Controls.UserControl>、カスタム<xref:System.Windows.Controls.Control>最大限の柔軟性を提供します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-176">Although building a custom <xref:System.Windows.Controls.Control> is not as simple as building a <xref:System.Windows.Controls.UserControl>, a custom <xref:System.Windows.Controls.Control> provides the most flexibility.</span></span>  
  
#### <a name="benefits-of-deriving-from-control"></a><span data-ttu-id="d55c6-177">Control からの派生の利点</span><span class="sxs-lookup"><span data-stu-id="d55c6-177">Benefits of Deriving from Control</span></span>  
 <span data-ttu-id="d55c6-178">派生することを検討してください<xref:System.Windows.Controls.Control>を使用してではなく、<xref:System.Windows.Controls.UserControl>クラスの場合、以下が適用されます。</span><span class="sxs-lookup"><span data-stu-id="d55c6-178">Consider deriving from <xref:System.Windows.Controls.Control> instead of using the <xref:System.Windows.Controls.UserControl> class if any of the following apply:</span></span>  
  
-   <span data-ttu-id="d55c6-179">使用してカスタマイズできるように、コントロールの外観にする、<xref:System.Windows.Controls.ControlTemplate>します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-179">You want the appearance of your control to be customizable via the <xref:System.Windows.Controls.ControlTemplate>.</span></span>  
  
-   <span data-ttu-id="d55c6-180">コントロールがさまざまなテーマをサポートする必要がある場合。</span><span class="sxs-lookup"><span data-stu-id="d55c6-180">You want your control to support different themes.</span></span>  
  
### <a name="deriving-from-frameworkelement"></a><span data-ttu-id="d55c6-181">FrameworkElement からの派生</span><span class="sxs-lookup"><span data-stu-id="d55c6-181">Deriving from FrameworkElement</span></span>  
 <span data-ttu-id="d55c6-182">派生したコントロール<xref:System.Windows.Controls.UserControl>または<xref:System.Windows.Controls.Control>既存の要素の構成に依存します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-182">Controls that derive from <xref:System.Windows.Controls.UserControl> or <xref:System.Windows.Controls.Control> rely upon composing existing elements.</span></span> <span data-ttu-id="d55c6-183">多くのシナリオでは、これは、適切な解決策ためから継承する任意のオブジェクト<xref:System.Windows.FrameworkElement>にできる、<xref:System.Windows.Controls.ControlTemplate>します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-183">For many scenarios, this is an acceptable solution, because any object that inherits from <xref:System.Windows.FrameworkElement> can be in a <xref:System.Windows.Controls.ControlTemplate>.</span></span> <span data-ttu-id="d55c6-184">しかし、場合によっては、単純な要素コンポジションでは、コントロールの外観に必要な機能を実現できないことがあります。</span><span class="sxs-lookup"><span data-stu-id="d55c6-184">However, there are times when a control's appearance requires more than the functionality of simple element composition.</span></span> <span data-ttu-id="d55c6-185">このようなシナリオのコンポーネントに基づく<xref:System.Windows.FrameworkElement>は適切な選択肢です。</span><span class="sxs-lookup"><span data-stu-id="d55c6-185">For these scenarios, basing a component on <xref:System.Windows.FrameworkElement> is the right choice.</span></span>  
  
 <span data-ttu-id="d55c6-186">ビルドするための 2 つの標準的なメソッドがある<xref:System.Windows.FrameworkElement>-ベースのコンポーネント: レンダリングとカスタム要素コンポジションをダイレクトします。</span><span class="sxs-lookup"><span data-stu-id="d55c6-186">There are two standard methods for building <xref:System.Windows.FrameworkElement>-based components: direct rendering and custom element composition.</span></span> <span data-ttu-id="d55c6-187">ダイレクト レンダリングでは、オーバーライド、<xref:System.Windows.UIElement.OnRender%2A>メソッドの<xref:System.Windows.FrameworkElement>おり<xref:System.Windows.Media.DrawingContext>コンポーネントのビジュアルを明示的に定義する操作。</span><span class="sxs-lookup"><span data-stu-id="d55c6-187">Direct rendering involves overriding the <xref:System.Windows.UIElement.OnRender%2A> method of <xref:System.Windows.FrameworkElement> and providing <xref:System.Windows.Media.DrawingContext> operations that explicitly define the component visuals.</span></span> <span data-ttu-id="d55c6-188">これは、メソッドで使用される<xref:System.Windows.Controls.Image>と<xref:System.Windows.Controls.Border>します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-188">This is the method used by <xref:System.Windows.Controls.Image> and <xref:System.Windows.Controls.Border>.</span></span> <span data-ttu-id="d55c6-189">カスタム要素コンポジションでは、型のオブジェクトを使用してでは<xref:System.Windows.Media.Visual>コンポーネントの外観を作成します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-189">Custom element composition involves using objects of type <xref:System.Windows.Media.Visual> to compose the appearance of your component.</span></span> <span data-ttu-id="d55c6-190">例については、「[DrawingVisual オブジェクトの使用](../../../../docs/framework/wpf/graphics-multimedia/using-drawingvisual-objects.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="d55c6-190">For an example, see [Using DrawingVisual Objects](../../../../docs/framework/wpf/graphics-multimedia/using-drawingvisual-objects.md).</span></span> <span data-ttu-id="d55c6-191"><xref:System.Windows.Controls.Primitives.Track> コントロールの例は、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]カスタム要素コンポジションを使用します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-191"><xref:System.Windows.Controls.Primitives.Track> is an example of a control in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] that uses custom element composition.</span></span> <span data-ttu-id="d55c6-192">同じコントロールでダイレクト レンダリングとカスタム要素コンポジションを混在させることもできます。</span><span class="sxs-lookup"><span data-stu-id="d55c6-192">It is also possible to mix direct rendering and custom element composition in the same control.</span></span>  
  
#### <a name="benefits-of-deriving-from-frameworkelement"></a><span data-ttu-id="d55c6-193">FrameworkElement からの派生の利点</span><span class="sxs-lookup"><span data-stu-id="d55c6-193">Benefits of Deriving from FrameworkElement</span></span>  
 <span data-ttu-id="d55c6-194">派生することを検討してください<xref:System.Windows.FrameworkElement>場合、以下が適用されます。</span><span class="sxs-lookup"><span data-stu-id="d55c6-194">Consider deriving from <xref:System.Windows.FrameworkElement> if any of the following apply:</span></span>  
  
-   <span data-ttu-id="d55c6-195">コントロールの外観について、単純な要素コンポジションが提供する以上の厳密な制御を必要とする場合。</span><span class="sxs-lookup"><span data-stu-id="d55c6-195">You want to have precise control over the appearance of your control beyond what is provided by simple element composition.</span></span>  
  
-   <span data-ttu-id="d55c6-196">独自のレンダリング ロジックを定義して、コントロールの外観を定義する必要がある場合。</span><span class="sxs-lookup"><span data-stu-id="d55c6-196">You want to define the appearance of your control by defining your own render logic.</span></span>  
  
-   <span data-ttu-id="d55c6-197">使って何ができる上回る斬新な方法で既存の要素を作成する<xref:System.Windows.Controls.UserControl>と<xref:System.Windows.Controls.Control>します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-197">You want to compose existing elements in novel ways that go beyond what is possible with <xref:System.Windows.Controls.UserControl> and <xref:System.Windows.Controls.Control>.</span></span>  
  
<a name="control_authoring_basics"></a>   
## <a name="control-authoring-basics"></a><span data-ttu-id="d55c6-198">コントロール作成の基本</span><span class="sxs-lookup"><span data-stu-id="d55c6-198">Control Authoring Basics</span></span>  
 <span data-ttu-id="d55c6-199">既に説明したように、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] の最も強力な機能の 1 つは、コントロールの基本的なプロパティ設定だけでは不可能な外観や動作の変更を実現し、しかもカスタム コントロールを作成する必要がないということです。</span><span class="sxs-lookup"><span data-stu-id="d55c6-199">As discussed earlier, one of the most powerful features of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is the ability to go beyond setting basic properties of a control to change its appearance and behavior, yet still not needing to create a custom control.</span></span> <span data-ttu-id="d55c6-200">スタイル設定、データ バインディング、トリガーの各機能は、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] プロパティ システムおよび [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] イベント システムによって実現されています。</span><span class="sxs-lookup"><span data-stu-id="d55c6-200">The styling, data binding, and trigger features are made possible by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property system and the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] event system.</span></span> <span data-ttu-id="d55c6-201">以降のセクションでは、カスタム コントロールのユーザーが、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] に付属のコントロールと同じように、これらの機能を使用できるようにするために、カスタム コントロールの作成に使用するモデルに関係なく、従う必要があるプラクティスについて説明します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-201">The following sections describe some practices that you should follow, regardless of the model you use to create the custom control, so that users of your custom control can use these features just as they would for a control that is included with [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].</span></span>  
  
### <a name="use-dependency-properties"></a><span data-ttu-id="d55c6-202">依存関係プロパティの使用</span><span class="sxs-lookup"><span data-stu-id="d55c6-202">Use Dependency Properties</span></span>  
 <span data-ttu-id="d55c6-203">プロパティが依存関係プロパティである場合、以下の操作が可能です。</span><span class="sxs-lookup"><span data-stu-id="d55c6-203">When a property is a dependency property, it is possible to do the following:</span></span>  
  
-   <span data-ttu-id="d55c6-204">スタイルのプロパティを設定する。</span><span class="sxs-lookup"><span data-stu-id="d55c6-204">Set the property in a style.</span></span>  
  
-   <span data-ttu-id="d55c6-205">プロパティをデータ ソースにバインドする。</span><span class="sxs-lookup"><span data-stu-id="d55c6-205">Bind the property to a data source.</span></span>  
  
-   <span data-ttu-id="d55c6-206">プロパティの値として、動的リソースを使用する。</span><span class="sxs-lookup"><span data-stu-id="d55c6-206">Use a dynamic resource as the property's value.</span></span>  
  
-   <span data-ttu-id="d55c6-207">プロパティ名をアニメーション化する。</span><span class="sxs-lookup"><span data-stu-id="d55c6-207">Animate the property.</span></span>  
  
 <span data-ttu-id="d55c6-208">コントロールのプロパティがこれらの機能のいずれかをサポートす必要がある場合、それを依存関係プロパティとして実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d55c6-208">If you want a property of your control to support any of this functionality, you should implement it as a dependency property.</span></span> <span data-ttu-id="d55c6-209">次の例では、以下の処理を実行して、`Value` という名前の依存関係プロパティを定義します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-209">The following example defines a dependency property named `Value` by doing the following:</span></span>  
  
-   <span data-ttu-id="d55c6-210">定義、<xref:System.Windows.DependencyProperty>という名前の識別子`ValueProperty`として、 `public` `static` `readonly`フィールド。</span><span class="sxs-lookup"><span data-stu-id="d55c6-210">Define a <xref:System.Windows.DependencyProperty> identifier named `ValueProperty` as a `public` `static` `readonly` field.</span></span>  
  
-   <span data-ttu-id="d55c6-211">プロパティ名をプロパティ システムを呼び出すことによって登録<xref:System.Windows.DependencyProperty.Register%2A?displayProperty=nameWithType>次を指定します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-211">Register the property name with the property system, by calling <xref:System.Windows.DependencyProperty.Register%2A?displayProperty=nameWithType>, to specify the following:</span></span>  
  
    -   <span data-ttu-id="d55c6-212">プロパティの名前。</span><span class="sxs-lookup"><span data-stu-id="d55c6-212">The name of the property.</span></span>  
  
    -   <span data-ttu-id="d55c6-213">プロパティの型。</span><span class="sxs-lookup"><span data-stu-id="d55c6-213">The type of the property.</span></span>  
  
    -   <span data-ttu-id="d55c6-214">プロパティを所有する型。</span><span class="sxs-lookup"><span data-stu-id="d55c6-214">The type that owns the property.</span></span>  
  
    -   <span data-ttu-id="d55c6-215">プロパティのメタデータ。</span><span class="sxs-lookup"><span data-stu-id="d55c6-215">The metadata for the property.</span></span> <span data-ttu-id="d55c6-216">メタデータにはプロパティの既定値が含まれています、<xref:System.Windows.CoerceValueCallback>と<xref:System.Windows.PropertyChangedCallback>します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-216">The metadata contains the property's default value, a <xref:System.Windows.CoerceValueCallback> and a <xref:System.Windows.PropertyChangedCallback>.</span></span>  
  
-   <span data-ttu-id="d55c6-217">プロパティの `get` アクセサーと `set` アクセサーを実装することにより、依存関係プロパティの登録名と同じ `Value` という名前で [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] ラッパー プロパティを定義します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-217">Define a [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] wrapper property named `Value`, which is the same name that is used to register the dependency property, by implementing the property's `get` and `set` accessors.</span></span> <span data-ttu-id="d55c6-218">なお、`get`と`set`アクセサーのみを呼び出す<xref:System.Windows.DependencyObject.GetValue%2A>と<xref:System.Windows.DependencyObject.SetValue%2A>それぞれします。</span><span class="sxs-lookup"><span data-stu-id="d55c6-218">Note that the `get` and `set` accessors only call <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> respectively.</span></span> <span data-ttu-id="d55c6-219">ある依存関係プロパティのアクセサーが含まれていない追加のロジックにはためにお勧めクライアントと[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]アクセサーと呼び出しをバイパスできる<xref:System.Windows.DependencyObject.GetValue%2A>と<xref:System.Windows.DependencyObject.SetValue%2A>直接します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-219">It is recommended that the accessors of dependency properties not contain additional logic because clients and [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] can bypass the accessors and call <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> directly.</span></span> <span data-ttu-id="d55c6-220">たとえば、プロパティがデータ ソースにバインドされている場合、プロパティの `set` アクセサーは呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="d55c6-220">For example, when a property is bound to a data source, the property's `set` accessor is not called.</span></span>  <span data-ttu-id="d55c6-221">取得する追加のロジックを追加する代わりに、set アクセサーは、使用、 <xref:System.Windows.ValidateValueCallback>、<xref:System.Windows.CoerceValueCallback>と<xref:System.Windows.PropertyChangedCallback>デリゲートに応答したり、変更するときに、値を確認します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-221">Instead of adding additional logic to the get and set accessors, use the <xref:System.Windows.ValidateValueCallback>, <xref:System.Windows.CoerceValueCallback>, and <xref:System.Windows.PropertyChangedCallback> delegates to respond to or check the value when it changes.</span></span>  <span data-ttu-id="d55c6-222">これらのコールバックの詳細については、「[依存関係プロパティのコールバックと検証](../../../../docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="d55c6-222">For more information on these callbacks, see [Dependency Property Callbacks and Validation](../../../../docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).</span></span>  
  
-   <span data-ttu-id="d55c6-223">メソッドを定義、<xref:System.Windows.CoerceValueCallback>という`CoerceValue`します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-223">Define a method for the <xref:System.Windows.CoerceValueCallback> named `CoerceValue`.</span></span> <span data-ttu-id="d55c6-224">`CoerceValue` によって、`Value` は `MinValue` 以上で `MaxValue` 以下になります。</span><span class="sxs-lookup"><span data-stu-id="d55c6-224">`CoerceValue` ensures that `Value` is greater or equal to `MinValue` and less than or equal to `MaxValue`.</span></span>  
  
-   <span data-ttu-id="d55c6-225">メソッドを定義、 <xref:System.Windows.PropertyChangedCallback>、名前付き`OnValueChanged`します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-225">Define a method for the <xref:System.Windows.PropertyChangedCallback>, named `OnValueChanged`.</span></span> <span data-ttu-id="d55c6-226">`OnValueChanged` 作成、<xref:System.Windows.RoutedPropertyChangedEventArgs%601>オブジェクトし、発生させる準備、`ValueChanged`ルーティング イベント。</span><span class="sxs-lookup"><span data-stu-id="d55c6-226">`OnValueChanged` creates a <xref:System.Windows.RoutedPropertyChangedEventArgs%601> object and prepares to raise the `ValueChanged` routed event.</span></span> <span data-ttu-id="d55c6-227">ルーティング イベントについては、次のセクションで説明します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-227">Routed events are discussed in the next section.</span></span>  
  
 [!code-csharp[UserControlNumericUpDown#DependencyProperty](../../../../samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDown/CSharp/NumericUpDown.xaml.cs#dependencyproperty)]
 [!code-vb[UserControlNumericUpDown#DependencyProperty](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/UserControlNumericUpDown/visualbasic/numericupdown.xaml.vb#dependencyproperty)]  
  
 <span data-ttu-id="d55c6-228">詳細については、「[カスタム依存関係プロパティ](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="d55c6-228">For more information, see [Custom Dependency Properties](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md).</span></span>  
  
### <a name="use-routed-events"></a><span data-ttu-id="d55c6-229">ルーティング イベントの使用</span><span class="sxs-lookup"><span data-stu-id="d55c6-229">Use Routed Events</span></span>  
 <span data-ttu-id="d55c6-230">依存関係プロパティが [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] プロパティの概念を追加機能によって拡張するのと同様に、ルーティング イベントは、標準の [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] イベントの概念を拡張します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-230">Just as dependency properties extend the notion of [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] properties with additional functionality, routed events extend the notion of standard [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] events.</span></span> <span data-ttu-id="d55c6-231">新しい [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] コントロール作成する場合、イベントをルーティング イベントとして実装することをお勧めします。ルーティング イベントは以下の機能をサポートしているためです。</span><span class="sxs-lookup"><span data-stu-id="d55c6-231">When you create a new [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] control, it is also good practice to implement your event as a routed event because a routed event supports the following behavior:</span></span>  
  
-   <span data-ttu-id="d55c6-232">複数のコントロールの親でイベントを処理できます。</span><span class="sxs-lookup"><span data-stu-id="d55c6-232">Events can be handled on a parent of multiple controls.</span></span> <span data-ttu-id="d55c6-233">イベントがバブル イベントの場合、要素ツリー内の単一の親はイベントをサブスクライブできます。</span><span class="sxs-lookup"><span data-stu-id="d55c6-233">If an event is a bubbling event, a single parent in the element tree can subscribe to the event.</span></span> <span data-ttu-id="d55c6-234">これにより、アプリケーション開発者は、複数のコントロールのイベントに 1 つのハンドラーで対応できます。</span><span class="sxs-lookup"><span data-stu-id="d55c6-234">Then application authors can use one handler to respond to the event of multiple controls.</span></span> <span data-ttu-id="d55c6-235">コントロール内の各項目の一部である場合など、 <xref:System.Windows.Controls.ListBox> (に含まれているため、 <xref:System.Windows.DataTemplate>)、アプリケーション開発者は、コントロールのイベントのイベント ハンドラーを定義できます、<xref:System.Windows.Controls.ListBox>します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-235">For example, if your control is a part of each item in a <xref:System.Windows.Controls.ListBox> (because it is included in a <xref:System.Windows.DataTemplate>), the application developer can define the event handler for your control's event on the <xref:System.Windows.Controls.ListBox>.</span></span> <span data-ttu-id="d55c6-236">いずれかのコントロールでイベントが発生するたびに、そのイベント ハンドラーが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="d55c6-236">Whenever the event occurs on any of the controls, the event handler is called.</span></span>  
  
-   <span data-ttu-id="d55c6-237">ルーティング イベントで使用できる、 <xref:System.Windows.EventSetter>、アプリケーション開発者は、スタイル内のイベントのハンドラーを指定できます。</span><span class="sxs-lookup"><span data-stu-id="d55c6-237">Routed events can be used in an <xref:System.Windows.EventSetter>, which enables application developers to specify the handler of an event within a style.</span></span>  
  
-   <span data-ttu-id="d55c6-238">ルーティング イベントで使用できる、<xref:System.Windows.EventTrigger>を使用してプロパティをアニメーション化するために便利です[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-238">Routed events can be used in an <xref:System.Windows.EventTrigger>, which is useful for animating properties by using [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)].</span></span> <span data-ttu-id="d55c6-239">詳しくは、「 [アニメーションの概要](../../../../docs/framework/wpf/graphics-multimedia/animation-overview.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="d55c6-239">For more information, see [Animation Overview](../../../../docs/framework/wpf/graphics-multimedia/animation-overview.md).</span></span>  
  
 <span data-ttu-id="d55c6-240">次に示す例では、以下の処理を実行して、ルーティング イベントを定義します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-240">The following example defines a routed event by doing the following:</span></span>  
  
-   <span data-ttu-id="d55c6-241">定義、<xref:System.Windows.RoutedEvent>という名前の識別子`ValueChangedEvent`として、 `public` `static` `readonly`フィールド。</span><span class="sxs-lookup"><span data-stu-id="d55c6-241">Define a <xref:System.Windows.RoutedEvent> identifier named `ValueChangedEvent` as a `public` `static` `readonly` field.</span></span>  
  
-   <span data-ttu-id="d55c6-242">呼び出すことによって、ルーティング イベントを登録、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A?displayProperty=nameWithType>メソッド。</span><span class="sxs-lookup"><span data-stu-id="d55c6-242">Register the routed event by calling the <xref:System.Windows.EventManager.RegisterRoutedEvent%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="d55c6-243">呼び出すときに、例を次の情報を指定します<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>:</span><span class="sxs-lookup"><span data-stu-id="d55c6-243">The example specifies the following information when it calls <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>:</span></span>  
  
    -   <span data-ttu-id="d55c6-244">イベントの名前が `ValueChanged` であること。</span><span class="sxs-lookup"><span data-stu-id="d55c6-244">The name of the event is `ValueChanged`.</span></span>  
  
    -   <span data-ttu-id="d55c6-245">ルーティング方法が、<xref:System.Windows.RoutingStrategy.Bubble>ソース (イベントを発生させるオブジェクト) にイベント ハンドラーが最初に、呼び出されることを意味してに、以降の最も近いイベント ハンドラーでソースの親要素のイベント ハンドラーが呼び出されるし、親要素です。</span><span class="sxs-lookup"><span data-stu-id="d55c6-245">The routing strategy is <xref:System.Windows.RoutingStrategy.Bubble>, which means that an event handler on the source (the object that raises the event) is called first, and then event handlers on the source's parent elements are called in succession, starting with the event handler on the closest parent element.</span></span>  
  
    -   <span data-ttu-id="d55c6-246">イベント ハンドラーの型が<xref:System.Windows.RoutedPropertyChangedEventHandler%601>で構築された、<xref:System.Decimal>型。</span><span class="sxs-lookup"><span data-stu-id="d55c6-246">The type of the event handler is <xref:System.Windows.RoutedPropertyChangedEventHandler%601>, constructed with a <xref:System.Decimal> type.</span></span>  
  
    -   <span data-ttu-id="d55c6-247">イベントを所有する型が `NumericUpDown` であること。</span><span class="sxs-lookup"><span data-stu-id="d55c6-247">The owning type of the event is `NumericUpDown`.</span></span>  
  
-   <span data-ttu-id="d55c6-248">`ValueChanged` という名前のパブリック イベントを宣言し、イベント アクセサー宣言を含めます。</span><span class="sxs-lookup"><span data-stu-id="d55c6-248">Declare a public event named `ValueChanged` and includes event-accessor declarations.</span></span> <span data-ttu-id="d55c6-249">例では、<xref:System.Windows.UIElement.AddHandler%2A>で、`add`アクセサーの宣言と<xref:System.Windows.UIElement.RemoveHandler%2A>で、`remove`アクセサーの宣言を使用する、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]イベント サービス。</span><span class="sxs-lookup"><span data-stu-id="d55c6-249">The example calls <xref:System.Windows.UIElement.AddHandler%2A> in the `add` accessor declaration and <xref:System.Windows.UIElement.RemoveHandler%2A> in the `remove` accessor declaration to use the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] event services.</span></span>  
  
-   <span data-ttu-id="d55c6-250">`ValueChanged`イベントを発生させる、保護された仮想メソッド `OnValueChanged` を作成します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-250">Create a protected, virtual method named `OnValueChanged` that raises the `ValueChanged` event.</span></span>  
  
 [!code-csharp[UserControlNumericUpDown#RoutedEvent](../../../../samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDown/CSharp/NumericUpDown.xaml.cs#routedevent)]
 [!code-vb[UserControlNumericUpDown#RoutedEvent](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/UserControlNumericUpDown/visualbasic/numericupdown.xaml.vb#routedevent)]  
  
 <span data-ttu-id="d55c6-251">詳細については、「[ルーティング イベントの概要](../../../../docs/framework/wpf/advanced/routed-events-overview.md)」および「[カスタム ルーティング イベントを作成する](../../../../docs/framework/wpf/advanced/how-to-create-a-custom-routed-event.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="d55c6-251">For more information, see [Routed Events Overview](../../../../docs/framework/wpf/advanced/routed-events-overview.md) and [Create a Custom Routed Event](../../../../docs/framework/wpf/advanced/how-to-create-a-custom-routed-event.md).</span></span>  
  
### <a name="use-binding"></a><span data-ttu-id="d55c6-252">バインディングの使用</span><span class="sxs-lookup"><span data-stu-id="d55c6-252">Use Binding</span></span>  
 <span data-ttu-id="d55c6-253">コントロールの UI とロジックを分離するには、データ バインディングを使用する方法もあります。</span><span class="sxs-lookup"><span data-stu-id="d55c6-253">To decouple the UI of your control from its logic, consider using data binding.</span></span> <span data-ttu-id="d55c6-254">これを使用して、コントロールの外観を定義する場合に特に重要な<xref:System.Windows.Controls.ControlTemplate>します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-254">This is particularly important if you define the appearance of your control by using a <xref:System.Windows.Controls.ControlTemplate>.</span></span> <span data-ttu-id="d55c6-255">データ バインディングを使用すると、コードから UI の特定の部分を参照する必要性がなくなる場合があります。</span><span class="sxs-lookup"><span data-stu-id="d55c6-255">When you use data binding, you might be able to eliminate the need to reference specific parts of the UI from the code.</span></span> <span data-ttu-id="d55c6-256">含まれている要素の参照を回避することをお勧め、<xref:System.Windows.Controls.ControlTemplate>ため、コードが含まれている要素を参照するときに、<xref:System.Windows.Controls.ControlTemplate>と<xref:System.Windows.Controls.ControlTemplate>が変更されると、新しいに含まれる参照先の要素のニーズ<xref:System.Windows.Controls.ControlTemplate>します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-256">It's a good idea to avoid referencing elements that are in the <xref:System.Windows.Controls.ControlTemplate> because when the code references elements that are in the <xref:System.Windows.Controls.ControlTemplate> and the <xref:System.Windows.Controls.ControlTemplate> is changed, the referenced element needs to be included in the new <xref:System.Windows.Controls.ControlTemplate>.</span></span>  
  
 <span data-ttu-id="d55c6-257">次の例の更新プログラム、<xref:System.Windows.Controls.TextBlock>の`NumericUpDown`コントロールにその名前を割り当てると、コード内の名前をテキスト ボックスの参照します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-257">The following example updates the <xref:System.Windows.Controls.TextBlock> of the `NumericUpDown` control, assigning a name to it and referencing the textbox by name in code.</span></span>  
  
 [!code-xaml[UserControlNumericUpDownSimple#UIRefMarkup](../../../../samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDownSimple/CSharp/NumericUpDown.xaml#uirefmarkup)]  
  
 [!code-csharp[UserControlNumericUpDownSimple#UIRefCode](../../../../samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDownSimple/CSharp/NumericUpDown.xaml.cs#uirefcode)]
 [!code-vb[UserControlNumericUpDownSimple#UIRefCode](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/UserControlNumericUpDownSimple/VisualBasic/NumericUpDown.xaml.vb#uirefcode)]  
  
 <span data-ttu-id="d55c6-258">次の例では、バインディングを使用して同じことを実現しています。</span><span class="sxs-lookup"><span data-stu-id="d55c6-258">The following example uses binding to accomplish the same thing.</span></span>  
  
 [!code-xaml[UserControlNumericUpDown#Binding](../../../../samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDown/CSharp/NumericUpDown.xaml#binding)]  
  
 <span data-ttu-id="d55c6-259">データ バインディングの詳細については、「[データ バインディングの概要](../../../../docs/framework/wpf/data/data-binding-overview.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="d55c6-259">For more information about data binding, see [Data Binding Overview](../../../../docs/framework/wpf/data/data-binding-overview.md).</span></span>  
  
### <a name="design-for-designers"></a><span data-ttu-id="d55c6-260">デザイナーに対応したデザイン</span><span class="sxs-lookup"><span data-stu-id="d55c6-260">Design for Designers</span></span>  
 <span data-ttu-id="d55c6-261">[!INCLUDE[wpfdesigner_current_long](../../../../includes/wpfdesigner-current-long-md.md)] でカスタム WPF コントロールのサポート (たとえば、[プロパティ] ウィンドウでのプロパティ編集) を利用するには、以下のガイドラインに従います。</span><span class="sxs-lookup"><span data-stu-id="d55c6-261">To receive support for custom WPF controls in the [!INCLUDE[wpfdesigner_current_long](../../../../includes/wpfdesigner-current-long-md.md)] (for example, property editing with the Properties window), follow these guidelines.</span></span>  <span data-ttu-id="d55c6-262">用の開発の詳細については、[!INCLUDE[wpfdesigner_current_short](../../../../includes/wpfdesigner-current-short-md.md)]を参照してください[Visual Studio で XAML をデザイン](/visualstudio/designers/designing-xaml-in-visual-studio)します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-262">For more information on developing for the [!INCLUDE[wpfdesigner_current_short](../../../../includes/wpfdesigner-current-short-md.md)], see [Design XAML in Visual Studio](/visualstudio/designers/designing-xaml-in-visual-studio).</span></span>  
  
#### <a name="dependency-properties"></a><span data-ttu-id="d55c6-263">依存関係プロパティ</span><span class="sxs-lookup"><span data-stu-id="d55c6-263">Dependency Properties</span></span>  
 <span data-ttu-id="d55c6-264">「依存関係プロパティの使用」で説明したように、[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] の `get` アクセサーと `set` アクセサーを実装します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-264">Be sure to implement [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] `get` and `set` accessors as described earlier, in "Use Dependency Properties."</span></span> <span data-ttu-id="d55c6-265">デザイナーは、ラッパーを使用して依存関係プロパティの存在を検出する場合がありますが、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] およびコントロールのクライアントと同様、プロパティを取得または設定するときにアクセサーを呼び出す必要はありません。</span><span class="sxs-lookup"><span data-stu-id="d55c6-265">Designers may use the wrapper to detect the presence of a dependency property, but they, like [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] and clients of the control, are not required to call the accessors when getting or setting the property.</span></span>  
  
#### <a name="attached-properties"></a><span data-ttu-id="d55c6-266">アタッチされるプロパティ</span><span class="sxs-lookup"><span data-stu-id="d55c6-266">Attached Properties</span></span>  
 <span data-ttu-id="d55c6-267">以下のガイドラインに従って、カスタム コントロールに添付プロパティを実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d55c6-267">You should implement attached properties on custom controls using the following guidelines:</span></span>  
  
-   <span data-ttu-id="d55c6-268">`public` `static` `readonly` <xref:System.Windows.DependencyProperty>フォームの*PropertyName* `Property`を使用して作成された、<xref:System.Windows.DependencyProperty.RegisterAttached%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="d55c6-268">Have a `public` `static` `readonly` <xref:System.Windows.DependencyProperty> of the form *PropertyName*`Property` that was creating using the <xref:System.Windows.DependencyProperty.RegisterAttached%2A> method.</span></span> <span data-ttu-id="d55c6-269">渡されるプロパティ名<xref:System.Windows.DependencyProperty.RegisterAttached%2A>と一致する必要があります*PropertyName*します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-269">The property name that is passed to <xref:System.Windows.DependencyProperty.RegisterAttached%2A> must match *PropertyName*.</span></span>  
  
-   <span data-ttu-id="d55c6-270">`Set` *PropertyName* および `Get` *PropertyName* という名前の `public``static` CLR メソッドのペアを実装します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-270">Implement a pair of `public` `static` CLR methods named `Set`*PropertyName* and `Get`*PropertyName*.</span></span> <span data-ttu-id="d55c6-271">どちらの方法から派生したクラスを受け入れる必要があります<xref:System.Windows.DependencyProperty>最初の引数として。</span><span class="sxs-lookup"><span data-stu-id="d55c6-271">Both methods should accept a class derived from <xref:System.Windows.DependencyProperty> as their first argument.</span></span> <span data-ttu-id="d55c6-272">また、`Set` *PropertyName* メソッドでは、プロパティの登録データ型と同じ型の引数も受け取ります。</span><span class="sxs-lookup"><span data-stu-id="d55c6-272">The `Set`*PropertyName* method also accepts an argument whose type matches the registered data type for the property.</span></span> <span data-ttu-id="d55c6-273">`Get` *PropertyName*メソッドでは、同じ型の値を返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="d55c6-273">The `Get`*PropertyName* method should return a value of the same type.</span></span> <span data-ttu-id="d55c6-274">`Set` *PropertyName*メソッドがない場合、プロパティは読み取り専用としてマークされます。</span><span class="sxs-lookup"><span data-stu-id="d55c6-274">If the `Set`*PropertyName* method is missing, the property is marked read-only.</span></span>  
  
-   <span data-ttu-id="d55c6-275">`Set` *PropertyName*と`Get` *PropertyName*に直接ルーティングする必要があります、<xref:System.Windows.DependencyObject.GetValue%2A>と<xref:System.Windows.DependencyObject.SetValue%2A>オブジェクトのメソッド ターゲット依存関係に、それぞれします。</span><span class="sxs-lookup"><span data-stu-id="d55c6-275">`Set` *PropertyName* and `Get`*PropertyName* must route directly to the <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> methods on the target dependency object, respectively.</span></span> <span data-ttu-id="d55c6-276">デザイナーが添付プロパティにアクセスするには、メソッド ラッパー経由で呼び出す場合もあれば、対象の依存関係オブジェクトを直接呼び出す場合もあります。</span><span class="sxs-lookup"><span data-stu-id="d55c6-276">Designers may access the attached property by calling through the method wrapper or making a direct call to the target dependency object.</span></span>  
  
 <span data-ttu-id="d55c6-277">添付プロパティの詳細については、「[添付プロパティの概要](../../../../docs/framework/wpf/advanced/attached-properties-overview.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="d55c6-277">For more information on attached properties, see [Attached Properties Overview](../../../../docs/framework/wpf/advanced/attached-properties-overview.md).</span></span>  
  
### <a name="define-and-use-shared-resources"></a><span data-ttu-id="d55c6-278">共有リソースの定義と使用</span><span class="sxs-lookup"><span data-stu-id="d55c6-278">Define and Use Shared Resources</span></span>  
 <span data-ttu-id="d55c6-279">アプリケーションと同じアセンブリにコントロールを含めることも、複数のアプリケーションが使用できる別のアセンブリにコントロールをパッケージ化することもできます。</span><span class="sxs-lookup"><span data-stu-id="d55c6-279">You can include your control in the same assembly as your application, or you can package your control in a separate assembly that can be used in multiple applications.</span></span> <span data-ttu-id="d55c6-280">このトピックで説明した情報の大部分は、使用する方法に関係なく適用されます。</span><span class="sxs-lookup"><span data-stu-id="d55c6-280">For the most part, the information discussed in this topic applies regardless of the method you use.</span></span>  <span data-ttu-id="d55c6-281">ただし、1 つだけ例外があります。</span><span class="sxs-lookup"><span data-stu-id="d55c6-281">There is one difference worth noting, however.</span></span>  <span data-ttu-id="d55c6-282">アプリケーションと同じアセンブリ内にコントロールを配置する場合、App.xaml ファイルにグローバル リソースを自由に追加できます。</span><span class="sxs-lookup"><span data-stu-id="d55c6-282">When you put a control in the same assembly as an application, you are free to add global resources to the App.xaml file.</span></span> <span data-ttu-id="d55c6-283">コントロールのみを格納するアセンブリはありませんが、 <xref:System.Windows.Application> App.xaml ファイルが使用できないために、それに関連付けられたオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="d55c6-283">But an assembly that contains only controls does not have an <xref:System.Windows.Application> object associated with it, so an App.xaml file is not available.</span></span>  
  
 <span data-ttu-id="d55c6-284">アプリケーションがリソースを検索するときは、次に示す順序で 3 つのレベルを検索します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-284">When an application looks for a resource, it looks at three levels in the following order:</span></span>  
  
1.  <span data-ttu-id="d55c6-285">要素レベル。</span><span class="sxs-lookup"><span data-stu-id="d55c6-285">The element level.</span></span>  
  
     <span data-ttu-id="d55c6-286">システムは、リソースを参照する要素から検索を開始し、ルート要素に到達するまで、論理上の親のリソースの検索を継続します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-286">The system starts with the element that references the resource and then searches resources of the logical parent and so forth until the root element is reached.</span></span>  
  
2.  <span data-ttu-id="d55c6-287">アプリケーション レベル。</span><span class="sxs-lookup"><span data-stu-id="d55c6-287">The application level.</span></span>  
  
     <span data-ttu-id="d55c6-288">定義されたリソース、<xref:System.Windows.Application>オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="d55c6-288">Resources defined by the <xref:System.Windows.Application> object.</span></span>  
  
3.  <span data-ttu-id="d55c6-289">テーマ レベル。</span><span class="sxs-lookup"><span data-stu-id="d55c6-289">The theme level.</span></span>  
  
     <span data-ttu-id="d55c6-290">テーマ レベルのディクショナリは、Themes という名前のサブフォルダーに格納されています。</span><span class="sxs-lookup"><span data-stu-id="d55c6-290">Theme-level dictionaries are stored in a subfolder named Themes.</span></span>  <span data-ttu-id="d55c6-291">Themes フォルダー内のファイルはテーマに対応しています。</span><span class="sxs-lookup"><span data-stu-id="d55c6-291">The files in the Themes folder correspond to themes.</span></span>  <span data-ttu-id="d55c6-292">たとえば、Aero.NormalColor.xaml、Luna.NormalColor.xaml、Royale.NormalColor.xaml などのファイルがあります。</span><span class="sxs-lookup"><span data-stu-id="d55c6-292">For example, you might have Aero.NormalColor.xaml, Luna.NormalColor.xaml, Royale.NormalColor.xaml, and so on.</span></span>  <span data-ttu-id="d55c6-293">generic.xaml という名前のファイルが含まれている場合もあります。</span><span class="sxs-lookup"><span data-stu-id="d55c6-293">You can also have a file named generic.xaml.</span></span>  <span data-ttu-id="d55c6-294">システムがテーマ レベルでリソースを検索するとき、最初にテーマ固有のファイル内を検索し、次に generic.xaml 内を検索します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-294">When the system looks for a resource at the themes level, it first looks for it in the theme-specific file and then looks for it in generic.xaml.</span></span>  
  
 <span data-ttu-id="d55c6-295">アプリケーションとは別のアセンブリ内にコントロールを含めるときは、グローバル リソースを要素レベルまたはテーマ レベルに配置する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d55c6-295">When your control is in an assembly that is separate from the application, you must put your global resources at the element level or at the theme level.</span></span> <span data-ttu-id="d55c6-296">どちらに配置する場合も、それぞれの利点があります。</span><span class="sxs-lookup"><span data-stu-id="d55c6-296">Both methods have their advantages.</span></span>  
  
#### <a name="defining-resources-at-the-element-level"></a><span data-ttu-id="d55c6-297">要素レベルでのリソース定義</span><span class="sxs-lookup"><span data-stu-id="d55c6-297">Defining Resources at the Element Level</span></span>  
 <span data-ttu-id="d55c6-298">カスタムのリソース ディクショナリを作成し、それをコントロールのリソース ディクショナリと結合することによって、共有リソースを要素レベルで定義できます。</span><span class="sxs-lookup"><span data-stu-id="d55c6-298">You can define shared resources at the element level by creating a custom resource dictionary and merging it with your control’s resource dictionary.</span></span>  <span data-ttu-id="d55c6-299">このメソッドで定義する場合は、リソース ファイルに任意の名前を付けて、コントロールと同じフォルダーに配置できます。</span><span class="sxs-lookup"><span data-stu-id="d55c6-299">When you use this method, you can name your resource file anything you want, and it can be in the same folder as your controls.</span></span> <span data-ttu-id="d55c6-300">要素レベルでのリソースでは、単純な文字列をキーとして使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="d55c6-300">Resources at the element level can also use simple strings as keys.</span></span> <span data-ttu-id="d55c6-301">次の例では、作成、 <xref:System.Windows.Media.LinearGradientBrush> Dictionary1.xaml という名前のリソース ファイル。</span><span class="sxs-lookup"><span data-stu-id="d55c6-301">The following example creates a <xref:System.Windows.Media.LinearGradientBrush> resource file named Dictionary1.xaml.</span></span>  
  
 [!code-xaml[SharedResources#1](../../../../samples/snippets/csharp/VS_Snippets_Wpf/SharedResources/CS/Dictionary1.xaml#1)]  
  
 <span data-ttu-id="d55c6-302">ディクショナリを定義したら、それをコントロールのリソース ディクショナリにマージする必要があります。</span><span class="sxs-lookup"><span data-stu-id="d55c6-302">Once you have defined your dictionary, you need to merge it with your control's resource dictionary.</span></span>  <span data-ttu-id="d55c6-303">これには、[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] またはコードを使用します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-303">You can do this by using [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] or code.</span></span>  
  
 <span data-ttu-id="d55c6-304">次の例では、[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] を使用してリソース ディクショナリを結合します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-304">The following example merges a resource dictionary by using [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 [!code-xaml[SharedResources#2](../../../../samples/snippets/csharp/VS_Snippets_Wpf/SharedResources/CS/ShapeResizer.xaml#2)]  
  
 <span data-ttu-id="d55c6-305">このアプローチの欠点は、<xref:System.Windows.ResourceDictionary>オブジェクトが参照するたびに作成します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-305">The disadvantage to this approach is that a <xref:System.Windows.ResourceDictionary> object is created each time you reference it.</span></span>  <span data-ttu-id="d55c6-306">たとえば、10 個のカスタム コントロールをライブラリにある XAML を使用して各コントロールの共有リソース ディクショナリをマージして場合を作成する 10 同一<xref:System.Windows.ResourceDictionary>オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="d55c6-306">For example, if you have 10 custom controls in your library and merge the shared resource dictionaries for each control by using XAML, you create 10 identical <xref:System.Windows.ResourceDictionary> objects.</span></span>  <span data-ttu-id="d55c6-307">コード内でリソースをマージし、その結果を取得する静的クラスを作成してこれを回避する<xref:System.Windows.ResourceDictionary>します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-307">You can avoid this by creating a static class that merges the resources in code and returns the resulting <xref:System.Windows.ResourceDictionary>.</span></span>  
  
 <span data-ttu-id="d55c6-308">次の例は、共有を表すクラスを作成します。<xref:System.Windows.ResourceDictionary>します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-308">The following example creates a class that returns a shared <xref:System.Windows.ResourceDictionary>.</span></span>  
  
 [!code-csharp[SharedResources#3](../../../../samples/snippets/csharp/VS_Snippets_Wpf/SharedResources/CS/SharedDictionaryManager.cs#3)]  
  
 <span data-ttu-id="d55c6-309">次の例では、`InitializeComponent` を呼び出す前に、共有リソースをコントロールのコンス トラクター内でカスタム コントロールのリソースと結合します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-309">The following example merges the shared resource with the resources of a custom control in the control's constructor before it calls `InitializeComponent`.</span></span>  <span data-ttu-id="d55c6-310">`SharedDictionaryManager.SharedDictionary`は静的なプロパティ、 <xref:System.Windows.ResourceDictionary> 1 回だけ作成されます。</span><span class="sxs-lookup"><span data-stu-id="d55c6-310">Because the `SharedDictionaryManager.SharedDictionary` is a static property, the <xref:System.Windows.ResourceDictionary> is created only once.</span></span> <span data-ttu-id="d55c6-311">`InitializeComponent` が呼び出される前に、リソース ディクショナリが結合されため、コントロールは [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] ファイル内でリソースを使用できます。</span><span class="sxs-lookup"><span data-stu-id="d55c6-311">Because the resource dictionary was merged before `InitializeComponent` was called, the resources are available to the control in its [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] file.</span></span>  
  
 [!code-csharp[SharedResources#4](../../../../samples/snippets/csharp/VS_Snippets_Wpf/SharedResources/CS/ShapeResizer.xaml.cs#4)]  
  
#### <a name="defining-resources-at-the-theme-level"></a><span data-ttu-id="d55c6-312">テーマ レベルでのリソース定義</span><span class="sxs-lookup"><span data-stu-id="d55c6-312">Defining Resources at the Theme Level</span></span>  
 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="d55c6-313"> では、さまざまな Windows テーマ用にリソースを作成できます。</span><span class="sxs-lookup"><span data-stu-id="d55c6-313"> enables you to create resources for different Windows themes.</span></span>  <span data-ttu-id="d55c6-314">コントロールの作成者は、特定のテーマ用のリソースを定義して、使用するテーマに応じてコントロールの外観を変更できます。</span><span class="sxs-lookup"><span data-stu-id="d55c6-314">As a control author, you can define a resource for a specific theme to change your control's appearance depending on what theme is in use.</span></span> <span data-ttu-id="d55c6-315">外観など、 <xref:System.Windows.Controls.Button> Windows クラシックのテーマ (Windows 2000 の既定のテーマ) とは異なります、 <xref:System.Windows.Controls.Button> Windows Luna テーマ (Windows XP の既定のテーマ) のため、<xref:System.Windows.Controls.Button>別使用<xref:System.Windows.Controls.ControlTemplate>各テーマ。</span><span class="sxs-lookup"><span data-stu-id="d55c6-315">For example, the appearance of a <xref:System.Windows.Controls.Button> in the Windows Classic theme (the default theme for Windows 2000) differs from a <xref:System.Windows.Controls.Button> in the Windows Luna theme (the default theme for Windows XP) because the <xref:System.Windows.Controls.Button> uses a different <xref:System.Windows.Controls.ControlTemplate> for each theme.</span></span>  
  
 <span data-ttu-id="d55c6-316">テーマ固有のリソースは、固有のファイル名でリソース ディクショナリに保持されます。</span><span class="sxs-lookup"><span data-stu-id="d55c6-316">Resources that are specific to a theme are kept in a resource dictionary with a specific file name.</span></span> <span data-ttu-id="d55c6-317">これらのファイルは、コントロールが格納されているフォルダーのサブフォルダーである `Themes` フォルダー内に配置する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d55c6-317">These files must be in a folder named `Themes` that is a subfolder of the folder that contains the control.</span></span> <span data-ttu-id="d55c6-318">次の表は、リソース ディクショナリ ファイルと、各ファイルに関連付けられているテーマを示しています。</span><span class="sxs-lookup"><span data-stu-id="d55c6-318">The following table lists the resource dictionary files and the theme that is associated with each file:</span></span>  
  
|<span data-ttu-id="d55c6-319">リソース ディクショナリ ファイル名</span><span class="sxs-lookup"><span data-stu-id="d55c6-319">Resource dictionary file name</span></span>|<span data-ttu-id="d55c6-320">Windows テーマ</span><span class="sxs-lookup"><span data-stu-id="d55c6-320">Windows theme</span></span>|  
|-----------------------------------|-------------------|  
|`Classic.xaml`|<span data-ttu-id="d55c6-321">Windows XP のクラシックな Windows 9x/2000 の外観</span><span class="sxs-lookup"><span data-stu-id="d55c6-321">Classic Windows 9x/2000 look on Windows XP</span></span>|  
|`Luna.NormalColor.xaml`|<span data-ttu-id="d55c6-322">Windows XP の既定の青のテーマ</span><span class="sxs-lookup"><span data-stu-id="d55c6-322">Default blue theme on Windows XP</span></span>|  
|`Luna.Homestead.xaml`|<span data-ttu-id="d55c6-323">Windows XP のオリーブのテーマ</span><span class="sxs-lookup"><span data-stu-id="d55c6-323">Olive theme on Windows XP</span></span>|  
|`Luna.Metallic.xaml`|<span data-ttu-id="d55c6-324">Windows XP のシルバーのテーマ</span><span class="sxs-lookup"><span data-stu-id="d55c6-324">Silver theme on Windows XP</span></span>|  
|`Royale.NormalColor.xaml`|<span data-ttu-id="d55c6-325">Windows XP Media Center Edition の既定テーマ</span><span class="sxs-lookup"><span data-stu-id="d55c6-325">Default theme on Windows XP Media Center Edition</span></span>|  
|`Aero.NormalColor.xaml`|<span data-ttu-id="d55c6-326">Windows Vista の既定テーマ</span><span class="sxs-lookup"><span data-stu-id="d55c6-326">Default theme on Windows Vista</span></span>|  
  
 <span data-ttu-id="d55c6-327">すべてのテーマのリソースを定義する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="d55c6-327">You do not need to define a resource for every theme.</span></span> <span data-ttu-id="d55c6-328">特定のテーマについてリソースが定義されていない場合、コントロールはリソースの `Classic.xaml` を確認します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-328">If a resource is not defined for a specific theme, then the control checks `Classic.xaml` for the resource.</span></span> <span data-ttu-id="d55c6-329">現在のテーマに対応するファイルや `Classic.xaml` でリソースが定義されていない場合、コントロールは汎用のリソースを使用します。汎用のリソースは、`generic.xaml` という名前のリソース ディクショナリ ファイルにあります。</span><span class="sxs-lookup"><span data-stu-id="d55c6-329">If the resource is not defined in the file that corresponds to the current theme or in `Classic.xaml`, the control uses the generic resource, which is in a resource dictionary file named `generic.xaml`.</span></span>  <span data-ttu-id="d55c6-330">`generic.xaml` ファイルは、テーマ固有のリソース ディクショナリ ファイルと同じフォルダーに配置されています。</span><span class="sxs-lookup"><span data-stu-id="d55c6-330">The `generic.xaml` file is located in the same folder as the theme-specific resource dictionary files.</span></span> <span data-ttu-id="d55c6-331">`generic.xaml` は、特定の Windows テーマには対応していませんが、テーマ レベルのディクショナリであることに変わりありません。</span><span class="sxs-lookup"><span data-stu-id="d55c6-331">Although `generic.xaml` does not correspond to a specific Windows theme, it is still a theme-level dictionary.</span></span>  
  
 <span data-ttu-id="d55c6-332">[テーマおよび UI オートメーションがサポートされた NumericUpDown カスタム コントロールのサンプル](https://go.microsoft.com/fwlink/?LinkID=160025)には、`NumericUpDown` コントロール用の 2 つのリソース ディクショナリが含まれています。1 つは generic.xaml で、もう 1 つは Luna.NormalColor.xaml です。</span><span class="sxs-lookup"><span data-stu-id="d55c6-332">[NumericUpDown Custom Control with Theme and UI Automation Support Sample](https://go.microsoft.com/fwlink/?LinkID=160025) contains two resource dictionaries for the `NumericUpDown` control: one is in generic.xaml and one is in Luna.NormalColor.xaml.</span></span>  <span data-ttu-id="d55c6-333">アプリケーションを実行し、Windows XP のシルバーのテーマと別のテーマを切り替えて、2 つのコントロール テンプレートの違いを確認できます。</span><span class="sxs-lookup"><span data-stu-id="d55c6-333">You can run the application and switch between the Silver theme in Windows XP and another theme to see the difference between the two control templates.</span></span> <span data-ttu-id="d55c6-334">(Windows Vista を使用している場合は、Luna.NormalColor.xaml を Aero.NormalColor.xaml という名前に変更し、Windows クラシック テーマと Windows Vista の既定のテーマなど、2 つのテーマを切り替えることができます)。</span><span class="sxs-lookup"><span data-stu-id="d55c6-334">(If you are running Windows Vista, you can rename Luna.NormalColor.xaml to Aero.NormalColor.xaml and switch between two themes, such as Windows Classic and the default theme for Windows Vista.)</span></span>  
  
 <span data-ttu-id="d55c6-335">配置すると、 <xref:System.Windows.Controls.ControlTemplate> 、テーマ固有のリソース ディクショナリ ファイルのいずれのコントロールと呼び出しの静的コンス トラクターを作成する必要があります、<xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>メソッドを<xref:System.Windows.FrameworkElement.DefaultStyleKey%2A>次の例のようにします。</span><span class="sxs-lookup"><span data-stu-id="d55c6-335">When you put a <xref:System.Windows.Controls.ControlTemplate> in any of the theme-specific resource dictionary files, you must create a static constructor for your control and call the <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29> method on the <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A>, as shown in the following example.</span></span>  
  
 [!code-csharp[CustomControlNumericUpDownOneProject#StaticConstructor](../../../../samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDownOneProject/CSharp/NumericUpDown.cs#staticconstructor)]
 [!code-vb[CustomControlNumericUpDownOneProject#StaticConstructor](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDownOneProject/visualbasic/numericupdown.vb#staticconstructor)]  
  
##### <a name="defining-and-referencing-keys-for-theme-resources"></a><span data-ttu-id="d55c6-336">テーマ リソース用のキーの定義と参照</span><span class="sxs-lookup"><span data-stu-id="d55c6-336">Defining and Referencing Keys for Theme Resources</span></span>  
 <span data-ttu-id="d55c6-337">要素レベルでリソースを定義するときに、文字列をキーとして割り当て、その文字列を使用してリソースにアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="d55c6-337">When you define a resource at the element level, you can assign a string as its key and access the resource via the string.</span></span> <span data-ttu-id="d55c6-338">テーマ レベルのリソースを定義する場合は、使用、<xref:System.Windows.ComponentResourceKey>キーとして。</span><span class="sxs-lookup"><span data-stu-id="d55c6-338">When you define a resource at the theme level, you must use a <xref:System.Windows.ComponentResourceKey> as the key.</span></span>  <span data-ttu-id="d55c6-339">次の例では、generic.xaml でリソースを定義します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-339">The following example defines a resource in generic.xaml.</span></span>  
  
 [!code-xaml[ThemeResourcesControlLibrary#5](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThemeResourcesControlLibrary/CS/Themes/generic.xaml#5)]  
  
 <span data-ttu-id="d55c6-340">次の例は、指定することで、リソースを参照、<xref:System.Windows.ComponentResourceKey>キーとして。</span><span class="sxs-lookup"><span data-stu-id="d55c6-340">The following example references the resource by specifying the <xref:System.Windows.ComponentResourceKey> as the key.</span></span>  
  
 [!code-xaml[ThemeResourcesControlLibrary#6](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThemeResourcesControlLibrary/CS/NumericUpDown.xaml#6)]  
  
##### <a name="specifying-the-location-of-theme-resources"></a><span data-ttu-id="d55c6-341">テーマ リソースの場所の指定</span><span class="sxs-lookup"><span data-stu-id="d55c6-341">Specifying the Location of Theme Resources</span></span>  
 <span data-ttu-id="d55c6-342">コントロールのリソースを見つけるには、アセンブリにコントロール固有のリソースが含まれていることを、ホスト アプリケーションが認識する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d55c6-342">To find the resources for a control, the hosting application needs to know that the assembly contains control-specific resources.</span></span> <span data-ttu-id="d55c6-343">ことを追加することで実現できる、<xref:System.Windows.ThemeInfoAttribute>コントロールを格納するアセンブリ。</span><span class="sxs-lookup"><span data-stu-id="d55c6-343">You can accomplish that by adding the <xref:System.Windows.ThemeInfoAttribute> to the assembly that contains the control.</span></span> <span data-ttu-id="d55c6-344"><xref:System.Windows.ThemeInfoAttribute>が、<xref:System.Windows.ThemeInfoAttribute.GenericDictionaryLocation%2A>汎用のリソースの場所を指定するプロパティと<xref:System.Windows.ThemeInfoAttribute.ThemeDictionaryLocation%2A>テーマ固有のリソースの場所を指定するプロパティ。</span><span class="sxs-lookup"><span data-stu-id="d55c6-344">The <xref:System.Windows.ThemeInfoAttribute> has a <xref:System.Windows.ThemeInfoAttribute.GenericDictionaryLocation%2A> property that specifies the location of generic resources, and a <xref:System.Windows.ThemeInfoAttribute.ThemeDictionaryLocation%2A> property that specifies the location of the theme-specific resources.</span></span>  
  
 <span data-ttu-id="d55c6-345">次の例のセット、<xref:System.Windows.ThemeInfoAttribute.GenericDictionaryLocation%2A>と<xref:System.Windows.ThemeInfoAttribute.ThemeDictionaryLocation%2A>プロパティを<xref:System.Windows.ResourceDictionaryLocation.SourceAssembly>ジェネリックとテーマ固有のリソースは、コントロールと同じアセンブリに指定します。</span><span class="sxs-lookup"><span data-stu-id="d55c6-345">The following example sets the <xref:System.Windows.ThemeInfoAttribute.GenericDictionaryLocation%2A> and <xref:System.Windows.ThemeInfoAttribute.ThemeDictionaryLocation%2A> properties to <xref:System.Windows.ResourceDictionaryLocation.SourceAssembly>, to specify that the generic and theme-specific resources are in the same assembly as the control.</span></span>  
  
 [!code-csharp[CustomControlNumericUpDown#ThemesSection](../../../../samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDown/CSharp/CustomControlLibrary/Properties/AssemblyInfo.cs#themessection)]
 [!code-vb[CustomControlNumericUpDown#ThemesSection](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDown/visualbasic/customcontrollibrary/my project/assemblyinfo.vb#themessection)]  
  
## <a name="see-also"></a><span data-ttu-id="d55c6-346">関連項目</span><span class="sxs-lookup"><span data-stu-id="d55c6-346">See Also</span></span>  
 [<span data-ttu-id="d55c6-347">Visual Studio で XAML をデザインする</span><span class="sxs-lookup"><span data-stu-id="d55c6-347">Design XAML in Visual Studio</span></span>](/visualstudio/designers/designing-xaml-in-visual-studio)  
 [<span data-ttu-id="d55c6-348">WPF におけるパッケージの URI</span><span class="sxs-lookup"><span data-stu-id="d55c6-348">Pack URIs in WPF</span></span>](../../../../docs/framework/wpf/app-development/pack-uris-in-wpf.md)  
 [<span data-ttu-id="d55c6-349">コントロールのカスタマイズ</span><span class="sxs-lookup"><span data-stu-id="d55c6-349">Control Customization</span></span>](../../../../docs/framework/wpf/controls/control-customization.md)
