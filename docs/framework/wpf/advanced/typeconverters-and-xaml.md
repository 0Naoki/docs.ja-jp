---
title: "TypeConverters および XAML"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-wpf
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords: XAML [WPF], TypeConverter class
ms.assetid: f6313e4d-e89d-497d-ac87-b43511a1ae4b
caps.latest.revision: "13"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.workload: dotnet
ms.openlocfilehash: 1b7ee4b3b00a675cfafc884d41079b76656bdf49
ms.sourcegitcommit: 16186c34a957fdd52e5db7294f291f7530ac9d24
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/22/2017
---
# <a name="typeconverters-and-xaml"></a><span data-ttu-id="53e7e-102">TypeConverters および XAML</span><span class="sxs-lookup"><span data-stu-id="53e7e-102">TypeConverters and XAML</span></span>
<span data-ttu-id="53e7e-103">このトピックでは、一般的な XAML 言語機能として、文字列からの型変換の目的について説明します。</span><span class="sxs-lookup"><span data-stu-id="53e7e-103">This topic introduces the purpose of type conversion from string as a general XAML language feature.</span></span> <span data-ttu-id="53e7e-104">.NET Framework で、<xref:System.ComponentModel.TypeConverter>クラスは、特定の目的を XAML 属性の使用方法のプロパティ値として使用できる管理対象のカスタム クラスの実装の一部として機能します。</span><span class="sxs-lookup"><span data-stu-id="53e7e-104">In the .NET Framework, the <xref:System.ComponentModel.TypeConverter> class serves a particular purpose as part of the implementation for a managed custom class that can be used as a property value in XAML attribute usage.</span></span> <span data-ttu-id="53e7e-105">場合は、カスタム クラスを記述する、XAML 設定可能な属性値として使用できるようにするのには、クラスのインスタンスは、適用する必要があります、 <xref:System.ComponentModel.TypeConverterAttribute> 、クラスに記述するカスタム<xref:System.ComponentModel.TypeConverter>クラス、またはその両方です。</span><span class="sxs-lookup"><span data-stu-id="53e7e-105">If you write a custom class, and you want instances of your class to be usable as XAML settable attribute values, you might need to apply a <xref:System.ComponentModel.TypeConverterAttribute> to your class, write a custom <xref:System.ComponentModel.TypeConverter> class, or both.</span></span>  
  

  
## <a name="type-conversion-concepts"></a><span data-ttu-id="53e7e-106">型変換の概念</span><span class="sxs-lookup"><span data-stu-id="53e7e-106">Type Conversion Concepts</span></span>  
  
### <a name="xaml-and-string-values"></a><span data-ttu-id="53e7e-107">XAML と文字列値</span><span class="sxs-lookup"><span data-stu-id="53e7e-107">XAML and String Values</span></span>  
 <span data-ttu-id="53e7e-108">XAML ファイルで属性値を設定する場合は、その値の最初の型では、文字列が純粋なテキストです。</span><span class="sxs-lookup"><span data-stu-id="53e7e-108">When you set an attribute value in a XAML file, the initial type of that value is a string in pure text.</span></span> <span data-ttu-id="53e7e-109">など、他のプリミティブ<xref:System.Double>最初は、XAML プロセッサに対してテキスト文字列です。</span><span class="sxs-lookup"><span data-stu-id="53e7e-109">Even other primitives such as <xref:System.Double> are initially text strings to a XAML processor.</span></span>  
  
 <span data-ttu-id="53e7e-110">XAML プロセッサでは、属性値を処理するために 2 つの情報が必要です。</span><span class="sxs-lookup"><span data-stu-id="53e7e-110">A XAML processor needs two pieces of information in order to process an attribute value.</span></span> <span data-ttu-id="53e7e-111">第 1 の情報は、設定しようとしているプロパティの値の型です。</span><span class="sxs-lookup"><span data-stu-id="53e7e-111">The first piece of information is the value type of the property that is being set.</span></span> <span data-ttu-id="53e7e-112">属性値を定義するすべての文字列は、XAML で処理され、最終的にはその型の値に変換 (解決) される必要があります。</span><span class="sxs-lookup"><span data-stu-id="53e7e-112">Any string that defines an attribute value and that is processed in XAML must ultimately be converted or resolved to a value of that type.</span></span> <span data-ttu-id="53e7e-113">値が、XAML パーサーで認識できるプリミティブ (数値など) である場合は、文字列の直接的な変換が試みられます。</span><span class="sxs-lookup"><span data-stu-id="53e7e-113">If the value is a primitive that is understood by the XAML parser (such as a numeric value), a direct conversion of the string is attempted.</span></span> <span data-ttu-id="53e7e-114">値は、列挙体は、その列挙体の名前付き定数に一致する名前を確認する文字列が使用されます。</span><span class="sxs-lookup"><span data-stu-id="53e7e-114">If the value is an enumeration, the string is used to check for a name match to a named constant in that enumeration.</span></span> <span data-ttu-id="53e7e-115">値がないパーサーで認識されるプリミティブも、列挙型、該当するタイプの場合は、型、または変換後の文字列に基づいて、値のインスタンスを提供できる必要があります。</span><span class="sxs-lookup"><span data-stu-id="53e7e-115">If the value is neither a parser-understood primitive nor an enumeration, then the type in question must be able to provide an instance of the type, or a value, based on a converted string.</span></span> <span data-ttu-id="53e7e-116">これは、型コンバーター クラスを示すことによって行います。</span><span class="sxs-lookup"><span data-stu-id="53e7e-116">This is done by indicating a type converter class.</span></span> <span data-ttu-id="53e7e-117">型コンバーターは、事実上、コードが .NET コードの呼び出しを別のクラスの XAML シナリオやも可能性がある値を提供するためのヘルパー クラスです。</span><span class="sxs-lookup"><span data-stu-id="53e7e-117">The type converter is effectively a helper class for providing values of another class, both for the XAML scenario and also potentially for code calls in .NET code.</span></span>  
  
### <a name="using-existing-type-conversion-behavior-in-xaml"></a><span data-ttu-id="53e7e-118">XAML で既存の型変換動作を使用してください。</span><span class="sxs-lookup"><span data-stu-id="53e7e-118">Using Existing Type Conversion Behavior in XAML</span></span>  
 <span data-ttu-id="53e7e-119">XAML の基礎概念に関する知識、に応じてする可能性があるで既に使用して型変換動作基本的なアプリケーションの XAML 気付かないうちにします。</span><span class="sxs-lookup"><span data-stu-id="53e7e-119">Depending on your familiarity with the underlying XAML concepts, you may already be using type conversion behavior in basic application XAML without realizing it.</span></span> <span data-ttu-id="53e7e-120">WPF が文字どおり数百台の型の値を使用するプロパティを定義するインスタンスの<xref:System.Windows.Point>します。</span><span class="sxs-lookup"><span data-stu-id="53e7e-120">For instance, WPF defines literally hundreds of properties that take a value of type <xref:System.Windows.Point>.</span></span> <span data-ttu-id="53e7e-121">A <xref:System.Windows.Point> 2 次元の座標空間内の座標を記述する値は、次の 2 つの重要なプロパティが実際には:<xref:System.Windows.Point.X%2A>と<xref:System.Windows.Point.Y%2A>です。</span><span class="sxs-lookup"><span data-stu-id="53e7e-121">A <xref:System.Windows.Point> is a value that describes a coordinate in a two-dimensional coordinate space, and it really just has two important properties: <xref:System.Windows.Point.X%2A> and <xref:System.Windows.Point.Y%2A>.</span></span> <span data-ttu-id="53e7e-122">XAML 内のポイントを指定する場合として指定する string 区切り記号 (コンマ) との間、<xref:System.Windows.Point.X%2A>と<xref:System.Windows.Point.Y%2A>に指定する値。</span><span class="sxs-lookup"><span data-stu-id="53e7e-122">When you specify a point in XAML, you specify it as a string with a delimiter (typically a comma) between the <xref:System.Windows.Point.X%2A> and <xref:System.Windows.Point.Y%2A> values you provide.</span></span> <span data-ttu-id="53e7e-123">たとえば、`<LinearGradientBrush StartPoint="0,0" EndPoint="1,1">` のように指定します。</span><span class="sxs-lookup"><span data-stu-id="53e7e-123">For example: `<LinearGradientBrush StartPoint="0,0" EndPoint="1,1">`.</span></span>  
  
 <span data-ttu-id="53e7e-124">この単純型のでも<xref:System.Windows.Point>XAML における単純な使用法が型コンバーターを必要とします。</span><span class="sxs-lookup"><span data-stu-id="53e7e-124">Even this simple type of <xref:System.Windows.Point> and its simple usage in XAML involve a type converter.</span></span> <span data-ttu-id="53e7e-125">ここでは、クラス<xref:System.Windows.PointConverter>です。</span><span class="sxs-lookup"><span data-stu-id="53e7e-125">In this case that is the class <xref:System.Windows.PointConverter>.</span></span>  
  
 <span data-ttu-id="53e7e-126">型コンバーター<xref:System.Windows.Point>マークアップの使用のすべてのプロパティをクラス レベルの効率化で定義されている<xref:System.Windows.Point>です。</span><span class="sxs-lookup"><span data-stu-id="53e7e-126">The type converter for <xref:System.Windows.Point> defined at the class level streamlines the markup usages of all properties that take <xref:System.Windows.Point>.</span></span> <span data-ttu-id="53e7e-127">型コンバーター、せずが必要になります次ずっと詳細なマークアップ前に示した例。</span><span class="sxs-lookup"><span data-stu-id="53e7e-127">Without a type converter here, you would need the following much more verbose markup for the same example shown previously:</span></span>  
  
 `<LinearGradientBrush>`  
  
 `<LinearGradientBrush.StartPoint>`  
  
 `<Point X="0" Y="0"/>`  
  
 `</LinearGradientBrush.StartPoint>`  
  
 `<LinearGradientBrush.EndPoint>`  
  
 `<Point X="1" Y="1"/>`  
  
 `</LinearGradientBrush.EndPoint>`  
  
 `<LinearGradientBrush>`  
  
 <span data-ttu-id="53e7e-128">文字列型変換または同等の構文をさらに詳細を使用するかどうかは、一般に、コーディング スタイル選択です。</span><span class="sxs-lookup"><span data-stu-id="53e7e-128">Whether to use the type conversion string or a more verbose equivalent syntax is generally a coding style choice.</span></span> <span data-ttu-id="53e7e-129">XAML ツールのワークフローが値の設定方法に影響を与える可能性があります。</span><span class="sxs-lookup"><span data-stu-id="53e7e-129">Your XAML tooling workflow might also influence how values are set.</span></span> <span data-ttu-id="53e7e-130">一部の XAML ツールは、デザイナー ビューまたは独自のシリアル化メカニズムへのラウンド トリップを簡単になっているために、最も詳細形式のマークアップを生成する傾向があります。</span><span class="sxs-lookup"><span data-stu-id="53e7e-130">Some XAML tools tend to emit the most verbose form of the markup because it is easier to round-trip to designer views or its own serialization mechanism.</span></span>  
  
 <span data-ttu-id="53e7e-131">既存の型コンバーターは通常、クラス (またはプロパティ) を適用の有無をチェック WPF と .NET Framework の型で検出された<xref:System.ComponentModel.TypeConverterAttribute>です。</span><span class="sxs-lookup"><span data-stu-id="53e7e-131">Existing type converters can generally be discovered on WPF and .NET Framework types by checking a class (or property) for the presence of an applied <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="53e7e-132">この属性はその型は、XAML の目的でだけでなく可能性のあるその他の目的の値がサポートする型コンバーターは、クラスに名前を付けます。</span><span class="sxs-lookup"><span data-stu-id="53e7e-132">This attribute will name the class that is the supporting type converter for values of that type, for XAML purposes as well as potentially other purposes.</span></span>  
  
### <a name="type-converters-and-markup-extensions"></a><span data-ttu-id="53e7e-133">型コンバーターとマークアップ拡張機能</span><span class="sxs-lookup"><span data-stu-id="53e7e-133">Type Converters and Markup Extensions</span></span>  
 <span data-ttu-id="53e7e-134">マークアップ拡張機能と型コンバーターは、XAML プロセッサの動作とそれらに適用されます、シナリオの観点から両方の役割を入力します。</span><span class="sxs-lookup"><span data-stu-id="53e7e-134">Markup extensions and type converters fill orthogonal roles in terms of XAML processor behavior and the scenarios that they are applied to.</span></span> <span data-ttu-id="53e7e-135">マークアップ拡張機能の使用時にはコンテキストを利用できますが、マークアップ拡張機能が値を提供するプロパティの型変換動作は一般にマークアップ拡張機能の実装ではチェックされません。</span><span class="sxs-lookup"><span data-stu-id="53e7e-135">Although context is available for markup extension usages, type conversion behavior of properties where a markup extension provides a value is generally is not checked in the markup extension implementations.</span></span> <span data-ttu-id="53e7e-136">つまり、マークアップ拡張機能としてテキスト文字列を返す場合でもその`ProvideValue`出力は、特定のプロパティまたはプロパティ値の型に適用されると、その文字列に対する型変換動作は呼び出されずに、一般に、マークアップ拡張機能の目的は、プロセスに、文字列と関連する型コンバーターを呼び出さず、オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="53e7e-136">In other words, even if a markup extension returns a text string as its `ProvideValue` output, type conversion behavior on that string as applied to a specific property or property value type is not invoked, Generally, the purpose of a markup extension is to process a string and return an object without any type converter involved.</span></span>  
  
 <span data-ttu-id="53e7e-137">ここで、マークアップ拡張機能は、型コンバーターではなく必要な 1 つの一般的な状況を既に存在するオブジェクトへの参照を行います。</span><span class="sxs-lookup"><span data-stu-id="53e7e-137">One common situation where a markup extension is necessary rather than a type converter is to make a reference to an object that already exists.</span></span> <span data-ttu-id="53e7e-138">最高でステートレスな型コンバーターは、必要とは限らないの新しいインスタンスを生成だけでした。</span><span class="sxs-lookup"><span data-stu-id="53e7e-138">At best, a stateless type converter could only generate a new instance, which might not be desirable.</span></span> <span data-ttu-id="53e7e-139">マークアップ拡張機能の詳細については、次を参照してください。[マークアップ拡張機能と WPF XAML](../../../../docs/framework/wpf/advanced/markup-extensions-and-wpf-xaml.md)です。</span><span class="sxs-lookup"><span data-stu-id="53e7e-139">For more information on markup extensions, see [Markup Extensions and WPF XAML](../../../../docs/framework/wpf/advanced/markup-extensions-and-wpf-xaml.md).</span></span>  
  
### <a name="native-type-converters"></a><span data-ttu-id="53e7e-140">ネイティブな型コンバーター</span><span class="sxs-lookup"><span data-stu-id="53e7e-140">Native Type Converters</span></span>  
 <span data-ttu-id="53e7e-141">XAML パーサーの WPF と .NET Framework の実装では、を持つネイティブ型の変換処理が通常と考えるのプリミティブ型がまだ特定の種類があります。</span><span class="sxs-lookup"><span data-stu-id="53e7e-141">In the WPF and .NET Framework implementation of the XAML parser, there are certain types that have native type conversion handling, yet are not types that might conventionally be thought of as primitives.</span></span> <span data-ttu-id="53e7e-142">このような型の例として、 <xref:System.DateTime>が挙げられます。</span><span class="sxs-lookup"><span data-stu-id="53e7e-142">An example of such a type is <xref:System.DateTime>.</span></span> <span data-ttu-id="53e7e-143">この理由は、.NET Framework のアーキテクチャの動作方法に基づいて: 型<xref:System.DateTime>mscorlib、.NET の最も基本的なライブラリで定義されています。</span><span class="sxs-lookup"><span data-stu-id="53e7e-143">The reason for this is based on how the .NET Framework architecture works: the type <xref:System.DateTime> is defined in mscorlib, the most basic library in .NET.</span></span> <span data-ttu-id="53e7e-144"><xref:System.DateTime>依存関係を導入する別のアセンブリから来る属性を持つ属性が設定されることはできません (<xref:System.ComponentModel.TypeConverterAttribute>は System から) ため、属性による通常の型コンバーターの検出機構がサポートされることはできません。</span><span class="sxs-lookup"><span data-stu-id="53e7e-144"><xref:System.DateTime> is not permitted to be attributed with an attribute that comes from another assembly that introduces a dependency (<xref:System.ComponentModel.TypeConverterAttribute> is from System) so the usual type converter discovery mechanism by attributing cannot be supported.</span></span> <span data-ttu-id="53e7e-145">代わりに、XAML パーサーでは、このようなネイティブの処理が必要な型のリストを持つし、通常のプリミティブの処理方法と同様にこれらを処理します。</span><span class="sxs-lookup"><span data-stu-id="53e7e-145">Instead, the XAML parser has a list of types that need such native processing and processes these similarly to how the true primitives are processed.</span></span> <span data-ttu-id="53e7e-146">(の場合、<xref:System.DateTime>への呼び出しでは、この<xref:System.DateTime.Parse%2A>)。</span><span class="sxs-lookup"><span data-stu-id="53e7e-146">(In the case of <xref:System.DateTime> this involves a call to <xref:System.DateTime.Parse%2A>.)</span></span>  
  
<a name="Implementing_a_Type_Converter"></a>   
## <a name="implementing-a-type-converter"></a><span data-ttu-id="53e7e-147">型コンバーターの実装</span><span class="sxs-lookup"><span data-stu-id="53e7e-147">Implementing a Type Converter</span></span>  
  
### <a name="typeconverter"></a><span data-ttu-id="53e7e-148">TypeConverter</span><span class="sxs-lookup"><span data-stu-id="53e7e-148">TypeConverter</span></span>  
 <span data-ttu-id="53e7e-149"><xref:System.Windows.Point>以前は、クラスの例<xref:System.Windows.PointConverter>述べたです。</span><span class="sxs-lookup"><span data-stu-id="53e7e-149">In the <xref:System.Windows.Point> example given previously, the class <xref:System.Windows.PointConverter> was mentioned.</span></span> <span data-ttu-id="53e7e-150">XAML の目的で使用されるすべての型コンバーターは、基本クラスから派生するクラスを XAML の実装は .NET、<xref:System.ComponentModel.TypeConverter>です。</span><span class="sxs-lookup"><span data-stu-id="53e7e-150">For .NET implementations of XAML, all type converters that are used for XAML purposes are classes that derive from the base class <xref:System.ComponentModel.TypeConverter>.</span></span> <span data-ttu-id="53e7e-151"><xref:System.ComponentModel.TypeConverter> XAML の存在を前にある .NET Framework のバージョンに存在していたクラスです。 ビジュアル デザイナーでのプロパティ ダイアログ ボックスの文字列の変換を提供するが、元の使用法のいずれか。</span><span class="sxs-lookup"><span data-stu-id="53e7e-151">The <xref:System.ComponentModel.TypeConverter> class existed in versions of .NET Framework that precede the existence of XAML; one of its original usages was to provide string conversion for property dialogs in visual designers.</span></span> <span data-ttu-id="53e7e-152">Xaml での役割<xref:System.ComponentModel.TypeConverter>を展開すると、文字列の属性値を解析およびの文字列に戻す可能性のある特定のオブジェクト プロパティのランタイム値を処理できるようにする文字列に変換して、文字列からの変換の基底クラスが含まれます属性としてシリアル化します。</span><span class="sxs-lookup"><span data-stu-id="53e7e-152">For XAML, the role of <xref:System.ComponentModel.TypeConverter> is expanded to include being the base class for to-string and from-string conversions that enable parsing a string attribute value, and possibly processing a run-time value of a particular object property back into a string for serialization as an attribute.</span></span>  
  
 <span data-ttu-id="53e7e-153"><xref:System.ComponentModel.TypeConverter>XAML の処理のための文字列との間の変換に関連する 4 つのメンバーを定義します。</span><span class="sxs-lookup"><span data-stu-id="53e7e-153"><xref:System.ComponentModel.TypeConverter> defines four members that are relevant for converting to and from strings for XAML processing purposes:</span></span>  
  
-   <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A>  
  
-   <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A>  
  
-   <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>  
  
-   <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>  
  
 <span data-ttu-id="53e7e-154">これらの最も重要なメソッドは<xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>します。</span><span class="sxs-lookup"><span data-stu-id="53e7e-154">Of these, the most important method is <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>.</span></span> <span data-ttu-id="53e7e-155">このメソッドは、入力文字列を必要なオブジェクトの種類に変換します。</span><span class="sxs-lookup"><span data-stu-id="53e7e-155">This method converts the input string to the required object type.</span></span> <span data-ttu-id="53e7e-156">厳密に言うと、<xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>くらい広範な型をコンバーターの目的の型に変換し、そのため、実行時の変換をサポートするなど、XAML の目的で XAML 以外の目的に使用するメソッドを実装する可能性があります処理できるコード パスのみが、<xref:System.String>自分にとって重要な入力です。</span><span class="sxs-lookup"><span data-stu-id="53e7e-156">Strictly speaking, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method could be implemented to convert a much wider range of types into the converter's intended destination type, and thus serve purposes that extend beyond XAML such as supporting run-time conversions, but for XAML purposes it is only the code path that can process a <xref:System.String> input that matters.</span></span>  
  
 <span data-ttu-id="53e7e-157">次の重要なメソッドは<xref:System.ComponentModel.TypeConverter.ConvertTo%2A>します。</span><span class="sxs-lookup"><span data-stu-id="53e7e-157">The next most important method is <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span></span> <span data-ttu-id="53e7e-158">かどうか、アプリケーションがマークアップ表現に変換されます (たとえば、ファイルとしての XAML に保存される) 場合、<xref:System.ComponentModel.TypeConverter.ConvertTo%2A>マークアップ形式を生成を担当します。</span><span class="sxs-lookup"><span data-stu-id="53e7e-158">If an application is converted to a markup representation (for instance, if it is saved to XAML as a file), <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is responsible for producing a markup representation.</span></span> <span data-ttu-id="53e7e-159">この場合、XAML にとって重要なコード パスは、渡す際に、`destinationType`の<xref:System.String>します。</span><span class="sxs-lookup"><span data-stu-id="53e7e-159">In this case, the code path that matters for XAML is when you pass a `destinationType` of <xref:System.String> .</span></span>  
  
 <span data-ttu-id="53e7e-160"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> と <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> は、サービスが <xref:System.ComponentModel.TypeConverter> の実装の機能を照会する時に使用されるサポート メソッドです。</span><span class="sxs-lookup"><span data-stu-id="53e7e-160"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> and <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> are support methods that are used when a service queries the capabilities of the <xref:System.ComponentModel.TypeConverter> implementation.</span></span> <span data-ttu-id="53e7e-161">これらのメソッドは、その型について、相当する変換メソッドをコンバーターがサポートしている場合に `true` を返すように実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="53e7e-161">You must implement these methods to return `true` for type-specific cases that the equivalent conversion methods of your converter support.</span></span> <span data-ttu-id="53e7e-162">XAML の目的では、通常、 <xref:System.String> 型であることを意味します。</span><span class="sxs-lookup"><span data-stu-id="53e7e-162">For XAML purposes, this generally means the <xref:System.String> type.</span></span>  
  
### <a name="culture-information-and-type-converters-for-xaml"></a><span data-ttu-id="53e7e-163">カルチャ情報と XAML の型コンバーター</span><span class="sxs-lookup"><span data-stu-id="53e7e-163">Culture Information and Type Converters for XAML</span></span>  
 <span data-ttu-id="53e7e-164">各<xref:System.ComponentModel.TypeConverter>実装、変換に対して有効な文字列の構成内容の独自の解釈およびことができますも使用したり、パラメーターとして渡される型の説明を無視します。</span><span class="sxs-lookup"><span data-stu-id="53e7e-164">Each <xref:System.ComponentModel.TypeConverter> implementation can have its own interpretation of what constitutes a valid string for a conversion, and can also use or ignore the type description passed as parameters.</span></span> <span data-ttu-id="53e7e-165">カルチャと XAML 型の変換に関して重要な考慮事項があります。</span><span class="sxs-lookup"><span data-stu-id="53e7e-165">There is an important consideration with regard to culture and XAML type conversion.</span></span> <span data-ttu-id="53e7e-166">XAML では、ローカライズ可能な文字列属性値として使用することはサポートされて完全。</span><span class="sxs-lookup"><span data-stu-id="53e7e-166">Using localizable strings as attribute values is entirely supported by XAML.</span></span> <span data-ttu-id="53e7e-167">XAML 属性の値の型コンバーターには、必ずしも特定の言語の解析動作が含まれまるために、特定のカルチャ要件を持つ型コンバーターの入力がサポートされていないのでそのローカライズ可能な文字列を使用が、`en-US`カルチャ。</span><span class="sxs-lookup"><span data-stu-id="53e7e-167">But using that localizable string as type converter input with specific culture requirements is not supported, because type converters for XAML attribute values involve a necessarily fixed-language parsing behavior, using `en-US` culture.</span></span> <span data-ttu-id="53e7e-168">この制限の設計上の理由の詳細については、XAML 言語仕様を参照してください ([\[MS-XAML\]](http://go.microsoft.com/fwlink/?LinkId=114525))。</span><span class="sxs-lookup"><span data-stu-id="53e7e-168">For more information on the design reasons for this restriction, you should consult the XAML language specification ([\[MS-XAML\]](http://go.microsoft.com/fwlink/?LinkId=114525)).</span></span>  
  
 <span data-ttu-id="53e7e-169">例として、カルチャが問題になることができます、一部のカルチャが数値の小数点区切り文字としてコンマを使用します。</span><span class="sxs-lookup"><span data-stu-id="53e7e-169">As an example where culture can be an issue, some cultures use a comma as their decimal point delimiter for numbers.</span></span> <span data-ttu-id="53e7e-170">これが、動作を持つ XAML の WPF 型コンバーターの多くはコンマを区切り記号として使用すると衝突する (共通の X などの従来の慣習に基づき、Y フォーム、またはコンマ区切りリスト)。</span><span class="sxs-lookup"><span data-stu-id="53e7e-170">This will collide with the behavior that many of the WPF XAML type converters have, which is to use a comma as a delimiter (based on historical precedents such as the common X,Y form, or comma delimited lists).</span></span> <span data-ttu-id="53e7e-171">周囲の XAML でカルチャを渡すことも (設定`Language`または`xml:lang`を`sl-SI`カルチャ、この方法で小数点のコンマを使用するカルチャの例)、問題は解決しません。</span><span class="sxs-lookup"><span data-stu-id="53e7e-171">Even passing a culture in the surrounding XAML (setting `Language` or `xml:lang` to the `sl-SI` culture, an example of a culture that uses a comma for decimal in this way) does not solve the issue.</span></span>  
  
### <a name="implementing-convertfrom"></a><span data-ttu-id="53e7e-172">ConvertFrom の実装</span><span class="sxs-lookup"><span data-stu-id="53e7e-172">Implementing ConvertFrom</span></span>  
 <span data-ttu-id="53e7e-173">XAML をサポートする <xref:System.ComponentModel.TypeConverter> の実装としてコンバーターを使用できるようにするためには、そのコンバーターの <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> メソッドが `value` パラメーターとして文字列を受け入れる必要があります。</span><span class="sxs-lookup"><span data-stu-id="53e7e-173">To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method for that converter must accept a string as the `value` parameter.</span></span> <span data-ttu-id="53e7e-174">とき、文字列が有効な書式設定、およびによって変換できる、<xref:System.ComponentModel.TypeConverter>実装し、返されたオブジェクトはプロパティによって予期される型へのキャストをサポートする必要があります。</span><span class="sxs-lookup"><span data-stu-id="53e7e-174">If the string was in valid format, and can be converted by the <xref:System.ComponentModel.TypeConverter> implementation, then the returned object must support a cast to the type expected by the property.</span></span> <span data-ttu-id="53e7e-175">それ以外の場合、 <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> 実装は `null`を返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="53e7e-175">Otherwise, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation must return `null`.</span></span>  
  
 <span data-ttu-id="53e7e-176">各<xref:System.ComponentModel.TypeConverter>実装、変換に対して有効な文字列の構成内容の独自の解釈およびことができますも使用したり、パラメーターとして渡された型の説明やカルチャ コンテキストを無視します。</span><span class="sxs-lookup"><span data-stu-id="53e7e-176">Each <xref:System.ComponentModel.TypeConverter> implementation can have its own interpretation of what constitutes a valid string for a conversion, and can also use or ignore the type description or culture contexts passed as parameters.</span></span> <span data-ttu-id="53e7e-177">ただし、WPF による XAML 処理の場合は、型の説明コンテキストに値を渡さない場合がありに基づくカルチャを渡さない場合がありますも`xml:lang`します。</span><span class="sxs-lookup"><span data-stu-id="53e7e-177">However, the WPF XAML processing might not pass values to the type description context in all cases, and also might not pass culture based on `xml:lang`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="53e7e-178">特に、中かっこ文字を使用しない {、文字列の書式の要素として。</span><span class="sxs-lookup"><span data-stu-id="53e7e-178">Do not use the curly brace characters, particularly {, as a possible element of your string format.</span></span> <span data-ttu-id="53e7e-179">これらの文字は、マークアップ拡張シーケンスの開始および終了を示す文字として予約されています。</span><span class="sxs-lookup"><span data-stu-id="53e7e-179">These characters are reserved as the entry and exit for a markup extension sequence.</span></span>  
  
### <a name="implementing-convertto"></a><span data-ttu-id="53e7e-180">ConvertTo の実装</span><span class="sxs-lookup"><span data-stu-id="53e7e-180">Implementing ConvertTo</span></span>  
 <span data-ttu-id="53e7e-181"><xref:System.ComponentModel.TypeConverter.ConvertTo%2A> は、シリアル化のサポートで使用される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="53e7e-181"><xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is potentially used for serialization support.</span></span> <span data-ttu-id="53e7e-182">カスタム型およびその型コンバーターに対して <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> によるシリアル化をサポートすることは、絶対要件ではありません。</span><span class="sxs-lookup"><span data-stu-id="53e7e-182">Serialization support through <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> for your custom type and its type converter is not an absolute requirement.</span></span> <span data-ttu-id="53e7e-183">ただし、コントロールを実装する場合、またはクラスの機能または設計の一部としてシリアル化を使用する場合は、 <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>を実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="53e7e-183">However, if you are implementing a control, or using serialization of as part of the features or design of your class, you should implement <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span></span>  
  
 <span data-ttu-id="53e7e-184">として使用できるように、 <xref:System.ComponentModel.TypeConverter> XAML をサポートする実装、<xref:System.ComponentModel.TypeConverter.ConvertTo%2A>としてそのコンバーターのメソッドがサポートされる型 (または値) のインスタンスを受け入れる必要があります、`value`パラメーター。</span><span class="sxs-lookup"><span data-stu-id="53e7e-184">To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> method for that converter must accept an instance of the type (or a value) being supported as the `value` parameter.</span></span> <span data-ttu-id="53e7e-185">ときに、`destinationType`パラメーターの型が<xref:System.String>、返されたオブジェクトとしてキャストできる必要があります、<xref:System.String>です。</span><span class="sxs-lookup"><span data-stu-id="53e7e-185">When the `destinationType` parameter is the type <xref:System.String>, then the returned object must be able to be cast as <xref:System.String>.</span></span> <span data-ttu-id="53e7e-186">返される文字列は、 `value`のシリアル化された値を表している必要があります。</span><span class="sxs-lookup"><span data-stu-id="53e7e-186">The returned string must represent a serialized value of `value`.</span></span> <span data-ttu-id="53e7e-187">理想的には、シリアル化の形式を選択できる必要がありますにその文字列が渡された場合は、同じ値を生成する、<xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>情報の大きな損失が発生せず、同じコンバーターの実装です。</span><span class="sxs-lookup"><span data-stu-id="53e7e-187">Ideally, the serialization format you choose should be capable of generating the same value if that string were passed to the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation of the same converter, without significant loss of information.</span></span>  
  
 <span data-ttu-id="53e7e-188">値をシリアル化することはできません、またはコンバーターがシリアル化をサポートしていない場合、<xref:System.ComponentModel.TypeConverter.ConvertTo%2A>実装を返す必要があります`null`、ここで例外をスローすることを許可されています。</span><span class="sxs-lookup"><span data-stu-id="53e7e-188">If the value cannot be serialized, or the converter does not support serialization, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> implementation must return `null`, and is permitted to throw an exception in this case.</span></span> <span data-ttu-id="53e7e-189">例外をスローする場合は、一部としてその変換を使用できないことを報告する必要がありますが、<xref:System.ComponentModel.TypeConverter.CanConvertTo%2A>実装ように確認する最善の方法<xref:System.ComponentModel.TypeConverter.CanConvertTo%2A>最初の例外を回避するのにはサポートされています。</span><span class="sxs-lookup"><span data-stu-id="53e7e-189">But if you do throw exceptions, you should report the inability to use that conversion as part of your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation so that the best practice of checking with <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> first to avoid exceptions is supported.</span></span>  
  
 <span data-ttu-id="53e7e-190">場合`destinationType`パラメーターの型ではありません<xref:System.String>、独自のコンバーター処理を選択できます。</span><span class="sxs-lookup"><span data-stu-id="53e7e-190">If `destinationType` parameter is not of type <xref:System.String>, you can choose your own converter handling.</span></span> <span data-ttu-id="53e7e-191">通常、処理、basemost の基本実装を元に戻すには<xref:System.ComponentModel.TypeConverter.ConvertTo%2A>特定の例外を発生させます。</span><span class="sxs-lookup"><span data-stu-id="53e7e-191">Typically, you would revert to base implementation handling, which in the basemost <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> raises a specific exception.</span></span>  
  
### <a name="implementing-canconvertto"></a><span data-ttu-id="53e7e-192">CanConvertTo の実装</span><span class="sxs-lookup"><span data-stu-id="53e7e-192">Implementing CanConvertTo</span></span>  
 <span data-ttu-id="53e7e-193"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> の実装は、 `true` が `destinationType` 型の場合は <xref:System.String>を返し、それ以外の場合は基底の実装に任せる必要があります。</span><span class="sxs-lookup"><span data-stu-id="53e7e-193">Your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation should return `true` for `destinationType` of type <xref:System.String>, and otherwise defer to the base implementation.</span></span>  
  
### <a name="implementing-canconvertfrom"></a><span data-ttu-id="53e7e-194">CanConvertFrom の実装</span><span class="sxs-lookup"><span data-stu-id="53e7e-194">Implementing CanConvertFrom</span></span>  
 <span data-ttu-id="53e7e-195"><xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> の実装は、`sourceType` が <xref:System.String> 型の場合は `true` を返し、それ以外の場合は基底の実装に任せる必要があります。</span><span class="sxs-lookup"><span data-stu-id="53e7e-195">Your <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> implementation should return `true` for `sourceType` of type <xref:System.String>, and otherwise defer to the base implementation.</span></span>  
  
<a name="Applying_the_TypeConverterAttribute"></a>   
## <a name="applying-the-typeconverterattribute"></a><span data-ttu-id="53e7e-196">TypeConverterAttribute の適用</span><span class="sxs-lookup"><span data-stu-id="53e7e-196">Applying the TypeConverterAttribute</span></span>  
 <span data-ttu-id="53e7e-197">カスタム型コンバーターとして使用するために、XAML プロセッサによってカスタム クラスの型コンバーターを適用する必要がある、 [!INCLUDE[TLA#tla_netframewkattr](../../../../includes/tlasharptla-netframewkattr-md.md)] <xref:System.ComponentModel.TypeConverterAttribute>クラス定義にします。</span><span class="sxs-lookup"><span data-stu-id="53e7e-197">In order for your custom type converter to be used as the acting type converter for a custom class by a XAML processor, you must apply the [!INCLUDE[TLA#tla_netframewkattr](../../../../includes/tlasharptla-netframewkattr-md.md)] <xref:System.ComponentModel.TypeConverterAttribute> to your class definition.</span></span> <span data-ttu-id="53e7e-198">属性を通して指定する <xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> は、カスタム型コンバーターの型名である必要があります。</span><span class="sxs-lookup"><span data-stu-id="53e7e-198">The <xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> that you specify through the attribute must be the type name of your custom type converter.</span></span> <span data-ttu-id="53e7e-199">この属性を適用するには、XAML プロセッサは、プロパティの型が、カスタムのクラス型で使用されている値を処理するときに、入力文字列と、オブジェクト インスタンスを返します。</span><span class="sxs-lookup"><span data-stu-id="53e7e-199">With this attribute applied, when a XAML processor handles values where the property type uses your custom class type, it can input strings and return object instances.</span></span>  
  
 <span data-ttu-id="53e7e-200">また、プロパティごとに型コンバーターを提供することもできます。</span><span class="sxs-lookup"><span data-stu-id="53e7e-200">You can also provide a type converter on a per-property basis.</span></span> <span data-ttu-id="53e7e-201">適用する代わりに、 [!INCLUDE[TLA#tla_netframewkattr](../../../../includes/tlasharptla-netframewkattr-md.md)] <xref:System.ComponentModel.TypeConverterAttribute>クラス定義にプロパティの定義に適用 (メイン定義されません、 `get` / `set`内に実装)。</span><span class="sxs-lookup"><span data-stu-id="53e7e-201">Instead of applying a [!INCLUDE[TLA#tla_netframewkattr](../../../../includes/tlasharptla-netframewkattr-md.md)] <xref:System.ComponentModel.TypeConverterAttribute> to the class definition, apply it to a property definition (the main definition, not the `get`/`set` implementations within it).</span></span> <span data-ttu-id="53e7e-202">プロパティの型は、カスタム型コンバーターによって処理される型と一致する必要があります。</span><span class="sxs-lookup"><span data-stu-id="53e7e-202">The type of the property must match the type that is processed by your custom type converter.</span></span> <span data-ttu-id="53e7e-203">この属性を適用するには、Xaml では、そのプロパティの値を処理するときに、入力文字列を処理し、オブジェクト インスタンスを返します。</span><span class="sxs-lookup"><span data-stu-id="53e7e-203">With this attribute applied, when a XAMLprocessor handles values of that property, it can process input strings and return object instances.</span></span> <span data-ttu-id="53e7e-204">プロパティごとに型コンバーターを提供する手法は、[!INCLUDE[TLA#tla_netframewk](../../../../includes/tlasharptla-netframewk-md.md)] やその他のライブラリなど、クラス定義を制御することができず、<xref:System.ComponentModel.TypeConverterAttribute> を適用できないライブラリからプロパティの型を使用する場合に特に便利です。</span><span class="sxs-lookup"><span data-stu-id="53e7e-204">The per-property type converter technique is particularly useful if you choose to use a property type from [!INCLUDE[TLA#tla_netframewk](../../../../includes/tlasharptla-netframewk-md.md)] or from some other library where you cannot control the class definition and cannot apply a <xref:System.ComponentModel.TypeConverterAttribute> there.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="53e7e-205">参照</span><span class="sxs-lookup"><span data-stu-id="53e7e-205">See Also</span></span>  
 <xref:System.ComponentModel.TypeConverter>  
 [<span data-ttu-id="53e7e-206">XAML の概要 (WPF)</span><span class="sxs-lookup"><span data-stu-id="53e7e-206">XAML Overview (WPF)</span></span>](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md)  
 [<span data-ttu-id="53e7e-207">マークアップ拡張機能と WPF XAML</span><span class="sxs-lookup"><span data-stu-id="53e7e-207">Markup Extensions and WPF XAML</span></span>](../../../../docs/framework/wpf/advanced/markup-extensions-and-wpf-xaml.md)  
 [<span data-ttu-id="53e7e-208">XAML 構文の詳細</span><span class="sxs-lookup"><span data-stu-id="53e7e-208">XAML Syntax In Detail</span></span>](../../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md)
