---
title: 添付プロパティの概要
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- attached properties [WPF Designer]
ms.assetid: 75928354-dc01-47e8-a018-8409aec1f32d
ms.openlocfilehash: 41be2862eef52a3731792096ff198e1aa629f4c0
ms.sourcegitcommit: 2701302a99cafbe0d86d53d540eb0fa7e9b46b36
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/28/2019
ms.locfileid: "64655545"
---
# <a name="attached-properties-overview"></a><span data-ttu-id="4d27f-102">添付プロパティの概要</span><span class="sxs-lookup"><span data-stu-id="4d27f-102">Attached Properties Overview</span></span>

<span data-ttu-id="4d27f-103">添付プロパティは、XAML によって定義された概念です。</span><span class="sxs-lookup"><span data-stu-id="4d27f-103">An attached property is a concept defined by XAML.</span></span> <span data-ttu-id="4d27f-104">添付プロパティは、任意のオブジェクトに設定可能なグローバル プロパティの型として使用されることを意図しています。</span><span class="sxs-lookup"><span data-stu-id="4d27f-104">An attached property is intended to be used as a type of global property that is settable on any object.</span></span> <span data-ttu-id="4d27f-105">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] では通常、添付プロパティは従来のプロパティ "ラッパー" を含まない依存関係プロパティの特殊な形式として定義されています。</span><span class="sxs-lookup"><span data-stu-id="4d27f-105">In [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], attached properties are typically defined as a specialized form of dependency property that does not have the conventional property "wrapper".</span></span>

## <span data-ttu-id="4d27f-106">前提条件 <a name="prerequisites"></a></span><span class="sxs-lookup"><span data-stu-id="4d27f-106">Prerequisites <a name="prerequisites"></a></span></span>

<span data-ttu-id="4d27f-107">このトピックでは、ユーザーが [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] クラスの既存の依存関係プロパティの使用という観点から依存関係プロパティを理解し、「[依存関係プロパティの概要](dependency-properties-overview.md)」トピックを通読していることを前提としています。</span><span class="sxs-lookup"><span data-stu-id="4d27f-107">This topic assumes that you understand dependency properties from the perspective of a consumer of existing dependency properties on [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] classes, and have read the [Dependency Properties Overview](dependency-properties-overview.md).</span></span> <span data-ttu-id="4d27f-108">このトピックの例を実行するにも XAML を理解して、WPF アプリケーションを作成する方法を理解する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4d27f-108">To follow the examples in this topic, you should also understand XAML and know how to write WPF applications.</span></span>

## <span data-ttu-id="4d27f-109">添付プロパティを使用する理由 <a name="attached_properties_usage"></a></span><span class="sxs-lookup"><span data-stu-id="4d27f-109">Why Use Attached Properties <a name="attached_properties_usage"></a></span></span>

<span data-ttu-id="4d27f-110">添付プロパティの目的の 1 つは、親要素に実際に定義されているプロパティに対する一意の値を、異なる子要素が指定できるようにすることです。</span><span class="sxs-lookup"><span data-stu-id="4d27f-110">One purpose of an attached property is to allow different child elements to specify unique values for a property that is actually defined in a parent element.</span></span> <span data-ttu-id="4d27f-111">このシナリオの適用例として、子要素から親要素に、[!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] での表示方法を通知させることがあります。</span><span class="sxs-lookup"><span data-stu-id="4d27f-111">A specific application of this scenario is having child elements inform the parent element of how they are to be presented in the [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)].</span></span> <span data-ttu-id="4d27f-112">1 つの例は、<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>プロパティ。</span><span class="sxs-lookup"><span data-stu-id="4d27f-112">One example is the <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="4d27f-113"><xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>内に含まれる要素に設定することが目的のため、プロパティが添付プロパティとして作成された、<xref:System.Windows.Controls.DockPanel>ではなくで<xref:System.Windows.Controls.DockPanel>自体。</span><span class="sxs-lookup"><span data-stu-id="4d27f-113">The <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> property is created as an attached property because it is designed to be set on elements that are contained within a <xref:System.Windows.Controls.DockPanel>, rather than on <xref:System.Windows.Controls.DockPanel> itself.</span></span> <span data-ttu-id="4d27f-114"><xref:System.Windows.Controls.DockPanel>クラス定義、静的な<xref:System.Windows.DependencyProperty>という名前のフィールド<xref:System.Windows.Controls.DockPanel.DockProperty>、し、説明、<xref:System.Windows.Controls.DockPanel.GetDock%2A>と<xref:System.Windows.Controls.DockPanel.SetDock%2A>添付プロパティのパブリック アクセサーとしてメソッド。</span><span class="sxs-lookup"><span data-stu-id="4d27f-114">The <xref:System.Windows.Controls.DockPanel> class defines the static <xref:System.Windows.DependencyProperty> field named <xref:System.Windows.Controls.DockPanel.DockProperty>, and then provides the <xref:System.Windows.Controls.DockPanel.GetDock%2A> and <xref:System.Windows.Controls.DockPanel.SetDock%2A> methods as public accessors for the attached property.</span></span>

## <span data-ttu-id="4d27f-115">XAML の添付プロパティ <a name="attached_properties_xaml"></a></span><span class="sxs-lookup"><span data-stu-id="4d27f-115">Attached Properties in XAML <a name="attached_properties_xaml"></a></span></span>

<span data-ttu-id="4d27f-116">XAML では、構文 *AttachedPropertyProvider*.*PropertyName* を使用して添付プロパティを設定します</span><span class="sxs-lookup"><span data-stu-id="4d27f-116">In XAML, you set attached properties by using the syntax *AttachedPropertyProvider*.*PropertyName*</span></span>

<span data-ttu-id="4d27f-117">設定する方法の例を次に<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>XAML で。</span><span class="sxs-lookup"><span data-stu-id="4d27f-117">The following is an example of how you can set <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> in XAML:</span></span>

[!code-xaml[PropertiesOvwSupport#APBasicUsage](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml#apbasicusage)]

<span data-ttu-id="4d27f-118">使用状況は、静的プロパティに少し似ています常に、型を参照する<xref:System.Windows.Controls.DockPanel>が所有し、添付プロパティを登録する名前で指定したインスタンスを参照するのではなく。</span><span class="sxs-lookup"><span data-stu-id="4d27f-118">Note that the usage is somewhat similar to a static property; you always reference the type <xref:System.Windows.Controls.DockPanel> that owns and registers the attached property, rather than referring to any instance specified by name.</span></span>

<span data-ttu-id="4d27f-119">さらに、XAML の添付プロパティはマークアップに設定する属性であるため、設定操作にのみ関連性があります。</span><span class="sxs-lookup"><span data-stu-id="4d27f-119">Also, because an attached property in XAML is an attribute that you set in markup, only the set operation has any relevance.</span></span> <span data-ttu-id="4d27f-120">XAML でプロパティを直接取得することはできませんが、スタイルのトリガー (詳細については、「[スタイルとテンプレート](../controls/styling-and-templating.md)」を参照) などの値を比較するための間接的な機構があります。</span><span class="sxs-lookup"><span data-stu-id="4d27f-120">You cannot directly get a property in XAML, although there are some indirect mechanisms for comparing values, such as triggers in styles (for details, see [Styling and Templating](../controls/styling-and-templating.md)).</span></span>

### <a name="attached-property-implementation-in-wpf"></a><span data-ttu-id="4d27f-121">WPF での添付プロパティの実装</span><span class="sxs-lookup"><span data-stu-id="4d27f-121">Attached Property Implementation in WPF</span></span>

<span data-ttu-id="4d27f-122">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]、UI プレゼンテーションに関連する WPF 型に存在する添付プロパティのほとんどは、依存関係プロパティとして実装されます。</span><span class="sxs-lookup"><span data-stu-id="4d27f-122">In [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], most of the attached properties that exist on WPF types that are related to UI presentation are implemented as dependency properties.</span></span> <span data-ttu-id="4d27f-123">添付プロパティは XAML の概念では、依存関係プロパティは、WPF の概念です。</span><span class="sxs-lookup"><span data-stu-id="4d27f-123">Attached properties are a XAML concept, whereas dependency properties are a WPF concept.</span></span> <span data-ttu-id="4d27f-124">接続されている WPF のプロパティは、依存関係プロパティであるために、プロパティ メタデータ、およびそのプロパティのメタデータからの既定値などの依存関係プロパティの概念をサポートしています。</span><span class="sxs-lookup"><span data-stu-id="4d27f-124">Because WPF attached properties are dependency properties, they support dependency property concepts such as property metadata, and default values from that property metadata.</span></span>

## <span data-ttu-id="4d27f-125">所有する型による添付プロパティの使用方法 <a name="howused"></a></span><span class="sxs-lookup"><span data-stu-id="4d27f-125">How Attached Properties Are Used by the Owning Type <a name="howused"></a></span></span>

<span data-ttu-id="4d27f-126">添付プロパティはどのオブジェクトにも設定できますが、プロパティを設定したことによって自動的に意味のある結果が得られるわけでも、値が別のオブジェクトによって使用されるわけでもありません。</span><span class="sxs-lookup"><span data-stu-id="4d27f-126">Although attached properties are settable on any object, that does not automatically mean that setting the property will produce a tangible result, or that the value will ever be used by another object.</span></span> <span data-ttu-id="4d27f-127">一般に、添付プロパティの目的は、想定されるさまざまなクラス階層または論理関係から生じるオブジェクトが、添付プロパティを定義する型に共通する情報をレポートできるようにすることです。</span><span class="sxs-lookup"><span data-stu-id="4d27f-127">Generally, attached properties are intended so that objects coming from a wide variety of possible class hierarchies or logical relationships can each report common information to the type that defines the attached property.</span></span> <span data-ttu-id="4d27f-128">添付プロパティを定義する型は、一般的に次のいずれかのモデルに従っています。</span><span class="sxs-lookup"><span data-stu-id="4d27f-128">The type that defines the attached property typically follows one of these models:</span></span>

- <span data-ttu-id="4d27f-129">添付プロパティを定義する型が、添付プロパティの値を設定する要素の親要素になるように設計されている。</span><span class="sxs-lookup"><span data-stu-id="4d27f-129">The type that defines the attached property is designed so that it can be the parent element of the elements that will set values for the attached property.</span></span> <span data-ttu-id="4d27f-130">この型の子オブジェクトは、一部のオブジェクト ツリー構造で内部ロジックを反復し、値を取得して、その値に対する処理を実行します。</span><span class="sxs-lookup"><span data-stu-id="4d27f-130">The type then iterates its child objects through internal logic against some object tree structure, obtains the values, and acts on those values in some manner.</span></span>

- <span data-ttu-id="4d27f-131">添付プロパティを定義する型が、想定されるさまざまな親要素およびコンテンツ モデルの子要素として使用される。</span><span class="sxs-lookup"><span data-stu-id="4d27f-131">The type that defines the attached property will be used as the child element for a variety of possible parent elements and content models.</span></span>

- <span data-ttu-id="4d27f-132">添付プロパティを定義する型が、サービスを表す。</span><span class="sxs-lookup"><span data-stu-id="4d27f-132">The type that defines the attached property represents a service.</span></span> <span data-ttu-id="4d27f-133">その他の型は、添付プロパティの値を設定します。</span><span class="sxs-lookup"><span data-stu-id="4d27f-133">Other types set values for the attached property.</span></span> <span data-ttu-id="4d27f-134">プロパティを設定する要素がサービスのコンテキストで評価されると、添付プロパティの値がサービス クラスの内部ロジックにより取得されます。</span><span class="sxs-lookup"><span data-stu-id="4d27f-134">Then, when the element that set the property is evaluated in the context of the service, the attached property values are obtained through internal logic of the service class.</span></span>

### <a name="an-example-of-a-parent-defined-attached-property"></a><span data-ttu-id="4d27f-135">親定義の添付プロパティの例</span><span class="sxs-lookup"><span data-stu-id="4d27f-135">An Example of a Parent-Defined Attached Property</span></span>

<span data-ttu-id="4d27f-136">WPF が添付プロパティを定義する最も一般的なシナリオは親要素の子要素のコレクションをサポートしているし、も動作を実装するときに各子要素の動作の詳細を個別に報告される場所です。</span><span class="sxs-lookup"><span data-stu-id="4d27f-136">The most typical scenario where WPF defines an attached property is when a parent element supports a child element collection, and also implements a behavior where the specifics of the behavior are reported individually for each child element.</span></span>

<span data-ttu-id="4d27f-137"><xref:System.Windows.Controls.DockPanel> 定義、<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>添付プロパティ、および<xref:System.Windows.Controls.DockPanel>そのレンダリング ロジックの一部としてクラスレベルのコードを持つ (具体的には、<xref:System.Windows.Controls.DockPanel.MeasureOverride%2A>と<xref:System.Windows.Controls.DockPanel.ArrangeOverride%2A>)。</span><span class="sxs-lookup"><span data-stu-id="4d27f-137"><xref:System.Windows.Controls.DockPanel> defines the <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> attached property, and <xref:System.Windows.Controls.DockPanel> has class-level code as part of its rendering logic (specifically, <xref:System.Windows.Controls.DockPanel.MeasureOverride%2A> and <xref:System.Windows.Controls.DockPanel.ArrangeOverride%2A>).</span></span> <span data-ttu-id="4d27f-138">A<xref:System.Windows.Controls.DockPanel>インスタンスは直下の子要素のいずれかの値を設定がかどうかを必ず確認<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>します。</span><span class="sxs-lookup"><span data-stu-id="4d27f-138">A <xref:System.Windows.Controls.DockPanel> instance will always check to see whether any of its immediate child elements have set a value for <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4d27f-139">設定されている場合は、その値が、その子要素に適用されるレンダリング ロジックの入力になります。</span><span class="sxs-lookup"><span data-stu-id="4d27f-139">If so, those values become input for the rendering logic applied to that particular child element.</span></span> <span data-ttu-id="4d27f-140">入れ子になった<xref:System.Windows.Controls.DockPanel>インスタンスはそれぞれが独自の直接の子要素のコレクションを扱いますが、その動作は実装固有方法<xref:System.Windows.Controls.DockPanel>プロセス<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>値。</span><span class="sxs-lookup"><span data-stu-id="4d27f-140">Nested <xref:System.Windows.Controls.DockPanel> instances each treat their own immediate child element collections, but that behavior is implementation-specific to how <xref:System.Windows.Controls.DockPanel> processes <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> values.</span></span> <span data-ttu-id="4d27f-141">直接の親以外の要素に影響を与える添付プロパティを所有することは、理論上は可能です。</span><span class="sxs-lookup"><span data-stu-id="4d27f-141">It is theoretically possible to have attached properties that influence elements beyond the immediate parent.</span></span> <span data-ttu-id="4d27f-142">場合、<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>を持たない要素で添付プロパティを設定<xref:System.Windows.Controls.DockPanel>がないエラーや例外に対して操作を実行する親要素が発生します。</span><span class="sxs-lookup"><span data-stu-id="4d27f-142">If the <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> attached property is set on an element that has no <xref:System.Windows.Controls.DockPanel> parent element to act upon it, no error or exception is raised.</span></span> <span data-ttu-id="4d27f-143">グローバル プロパティの値が設定されたが、現在は持たないこれは<xref:System.Windows.Controls.DockPanel>情報を利用できる親。</span><span class="sxs-lookup"><span data-stu-id="4d27f-143">This simply means that a global property value was set, but it has no current <xref:System.Windows.Controls.DockPanel> parent that could consume the information.</span></span>

## <span data-ttu-id="4d27f-144">コードの添付プロパティ <a name="attached_properties_code"></a></span><span class="sxs-lookup"><span data-stu-id="4d27f-144">Attached Properties in Code <a name="attached_properties_code"></a></span></span>

<span data-ttu-id="4d27f-145">WPF で添付プロパティには、一般的なありません[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]取得/設定を簡単にアクセスするための「ラッパー」メソッドです。</span><span class="sxs-lookup"><span data-stu-id="4d27f-145">Attached properties in WPF do not have the typical [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] "wrapper" methods for easy get/set access.</span></span> <span data-ttu-id="4d27f-146">これは、添付プロパティが、プロパティが設定されているインスタンスの [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] 名前空間の一部とは限らないためです。</span><span class="sxs-lookup"><span data-stu-id="4d27f-146">This is because the attached property is not necessarily part of the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] namespace for instances where the property is set.</span></span> <span data-ttu-id="4d27f-147">ただし、XAML の解析時に XAML プロセッサがその値を設定できる必要があります。</span><span class="sxs-lookup"><span data-stu-id="4d27f-147">However, a XAML processor must be able to set those values when XAML is parsed.</span></span> <span data-ttu-id="4d27f-148">有効な添付プロパティの使用をサポートする添付プロパティの所有者の種類は、フォームで専用のアクセサー メソッドを実装する必要があります**Get_PropertyName_** と**Set_PropertyName_** します。</span><span class="sxs-lookup"><span data-stu-id="4d27f-148">To support an effective attached property usage, the owner type of the attached property must implement dedicated accessor methods in the form **Get_PropertyName_** and **Set_PropertyName_**.</span></span> <span data-ttu-id="4d27f-149">この専用のアクセサー メソッドは、コード内の添付プロパティの取得/設定でも役立ちます。</span><span class="sxs-lookup"><span data-stu-id="4d27f-149">These dedicated accessor methods are also useful to get or set the attached property in code.</span></span> <span data-ttu-id="4d27f-150">コードの観点では、添付プロパティはプロパティ アクセサーではなくメソッド アクセサーを含むバッキング フィールドに似ており、そのバッキング フィールドは特に定義することなくすべてのオブジェクトに存在することができます。</span><span class="sxs-lookup"><span data-stu-id="4d27f-150">From a code perspective, an attached property is similar to a backing field that has method accessors instead of property accessors, and that backing field can exist on any object rather than needing to be specifically defined.</span></span>

<span data-ttu-id="4d27f-151">次の例は、コードに添付プロパティを設定する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="4d27f-151">The following example shows how you can set an attached property in code.</span></span> <span data-ttu-id="4d27f-152">この例で`myCheckBox`のインスタンスである、<xref:System.Windows.Controls.CheckBox>クラス。</span><span class="sxs-lookup"><span data-stu-id="4d27f-152">In this example, `myCheckBox` is an instance of the <xref:System.Windows.Controls.CheckBox> class.</span></span>

[!code-csharp[PropertiesOvwSupport#APCode](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml.cs#apcode)]
[!code-vb[PropertiesOvwSupport#APCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertiesOvwSupport/visualbasic/page4.xaml.vb#apcode)]

<span data-ttu-id="4d27f-153">同様に、XAML の場合する場合、`myCheckBox`としての子要素が既に追加されていなかった`myDockPanel`コードの 3 番目の行でコードの 4 行目は例外を発生させないがないプロパティの値とのやり取りを<xref:System.Windows.Controls.DockPanel>親と、それに伴って何も実行します。</span><span class="sxs-lookup"><span data-stu-id="4d27f-153">Similar to the XAML case, if `myCheckBox` had not already been added as a child element of `myDockPanel` by the third line of code, the fourth line of code would not raise an exception, but the property value would not interact with a <xref:System.Windows.Controls.DockPanel> parent and thus would do nothing.</span></span> <span data-ttu-id="4d27f-154">のみ、<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>値の存在し、子要素のセットを<xref:System.Windows.Controls.DockPanel>親要素によってレンダリングされたアプリケーションで有効な動作が発生します。</span><span class="sxs-lookup"><span data-stu-id="4d27f-154">Only a <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> value set on a child element combined with the presence of a <xref:System.Windows.Controls.DockPanel> parent element will cause an effective behavior in the rendered application.</span></span> <span data-ttu-id="4d27f-155">(この場合、添付プロパティを設定してからツリーに接続するか、</span><span class="sxs-lookup"><span data-stu-id="4d27f-155">(In this case, you could set the attached property, then attach to the tree.</span></span> <span data-ttu-id="4d27f-156">ツリーに接続してから添付プロパティを設定することができます。</span><span class="sxs-lookup"><span data-stu-id="4d27f-156">Or you could attach to the tree then set the attached property.</span></span> <span data-ttu-id="4d27f-157">どちらの操作でも、結果は同じです。)</span><span class="sxs-lookup"><span data-stu-id="4d27f-157">Either action order provides the same result.)</span></span>

## <span data-ttu-id="4d27f-158">添付プロパティのメタデータ <a name="attached_properties_metadata"></a></span><span class="sxs-lookup"><span data-stu-id="4d27f-158">Attached Property Metadata <a name="attached_properties_metadata"></a></span></span>

<span data-ttu-id="4d27f-159">プロパティを登録するときに<xref:System.Windows.FrameworkPropertyMetadata>プロパティがレンダリング、測定、そして具合にどのように影響するかどうかなど、プロパティの特性を指定に設定されます。</span><span class="sxs-lookup"><span data-stu-id="4d27f-159">When registering the property, <xref:System.Windows.FrameworkPropertyMetadata> is set to specify characteristics of the property, such as whether the property affects rendering, measurement, and so on.</span></span> <span data-ttu-id="4d27f-160">添付プロパティのメタデータは、一般的に依存関係プロパティとの違いがありません。</span><span class="sxs-lookup"><span data-stu-id="4d27f-160">Metadata for an attached property is generally no different than on a dependency property.</span></span> <span data-ttu-id="4d27f-161">オーバーライドの既定値を添付プロパティのメタデータに指定すると、その値がオーバーライドするクラスのインスタンスの暗黙的な添付プロパティの既定値になります。</span><span class="sxs-lookup"><span data-stu-id="4d27f-161">If you specify a default value in an override to attached property metadata, that value becomes the default value of the implicit attached property on instances of the overriding class.</span></span> <span data-ttu-id="4d27f-162">具体的には、一部のプロセスが添付プロパティの `Get` メソッド アクセサーを使用してそのプロパティの値のクエリを行った場合に、メタデータを指定したクラスのインスタンスが指定されており、その添付プロパティの値が設定されていないと、既定値がレポートされます。</span><span class="sxs-lookup"><span data-stu-id="4d27f-162">Specifically, your default value is reported if some process queries for the value of an attached property through the `Get` method accessor for that property, specifying an instance of the class where you specified the metadata, and the value for that attached property was otherwise not set.</span></span>

<span data-ttu-id="4d27f-163">プロパティでプロパティ値の継承を有効にする場合は、未接続の依存関係プロパティではなく添付プロパティを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4d27f-163">If you want to enable property value inheritance on a property, you should use attached properties rather than non-attached dependency properties.</span></span> <span data-ttu-id="4d27f-164">詳細については、「[プロパティ値の継承](property-value-inheritance.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="4d27f-164">For details, see [Property Value Inheritance](property-value-inheritance.md).</span></span>

## <span data-ttu-id="4d27f-165">カスタム添付プロパティ <a name="custom"></a></span><span class="sxs-lookup"><span data-stu-id="4d27f-165">Custom Attached Properties <a name="custom"></a></span></span>

### <span data-ttu-id="4d27f-166">添付プロパティを作成する場合 <a name="create_attached_properties"></a></span><span class="sxs-lookup"><span data-stu-id="4d27f-166">When to Create an Attached Property <a name="create_attached_properties"></a></span></span>

<span data-ttu-id="4d27f-167">添付プロパティは、定義クラスではないクラスで使用できるプロパティ設定機構を用意する理由がある場合に作成できます。</span><span class="sxs-lookup"><span data-stu-id="4d27f-167">You might create an attached property when there is a reason to have a property setting mechanism available for classes other than the defining class.</span></span> <span data-ttu-id="4d27f-168">この最も一般的なシナリオが、レイアウトです。</span><span class="sxs-lookup"><span data-stu-id="4d27f-168">The most common scenario for this is layout.</span></span> <span data-ttu-id="4d27f-169">既存のレイアウト プロパティの例は、 <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>、 <xref:System.Windows.Controls.Panel.ZIndex%2A?displayProperty=nameWithType>、および<xref:System.Windows.Controls.Canvas.Top%2A?displayProperty=nameWithType>します。</span><span class="sxs-lookup"><span data-stu-id="4d27f-169">Examples of existing layout properties are <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>, <xref:System.Windows.Controls.Panel.ZIndex%2A?displayProperty=nameWithType>, and <xref:System.Windows.Controls.Canvas.Top%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4d27f-170">これによって実現するシナリオは、レイアウト制御要素の子要素として存在する要素が、レイアウト親要素に対して個別にレイアウト要件を表現するというものです。親が添付プロパティとして定義したプロパティ値を、個々の子要素が設定します。</span><span class="sxs-lookup"><span data-stu-id="4d27f-170">The scenario enabled here is that elements that exist as child elements to layout-controlling elements are able to express layout requirements to their layout parent elements individually, each setting a property value that the parent defined as an attached property.</span></span>

<span data-ttu-id="4d27f-171">クラスがサービスを表しており、クラスでサービスをより透過的に統合できるようにしたい場合にも、添付プロパティを使用します。</span><span class="sxs-lookup"><span data-stu-id="4d27f-171">Another scenario for using an attached property is when your class represents a service, and you want classes to be able to integrate the service more transparently.</span></span>

<span data-ttu-id="4d27f-172">別のシナリオがなど、Visual Studio の WPF デザイナーのサポートを受けるにはまだ**プロパティ**ウィンドウを編集します。</span><span class="sxs-lookup"><span data-stu-id="4d27f-172">Yet another scenario is to receive Visual Studio WPF Designer support, such as **Properties** window editing.</span></span> <span data-ttu-id="4d27f-173">詳しくは、「[コントロールの作成の概要](../controls/control-authoring-overview.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="4d27f-173">For more information, see [Control Authoring Overview](../controls/control-authoring-overview.md).</span></span>

<span data-ttu-id="4d27f-174">前述のように、プロパティ値の継承を使用する場合には、添付プロパティを登録する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4d27f-174">As mentioned before, you should register as an attached property if you want to use property value inheritance.</span></span>

### <span data-ttu-id="4d27f-175">添付プロパティを作成する方法 <a name="how_do_i_create_attached_properties"></a></span><span class="sxs-lookup"><span data-stu-id="4d27f-175">How to Create an Attached Property <a name="how_do_i_create_attached_properties"></a></span></span>

<span data-ttu-id="4d27f-176">派生するクラスが必要ない場合、クラスが他の種類で使用する目的のみで添付プロパティを定義する<xref:System.Windows.DependencyObject>します。</span><span class="sxs-lookup"><span data-stu-id="4d27f-176">If your class is defining the attached property strictly for use on other types, then the class does not have to derive from <xref:System.Windows.DependencyObject>.</span></span> <span data-ttu-id="4d27f-177">派生する必要がある操作を行いますが、<xref:System.Windows.DependencyObject>の添付プロパティを依存関係プロパティでもある WPF の全体的なモデルに従う場合。</span><span class="sxs-lookup"><span data-stu-id="4d27f-177">But you do need to derive from <xref:System.Windows.DependencyObject> if you follow the overall WPF model of having your attached property also be a dependency property.</span></span>

<span data-ttu-id="4d27f-178">依存関係プロパティとして宣言することで、添付プロパティを定義、`public static readonly`型のフィールド<xref:System.Windows.DependencyProperty>します。</span><span class="sxs-lookup"><span data-stu-id="4d27f-178">Define your attached property as a dependency property by declaring a `public static readonly` field of type <xref:System.Windows.DependencyProperty>.</span></span> <span data-ttu-id="4d27f-179">戻り値を使用してこのフィールドを定義する、<xref:System.Windows.DependencyProperty.RegisterAttached%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="4d27f-179">You define this field by using the return value of the <xref:System.Windows.DependencyProperty.RegisterAttached%2A> method.</span></span> <span data-ttu-id="4d27f-180">フィールド名は文字列が付加され、添付プロパティの名前と一致する必要があります`Property`を表していると識別フィールドの名前付けの確立された WPF パターンに従います。</span><span class="sxs-lookup"><span data-stu-id="4d27f-180">The field name must match the attached property name, appended with the string `Property`, to follow the established WPF pattern of naming the identifying fields versus the properties that they represent.</span></span> <span data-ttu-id="4d27f-181">添付プロパティのプロバイダーは、静的にも提供する必要があります**Get_PropertyName_** と**Set_PropertyName_** ; 添付プロパティのアクセサー メソッド、プロパティに失敗が発生システムが添付プロパティを使用することができません。</span><span class="sxs-lookup"><span data-stu-id="4d27f-181">The attached property provider must also provide static **Get_PropertyName_** and **Set_PropertyName_** methods as accessors for the attached property; failing to do this will result in the property system being unable to use your attached property.</span></span>

> [!NOTE]
> <span data-ttu-id="4d27f-182">添付プロパティの get アクセサーを省略した場合、プロパティのデータ バインディングは、Visual Studio および Expression Blend などのデザイン ツールでは機能しません。</span><span class="sxs-lookup"><span data-stu-id="4d27f-182">If you omit the attached property's get accessor, data binding on the property will not work in design tools, such as Visual Studio and Expression Blend.</span></span>

#### <a name="the-get-accessor"></a><span data-ttu-id="4d27f-183">Get アクセサー</span><span class="sxs-lookup"><span data-stu-id="4d27f-183">The Get Accessor</span></span>

<span data-ttu-id="4d27f-184">署名、 **Get_PropertyName_** アクセサーを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4d27f-184">The signature for the **Get_PropertyName_** accessor must be:</span></span>

`public static object GetPropertyName(object target)`

- <span data-ttu-id="4d27f-185">`target` オブジェクトは、実装のより具体的な型として指定することができます。</span><span class="sxs-lookup"><span data-stu-id="4d27f-185">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="4d27f-186">たとえば、<xref:System.Windows.Controls.DockPanel.GetDock%2A?displayProperty=nameWithType>メソッドの型パラメーターとして<xref:System.Windows.UIElement>添付プロパティに設定する目的のみであるため、<xref:System.Windows.UIElement>インスタンス。</span><span class="sxs-lookup"><span data-stu-id="4d27f-186">For example, the <xref:System.Windows.Controls.DockPanel.GetDock%2A?displayProperty=nameWithType> method types the parameter as <xref:System.Windows.UIElement>, because the attached property is only intended to be set on <xref:System.Windows.UIElement> instances.</span></span>

- <span data-ttu-id="4d27f-187">戻り値は、実装のより具体的な型として指定することができます。</span><span class="sxs-lookup"><span data-stu-id="4d27f-187">The return value can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="4d27f-188">たとえば、<xref:System.Windows.Controls.DockPanel.GetDock%2A>メソッドの型としては<xref:System.Windows.Controls.Dock>のため、値は、その列挙体にのみ設定できます。</span><span class="sxs-lookup"><span data-stu-id="4d27f-188">For example, the <xref:System.Windows.Controls.DockPanel.GetDock%2A> method types it as <xref:System.Windows.Controls.Dock>, because the value can only be set to that enumeration.</span></span>

#### <a name="the-set-accessor"></a><span data-ttu-id="4d27f-189">Set アクセサー</span><span class="sxs-lookup"><span data-stu-id="4d27f-189">The Set Accessor</span></span>

<span data-ttu-id="4d27f-190">署名、 **Set_PropertyName_** アクセサーを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4d27f-190">The signature for the **Set_PropertyName_** accessor must be:</span></span>

`public static void SetPropertyName(object target, object value)`

- <span data-ttu-id="4d27f-191">`target` オブジェクトは、実装のより具体的な型として指定することができます。</span><span class="sxs-lookup"><span data-stu-id="4d27f-191">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="4d27f-192">たとえば、<xref:System.Windows.Controls.DockPanel.SetDock%2A>メソッドの型としては<xref:System.Windows.UIElement>添付プロパティに設定する目的のみであるため、<xref:System.Windows.UIElement>インスタンス。</span><span class="sxs-lookup"><span data-stu-id="4d27f-192">For example, the <xref:System.Windows.Controls.DockPanel.SetDock%2A> method types it as <xref:System.Windows.UIElement>, because the attached property is only intended to be set on <xref:System.Windows.UIElement> instances.</span></span>

- <span data-ttu-id="4d27f-193">`value` オブジェクトは、実装のより具体的な型として指定することができます。</span><span class="sxs-lookup"><span data-stu-id="4d27f-193">The `value` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="4d27f-194">たとえば、<xref:System.Windows.Controls.DockPanel.SetDock%2A>メソッドの型としては<xref:System.Windows.Controls.Dock>のため、値は、その列挙体にのみ設定できます。</span><span class="sxs-lookup"><span data-stu-id="4d27f-194">For example, the <xref:System.Windows.Controls.DockPanel.SetDock%2A> method types it as <xref:System.Windows.Controls.Dock>, because the value can only be set to that enumeration.</span></span> <span data-ttu-id="4d27f-195">このメソッドの値は、マークアップの添付プロパティの使用で添付プロパティが検出されたときに XAML ローダーから生じる入力であることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="4d27f-195">Remember that the value for this method is the input coming from the XAML loader when it encounters your attached property in an attached property usage in markup.</span></span> <span data-ttu-id="4d27f-196">この入力はマークアップの XAML 属性値として指定された値です。</span><span class="sxs-lookup"><span data-stu-id="4d27f-196">That input is the value specified as a XAML attribute value in markup.</span></span> <span data-ttu-id="4d27f-197">したがって、適切な型を属性値 (最終的には単なる文字列) から作成できるように、使用する型の型変換、値シリアライザー、またはマークアップ拡張サポートが必要です。</span><span class="sxs-lookup"><span data-stu-id="4d27f-197">Therefore there must be type conversion, value serializer, or markup extension support for the type you use, such that the appropriate type can be created from the attribute value (which is ultimately just a string).</span></span>

<span data-ttu-id="4d27f-198">次の例では、依存関係プロパティの登録 (を使用して、<xref:System.Windows.DependencyProperty.RegisterAttached%2A>メソッド)、だけでなく**Get_PropertyName_** と**Set_PropertyName_** アクセサー。</span><span class="sxs-lookup"><span data-stu-id="4d27f-198">The following example shows the dependency property registration (using the <xref:System.Windows.DependencyProperty.RegisterAttached%2A> method), as well as the **Get_PropertyName_** and **Set_PropertyName_** accessors.</span></span> <span data-ttu-id="4d27f-199">この例では、添付プロパティ名は `IsBubbleSource` です。</span><span class="sxs-lookup"><span data-stu-id="4d27f-199">In the example, the attached property name is `IsBubbleSource`.</span></span> <span data-ttu-id="4d27f-200">したがって、アクセサーの名前は `GetIsBubbleSource` および `SetIsBubbleSource` である必要があります。</span><span class="sxs-lookup"><span data-stu-id="4d27f-200">Therefore, the accessors must be named `GetIsBubbleSource` and `SetIsBubbleSource`.</span></span>

[!code-csharp[WPFAquariumSln#RegisterAttachedBubbler](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler)]
[!code-vb[WPFAquariumSln#RegisterAttachedBubbler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler)]

#### <a name="attached-property-attributes"></a><span data-ttu-id="4d27f-201">添付プロパティの属性</span><span class="sxs-lookup"><span data-stu-id="4d27f-201">Attached Property Attributes</span></span>

<span data-ttu-id="4d27f-202">WPF では、いくつかを定義します[!INCLUDE[TLA2#tla_netframewkattr#plural](../../../../includes/tla2sharptla-netframewkattrsharpplural-md.md)]添付プロパティをリフレクション プロセス、およびデザイナーなどのリフレクションおよびプロパティ情報の一般的なユーザーに関する情報を提供するためのものですが。</span><span class="sxs-lookup"><span data-stu-id="4d27f-202">WPF defines several [!INCLUDE[TLA2#tla_netframewkattr#plural](../../../../includes/tla2sharptla-netframewkattrsharpplural-md.md)] that are intended to provide information about attached properties to reflection processes, and to typical users of reflection and property information such as designers.</span></span> <span data-ttu-id="4d27f-203">添付プロパティに含まれる型は膨大な範囲に及ぶため、デザイナーには XAML を使用する特定のテクノロジの実装に定義されたすべての添付プロパティのグローバル リストがユーザーに表示されないようにするための手段が必要となります。</span><span class="sxs-lookup"><span data-stu-id="4d27f-203">Because attached properties have a type of unlimited scope, designers need a way to avoid overwhelming users with a global list of all the attached properties that are defined in a particular technology implementation that uses XAML.</span></span> <span data-ttu-id="4d27f-204">[!INCLUDE[TLA2#tla_netframewkattr#plural](../../../../includes/tla2sharptla-netframewkattrsharpplural-md.md)]その WPF を添付プロパティを使用して、スコープのプロパティ ウィンドウで特定の添付プロパティを表示する必要があります、状況を定義します。</span><span class="sxs-lookup"><span data-stu-id="4d27f-204">The [!INCLUDE[TLA2#tla_netframewkattr#plural](../../../../includes/tla2sharptla-netframewkattrsharpplural-md.md)] that WPF defines for attached properties can be used to scope the situations where a given attached property should be shown in a properties window.</span></span> <span data-ttu-id="4d27f-205">また、この属性をカスタム添付プロパティに適用するという選択肢もあります。</span><span class="sxs-lookup"><span data-stu-id="4d27f-205">You might consider applying these attributes for your own custom attached properties also.</span></span> <span data-ttu-id="4d27f-206">[!INCLUDE[TLA2#tla_netframewkattr#plural](../../../../includes/tla2sharptla-netframewkattrsharpplural-md.md)]の目的および構文は、次の参照ページに記載されています。</span><span class="sxs-lookup"><span data-stu-id="4d27f-206">The purpose and syntax of the [!INCLUDE[TLA2#tla_netframewkattr#plural](../../../../includes/tla2sharptla-netframewkattrsharpplural-md.md)] is described on the appropriate reference pages:</span></span>

- <xref:System.Windows.AttachedPropertyBrowsableAttribute>

- <xref:System.Windows.AttachedPropertyBrowsableForChildrenAttribute>

- <xref:System.Windows.AttachedPropertyBrowsableForTypeAttribute>

- <xref:System.Windows.AttachedPropertyBrowsableWhenAttributePresentAttribute>

## <span data-ttu-id="4d27f-207">添付プロパティの詳細情報 <a name="more"></a></span><span class="sxs-lookup"><span data-stu-id="4d27f-207">Learning More About Attached Properties <a name="more"></a></span></span>

- <span data-ttu-id="4d27f-208">添付プロパティの作成の詳細については、「[方法: 添付プロパティを登録する](how-to-register-an-attached-property.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="4d27f-208">For more information on creating an attached property, see [Register an Attached Property](how-to-register-an-attached-property.md).</span></span>

- <span data-ttu-id="4d27f-209">依存関係プロパティおよび添付プロパティの高度な使用シナリオについては、「[カスタム依存関係プロパティ](custom-dependency-properties.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="4d27f-209">For more advanced usage scenarios for dependency properties and attached properties, see [Custom Dependency Properties](custom-dependency-properties.md).</span></span>

- <span data-ttu-id="4d27f-210">プロパティは添付プロパティとしても依存関係プロパティとしても登録できますが、"ラッパー" 実装は公開したままにすることができます。</span><span class="sxs-lookup"><span data-stu-id="4d27f-210">You can also register a property as an attached property, and as a dependency property, but then still expose "wrapper" implementations.</span></span> <span data-ttu-id="4d27f-211">この場合、プロパティをその要素に設定することも、XAML の添付プロパティの構文を使用して任意の要素に設定することもできます。</span><span class="sxs-lookup"><span data-stu-id="4d27f-211">In this case, the property can be set either on that element, or on any element through the XAML attached property syntax.</span></span> <span data-ttu-id="4d27f-212">標準と接続の両方の使用状況を適切なシナリオでのプロパティの例は、<xref:System.Windows.FrameworkElement.FlowDirection%2A?displayProperty=nameWithType>します。</span><span class="sxs-lookup"><span data-stu-id="4d27f-212">An example of a property with an appropriate scenario for both standard and attached usages is <xref:System.Windows.FrameworkElement.FlowDirection%2A?displayProperty=nameWithType>.</span></span>

## <a name="see-also"></a><span data-ttu-id="4d27f-213">関連項目</span><span class="sxs-lookup"><span data-stu-id="4d27f-213">See also</span></span>

- <xref:System.Windows.DependencyProperty>
- [<span data-ttu-id="4d27f-214">依存関係プロパティの概要</span><span class="sxs-lookup"><span data-stu-id="4d27f-214">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="4d27f-215">カスタム依存関係プロパティ</span><span class="sxs-lookup"><span data-stu-id="4d27f-215">Custom Dependency Properties</span></span>](custom-dependency-properties.md)
- [<span data-ttu-id="4d27f-216">XAML の概要 (WPF)</span><span class="sxs-lookup"><span data-stu-id="4d27f-216">XAML Overview (WPF)</span></span>](xaml-overview-wpf.md)
- [<span data-ttu-id="4d27f-217">方法: 添付プロパティを登録する</span><span class="sxs-lookup"><span data-stu-id="4d27f-217">Register an Attached Property</span></span>](how-to-register-an-attached-property.md)