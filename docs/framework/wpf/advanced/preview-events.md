---
title: "プレビュー イベント"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-wpf
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- Preview events [WPF]
- suppressing events [WPF]
- events [WPF], Preview
- events [WPF], suppressing
ms.assetid: b5032308-aa9c-4d02-af11-630ecec8df7e
caps.latest.revision: "7"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.workload: dotnet
ms.openlocfilehash: a258a0e145e9a24e6e87bb511fdbd6166422a656
ms.sourcegitcommit: 16186c34a957fdd52e5db7294f291f7530ac9d24
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/22/2017
---
# <a name="preview-events"></a><span data-ttu-id="160e3-102">プレビュー イベント</span><span class="sxs-lookup"><span data-stu-id="160e3-102">Preview Events</span></span>
<span data-ttu-id="160e3-103">プレビュー イベントは、イベントのトンネリングとも呼ばれるは、イベントを発生し、イベント データのソースとして報告されている要素に対するアプリケーションのルートからのルートの方向の移動、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="160e3-103">Preview events, also known as tunneling events, are routed events where the direction of the route travels from the application root towards the element that raised the event and is reported as the source in event data.</span></span> <span data-ttu-id="160e3-104">すべてのイベント シナリオがサポートまたはプレビュー イベント; が必要このトピックでは、プレビュー イベントが存在、アプリケーションやコンポーネントを処理する方法、それらの状況と、カスタム コンポーネントまたはクラスでプレビュー イベントを作成する場合があります適切なケースについて説明します。</span><span class="sxs-lookup"><span data-stu-id="160e3-104">Not all event scenarios support or require preview events; this topic describes the situations where preview events exist, how applications or components should handle them, and cases where creating preview events in custom components or classes might be appropriate.</span></span>  
  
## <a name="preview-events-and-input"></a><span data-ttu-id="160e3-105">プレビュー イベントと入力</span><span class="sxs-lookup"><span data-stu-id="160e3-105">Preview Events and Input</span></span>  
 <span data-ttu-id="160e3-106">イベントは一般には注意してプレビューを処理する場合、イベントをマーク処理イベントのデータ。</span><span class="sxs-lookup"><span data-stu-id="160e3-106">When you handle Preview events in general, be cautious about marking the events handled in the event data.</span></span> <span data-ttu-id="160e3-107">以外の任意の要素でプレビュー イベントの処理 (イベント データのソースとして報告されている要素) を発生させた要素は、要素外の発生するイベントを処理する機会が提供されていないのです。</span><span class="sxs-lookup"><span data-stu-id="160e3-107">Handling a Preview event on any element other than the element that raised it (the element that is reported as the source in the event data) has the effect of not providing an element the opportunity to handle the event that it originated.</span></span> <span data-ttu-id="160e3-108">場合によってコントロールの複合内のリレーションシップに問題の要素が存在しない場合に特に目的の結果を示します。</span><span class="sxs-lookup"><span data-stu-id="160e3-108">Sometimes this is the desired result, particularly if the elements in question exist in relationships within the compositing of a control.</span></span>  
  
 <span data-ttu-id="160e3-109">入力イベントの具体的には、プレビュー イベントもイベント データのインスタンスと共有と同じバブル イベント。</span><span class="sxs-lookup"><span data-stu-id="160e3-109">For input events specifically, Preview events also share event data instances with the equivalent bubbling event.</span></span> <span data-ttu-id="160e3-110">プレビュー イベントのクラスのハンドラーを使用して処理する入力イベントをマークする場合、バブルの入力イベント クラスのハンドラーは呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="160e3-110">If you use a Preview event class handler to mark the input event handled, the bubbling input event class handler will not be invoked.</span></span> <span data-ttu-id="160e3-111">または、プレビュー イベントのインスタンス ハンドラーを使用してイベントを処理済みのマークする場合、バブルのイベントのハンドラーは通常呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="160e3-111">Or, if you use a Preview event instance handler to mark the event handled, handlers for the bubbling event will not typically be invoked.</span></span> <span data-ttu-id="160e3-112">クラス ハンドラーまたはインスタンス ハンドラーを登録またはアタッチする手法は通常使用されませんが、イベントが処理される、マークされている場合でも呼び出されるオプションです。</span><span class="sxs-lookup"><span data-stu-id="160e3-112">Class handlers or instance handlers can be registered or attached with an option to be invoked even if the event is marked handled, but that technique is not commonly used.</span></span>  
  
 <span data-ttu-id="160e3-113">クラスの処理とプレビュー イベントに関連する方法の詳細については、次を参照してください。 [Handled、クラス処理とルーティング イベントをマーク](../../../../docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md)です。</span><span class="sxs-lookup"><span data-stu-id="160e3-113">For more information about class handling and how it relates to Preview events see [Marking Routed Events as Handled, and Class Handling](../../../../docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md).</span></span>  
  
### <a name="working-around-event-suppression-by-controls"></a><span data-ttu-id="160e3-114">コントロールによるイベント抑制の回避</span><span class="sxs-lookup"><span data-stu-id="160e3-114">Working Around Event Suppression by Controls</span></span>  
 <span data-ttu-id="160e3-115">プレビュー イベントは一般的に使用されている 1 つのシナリオでは、入力イベントの複合コントロールの処理です。</span><span class="sxs-lookup"><span data-stu-id="160e3-115">One scenario where Preview events are commonly used is for composited control handling of input events.</span></span> <span data-ttu-id="160e3-116">場合によっては、コントロールの作成者は、コンポーネント定義のイベント詳細についてを実行するかより具体的な動作を表すを置換するために、そのコントロールから送信されたから特定のイベントを抑制します。</span><span class="sxs-lookup"><span data-stu-id="160e3-116">Sometimes, the author of the control suppresses a certain event from originating from their control, perhaps in order to substitute a component-defined event that carries more information or implies a more specific behavior.</span></span> <span data-ttu-id="160e3-117">インスタンス、 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button>抑制<xref:System.Windows.UIElement.MouseLeftButtonDown>と<xref:System.Windows.UIElement.MouseLeftButtonDown>によって生成されるバブルのイベント、<xref:System.Windows.Controls.Button>またはその複合要素にマウスをキャプチャして、発生を優先するため、<xref:System.Windows.Controls.Primitives.ButtonBase.Click>によって常に発生するイベントを<xref:System.Windows.Controls.Button>自体です。</span><span class="sxs-lookup"><span data-stu-id="160e3-117">For instance, a [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button> suppresses <xref:System.Windows.UIElement.MouseLeftButtonDown> and <xref:System.Windows.UIElement.MouseLeftButtonDown> bubbling events raised by the <xref:System.Windows.Controls.Button> or its composite elements in favor of capturing the mouse and raising a <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event that is always raised by the <xref:System.Windows.Controls.Button> itself.</span></span> <span data-ttu-id="160e3-118">イベントとそのデータ、ルートで引き続きするので、 <xref:System.Windows.Controls.Button> 、イベント データをマーク<xref:System.Windows.RoutedEventArgs.Handled%2A>、のみ、イベントのハンドラーを示す具体的で動作する、`handledEventsToo`ケースが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="160e3-118">The event and its data still continue along the route, but because the <xref:System.Windows.Controls.Button> marks the event data as <xref:System.Windows.RoutedEventArgs.Handled%2A>, only handlers for the event that specifically indicated they should act in the `handledEventsToo` case  are invoked.</span></span>  <span data-ttu-id="160e3-119">1 つの代替手段がコードでのハンドラーをアタッチするには、アプリケーションのルートに近い方には、その他の要素も必要がある場合、コントロールで抑制されたイベントを処理する、`handledEventsToo`として指定された`true`です。</span><span class="sxs-lookup"><span data-stu-id="160e3-119">If other elements towards the root of your application still wanted an opportunity to handle a control-suppressed event, one alternative is to attach handlers in code with `handledEventsToo` specified as `true`.</span></span> <span data-ttu-id="160e3-120">入力イベントの プレビューと同等に処理するルーティングの方向を変更する簡単な手法は、多くの場合。</span><span class="sxs-lookup"><span data-stu-id="160e3-120">But often a simpler technique is to change the routing direction you handle to be the Preview equivalent of an input event.</span></span> <span data-ttu-id="160e3-121">インスタンスの場合は、コントロールを抑制<xref:System.Windows.UIElement.MouseLeftButtonDown>のハンドラーを添付してみてください<xref:System.Windows.UIElement.PreviewMouseLeftButtonDown>代わりにします。</span><span class="sxs-lookup"><span data-stu-id="160e3-121">For instance, if a control suppresses <xref:System.Windows.UIElement.MouseLeftButtonDown>, try attaching a handler for <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> instead.</span></span> <span data-ttu-id="160e3-122">この手法だけが、基本要素の入力イベントなど<xref:System.Windows.UIElement.MouseLeftButtonDown>です。</span><span class="sxs-lookup"><span data-stu-id="160e3-122">This technique only works for base element input events such as <xref:System.Windows.UIElement.MouseLeftButtonDown>.</span></span> <span data-ttu-id="160e3-123">これらの入力イベントは、トンネル/バブルのペアを使用して、両方のイベントを発生させるし、イベント データを共有します。</span><span class="sxs-lookup"><span data-stu-id="160e3-123">These input events use tunnel/bubble pairs, raise both events, and share the event data.</span></span>  
  
 <span data-ttu-id="160e3-124">これらの手法のそれぞれは、副作用または制限事項のいずれかにあります。</span><span class="sxs-lookup"><span data-stu-id="160e3-124">Each of these techniques has either side effects or limitations.</span></span> <span data-ttu-id="160e3-125">プレビュー イベントの処理の有効であること、バブルのイベントを処理するハンドラーが無効にその時点でイベントを処理であるため、制限することは通常、Previ のままである間に処理されるイベントをマークすることをお勧めルートの新しい部分。</span><span class="sxs-lookup"><span data-stu-id="160e3-125">The side effect of handling the Preview event is that handling the event at that point might disable handlers that expect to handle the bubbling event, and therefore the limitation is that it is usually not a good idea to mark the event handled while it is still on the Preview part of the route.</span></span> <span data-ttu-id="160e3-126">制限事項、`handledEventsToo`手法は指定できません、`handledEventsToo`ハンドラー[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]を属性として登録する必要あります、イベント ハンドラー コードでハンドラーがアタッチするのには、要素へのオブジェクト参照を取得した後にします。</span><span class="sxs-lookup"><span data-stu-id="160e3-126">The limitation of the `handledEventsToo` technique is that you cannot specify a `handledEventsToo` handler in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] as an attribute, you must register the event handler in code after obtaining an object reference to the element where the handler is to be attached.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="160e3-127">参照</span><span class="sxs-lookup"><span data-stu-id="160e3-127">See Also</span></span>  
 [<span data-ttu-id="160e3-128">ルーティング イベントの処理済みとしてのマーキング、およびクラス処理</span><span class="sxs-lookup"><span data-stu-id="160e3-128">Marking Routed Events as Handled, and Class Handling</span></span>](../../../../docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md)  
 [<span data-ttu-id="160e3-129">ルーティング イベントの概要</span><span class="sxs-lookup"><span data-stu-id="160e3-129">Routed Events Overview</span></span>](../../../../docs/framework/wpf/advanced/routed-events-overview.md)
