---
title: WPF のツリー
ms.date: 03/30/2017
helpviewer_keywords:
- logical tree [WPF]
- element tree [WPF]
- visual tree [WPF]
ms.assetid: e83f25e5-d66b-4fc7-92d2-50130c9a6649
ms.openlocfilehash: e7695fa94a7742d474cb998ff26a5cf009cdb6eb
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/04/2018
ms.locfileid: "33549073"
---
# <a name="trees-in-wpf"></a><span data-ttu-id="52460-102">WPF のツリー</span><span class="sxs-lookup"><span data-stu-id="52460-102">Trees in WPF</span></span>
<span data-ttu-id="52460-103">多くのテクノロジ要素とコンポーネントは、開発者が直接レンダリングやアプリケーションの動作に影響を与えるツリー内のオブジェクト ノードを操作をツリー構造に編成されています。</span><span class="sxs-lookup"><span data-stu-id="52460-103">In many technologies, elements and components are organized in a tree structure where developers directly manipulate the object nodes in the tree to affect the rendering or behavior of an application.</span></span> [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]<span data-ttu-id="52460-104"> プログラム要素間のリレーションシップを定義するのにいくつかのツリー構造体要素を使用します。</span><span class="sxs-lookup"><span data-stu-id="52460-104"> also uses several tree structure metaphors to define relationships between program elements.</span></span> <span data-ttu-id="52460-105">WPF の開発者の大部分できますコードでアプリケーションを作成またはオブジェクト ツリーの比喩、概念的には検討中に XAML で、アプリケーションの部分を定義するが、特定の API を呼び出すか、いくつかの一般的なのではなく、そのために特定のマークアップを使用します。XML DOM で使用するなどのオブジェクト ツリー操作 API</span><span class="sxs-lookup"><span data-stu-id="52460-105">For the most part WPF developers can create an application in code or define portions of the application in XAML while thinking conceptually about the object tree metaphor, but will be calling specific API or using specific markup to do so rather than some general object tree manipulation API such as you might use in XML DOM.</span></span> <span data-ttu-id="52460-106">WPF は、ツリーの比喩ビューを提供する 2 つのヘルパー クラスを公開<xref:System.Windows.LogicalTreeHelper>と<xref:System.Windows.Media.VisualTreeHelper>です。</span><span class="sxs-lookup"><span data-stu-id="52460-106">WPF exposes two helper classes that provide a tree metaphor view, <xref:System.Windows.LogicalTreeHelper> and <xref:System.Windows.Media.VisualTreeHelper>.</span></span> <span data-ttu-id="52460-107">用語のビジュアル ツリーおよび論理ツリーも使われます、WPF ドキュメントのため、これらの同じツリーが特定のキーの WPF 機能の動作を理解するのに便利です。</span><span class="sxs-lookup"><span data-stu-id="52460-107">The terms visual tree and logical tree are also used in the WPF documentation because these same trees are useful for understanding the behavior of certain key WPF features.</span></span> <span data-ttu-id="52460-108">このトピックは、ビジュアル ツリーおよび論理ツリーを表す新機能を定義し、このようなツリーが、全体的なオブジェクトのツリーの概念に関連する方法について説明しますが導入されています<xref:System.Windows.LogicalTreeHelper>と<xref:System.Windows.Media.VisualTreeHelper>s。</span><span class="sxs-lookup"><span data-stu-id="52460-108">This topic defines what the visual tree and logical tree represent, discusses how such trees relate to an overall object tree concept, and introduces <xref:System.Windows.LogicalTreeHelper> and <xref:System.Windows.Media.VisualTreeHelper>s.</span></span>  
  

  
<a name="element_tree"></a>   
## <a name="trees-in-wpf"></a><span data-ttu-id="52460-109">WPF のツリー</span><span class="sxs-lookup"><span data-stu-id="52460-109">Trees in WPF</span></span>  
 <span data-ttu-id="52460-110">最も包括的なツリー構造[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]オブジェクト ツリーです。</span><span class="sxs-lookup"><span data-stu-id="52460-110">The most complete tree structure in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is the object tree.</span></span> <span data-ttu-id="52460-111">アプリケーション ページを定義する場合[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]し、ロード、[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]マークアップ内の要素の入れ子のリレーションシップに基づいてツリー構造が作成されます。</span><span class="sxs-lookup"><span data-stu-id="52460-111">If you define an application page in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] and then load the [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], the tree structure is created based on the nesting relationships of the elements in the markup.</span></span> <span data-ttu-id="52460-112">アプリケーションを定義するか、コードでは、アプリケーション、ツリー構造の一部が作成された場合は、特定のオブジェクトのコンテンツ モデルを実装するプロパティのプロパティ値を割り当てる方法に基づいています。</span><span class="sxs-lookup"><span data-stu-id="52460-112">If you define an application or a portion of the application in code, then the tree structure is created based on how you assign property values for properties that implement the content model for a given object.</span></span> <span data-ttu-id="52460-113">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]、完全なオブジェクト ツリーを概念化し、パブリック API に報告できる 2 つの方法がある: ビジュアル ツリーおよび論理ツリーとして。</span><span class="sxs-lookup"><span data-stu-id="52460-113">In [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], there are two ways that the complete object tree is conceptualized and can be reported to its public API: as the logical tree and as the visual tree.</span></span> <span data-ttu-id="52460-114">論理ツリーとビジュアル ツリーの違いは、必ずしも必ずしも重要が特定の問題が発生することができる場合によっては、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]サブシステムとマークアップやコードで選択したに影響します。</span><span class="sxs-lookup"><span data-stu-id="52460-114">The distinctions between logical tree and visual tree are not always necessarily important, but they can occasionally cause issues with certain [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] subsystems and affect choices you make in markup or code.</span></span>  
  
 <span data-ttu-id="52460-115">いない常に、論理ツリーまたはビジュアル ツリーを直接操作する場合でも、ツリーの操作方法の概念を理解するはテクノロジとして WPF を理解するために役立ちます。</span><span class="sxs-lookup"><span data-stu-id="52460-115">Even though you do not always manipulate either the logical tree or the visual tree directly, understanding the concepts of how the trees interact is useful for understanding WPF as a technology.</span></span> <span data-ttu-id="52460-116">WPF ツリーの比喩、ある種が非常に重要のプロパティの継承とイベントのルーティングのしくみを理解することにもとして見なすこと[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]です。</span><span class="sxs-lookup"><span data-stu-id="52460-116">Thinking of WPF as a tree metaphor of some kind is also crucial to understanding how property inheritance and event routing work in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="52460-117">オブジェクト ツリーは、実際の API の概念の詳細であるため、オブジェクト グラフは概念について考えるを別の方法です。</span><span class="sxs-lookup"><span data-stu-id="52460-117">Because the object tree is more of a concept than an actual API, another way to think of the concept is as an object graph.</span></span> <span data-ttu-id="52460-118">実際には、リレーションシップの間はツリーの比喩が分割が実行時のオブジェクトです。</span><span class="sxs-lookup"><span data-stu-id="52460-118">In practice, there are relationships between objects at run time where the tree metaphor will break down.</span></span> <span data-ttu-id="52460-119">ただし、特に XAML で定義された UI を備えた、ツリーの比喩は関連この一般的な概念を参照するときに、ほとんどの WPF のドキュメントがオブジェクト ツリーのという用語を使用します。</span><span class="sxs-lookup"><span data-stu-id="52460-119">Nevertheless, particularly with XAML-defined UI, the tree metaphor is relevant enough that most WPF documentation will use the term object tree when referencing this general concept.</span></span>  
  
<a name="logical_tree"></a>   
## <a name="the-logical-tree"></a><span data-ttu-id="52460-120">論理ツリー</span><span class="sxs-lookup"><span data-stu-id="52460-120">The Logical Tree</span></span>  
 <span data-ttu-id="52460-121">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]をそれらの要素を格納するオブジェクトのプロパティを設定して、UI 要素にコンテンツを追加します。</span><span class="sxs-lookup"><span data-stu-id="52460-121">In [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], you add content to UI elements by setting properties of the objects that back those elements.</span></span> <span data-ttu-id="52460-122">項目を追加するなど、<xref:System.Windows.Controls.ListBox>コントロールを操作することでその<xref:System.Windows.Controls.ItemsControl.Items%2A>プロパティです。</span><span class="sxs-lookup"><span data-stu-id="52460-122">For example, you add items to a <xref:System.Windows.Controls.ListBox> control by manipulating its <xref:System.Windows.Controls.ItemsControl.Items%2A> property.</span></span> <span data-ttu-id="52460-123">これによりにアイテムを配置する、<xref:System.Windows.Controls.ItemCollection>されている、<xref:System.Windows.Controls.ItemsControl.Items%2A>プロパティの値。</span><span class="sxs-lookup"><span data-stu-id="52460-123">By doing this, you are placing items into the <xref:System.Windows.Controls.ItemCollection> that is the <xref:System.Windows.Controls.ItemsControl.Items%2A> property value.</span></span> <span data-ttu-id="52460-124">同様に、追加するオブジェクトを<xref:System.Windows.Controls.DockPanel>を操作することでその<xref:System.Windows.Controls.Panel.Children%2A>プロパティの値。</span><span class="sxs-lookup"><span data-stu-id="52460-124">Similarly, to add objects to a <xref:System.Windows.Controls.DockPanel>, you manipulate its <xref:System.Windows.Controls.Panel.Children%2A> property value.</span></span> <span data-ttu-id="52460-125">ここでは、オブジェクトを追加する、<xref:System.Windows.Controls.UIElementCollection>です。</span><span class="sxs-lookup"><span data-stu-id="52460-125">Here, you are adding objects to the <xref:System.Windows.Controls.UIElementCollection>.</span></span> <span data-ttu-id="52460-126">コード例は、次を参照してください。 [、要素を動的に追加](http://msdn.microsoft.com/library/d00f258a-7973-4de7-bc54-a3fc1f638419)です。</span><span class="sxs-lookup"><span data-stu-id="52460-126">For a code example, see [Add an Element Dynamically](http://msdn.microsoft.com/library/d00f258a-7973-4de7-bc54-a3fc1f638419).</span></span>  
  
 <span data-ttu-id="52460-127">[!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)]でリスト項目を配置するとき、<xref:System.Windows.Controls.ListBox>コントロールまたはその他の UI 要素で、 <xref:System.Windows.Controls.DockPanel>、使用することも、<xref:System.Windows.Controls.ItemsControl.Items%2A>と<xref:System.Windows.Controls.Panel.Children%2A>プロパティ、明示的または暗黙的に、次の例のようにです。</span><span class="sxs-lookup"><span data-stu-id="52460-127">In [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)], when you place list items in a <xref:System.Windows.Controls.ListBox> or controls or other UI elements in a <xref:System.Windows.Controls.DockPanel>, you also use the <xref:System.Windows.Controls.ItemsControl.Items%2A> and <xref:System.Windows.Controls.Panel.Children%2A> properties, either explicitly or implicitly, as in the following example.</span></span>  
  
 [!code-xaml[TreeOvwsSupport#AllCode](../../../../samples/snippets/csharp/VS_Snippets_Wpf/TreeOvwsSupport/CS/page1.xaml#allcode)]  
  
 <span data-ttu-id="52460-128">かどうかとして XML ドキュメント オブジェクト モデルでは、次の XAML を処理するコメント タグが含まれていたかどうか、アウト暗黙的な (これが有効な)、結果の XML DOM ツリーに要素が含まれますが、`<ListBox.Items>`およびその他の暗黙的な項目です。</span><span class="sxs-lookup"><span data-stu-id="52460-128">If you were to process this XAML as XML under a document object model, and if you had included the tags commented out as implicit (which would have been legal), then the resulting XML DOM tree would have included elements for `<ListBox.Items>` and the other implicit items.</span></span> <span data-ttu-id="52460-129">XAML を処理しないようにして、マークアップを読み取るし、オブジェクトを書き込むときに、生成されたオブジェクト グラフには文字どおりは含まれませんが、`ListBox.Items`です。</span><span class="sxs-lookup"><span data-stu-id="52460-129">But XAML does not process that way when you read the markup and write to objects, the resulting object graph does not literally include `ListBox.Items`.</span></span> <span data-ttu-id="52460-130">ただしが、<xref:System.Windows.Controls.ListBox>という名前のプロパティ`Items`を格納している、 <xref:System.Windows.Controls.ItemCollection>、および<xref:System.Windows.Controls.ItemCollection>は初期化されますが、空のときに、 <xref:System.Windows.Controls.ListBox> XAML を処理します。</span><span class="sxs-lookup"><span data-stu-id="52460-130">It does however have a <xref:System.Windows.Controls.ListBox> property named `Items` that contains a <xref:System.Windows.Controls.ItemCollection>, and that <xref:System.Windows.Controls.ItemCollection> is initialized but empty when the <xref:System.Windows.Controls.ListBox> XAML is processed.</span></span> <span data-ttu-id="52460-131">次に、各子オブジェクト要素のコンテンツとして存在する、<xref:System.Windows.Controls.ListBox>に追加、<xref:System.Windows.Controls.ItemCollection>パーサーの呼び出しで`ItemCollection.Add`です。</span><span class="sxs-lookup"><span data-stu-id="52460-131">Then, each child object element that exists as content for the <xref:System.Windows.Controls.ListBox> is added to the <xref:System.Windows.Controls.ItemCollection> by parser calls to `ItemCollection.Add`.</span></span> <span data-ttu-id="52460-132">オブジェクト ツリーに XAML の処理には、この例はこれまで一見例で作成されたオブジェクト ツリーは、基本的に論理ツリーです。</span><span class="sxs-lookup"><span data-stu-id="52460-132">This example of processing XAML into an object tree is so far seemingly an example where the created object tree is basically the logical tree.</span></span>  
  
 <span data-ttu-id="52460-133">ただし、論理ツリーは、オブジェクト グラフ全体の XAML の暗黙的な構文項目を使用しても、実行時に UI が除外されているアプリケーションが存在するではありません。主な理由は、ビジュアルとテンプレート。</span><span class="sxs-lookup"><span data-stu-id="52460-133">However, the logical tree is not the entire object graph that exists for your application UI at run time, even with the XAML implicit syntax items factored out. The main reason for this is visuals and templates.</span></span> <span data-ttu-id="52460-134">たとえば、<xref:System.Windows.Controls.Button>です。</span><span class="sxs-lookup"><span data-stu-id="52460-134">For example, consider the <xref:System.Windows.Controls.Button>.</span></span> <span data-ttu-id="52460-135">論理ツリーのレポート、<xref:System.Windows.Controls.Button>オブジェクトともその文字列`Content`です。</span><span class="sxs-lookup"><span data-stu-id="52460-135">The logical tree reports the <xref:System.Windows.Controls.Button> object and also its string `Content`.</span></span> <span data-ttu-id="52460-136">実行時のオブジェクト ツリーで、このボタンに詳細があります。</span><span class="sxs-lookup"><span data-stu-id="52460-136">But there is more to this button in the run-time object tree.</span></span> <span data-ttu-id="52460-137">具体的には、ボタンのみ画面に表示されますがあるため、特定<xref:System.Windows.Controls.Button>コントロール テンプレートを適用します。</span><span class="sxs-lookup"><span data-stu-id="52460-137">In particular, the button only appears on screen the way it does because a specific <xref:System.Windows.Controls.Button> control template was applied.</span></span> <span data-ttu-id="52460-138">テンプレートを適用したに由来するビジュアル (テンプレートで定義されたなど<xref:System.Windows.Controls.Border>ビジュアル ボタンを囲む濃い灰色の) 場合でも、実行時に、論理ツリーを見ることが、論理ツリーには報告されません (からの入力イベントの処理など、表示される UI および論理ツリーを読み取り)。</span><span class="sxs-lookup"><span data-stu-id="52460-138">The visuals that come from an applied template (such as the template-defined <xref:System.Windows.Controls.Border> of dark gray around the visual button) are not reported in the logical tree, even if you are looking at the logical tree during run time (such as handling an input event from the visible UI and then reading the logical tree).</span></span> <span data-ttu-id="52460-139">テンプレートのビジュアルを検索するには、代わりに、ビジュアル ツリーを検査する必要なります。</span><span class="sxs-lookup"><span data-stu-id="52460-139">To find the template visuals, you would instead need to examine the visual tree.</span></span>  
  
 <span data-ttu-id="52460-140">方法の詳細についての[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]、作成されたオブジェクト グラフと XAML では、暗黙的な構文に構文のマップを参照してください[XAML 構文の詳細](../../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md)または[XAML の概要 (WPF)](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md)です。</span><span class="sxs-lookup"><span data-stu-id="52460-140">For more information about how [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] syntax maps to the created object graph, and implicit syntax in XAML, see [XAML Syntax In Detail](../../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md) or [XAML Overview (WPF)](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md).</span></span>  
  
<a name="tree_property_inheritance_event_routing"></a>   
### <a name="the-purpose-of-the-logical-tree"></a><span data-ttu-id="52460-141">論理ツリーの目的は、</span><span class="sxs-lookup"><span data-stu-id="52460-141">The Purpose of the Logical Tree</span></span>  
 <span data-ttu-id="52460-142">論理ツリーには、コンテンツ モデルは、それらの使用可能な子オブジェクトを簡単に反復処理できますのでこと、およびコンテンツ モデルの拡張が存在しています。</span><span class="sxs-lookup"><span data-stu-id="52460-142">The logical tree exists so that content models can readily iterate over their possible child objects, and so that content models can be extensible.</span></span> <span data-ttu-id="52460-143">また、論理ツリー フレームワークを提供、特定の論理ツリー内のすべてのオブジェクトが読み込まれるときになど、通知します。</span><span class="sxs-lookup"><span data-stu-id="52460-143">Also, the logical tree provides a framework for certain notifications, such as when all objects in the logical tree are loaded.</span></span> <span data-ttu-id="52460-144">基本的には、論理ツリーには、フレームワーク レベルで、ビジュアルは含まれませんが、独自の実行時のアプリケーションの合成に対する多くのクエリ処理の適切な実行時のオブジェクト グラフの近似値です。</span><span class="sxs-lookup"><span data-stu-id="52460-144">Basically, the logical tree is an approximation of a run time object graph at the framework level, which excludes visuals, but is adequate for many querying operations against your own run time application's composition.</span></span>  
  
 <span data-ttu-id="52460-145">論理ツリーを上へ検索で両方の静的および動的リソース参照を解決するさらに、<xref:System.Windows.FrameworkElement.Resources%2A>のコレクションに、初期要求側のオブジェクト、および論理ツリーを続行し、各<xref:System.Windows.FrameworkElement>(または<xref:System.Windows.FrameworkContentElement>)別の`Resources`値を含む、 <xref:System.Windows.ResourceDictionary>、そのキーを含む可能性があります。</span><span class="sxs-lookup"><span data-stu-id="52460-145">In addition, both static and dynamic resource references are resolved by looking upwards through the logical tree for <xref:System.Windows.FrameworkElement.Resources%2A> collections on the initial requesting object, and then continuing up the logical tree and checking each <xref:System.Windows.FrameworkElement> (or <xref:System.Windows.FrameworkContentElement>) for another `Resources` value that contains a <xref:System.Windows.ResourceDictionary>, possibly containing that key.</span></span> <span data-ttu-id="52460-146">論理ツリーとビジュアル ツリーの両方が存在する場合は、論理ツリーをリソースの検索に使用されます。</span><span class="sxs-lookup"><span data-stu-id="52460-146">The logical tree is used for resource lookup when both the logical tree and the visual tree are present.</span></span> <span data-ttu-id="52460-147">リソース ディクショナリと照合の詳細については、次を参照してください。 [XAML リソース](../../../../docs/framework/wpf/advanced/xaml-resources.md)です。</span><span class="sxs-lookup"><span data-stu-id="52460-147">For more information on resource dictionaries and lookup, see [XAML Resources](../../../../docs/framework/wpf/advanced/xaml-resources.md).</span></span>  
  
<a name="composition"></a>   
### <a name="composition-of-the-logical-tree"></a><span data-ttu-id="52460-148">論理ツリーの合成</span><span class="sxs-lookup"><span data-stu-id="52460-148">Composition of the Logical Tree</span></span>  
 <span data-ttu-id="52460-149">論理ツリーが、WPF フレームワーク レベル、つまり論理ツリーの操作に最も関連性は、WPF の基本要素はいずれかで定義されている<xref:System.Windows.FrameworkElement>または<xref:System.Windows.FrameworkContentElement>です。</span><span class="sxs-lookup"><span data-stu-id="52460-149">The logical tree is defined at the WPF framework-level, which means that the WPF base element that is most relevant for logical tree operations is either <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>.</span></span> <span data-ttu-id="52460-150">ただし、することができますを参照してくださいかどうかは実際に使用する、 <xref:System.Windows.LogicalTreeHelper> API、論理ツリー場合もありますノードが含まれていないか<xref:System.Windows.FrameworkElement>または<xref:System.Windows.FrameworkContentElement>です。</span><span class="sxs-lookup"><span data-stu-id="52460-150">However, as you can see if you actually use the <xref:System.Windows.LogicalTreeHelper> API, the logical tree sometimes contains nodes that are not either <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>.</span></span> <span data-ttu-id="52460-151">論理ツリーのインスタンスのレポート、<xref:System.Windows.Controls.TextBlock.Text%2A>の値、 <xref:System.Windows.Controls.TextBlock>、された文字列します。</span><span class="sxs-lookup"><span data-stu-id="52460-151">For instance, the logical tree reports the <xref:System.Windows.Controls.TextBlock.Text%2A> value of a <xref:System.Windows.Controls.TextBlock>, which is a string.</span></span>  
  
<a name="override_logical_tree"></a>   
### <a name="overriding-the-logical-tree"></a><span data-ttu-id="52460-152">論理ツリーのオーバーライド</span><span class="sxs-lookup"><span data-stu-id="52460-152">Overriding the Logical Tree</span></span>  
 <span data-ttu-id="52460-153">高度なコントロールの作成者がいくつかの操作をオーバーライドすることで、論理ツリーをオーバーライドできます[!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)]一般的なオブジェクトまたはコンテンツ モデルが追加または論理ツリー内のオブジェクトを削除する方法を定義します。</span><span class="sxs-lookup"><span data-stu-id="52460-153">Advanced control authors can override the logical tree by overriding several [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] that define how a general object or content model adds or removes objects within the logical tree.</span></span> <span data-ttu-id="52460-154">論理ツリーをオーバーライドする方法の例は、次を参照してください。[論理ツリーをオーバーライドする](../../../../docs/framework/wpf/advanced/how-to-override-the-logical-tree.md)です。</span><span class="sxs-lookup"><span data-stu-id="52460-154">For an example of how to override the logical tree, see [Override the Logical Tree](../../../../docs/framework/wpf/advanced/how-to-override-the-logical-tree.md).</span></span>  
  
<a name="pvi"></a>   
### <a name="property-value-inheritance"></a><span data-ttu-id="52460-155">プロパティ値の継承</span><span class="sxs-lookup"><span data-stu-id="52460-155">Property Value Inheritance</span></span>  
 <span data-ttu-id="52460-156">プロパティ値の継承は、ハイブリッド ツリーを通じて動作します。</span><span class="sxs-lookup"><span data-stu-id="52460-156">Property value inheritance operates through a hybrid tree.</span></span> <span data-ttu-id="52460-157">実際のメタデータを含む、<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>プロパティをプロパティの継承を有効にするには、WPF フレームワーク レベル<xref:System.Windows.FrameworkPropertyMetadata>クラスです。</span><span class="sxs-lookup"><span data-stu-id="52460-157">The actual metadata that contains the <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> property that enables property inheritance is the WPF framework-level <xref:System.Windows.FrameworkPropertyMetadata> class.</span></span> <span data-ttu-id="52460-158">したがって、元の値を保持する親とその値を継承する子オブジェクトの両方両方あります<xref:System.Windows.FrameworkElement>または<xref:System.Windows.FrameworkContentElement>、それら両方を指定する必要な論理ツリーの一部とします。</span><span class="sxs-lookup"><span data-stu-id="52460-158">Therefore, both the parent that holds the original value and the child object that inherits that value must both be <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>, and they must both be part of some logical tree.</span></span> <span data-ttu-id="52460-159">ただし、プロパティの継承をサポートする既存の WPF プロパティ、プロパティ値の継承が論理ツリーに含まれていない間にあるオブジェクトを永続化することです。</span><span class="sxs-lookup"><span data-stu-id="52460-159">However, for existing WPF properties that support property inheritance, property value inheritance is able to perpetuate through an intervening object that is not in the logical tree.</span></span> <span data-ttu-id="52460-160">主にですが、テンプレート化されているインスタンスのいずれかに設定されている継承されたプロパティ値を使用して要素がテンプレートまたはページ レベルの構成のさらに高いレベルで論理ツリー内の上位。</span><span class="sxs-lookup"><span data-stu-id="52460-160">Mainly this is relevant for having template elements use any inherited property values set either on the instance that is templated, or at still higher levels of page-level composition and therefore higher in the logical tree.</span></span> <span data-ttu-id="52460-161">このような境界を越えて一貫して動作するプロパティ値の継承の順番は、継承したプロパティは、添付プロパティとして登録する必要があり。、プロパティを使用してカスタムの依存関係プロパティを定義する場合、このパターンに従う必要があります。継承の動作です。</span><span class="sxs-lookup"><span data-stu-id="52460-161">In order for property value inheritance to work consistently across such a boundary, the inheriting property must be registered as an attached property, and you should follow this pattern if you intend to define a custom dependency property with property inheritance behavior.</span></span> <span data-ttu-id="52460-162">正確なツリー プロパティの継承を使用することはできませんで完全に予測ヘルパー クラスのユーティリティ メソッドの実行時にもします。</span><span class="sxs-lookup"><span data-stu-id="52460-162">The exact tree used for property inheritance cannot be entirely anticipated by a helper class utility method, even at run time.</span></span> <span data-ttu-id="52460-163">詳細については、「[プロパティ値の継承](../../../../docs/framework/wpf/advanced/property-value-inheritance.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="52460-163">For more information, see [Property Value Inheritance](../../../../docs/framework/wpf/advanced/property-value-inheritance.md).</span></span>  
  
<a name="two_trees"></a>   
## <a name="the-visual-tree"></a><span data-ttu-id="52460-164">ビジュアル ツリー</span><span class="sxs-lookup"><span data-stu-id="52460-164">The Visual Tree</span></span>  
 <span data-ttu-id="52460-165">論理ツリーの概念、に加えてものビジュアル ツリーの概念[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]です。</span><span class="sxs-lookup"><span data-stu-id="52460-165">In addition to the concept of the logical tree, there is also the concept of the visual tree in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].</span></span> <span data-ttu-id="52460-166">によって表されるように、ビジュアル ツリーが、ビジュアル オブジェクトの構造を記述、<xref:System.Windows.Media.Visual>基本クラスです。</span><span class="sxs-lookup"><span data-stu-id="52460-166">The visual tree describes the structure of visual objects, as represented by the <xref:System.Windows.Media.Visual> base class.</span></span> <span data-ttu-id="52460-167">コントロール用のテンプレートを記述するときにを定義するか、そのコントロールに適用するビジュアル ツリーを再定義ができます。</span><span class="sxs-lookup"><span data-stu-id="52460-167">When you write a template for a control, you are defining or redefining the visual tree that applies for that control.</span></span> <span data-ttu-id="52460-168">ビジュアル ツリーは、下位のパフォーマンスおよび最適化のための描画を制御したい開発者を対象もです。</span><span class="sxs-lookup"><span data-stu-id="52460-168">The visual tree is also of interest to developers who want lower-level control over drawing for performance and optimization reasons.</span></span> <span data-ttu-id="52460-169">ビジュアル ツリーを従来の一部としての 1 つの露出[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]ルーティング イベントのイベントのルートが、論理ツリーではなく、ビジュアル ツリーに沿って出張ほとんどの場合は、アプリケーション プログラミングします。</span><span class="sxs-lookup"><span data-stu-id="52460-169">One exposure of the visual tree as part of conventional [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] application programming is that event routes for a routed event mostly travel along the visual tree, not the logical tree.</span></span> <span data-ttu-id="52460-170">コントロールの作成者でない限り、ルーティングされたイベントの動作の細部がすぐにわかりますできない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="52460-170">This subtlety of routed event behavior might not be immediately apparent unless you are a control author.</span></span> <span data-ttu-id="52460-171">ビジュアル ツリーを使用してイベントのルーティング イベントを処理したり、イベント セッターを作成するビジュアルのレベルで構成を実装するコントロールを使用します。</span><span class="sxs-lookup"><span data-stu-id="52460-171">Routing events through the visual tree enables controls that implement composition at the visual level to handle events or create event setters.</span></span>  
  
<a name="trees_content"></a>   
## <a name="trees-content-elements-and-content-hosts"></a><span data-ttu-id="52460-172">ツリーのコンテンツ要素、およびコンテンツ ホスト</span><span class="sxs-lookup"><span data-stu-id="52460-172">Trees, Content Elements, and Content Hosts</span></span>  
 <span data-ttu-id="52460-173">コンテンツ要素 (から派生したクラス<xref:System.Windows.ContentElement>) のビジュアル ツリーの一部ではない; から継承しない<xref:System.Windows.Media.Visual>視覚的に表現はありません。</span><span class="sxs-lookup"><span data-stu-id="52460-173">Content elements (classes that derive from <xref:System.Windows.ContentElement>) are not part of the visual tree; they do not inherit from <xref:System.Windows.Media.Visual> and do not have a visual representation.</span></span> <span data-ttu-id="52460-174">すべての UI に表示するために、<xref:System.Windows.ContentElement>をコンテンツ ホストでホストされる必要があります、<xref:System.Windows.Media.Visual>および論理ツリーの参加要素。</span><span class="sxs-lookup"><span data-stu-id="52460-174">In order to appear in a UI at all, a <xref:System.Windows.ContentElement> must be hosted in a content host that is both a <xref:System.Windows.Media.Visual> and a logical tree participant.</span></span> <span data-ttu-id="52460-175">このようなオブジェクトは、通常、<xref:System.Windows.FrameworkElement>です。</span><span class="sxs-lookup"><span data-stu-id="52460-175">Usually such an object is a <xref:System.Windows.FrameworkElement>.</span></span> <span data-ttu-id="52460-176">コンテンツ ホストは、コンテンツが、"browser"のようなものと、ホストを制御する画面領域内でそのコンテンツを表示する方法を選択を考えることができます。</span><span class="sxs-lookup"><span data-stu-id="52460-176">You can conceptualize that the content host is somewhat like a "browser" for the content and chooses how to display that content within the screen region that the host controls.</span></span> <span data-ttu-id="52460-177">コンテンツがホストされている場合、コンテンツは通常、ビジュアル ツリーに関連付けられている特定のツリー プロセス内の参加者作成できます。</span><span class="sxs-lookup"><span data-stu-id="52460-177">When the content is hosted, the content can be made a participant in certain tree processes that are normally associated with the visual tree.</span></span> <span data-ttu-id="52460-178">一般に、<xref:System.Windows.FrameworkElement>ホスト クラスには、いずれかのホストを追加する実装コードが含まれています。<xref:System.Windows.ContentElement>コンテンツの論理ツリーのサブノードを介してイベント ルートにいなくてもホストするコンテンツが true のビジュアル ツリーの一部です。</span><span class="sxs-lookup"><span data-stu-id="52460-178">Generally, the <xref:System.Windows.FrameworkElement> host class includes implementation code that adds any hosted <xref:System.Windows.ContentElement> to the event route through subnodes of the content logical tree, even though the hosted content is not part of the true visual tree.</span></span> <span data-ttu-id="52460-179">これは、必要なできるように、<xref:System.Windows.ContentElement>自体以外の任意の要素にルーティングするルーティング イベントを送信できます。</span><span class="sxs-lookup"><span data-stu-id="52460-179">This is necessary so that a <xref:System.Windows.ContentElement> can source a routed event that routes to any element other than itself.</span></span>  
  
<a name="tree_traversal"></a>   
## <a name="tree-traversal"></a><span data-ttu-id="52460-180">ツリーの移動</span><span class="sxs-lookup"><span data-stu-id="52460-180">Tree Traversal</span></span>  
 <span data-ttu-id="52460-181"><xref:System.Windows.LogicalTreeHelper>クラスを提供、 <xref:System.Windows.LogicalTreeHelper.GetChildren%2A>、 <xref:System.Windows.LogicalTreeHelper.GetParent%2A>、および<xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A>の論理ツリーの移動メソッドです。</span><span class="sxs-lookup"><span data-stu-id="52460-181">The <xref:System.Windows.LogicalTreeHelper> class provides the <xref:System.Windows.LogicalTreeHelper.GetChildren%2A>, <xref:System.Windows.LogicalTreeHelper.GetParent%2A>, and <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> methods for logical tree traversal.</span></span> <span data-ttu-id="52460-182">ほとんどの場合、する必要はありません、既存のコントロールの論理ツリーを走査するため、ほとんどの場合、これらのコントロールはなど、コレクションへのアクセスをサポートする専用のコレクション プロパティとして、論理上の子要素を公開`Add`インデクサー、などなど。</span><span class="sxs-lookup"><span data-stu-id="52460-182">In most cases, you should not have to traverse the logical tree of existing controls, because these controls almost always expose their logical child elements as a dedicated collection property that supports collection access such as `Add`, an indexer, and so on.</span></span> <span data-ttu-id="52460-183">ツリーの移動は主のシナリオなどの目的のコントロール パターンから派生しないように選択コントロールの作成者によって使用される<xref:System.Windows.Controls.ItemsControl>または<xref:System.Windows.Controls.Panel>コレクションのプロパティが既に定義されている、および、独自のコレクションを使用するユーザープロパティのサポート。</span><span class="sxs-lookup"><span data-stu-id="52460-183">Tree traversal is mainly a scenario that is used by control authors who choose not to derive from intended control patterns such as <xref:System.Windows.Controls.ItemsControl> or <xref:System.Windows.Controls.Panel> where collection properties are already defined, and who intend to provide their own collection property support.</span></span>  
  
 <span data-ttu-id="52460-184">ビジュアル ツリーを走査のビジュアル ツリーがヘルパー クラスにもサポートしています<xref:System.Windows.Media.VisualTreeHelper>です。</span><span class="sxs-lookup"><span data-stu-id="52460-184">The visual tree also supports a helper class for visual tree traversal, <xref:System.Windows.Media.VisualTreeHelper>.</span></span> <span data-ttu-id="52460-185">ビジュアル ツリーに便利コントロール固有のプロパティを通じて公開されていないため、<xref:System.Windows.Media.VisualTreeHelper>クラスは、プログラミング シナリオで必要とされる場合に、ビジュアル ツリーを走査することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="52460-185">The visual tree is not exposed as conveniently through control-specific properties, so the <xref:System.Windows.Media.VisualTreeHelper> class is the recommended way to traverse the visual tree if that is necessary for your programming scenario.</span></span> <span data-ttu-id="52460-186">詳しくは、「[WPF グラフィックス レンダリングの概要](../../../../docs/framework/wpf/graphics-multimedia/wpf-graphics-rendering-overview.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="52460-186">For more information, see [WPF Graphics Rendering Overview](../../../../docs/framework/wpf/graphics-multimedia/wpf-graphics-rendering-overview.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="52460-187">適用されているテンプレートのビジュアル ツリーを検査するために必要な場合があります。</span><span class="sxs-lookup"><span data-stu-id="52460-187">Sometimes it is necessary to examine the visual tree of an applied template.</span></span> <span data-ttu-id="52460-188">この手法を使用する場合に注意する必要があります。</span><span class="sxs-lookup"><span data-stu-id="52460-188">You should be careful when using this technique.</span></span> <span data-ttu-id="52460-189">コントロールのコンシューマーが設定してでテンプレートを変更できる常にコントロールのビジュアル ツリーを走査し、テンプレートを定義した場合は、場合でも、<xref:System.Windows.Controls.Control.Template%2A>インスタンス、およびエンド ユーザーでもプロパティに影響を与えるテンプレートを適用した変更することで、システムのテーマ。</span><span class="sxs-lookup"><span data-stu-id="52460-189">Even if you are traversing a visual tree for a control where you define the template, consumers of your control can always change the template by setting the <xref:System.Windows.Controls.Control.Template%2A> property on instances, and even the end user can influence the applied template by changing the system theme.</span></span>  
  
<a name="routes"></a>   
## <a name="routes-for-routed-events-as-a-tree"></a><span data-ttu-id="52460-190">ルーティングされたイベントに「ツリー」としてのルート</span><span class="sxs-lookup"><span data-stu-id="52460-190">Routes for Routed Events as a "Tree"</span></span>  
 <span data-ttu-id="52460-191">前述のように、visual および論理ツリー表現のハイブリッドであるツリーの単一引用符と事前に指定されたパスに沿った特定のルーティング イベントの経路を通過します。</span><span class="sxs-lookup"><span data-stu-id="52460-191">As mentioned before, the route of any given routed event travels along a single and predetermined path of a tree that is a hybrid of the visual and logical tree representations.</span></span> <span data-ttu-id="52460-192">イベントのルーティングが出張上矢印のいずれかまたはがかどうかに応じて、ツリー内での手順をトンネルまたはバブル ルーティング イベント。</span><span class="sxs-lookup"><span data-stu-id="52460-192">The event route can travel either in the up or down directions within the tree depending on whether it is a tunneling or bubbling routed event.</span></span> <span data-ttu-id="52460-193">イベント ルートの概念には、実際にルーティング イベントを発生させるとは別にイベントのルートを「参照」するために使用できるヘルパー クラスを直接サポートはありません。</span><span class="sxs-lookup"><span data-stu-id="52460-193">The event route concept does not have a directly supporting helper class that could be used to "walk" the event route independently of raising an event that actually routes.</span></span> <span data-ttu-id="52460-194">ルートを表すクラスが<xref:System.Windows.EventRoute>、そのクラスのメソッドしますが、一般に内部でのみ使用します。</span><span class="sxs-lookup"><span data-stu-id="52460-194">There is a class that represents the route, <xref:System.Windows.EventRoute>, but the methods of that class are generally for internal use only.</span></span>  
  
<a name="resourcesandtrees"></a>   
## <a name="resource-dictionaries-and-trees"></a><span data-ttu-id="52460-195">リソース ディクショナリとツリー</span><span class="sxs-lookup"><span data-stu-id="52460-195">Resource Dictionaries and Trees</span></span>  
 <span data-ttu-id="52460-196">すべてのリソース ディクショナリ検索`Resources`定義されているページ内を通過する時間基本的には、論理ツリー。</span><span class="sxs-lookup"><span data-stu-id="52460-196">Resource dictionary lookup for all `Resources` defined in a page traverses basically the logical tree.</span></span> <span data-ttu-id="52460-197">論理ツリーに含まれていないオブジェクトがキーを持つリソースを参照できますが、論理ツリーにそのオブジェクトが接続されている時点リソース ルックアップ シーケンスを開始します。</span><span class="sxs-lookup"><span data-stu-id="52460-197">Objects that are not in the logical tree can reference keyed resources, but the resource lookup sequence begins at the point where that object is connected to the logical tree.</span></span> <span data-ttu-id="52460-198">WPF では、論理ツリーのノードのみを持つことができます、`Resources`プロパティを含む、 <xref:System.Windows.ResourceDictionary>、したがって利点はありません。 キー付きのリソースを探してビジュアル ツリーを走査することで、<xref:System.Windows.ResourceDictionary>です。</span><span class="sxs-lookup"><span data-stu-id="52460-198">In WPF, only logical tree nodes can have a `Resources` property that contains a <xref:System.Windows.ResourceDictionary>, therefore there is no benefit in traversing the visual tree looking for keyed resources from a <xref:System.Windows.ResourceDictionary>.</span></span>  
  
 <span data-ttu-id="52460-199">ただし、リソースの検索も、直接の論理ツリーを超えて拡張できます。</span><span class="sxs-lookup"><span data-stu-id="52460-199">However, resource lookup can also extend beyond the immediate logical tree.</span></span> <span data-ttu-id="52460-200">アプリケーション マークアップでは、アプリケーション レベルのリソース ディクショナリしてから、静的プロパティまたはキーとして参照されるテーマのサポート、およびシステムの値にへとリソース ルックアップが続きます。</span><span class="sxs-lookup"><span data-stu-id="52460-200">For application markup, the resource lookup can then continue onward to application-level resource dictionaries and then to theme support and system values that are referenced as static properties or keys.</span></span> <span data-ttu-id="52460-201">テーマ自体リソース参照が動的な場合は、テーマの論理ツリーの外部システムの値を参照できます。</span><span class="sxs-lookup"><span data-stu-id="52460-201">Themes themselves can also reference system values outside of the theme logical tree if the resource references are dynamic.</span></span> <span data-ttu-id="52460-202">リソース ディクショナリ、および検索ロジックの詳細については、次を参照してください。 [XAML リソース](../../../../docs/framework/wpf/advanced/xaml-resources.md)です。</span><span class="sxs-lookup"><span data-stu-id="52460-202">For more information on resource dictionaries and the lookup logic, see [XAML Resources](../../../../docs/framework/wpf/advanced/xaml-resources.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="52460-203">関連項目</span><span class="sxs-lookup"><span data-stu-id="52460-203">See Also</span></span>  
 [<span data-ttu-id="52460-204">入力の概要</span><span class="sxs-lookup"><span data-stu-id="52460-204">Input Overview</span></span>](../../../../docs/framework/wpf/advanced/input-overview.md)  
 [<span data-ttu-id="52460-205">WPF グラフィックス レンダリングの概要</span><span class="sxs-lookup"><span data-stu-id="52460-205">WPF Graphics Rendering Overview</span></span>](../../../../docs/framework/wpf/graphics-multimedia/wpf-graphics-rendering-overview.md)  
 [<span data-ttu-id="52460-206">ルーティング イベントの概要</span><span class="sxs-lookup"><span data-stu-id="52460-206">Routed Events Overview</span></span>](../../../../docs/framework/wpf/advanced/routed-events-overview.md)  
 [<span data-ttu-id="52460-207">オブジェクト ツリーに存在しないオブジェクト要素の初期化</span><span class="sxs-lookup"><span data-stu-id="52460-207">Initialization for Object Elements Not in an Object Tree</span></span>](../../../../docs/framework/wpf/advanced/initialization-for-object-elements-not-in-an-object-tree.md)  
 [<span data-ttu-id="52460-208">WPF アーキテクチャ</span><span class="sxs-lookup"><span data-stu-id="52460-208">WPF Architecture</span></span>](../../../../docs/framework/wpf/advanced/wpf-architecture.md)
