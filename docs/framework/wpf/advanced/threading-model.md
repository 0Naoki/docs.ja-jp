---
title: スレッド モデル
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- text on buttons [WPF], updating
- message processing [WPF], nested
- blocking operations [WPF]
- Common Language Runtime (CLR), locking mechanism
- locking mechanism of Common Language Runtime (CLR)
- threading model [WPF]
- Word [WPF], spelling checking
- button text [WPF], updating
- spelling checking in Word [WPF]
- asynchronous behavior [WPF], exposing
- nested message processing [WPF]
- reentrancy [WPF]
ms.assetid: 02d8fd00-8d7c-4604-874c-58e40786770b
ms.openlocfilehash: ebfbb2df3e931690f2ba12f0a2ad868da0212f5d
ms.sourcegitcommit: 09d699aca28ae9723399bbd9d3d44aa0cbd3848d
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 07/19/2019
ms.locfileid: "68331626"
---
# <a name="threading-model"></a><span data-ttu-id="97923-102">スレッド モデル</span><span class="sxs-lookup"><span data-stu-id="97923-102">Threading Model</span></span>
[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]<span data-ttu-id="97923-103">は、スレッド処理の難しさから開発者を保存するように設計されています。</span><span class="sxs-lookup"><span data-stu-id="97923-103">is designed to save developers from the difficulties of threading.</span></span> <span data-ttu-id="97923-104">その結果、多くの[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]開発者は、複数のスレッドを使用するインターフェイスを作成する必要がなくなります。</span><span class="sxs-lookup"><span data-stu-id="97923-104">As a result, the majority of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] developers won't have to write an interface that uses more than one thread.</span></span> <span data-ttu-id="97923-105">マルチスレッドプログラムは複雑でデバッグが困難なため、シングルスレッドソリューションが存在する場合は回避する必要があります。</span><span class="sxs-lookup"><span data-stu-id="97923-105">Because multithreaded programs are complex and difficult to debug, they should be avoided when single-threaded solutions exist.</span></span>  
  
 <span data-ttu-id="97923-106">しかし、どのように設計されて[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]いても、どのような種類の問題に対しても、シングルスレッドソリューションを提供できるフレームワークはありません。</span><span class="sxs-lookup"><span data-stu-id="97923-106">No matter how well architected, however, no [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] framework will ever be able to provide a single-threaded solution for every sort of problem.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="97923-107">これで終わりですが、複数のスレッドが応答性[!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)]やアプリケーションのパフォーマンスを向上させる状況もあります。</span><span class="sxs-lookup"><span data-stu-id="97923-107">comes close, but there are still situations where multiple threads improve [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] responsiveness or application performance.</span></span> <span data-ttu-id="97923-108">いくつかの背景情報について説明した後、この記事ではこのような状況をいくつか紹介した後、いくつかの下位レベルの詳細について説明します。</span><span class="sxs-lookup"><span data-stu-id="97923-108">After discussing some background material, this paper explores some of these situations and then concludes with a discussion of some lower-level details.</span></span>  

> [!NOTE]
>  <span data-ttu-id="97923-109">このトピックでは、非同期呼び出し<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>のメソッドを使用したスレッド処理について説明します。</span><span class="sxs-lookup"><span data-stu-id="97923-109">This topic discusses threading by using the <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method for asynchronous calls.</span></span> <span data-ttu-id="97923-110"><xref:System.Action>また<xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> は<xref:System.Func%601>をパラメーターとして受け取るメソッドを呼び出すことにより、非同期呼び出しを行うこともできます。</span><span class="sxs-lookup"><span data-stu-id="97923-110">You can also make asynchronous calls by calling the <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method, which take an <xref:System.Action> or <xref:System.Func%601> as a parameter.</span></span>  <span data-ttu-id="97923-111">メソッドは、プロパティ<xref:System.Windows.Threading.DispatcherOperation> <xref:System.Windows.Threading.DispatcherOperation%601>を<xref:System.Windows.Threading.DispatcherOperation.Task%2A>持つまたはを返します。 <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A></span><span class="sxs-lookup"><span data-stu-id="97923-111">The <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method returns a <xref:System.Windows.Threading.DispatcherOperation> or <xref:System.Windows.Threading.DispatcherOperation%601>, which has a <xref:System.Windows.Threading.DispatcherOperation.Task%2A> property.</span></span> <span data-ttu-id="97923-112">`await`キーワードは、 <xref:System.Windows.Threading.DispatcherOperation>またはに関連付けられ<xref:System.Threading.Tasks.Task>たで使用できます。</span><span class="sxs-lookup"><span data-stu-id="97923-112">You can use the `await` keyword with either the <xref:System.Windows.Threading.DispatcherOperation> or the associated <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="97923-113"><xref:System.Threading.Tasks.Task> または <xref:System.Windows.Threading.DispatcherOperation> によって返される <xref:System.Windows.Threading.DispatcherOperation%601> を同期的に待機する必要がある場合、<xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A> 拡張メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="97923-113">If you need to wait synchronously for the <xref:System.Threading.Tasks.Task> that is returned by a <xref:System.Windows.Threading.DispatcherOperation> or <xref:System.Windows.Threading.DispatcherOperation%601>, call the <xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A> extension method.</span></span>  <span data-ttu-id="97923-114">を<xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>呼び出すと、デッドロックが発生します。</span><span class="sxs-lookup"><span data-stu-id="97923-114">Calling <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> will result in a deadlock.</span></span> <span data-ttu-id="97923-115">を使用した<xref:System.Threading.Tasks.Task>非同期操作の実行の詳細については、「タスクの並列化」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="97923-115">For more information about using a <xref:System.Threading.Tasks.Task> to perform asynchronous operations, see Task Parallelism.</span></span>  <span data-ttu-id="97923-116">メソッド<xref:System.Windows.Threading.Dispatcher.Invoke%2A>に<xref:System.Action>は、パラメーターとしてまた<xref:System.Func%601>はを受け取るオーバーロードもあります。</span><span class="sxs-lookup"><span data-stu-id="97923-116">The <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method also has overloads that take an <xref:System.Action> or <xref:System.Func%601> as a parameter.</span></span>  <span data-ttu-id="97923-117"><xref:System.Windows.Threading.Dispatcher.Invoke%2A>メソッドを使用して、 <xref:System.Action>デリゲートまたは<xref:System.Func%601>を渡すことによって同期呼び出しを行うことができます。</span><span class="sxs-lookup"><span data-stu-id="97923-117">You can use the <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method to make synchronous calls by passing in a delegate, <xref:System.Action> or <xref:System.Func%601>.</span></span>  
  
<a name="threading_overview"></a>   
## <a name="overview-and-the-dispatcher"></a><span data-ttu-id="97923-118">概要とディスパッチャー</span><span class="sxs-lookup"><span data-stu-id="97923-118">Overview and the Dispatcher</span></span>  
 <span data-ttu-id="97923-119">通常、 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]アプリケーションは2つのスレッドを使用して起動します。 1 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]つはレンダリングの処理用で、もう1つはの管理用です。</span><span class="sxs-lookup"><span data-stu-id="97923-119">Typically, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications start with two threads: one for handling rendering and another for managing the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="97923-120">レンダリングスレッドは、スレッドが[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]入力を受け取り、イベントを処理し、画面を描画し、アプリケーションコードを実行している間に、バックグラウンドで非表示で実行されます。</span><span class="sxs-lookup"><span data-stu-id="97923-120">The rendering thread effectively runs hidden in the background while the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread receives input, handles events, paints the screen, and runs application code.</span></span> <span data-ttu-id="97923-121">ほとんどのアプリケーションは 1 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]つのスレッドを使用しますが、状況によっては複数のを使用するのが最適です。</span><span class="sxs-lookup"><span data-stu-id="97923-121">Most applications use a single [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread, although in some situations it is best to use several.</span></span> <span data-ttu-id="97923-122">これについては、後で例を使って説明します。</span><span class="sxs-lookup"><span data-stu-id="97923-122">We’ll discuss this with an example later.</span></span>  
  
 <span data-ttu-id="97923-123">スレッド[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]は、と呼ばれるオブジェクト内の作業<xref:System.Windows.Threading.Dispatcher>項目をキューに配置します。</span><span class="sxs-lookup"><span data-stu-id="97923-123">The [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread queues work items inside an object called a <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="97923-124"><xref:System.Windows.Threading.Dispatcher> は作業項目を優先順位に従って選択し、それぞれを最後まで実行します。</span><span class="sxs-lookup"><span data-stu-id="97923-124">The <xref:System.Windows.Threading.Dispatcher> selects work items on a priority basis and runs each one to completion.</span></span>  <span data-ttu-id="97923-125">すべて[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]のスレッドには少なくと<xref:System.Windows.Threading.Dispatcher>も1つ<xref:System.Windows.Threading.Dispatcher>のが必要であり、それぞれが1つのスレッドで作業項目を実行できます。</span><span class="sxs-lookup"><span data-stu-id="97923-125">Every [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread must have at least one <xref:System.Windows.Threading.Dispatcher>, and each <xref:System.Windows.Threading.Dispatcher> can execute work items in exactly one thread.</span></span>  
  
 <span data-ttu-id="97923-126">応答性の高いユーザーフレンドリなアプリケーションを構築するには、 <xref:System.Windows.Threading.Dispatcher>作業項目を小さくしてスループットを最大化します。</span><span class="sxs-lookup"><span data-stu-id="97923-126">The trick to building responsive, user-friendly applications is to maximize the <xref:System.Windows.Threading.Dispatcher> throughput by keeping the work items small.</span></span> <span data-ttu-id="97923-127">このようにすると、処理を待機<xref:System.Windows.Threading.Dispatcher>しているキューに項目が古くなることはありません。</span><span class="sxs-lookup"><span data-stu-id="97923-127">This way items never get stale sitting in the <xref:System.Windows.Threading.Dispatcher> queue waiting for processing.</span></span> <span data-ttu-id="97923-128">入力と応答の間の perceivable 遅延によって、ユーザーの不満が生じる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="97923-128">Any perceivable delay between input and response can frustrate a user.</span></span>  
  
 <span data-ttu-id="97923-129">アプリケーションでビッグ[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]操作を処理するにはどうすればよいでしょうか。</span><span class="sxs-lookup"><span data-stu-id="97923-129">How then are [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications supposed to handle big operations?</span></span> <span data-ttu-id="97923-130">コードに大きな計算が含まれている場合、またはリモートサーバー上のデータベースに対してクエリを実行する必要がある場合は、どうすればよいでしょうか。</span><span class="sxs-lookup"><span data-stu-id="97923-130">What if your code involves a large calculation or needs to query a database on some remote server?</span></span> <span data-ttu-id="97923-131">通常は、大きな操作を別のスレッド[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]で処理することで、スレッドを<xref:System.Windows.Threading.Dispatcher>キュー内の項目に対して自由に解放できます。</span><span class="sxs-lookup"><span data-stu-id="97923-131">Usually, the answer is to handle the big operation in a separate thread, leaving the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread free to tend to items in the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="97923-132">大規模な操作が完了すると、結果を表示のために[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]スレッドに報告できます。</span><span class="sxs-lookup"><span data-stu-id="97923-132">When the big operation is complete, it can report its result back to the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread for display.</span></span>  
  
 <span data-ttu-id="97923-133">これまで[!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)] 、 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]では、作成したスレッドだけが要素にアクセスできるようになりました。</span><span class="sxs-lookup"><span data-stu-id="97923-133">Historically, [!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)] allows [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elements to be accessed only by the thread that created them.</span></span> <span data-ttu-id="97923-134">これは、長時間実行されているタスクを実行するバックグラウンドスレッドが、完了時にテキストボックスを更新できないことを意味します。</span><span class="sxs-lookup"><span data-stu-id="97923-134">This means that a background thread in charge of some long-running task cannot update a text box when it is finished.</span></span> [!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)]<span data-ttu-id="97923-135">は、コンポーネントの[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]整合性を確保するためにこれを行います。</span><span class="sxs-lookup"><span data-stu-id="97923-135">does this to ensure the integrity of [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] components.</span></span> <span data-ttu-id="97923-136">コンテンツが描画中にバックグラウンドスレッドによって更新された場合、リストボックスは奇妙に見える可能性があります。</span><span class="sxs-lookup"><span data-stu-id="97923-136">A list box could look strange if its contents were updated by a background thread during painting.</span></span>  
  
 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="97923-137">には、この調整を強制する組み込みの相互排他機構があります。</span><span class="sxs-lookup"><span data-stu-id="97923-137">has a built-in mutual exclusion mechanism that enforces this coordination.</span></span> <span data-ttu-id="97923-138">のほとんどの[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]クラスは<xref:System.Windows.Threading.DispatcherObject>、から派生します。</span><span class="sxs-lookup"><span data-stu-id="97923-138">Most classes in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] derive from <xref:System.Windows.Threading.DispatcherObject>.</span></span> <span data-ttu-id="97923-139">構築時に、 <xref:System.Windows.Threading.DispatcherObject>は現在実行中の<xref:System.Windows.Threading.Dispatcher>スレッドにリンクされているへの参照を格納します。</span><span class="sxs-lookup"><span data-stu-id="97923-139">At construction, a <xref:System.Windows.Threading.DispatcherObject> stores a reference to the <xref:System.Windows.Threading.Dispatcher> linked to the currently running thread.</span></span> <span data-ttu-id="97923-140">実際には、 <xref:System.Windows.Threading.DispatcherObject>は、それを作成するスレッドに関連付けられます。</span><span class="sxs-lookup"><span data-stu-id="97923-140">In effect, the <xref:System.Windows.Threading.DispatcherObject> associates with the thread that creates it.</span></span> <span data-ttu-id="97923-141">プログラムの実行中、 <xref:System.Windows.Threading.DispatcherObject>はパブリック<xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A>メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="97923-141">During program execution, a <xref:System.Windows.Threading.DispatcherObject> can call its public <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> method.</span></span> <span data-ttu-id="97923-142"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A>現在の<xref:System.Windows.Threading.Dispatcher>スレッドに関連付けられているを調べ<xref:System.Windows.Threading.Dispatcher> 、構築中に格納されている参照と比較します。</span><span class="sxs-lookup"><span data-stu-id="97923-142"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> examines the <xref:System.Windows.Threading.Dispatcher> associated with the current thread and compares it to the <xref:System.Windows.Threading.Dispatcher> reference stored during construction.</span></span> <span data-ttu-id="97923-143">一致しない場合、 <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A>は例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="97923-143">If they don’t match, <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> throws an exception.</span></span> <span data-ttu-id="97923-144"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A>は、 <xref:System.Windows.Threading.DispatcherObject>に属するすべてのメソッドの先頭で呼び出されることを意図しています。</span><span class="sxs-lookup"><span data-stu-id="97923-144"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> is intended to be called at the beginning of every method belonging to a <xref:System.Windows.Threading.DispatcherObject>.</span></span>  
  
 <span data-ttu-id="97923-145">を変更できるのが1つ[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]のスレッドだけの場合、バックグラウンドスレッドはどのようにしてユーザーと対話しますか。</span><span class="sxs-lookup"><span data-stu-id="97923-145">If only one thread can modify the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)], how do background threads interact with the user?</span></span> <span data-ttu-id="97923-146">バックグラウンドスレッドは、 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]スレッドに代わって操作を実行するように要求できます。</span><span class="sxs-lookup"><span data-stu-id="97923-146">A background thread can ask the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread to perform an operation on its behalf.</span></span> <span data-ttu-id="97923-147">これを行うには、作業項目<xref:System.Windows.Threading.Dispatcher>を[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]スレッドのに登録します。</span><span class="sxs-lookup"><span data-stu-id="97923-147">It does this by registering a work item with the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="97923-148">クラス<xref:System.Windows.Threading.Dispatcher>には<xref:System.Windows.Threading.Dispatcher.Invoke%2A> 、作業項目を登録するための<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>2 つのメソッドとが用意されています。</span><span class="sxs-lookup"><span data-stu-id="97923-148">The <xref:System.Windows.Threading.Dispatcher> class provides two methods for registering work items: <xref:System.Windows.Threading.Dispatcher.Invoke%2A> and <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</span></span> <span data-ttu-id="97923-149">どちらのメソッドも、デリゲートの実行をスケジュールします。</span><span class="sxs-lookup"><span data-stu-id="97923-149">Both methods schedule a delegate for execution.</span></span> <span data-ttu-id="97923-150"><xref:System.Windows.Threading.Dispatcher.Invoke%2A>は同期呼び出しです。つまり、 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]スレッドが実際にデリゲートの実行を終了するまでは戻りません。</span><span class="sxs-lookup"><span data-stu-id="97923-150"><xref:System.Windows.Threading.Dispatcher.Invoke%2A> is a synchronous call – that is, it doesn’t return until the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread actually finishes executing the delegate.</span></span> <span data-ttu-id="97923-151"><xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>は非同期で、直ちにを返します。</span><span class="sxs-lookup"><span data-stu-id="97923-151"><xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> is asynchronous and returns immediately.</span></span>  
  
 <span data-ttu-id="97923-152">は<xref:System.Windows.Threading.Dispatcher> 、優先順位によってキュー内の要素を並べ替えます。</span><span class="sxs-lookup"><span data-stu-id="97923-152">The <xref:System.Windows.Threading.Dispatcher> orders the elements in its queue by priority.</span></span> <span data-ttu-id="97923-153"><xref:System.Windows.Threading.Dispatcher>キューに要素を追加するときに指定できるレベルは10個あります。</span><span class="sxs-lookup"><span data-stu-id="97923-153">There are ten levels that may be specified when adding an element to the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="97923-154">これらの優先順位は、 <xref:System.Windows.Threading.DispatcherPriority>列挙体に保持されます。</span><span class="sxs-lookup"><span data-stu-id="97923-154">These priorities are maintained in the <xref:System.Windows.Threading.DispatcherPriority> enumeration.</span></span> <span data-ttu-id="97923-155">レベルの詳細<xref:System.Windows.Threading.DispatcherPriority>については、の[!INCLUDE[TLA2#tla_winfxsdk](../../../../includes/tla2sharptla-winfxsdk-md.md)]ドキュメントを参照してください。</span><span class="sxs-lookup"><span data-stu-id="97923-155">Detailed information about <xref:System.Windows.Threading.DispatcherPriority> levels can be found in the [!INCLUDE[TLA2#tla_winfxsdk](../../../../includes/tla2sharptla-winfxsdk-md.md)] documentation.</span></span>  
  
<a name="samples"></a>   
## <a name="threads-in-action-the-samples"></a><span data-ttu-id="97923-156">動作中のスレッド:サンプル</span><span class="sxs-lookup"><span data-stu-id="97923-156">Threads in Action: The Samples</span></span>  
  
<a name="prime_number"></a>   
### <a name="a-single-threaded-application-with-a-long-running-calculation"></a><span data-ttu-id="97923-157">実行時間の長い計算を含むシングルスレッドアプリケーション</span><span class="sxs-lookup"><span data-stu-id="97923-157">A Single-Threaded Application with a Long-Running Calculation</span></span>  
 <span data-ttu-id="97923-158">多く[!INCLUDE[TLA#tla_gui#plural](../../../../includes/tlasharptla-guisharpplural-md.md)]の場合、ユーザーの操作に応じて生成されたイベントを待機している間、時間の大部分が費やされます。</span><span class="sxs-lookup"><span data-stu-id="97923-158">Most [!INCLUDE[TLA#tla_gui#plural](../../../../includes/tlasharptla-guisharpplural-md.md)] spend a large portion of their time idle while waiting for events that are generated in response to user interactions.</span></span> <span data-ttu-id="97923-159">プログラムを注意深くプログラミングすると、 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]の応答性に影響を与えることなく、このアイドル時間を constructively に使用できます。</span><span class="sxs-lookup"><span data-stu-id="97923-159">With careful programming this idle time can be used constructively, without affecting the responsiveness of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="97923-160">スレッド[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]処理モデルでは、入力を使用して[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]スレッドで発生する操作を中断することはできません。</span><span class="sxs-lookup"><span data-stu-id="97923-160">The [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] threading model doesn’t allow input to interrupt an operation happening in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="97923-161">これは、保留中の入力イベントが古く<xref:System.Windows.Threading.Dispatcher>なる前に処理するために、定期的にに戻る必要があることを意味します。</span><span class="sxs-lookup"><span data-stu-id="97923-161">This means you must be sure to return to the <xref:System.Windows.Threading.Dispatcher> periodically to process pending input events before they get stale.</span></span>  
  
 <span data-ttu-id="97923-162">次に例を示します。</span><span class="sxs-lookup"><span data-stu-id="97923-162">Consider the following example:</span></span>  
  
 ![素数のスレッド処理を示すスクリーンショット。](./media/threading-model/threading-prime-numbers.png)  
  
 <span data-ttu-id="97923-164">この単純なアプリケーションは、3から昇順にカウントし、素数を検索します。</span><span class="sxs-lookup"><span data-stu-id="97923-164">This simple application counts upwards from three, searching for prime numbers.</span></span> <span data-ttu-id="97923-165">ユーザーが **[スタート]** ボタンをクリックすると、検索が開始されます。</span><span class="sxs-lookup"><span data-stu-id="97923-165">When the user clicks the **Start** button, the search begins.</span></span> <span data-ttu-id="97923-166">プログラムが素数を検出すると、ユーザーインターフェイスが検出されて更新されます。</span><span class="sxs-lookup"><span data-stu-id="97923-166">When the program finds a prime, it updates the user interface with its discovery.</span></span> <span data-ttu-id="97923-167">どの時点でも、ユーザーは検索を停止できます。</span><span class="sxs-lookup"><span data-stu-id="97923-167">At any point, the user can stop the search.</span></span>  
  
 <span data-ttu-id="97923-168">非常に単純ですが、素数の検索は永久に発生し、いくつかの問題が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="97923-168">Although simple enough, the prime number search could go on forever, which presents some difficulties.</span></span>  <span data-ttu-id="97923-169">ボタンの click イベントハンドラー内で検索全体を処理した場合、他のイベントを処理する[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]機会がスレッドに与えられることはありません。</span><span class="sxs-lookup"><span data-stu-id="97923-169">If we handled the entire search inside of the click event handler of the button, we would never give the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread a chance to handle other events.</span></span> <span data-ttu-id="97923-170">は[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 、入力メッセージまたは処理メッセージに応答できません。</span><span class="sxs-lookup"><span data-stu-id="97923-170">The [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] would be unable to respond to input or process messages.</span></span> <span data-ttu-id="97923-171">これは再描画せず、ボタンのクリックに応答することもありません。</span><span class="sxs-lookup"><span data-stu-id="97923-171">It would never repaint and never respond to button clicks.</span></span>  
  
 <span data-ttu-id="97923-172">素数の検索は別のスレッドで実行できますが、その場合は同期の問題に対処する必要があります。</span><span class="sxs-lookup"><span data-stu-id="97923-172">We could conduct the prime number search in a separate thread, but then we would need to deal with synchronization issues.</span></span> <span data-ttu-id="97923-173">シングルスレッド方式では、検出された最大素数を一覧表示するラベルを直接更新できます。</span><span class="sxs-lookup"><span data-stu-id="97923-173">With a single-threaded approach, we can directly update the label that lists the largest prime found.</span></span>  
  
 <span data-ttu-id="97923-174">計算作業を管理しやすいチャンクに分割した場合は、 <xref:System.Windows.Threading.Dispatcher>に定期的に戻り、イベントを処理することができます。</span><span class="sxs-lookup"><span data-stu-id="97923-174">If we break up the task of calculation into manageable chunks, we can periodically return to the <xref:System.Windows.Threading.Dispatcher> and process events.</span></span> <span data-ttu-id="97923-175">入力を再[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]描画して処理する機会を与えることができます。</span><span class="sxs-lookup"><span data-stu-id="97923-175">We can give [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] an opportunity to repaint and process input.</span></span>  
  
 <span data-ttu-id="97923-176">計算とイベント処理の間で処理時間を分割する最善の方法は、 <xref:System.Windows.Threading.Dispatcher>から計算を管理することです。</span><span class="sxs-lookup"><span data-stu-id="97923-176">The best way to split processing time between calculation and event handling is to manage calculation from the <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="97923-177"><xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>メソッドを使用すると、イベントが描画される[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]のと同じキューで素数のチェックをスケジュールできます。</span><span class="sxs-lookup"><span data-stu-id="97923-177">By using the <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method, we can schedule prime number checks in the same queue that [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] events are drawn from.</span></span> <span data-ttu-id="97923-178">この例では、一度に1つの素数チェックのみをスケジュールします。</span><span class="sxs-lookup"><span data-stu-id="97923-178">In our example, we schedule only a single prime number check at a time.</span></span> <span data-ttu-id="97923-179">素数の確認が完了したら、すぐに次のチェックをスケジュールします。</span><span class="sxs-lookup"><span data-stu-id="97923-179">After the prime number check is complete, we schedule the next check immediately.</span></span> <span data-ttu-id="97923-180">このチェックは、保留中[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]のイベントが処理された後にのみ実行されます。</span><span class="sxs-lookup"><span data-stu-id="97923-180">This check proceeds only after pending [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] events have been handled.</span></span>  
  
 ![ディスパッチャーキューを示すスクリーンショット。](./media/threading-model/threading-dispatcher-queue.png)  
  
 [!INCLUDE[TLA#tla_word](../../../../includes/tlasharptla-word-md.md)]<span data-ttu-id="97923-182">このメカニズムを使用してスペルチェックを行います。</span><span class="sxs-lookup"><span data-stu-id="97923-182">accomplishes spell checking using this mechanism.</span></span> <span data-ttu-id="97923-183">スペルチェックは、 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]スレッドのアイドル時間を使用してバックグラウンドで実行されます。</span><span class="sxs-lookup"><span data-stu-id="97923-183">Spell checking is done in the background using the idle time of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="97923-184">コードを見てみましょう。</span><span class="sxs-lookup"><span data-stu-id="97923-184">Let's take a look at the code.</span></span>  
  
 <span data-ttu-id="97923-185">次の例は、ユーザーインターフェイスを作成する XAML を示しています。</span><span class="sxs-lookup"><span data-stu-id="97923-185">The following example shows the XAML that creates the user interface.</span></span>  
  
 [!code-xaml[ThreadingPrimeNumbers#ThreadingPrimeNumberXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml#threadingprimenumberxaml)]  
  
 <span data-ttu-id="97923-186">次の例は、分離コードを示しています。</span><span class="sxs-lookup"><span data-stu-id="97923-186">The following example shows the code-behind.</span></span>  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumbercodebehind)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumbercodebehind)]  
  
 <span data-ttu-id="97923-187">次の例は、 <xref:System.Windows.Controls.Button>のイベントハンドラーを示しています。</span><span class="sxs-lookup"><span data-stu-id="97923-187">The following example shows the event handler for the <xref:System.Windows.Controls.Button>.</span></span>  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberstartorstop)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberstartorstop)]  
  
 <span data-ttu-id="97923-188">このハンドラーは、の<xref:System.Windows.Controls.Button>テキストを更新するだけでなく、デリゲートを<xref:System.Windows.Threading.Dispatcher>キューに追加することによって最初の素数チェックをスケジュールします。</span><span class="sxs-lookup"><span data-stu-id="97923-188">Besides updating the text on the <xref:System.Windows.Controls.Button>, this handler is responsible for scheduling the first prime number check by adding a delegate to the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="97923-189">このイベントハンドラーが処理を完了した後で<xref:System.Windows.Threading.Dispatcher> 、はこのデリゲートを選択して実行します。</span><span class="sxs-lookup"><span data-stu-id="97923-189">Sometime after this event handler has completed its work, the <xref:System.Windows.Threading.Dispatcher> will select this delegate for execution.</span></span>  
  
 <span data-ttu-id="97923-190">既に説明した<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>ように<xref:System.Windows.Threading.Dispatcher> 、は、実行のためにデリゲートをスケジュールするために使用されるメンバーです。</span><span class="sxs-lookup"><span data-stu-id="97923-190">As we mentioned earlier, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> is the <xref:System.Windows.Threading.Dispatcher> member used to schedule a delegate for execution.</span></span> <span data-ttu-id="97923-191">この場合は、 <xref:System.Windows.Threading.DispatcherPriority.SystemIdle>優先度を選択します。</span><span class="sxs-lookup"><span data-stu-id="97923-191">In this case, we choose the <xref:System.Windows.Threading.DispatcherPriority.SystemIdle> priority.</span></span> <span data-ttu-id="97923-192">は<xref:System.Windows.Threading.Dispatcher> 、処理する重要なイベントがない場合にのみ、このデリゲートを実行します。</span><span class="sxs-lookup"><span data-stu-id="97923-192">The <xref:System.Windows.Threading.Dispatcher> will execute this delegate only when there are no important events to process.</span></span> [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]<span data-ttu-id="97923-193">応答性は、数値チェックよりも重要です。</span><span class="sxs-lookup"><span data-stu-id="97923-193">responsiveness is more important than number checking.</span></span> <span data-ttu-id="97923-194">また、数値チェックルーチンを表す新しいデリゲートも渡します。</span><span class="sxs-lookup"><span data-stu-id="97923-194">We also pass a new delegate representing the number-checking routine.</span></span>  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberchecknextnumber)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberchecknextnumber)]  
  
 <span data-ttu-id="97923-195">このメソッドは、次の奇数の値が素数かどうかを確認します。</span><span class="sxs-lookup"><span data-stu-id="97923-195">This method checks if the next odd number is prime.</span></span> <span data-ttu-id="97923-196">素数の場合、メソッドは、 `bigPrime` <xref:System.Windows.Controls.TextBlock>その検出を反映するためにを直接更新します。</span><span class="sxs-lookup"><span data-stu-id="97923-196">If it is prime, the method directly updates the `bigPrime`<xref:System.Windows.Controls.TextBlock> to reflect its discovery.</span></span> <span data-ttu-id="97923-197">これは、コンポーネントの作成に使用されたのと同じスレッドで計算が行われているためです。</span><span class="sxs-lookup"><span data-stu-id="97923-197">We can do this because the calculation is occurring in the same thread that was used to create the component.</span></span> <span data-ttu-id="97923-198">計算に別のスレッドを使用することを選択した場合は、より複雑な同期機構を使用して、 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]スレッドで更新を実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="97923-198">Had we chosen to use a separate thread for the calculation, we would have to use a more complicated synchronization mechanism and execute the update in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="97923-199">この状況を次に示します。</span><span class="sxs-lookup"><span data-stu-id="97923-199">We’ll demonstrate this situation next.</span></span>  
  
 <span data-ttu-id="97923-200">このサンプルの完全なソースコードについては、「[実行時間の長い計算サンプルを使用したシングルスレッドアプリケーション](https://go.microsoft.com/fwlink/?LinkID=160038)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="97923-200">For the complete source code for this sample, see the [Single-Threaded Application with Long-Running Calculation Sample](https://go.microsoft.com/fwlink/?LinkID=160038)</span></span>  
  
<a name="weather_sim"></a>   
### <a name="handling-a-blocking-operation-with-a-background-thread"></a><span data-ttu-id="97923-201">バックグラウンドスレッドを使用したブロッキング操作の処理</span><span class="sxs-lookup"><span data-stu-id="97923-201">Handling a Blocking Operation with a Background Thread</span></span>  
 <span data-ttu-id="97923-202">グラフィカルアプリケーションでのブロック操作の処理は困難な場合があります。</span><span class="sxs-lookup"><span data-stu-id="97923-202">Handling blocking operations in a graphical application can be difficult.</span></span> <span data-ttu-id="97923-203">アプリケーションがフリーズしているように見えるため、イベントハンドラーからブロックメソッドを呼び出す必要はありません。</span><span class="sxs-lookup"><span data-stu-id="97923-203">We don’t want to call blocking methods from event handlers because the application will appear to freeze up.</span></span> <span data-ttu-id="97923-204">これらの操作を処理するために別のスレッドを使用できますが、完了したら、ワーカースレッド[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] [!INCLUDE[TLA2#tla_gui](../../../../includes/tla2sharptla-gui-md.md)]からを直接変更することはできないため、スレッドと同期する必要があります。</span><span class="sxs-lookup"><span data-stu-id="97923-204">We can use a separate thread to handle these operations, but when we’re done, we have to synchronize with the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread because we can’t directly modify the [!INCLUDE[TLA2#tla_gui](../../../../includes/tla2sharptla-gui-md.md)] from our worker thread.</span></span> <span data-ttu-id="97923-205"><xref:System.Windows.Threading.Dispatcher.Invoke%2A>または<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>を使用して、 <xref:System.Windows.Threading.Dispatcher> [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]スレッドのにデリゲートを挿入できます。</span><span class="sxs-lookup"><span data-stu-id="97923-205">We can use <xref:System.Windows.Threading.Dispatcher.Invoke%2A> or <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> to insert delegates into the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="97923-206">最終的には、これらのデリゲートは、要素を[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]変更するためのアクセス許可を使用して実行されます。</span><span class="sxs-lookup"><span data-stu-id="97923-206">Eventually, these delegates will be executed with permission to modify [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elements.</span></span>  
  
 <span data-ttu-id="97923-207">この例では、天気予報を取得するリモートプロシージャ呼び出しを模倣しています。</span><span class="sxs-lookup"><span data-stu-id="97923-207">In this example, we mimic a remote procedure call that retrieves a weather forecast.</span></span> <span data-ttu-id="97923-208">この呼び出しを実行するために別のワーカースレッドを使用し、終了時に<xref:System.Windows.Threading.Dispatcher> [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]スレッドのに更新メソッドをスケジュールします。</span><span class="sxs-lookup"><span data-stu-id="97923-208">We use a separate worker thread to execute this call, and we schedule an update method in the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread when we’re finished.</span></span>  
  
 ![気象 UI を示すスクリーンショット。](./media/threading-model/threading-weather-ui.png)  
  
 [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweathercodebehind)]
 [!code-vb[ThreadingWeatherForecast#ThreadingWeatherCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweathercodebehind)]  
  
 <span data-ttu-id="97923-210">注意する必要がある詳細の一部を次に示します。</span><span class="sxs-lookup"><span data-stu-id="97923-210">The following are some of the details to be noted.</span></span>  
  
- <span data-ttu-id="97923-211">ボタンハンドラーの作成</span><span class="sxs-lookup"><span data-stu-id="97923-211">Creating the Button Handler</span></span>  
  
     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherbuttonhandler)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherbuttonhandler)]  
  
 <span data-ttu-id="97923-212">ボタンがクリックされると、時計の描画が表示され、アニメーション化が開始されます。</span><span class="sxs-lookup"><span data-stu-id="97923-212">When the button is clicked, we display the clock drawing and start animating it.</span></span> <span data-ttu-id="97923-213">このボタンは無効になっています。</span><span class="sxs-lookup"><span data-stu-id="97923-213">We disable the button.</span></span> <span data-ttu-id="97923-214">新しいスレッドで`FetchWeatherFromServer`メソッドを呼び出し、を返します。これにより、は<xref:System.Windows.Threading.Dispatcher> 、天気予報の収集を待機している間にイベントを処理できるようになります。</span><span class="sxs-lookup"><span data-stu-id="97923-214">We invoke the `FetchWeatherFromServer` method in a new thread, and then we return, allowing the <xref:System.Windows.Threading.Dispatcher> to process events while we wait to collect the weather forecast.</span></span>  
  
- <span data-ttu-id="97923-215">天気予報</span><span class="sxs-lookup"><span data-stu-id="97923-215">Fetching the Weather</span></span>  
  
     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherfetchweather)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherfetchweather)]  
  
 <span data-ttu-id="97923-216">単純にするために、この例ではネットワークコードを実際に使用していません。</span><span class="sxs-lookup"><span data-stu-id="97923-216">To keep things simple, we don’t actually have any networking code in this example.</span></span> <span data-ttu-id="97923-217">代わりに、新しいスレッドを4秒間スリープ状態にすることで、ネットワークアクセスの遅延をシミュレートします。</span><span class="sxs-lookup"><span data-stu-id="97923-217">Instead, we simulate the delay of network access by putting our new thread to sleep for four seconds.</span></span> <span data-ttu-id="97923-218">この時点で、元[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]のスレッドはまだ実行中で、イベントに応答しています。</span><span class="sxs-lookup"><span data-stu-id="97923-218">In this time, the original [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread is still running and responding to events.</span></span> <span data-ttu-id="97923-219">これを示すために、アニメーションを実行したままにしておき、[最小化] ボタンと [最大化] ボタンも引き続き機能します。</span><span class="sxs-lookup"><span data-stu-id="97923-219">To show this, we’ve left an animation running, and the minimize and maximize buttons also continue to work.</span></span>  
  
 <span data-ttu-id="97923-220">遅延が終了し、天気予報をランダムに選択した場合は、 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]スレッドに報告します。</span><span class="sxs-lookup"><span data-stu-id="97923-220">When the delay is finished, and we’ve randomly selected our weather forecast, it’s time to report back to the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="97923-221">これを行うには、スレッドの`UpdateUserInterface`を使用[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]して、スレッドで<xref:System.Windows.Threading.Dispatcher>の呼び出しをスケジュールします。</span><span class="sxs-lookup"><span data-stu-id="97923-221">We do this by scheduling a call to `UpdateUserInterface` in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread using that thread’s <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="97923-222">このスケジュールされたメソッドの呼び出しに、天気を説明する文字列を渡します。</span><span class="sxs-lookup"><span data-stu-id="97923-222">We pass a string describing the weather to this scheduled method call.</span></span>  
  
- <span data-ttu-id="97923-223">を更新する[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</span><span class="sxs-lookup"><span data-stu-id="97923-223">Updating the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</span></span>  
  
     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherupdateui)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherupdateui)]  
  
 <span data-ttu-id="97923-224">スレッド内のに時間がある場合は、の<xref:System.Windows.Threading.Dispatcher>スケジュールされた呼び出しが`UpdateUserInterface`実行されます。 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</span><span class="sxs-lookup"><span data-stu-id="97923-224">When the <xref:System.Windows.Threading.Dispatcher> in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread has time, it executes the scheduled call to `UpdateUserInterface`.</span></span> <span data-ttu-id="97923-225">このメソッドは、クロックアニメーションを停止し、天気を説明する画像を選択します。</span><span class="sxs-lookup"><span data-stu-id="97923-225">This method stops the clock animation and chooses an image to describe the weather.</span></span> <span data-ttu-id="97923-226">このイメージが表示され、"フェッチ予測" ボタンが復元されます。</span><span class="sxs-lookup"><span data-stu-id="97923-226">It displays this image and restores the "fetch forecast" button.</span></span>  
  
<a name="multi_browser"></a>   
### <a name="multiple-windows-multiple-threads"></a><span data-ttu-id="97923-227">複数のウィンドウ、複数のスレッド</span><span class="sxs-lookup"><span data-stu-id="97923-227">Multiple Windows, Multiple Threads</span></span>  
 <span data-ttu-id="97923-228">アプリケーション[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]によっては、複数のトップレベルウィンドウが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="97923-228">Some [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications require multiple top-level windows.</span></span> <span data-ttu-id="97923-229">1つのスレッド/<xref:System.Windows.Threading.Dispatcher>組み合わせで複数のウィンドウを管理することは完全に許容されますが、複数のスレッドがより適切なジョブを実行する場合もあります。</span><span class="sxs-lookup"><span data-stu-id="97923-229">It is perfectly acceptable for one Thread/<xref:System.Windows.Threading.Dispatcher> combination to manage multiple windows, but sometimes several threads do a better job.</span></span> <span data-ttu-id="97923-230">これは特に、いずれかのウィンドウがスレッドを独占する可能性がある場合に当てはまります。</span><span class="sxs-lookup"><span data-stu-id="97923-230">This is especially true if there is any chance that one of the windows will monopolize the thread.</span></span>  
  
 [!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)]<span data-ttu-id="97923-231">エクスプローラーでは、この方法で動作します。</span><span class="sxs-lookup"><span data-stu-id="97923-231">Explorer works in this fashion.</span></span> <span data-ttu-id="97923-232">新しいエクスプローラーウィンドウはそれぞれ元のプロセスに属していますが、独立したスレッドの制御下に作成されます。</span><span class="sxs-lookup"><span data-stu-id="97923-232">Each new Explorer window belongs to the original process, but it is created under the control of an independent thread.</span></span>  
  
 <span data-ttu-id="97923-233"><xref:System.Windows.Controls.Frame>コントロールを使用[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]して、Web ページを表示できます。</span><span class="sxs-lookup"><span data-stu-id="97923-233">By using a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<xref:System.Windows.Controls.Frame> control, we can display Web pages.</span></span> <span data-ttu-id="97923-234">簡単な[!INCLUDE[TLA2#tla_ie](../../../../includes/tla2sharptla-ie-md.md)]代替を簡単に作成できます。</span><span class="sxs-lookup"><span data-stu-id="97923-234">We can easily create a simple [!INCLUDE[TLA2#tla_ie](../../../../includes/tla2sharptla-ie-md.md)] substitute.</span></span> <span data-ttu-id="97923-235">まず、重要な機能である、新しいエクスプローラーウィンドウを開く機能について説明します。</span><span class="sxs-lookup"><span data-stu-id="97923-235">We start with an important feature: the ability to open a new explorer window.</span></span> <span data-ttu-id="97923-236">ユーザーが [新しいウィンドウ] ボタンをクリックすると、ウィンドウのコピーが別のスレッドで起動されます。</span><span class="sxs-lookup"><span data-stu-id="97923-236">When the user clicks the "new window" button, we launch a copy of our window in a separate thread.</span></span> <span data-ttu-id="97923-237">これにより、windows の1つで実行時間の長い操作またはブロック操作によって、他のウィンドウがすべてロックされることはありません。</span><span class="sxs-lookup"><span data-stu-id="97923-237">This way, long-running or blocking operations in one of the windows won’t lock all the other windows.</span></span>  
  
 <span data-ttu-id="97923-238">実際には、Web ブラウザーモデルには独自の複雑なスレッドモデルがあります。</span><span class="sxs-lookup"><span data-stu-id="97923-238">In reality, the Web browser model has its own complicated threading model.</span></span> <span data-ttu-id="97923-239">これは、ほとんどの閲覧者にとって理解しておく必要があるため、選択しました。</span><span class="sxs-lookup"><span data-stu-id="97923-239">We’ve chosen it because it should be familiar to most readers.</span></span>  
  
 <span data-ttu-id="97923-240">次の例は、コードを示しています。</span><span class="sxs-lookup"><span data-stu-id="97923-240">The following example shows the code.</span></span>  
  
 [!code-xaml[ThreadingMultipleBrowsers#ThreadingMultiBrowserXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml#threadingmultibrowserxaml)]  
  
 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsercodebehind)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsercodebehind)]  
  
 <span data-ttu-id="97923-241">このコードの次のスレッド処理セグメントは、このコンテキストで最も興味深いものです。</span><span class="sxs-lookup"><span data-stu-id="97923-241">The following threading segments of this code are the most interesting to us in this context:</span></span>  
  
 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsernewwindow)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsernewwindow)]  
  
 <span data-ttu-id="97923-242">このメソッドは、[新しいウィンドウ] ボタンがクリックされたときに呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="97923-242">This method is called when the "new window" button is clicked.</span></span> <span data-ttu-id="97923-243">新しいスレッドを作成し、非同期的に開始します。</span><span class="sxs-lookup"><span data-stu-id="97923-243">It creates a new thread and starts it asynchronously.</span></span>  
  
 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowserthreadstart)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowserthreadstart)]  
  
 <span data-ttu-id="97923-244">このメソッドは、新しいスレッドの開始点です。</span><span class="sxs-lookup"><span data-stu-id="97923-244">This method is the starting point for the new thread.</span></span> <span data-ttu-id="97923-245">このスレッドのコントロールの下に新しいウィンドウを作成します。</span><span class="sxs-lookup"><span data-stu-id="97923-245">We create a new window under the control of this thread.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="97923-246">新しいを<xref:System.Windows.Threading.Dispatcher>自動的に作成し、新しいスレッドを管理します。</span><span class="sxs-lookup"><span data-stu-id="97923-246">automatically creates a new <xref:System.Windows.Threading.Dispatcher> to manage the new thread.</span></span> <span data-ttu-id="97923-247">ウィンドウを機能させるには、 <xref:System.Windows.Threading.Dispatcher>を起動するだけで済みます。</span><span class="sxs-lookup"><span data-stu-id="97923-247">All we have to do to make the window functional is to start the <xref:System.Windows.Threading.Dispatcher>.</span></span>  
  
<a name="stumbling_points"></a>   
## <a name="technical-details-and-stumbling-points"></a><span data-ttu-id="97923-248">技術的な詳細とむやみポイント</span><span class="sxs-lookup"><span data-stu-id="97923-248">Technical Details and Stumbling Points</span></span>  
  
### <a name="writing-components-using-threading"></a><span data-ttu-id="97923-249">スレッド処理を使用したコンポーネントの記述</span><span class="sxs-lookup"><span data-stu-id="97923-249">Writing Components Using Threading</span></span>  
 <span data-ttu-id="97923-250">Microsoft .NET Framework 開発者ガイドでは、コンポーネントがクライアントに非同期動作を公開する方法のパターンについて説明します (「[イベントベースの非同期パターンの概要](../../../standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md)」を参照してください)。</span><span class="sxs-lookup"><span data-stu-id="97923-250">The Microsoft .NET Framework Developer's Guide describes a pattern for how a component can expose asynchronous behavior to its clients (see [Event-based Asynchronous Pattern Overview](../../../standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md)).</span></span> <span data-ttu-id="97923-251">たとえば、 `FetchWeatherFromServer`メソッドを再利用可能な非グラフィカルコンポーネントにパッケージ化するとします。</span><span class="sxs-lookup"><span data-stu-id="97923-251">For instance, suppose we wanted to package the `FetchWeatherFromServer` method into a reusable, nongraphical component.</span></span> <span data-ttu-id="97923-252">標準の Microsoft .NET Framework パターンに従うと、次のようになります。</span><span class="sxs-lookup"><span data-stu-id="97923-252">Following the standard Microsoft .NET Framework pattern, this would look something like the following.</span></span>  
  
 [!code-csharp[CommandingOverviewSnippets#ThreadingArticleWeatherComponent1](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent1)]
 [!code-vb[CommandingOverviewSnippets#ThreadingArticleWeatherComponent1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent1)]  
  
 <span data-ttu-id="97923-253">`GetWeatherAsync`バックグラウンドスレッドの作成など、前に説明した手法のいずれかを使用して、非同期的に作業を実行し、呼び出し元のスレッドをブロックしません。</span><span class="sxs-lookup"><span data-stu-id="97923-253">`GetWeatherAsync` would use one of the techniques described earlier, such as creating a background thread, to do the work asynchronously, not blocking the calling thread.</span></span>  
  
 <span data-ttu-id="97923-254">このパターンの最も重要な部分の1つは、 *methodname* `Async`メソッドを呼び出したのと同じスレッドで*methodname* `Completed`メソッドを呼び出すことです。</span><span class="sxs-lookup"><span data-stu-id="97923-254">One of the most important parts of this pattern is calling the *MethodName*`Completed` method on the same thread that called the *MethodName*`Async` method to begin with.</span></span> <span data-ttu-id="97923-255">これは、 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]を格納<xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>することで非常に簡単に行うことができます。ただし、グラフィカルでないコンポーネントは、 [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)]または ASP.NET プログラムではなく、アプリケーションで[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]のみ使用できます。</span><span class="sxs-lookup"><span data-stu-id="97923-255">You could do this using [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] fairly easily, by storing <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>—but then the nongraphical component could only be used in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications, not in [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] or ASP.NET programs.</span></span>  
  
 <span data-ttu-id="97923-256">クラス<xref:System.Windows.Threading.DispatcherSynchronizationContext>はこのニーズに対応しており、他[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]のフレームワークで<xref:System.Windows.Threading.Dispatcher>も動作するの簡略化されたバージョンと考えてください。</span><span class="sxs-lookup"><span data-stu-id="97923-256">The <xref:System.Windows.Threading.DispatcherSynchronizationContext> class addresses this need—think of it as a simplified version of <xref:System.Windows.Threading.Dispatcher> that works with other [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] frameworks as well.</span></span>  
  
 [!code-csharp[CommandingOverviewSnippets#ThreadingArticleWeatherComponent2](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent2)]
 [!code-vb[CommandingOverviewSnippets#ThreadingArticleWeatherComponent2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent2)]  
  
### <a name="nested-pumping"></a><span data-ttu-id="97923-257">入れ子になったポンプ</span><span class="sxs-lookup"><span data-stu-id="97923-257">Nested Pumping</span></span>  
 <span data-ttu-id="97923-258">場合によっては、 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]スレッドを完全にロックすることはできません。</span><span class="sxs-lookup"><span data-stu-id="97923-258">Sometimes it is not feasible to completely lock up the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="97923-259">クラスのメソッドに<xref:System.Windows.MessageBox.Show%2A>ついて考えてみましょう。 <xref:System.Windows.MessageBox></span><span class="sxs-lookup"><span data-stu-id="97923-259">Let’s consider the <xref:System.Windows.MessageBox.Show%2A> method of the <xref:System.Windows.MessageBox> class.</span></span> <span data-ttu-id="97923-260"><xref:System.Windows.MessageBox.Show%2A>ユーザーが [OK] ボタンをクリックするまでは戻りません。</span><span class="sxs-lookup"><span data-stu-id="97923-260"><xref:System.Windows.MessageBox.Show%2A> doesn’t return until the user clicks the OK button.</span></span> <span data-ttu-id="97923-261">ただし、対話型にするためにメッセージループが必要なウィンドウを作成します。</span><span class="sxs-lookup"><span data-stu-id="97923-261">It does, however, create a window that must have a message loop in order to be interactive.</span></span> <span data-ttu-id="97923-262">ユーザーが [OK] をクリックするのを待機している間、元のアプリケーションウィンドウはユーザー入力に応答しません。</span><span class="sxs-lookup"><span data-stu-id="97923-262">While we are waiting for the user to click OK, the original application window does not respond to user input.</span></span> <span data-ttu-id="97923-263">ただし、描画メッセージの処理は続行されます。</span><span class="sxs-lookup"><span data-stu-id="97923-263">It does, however, continue to process paint messages.</span></span> <span data-ttu-id="97923-264">元のウィンドウは、カバーされて表示されたときに再描画します。</span><span class="sxs-lookup"><span data-stu-id="97923-264">The original window redraws itself when covered and revealed.</span></span>  
  
 ![MessageBox と [OK] ボタンを示すスクリーンショット](./media/threading-model/threading-message-loop.png)  
  
 <span data-ttu-id="97923-266">スレッドによっては、メッセージボックスウィンドウが使用されている必要があります。</span><span class="sxs-lookup"><span data-stu-id="97923-266">Some thread must be in charge of the message box window.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="97923-267">メッセージボックスウィンドウだけに新しいスレッドを作成することもできますが、このスレッドでは、元のウィンドウで無効になっている要素を描画することはできません (前述の相互排他の説明を思い出してください)。</span><span class="sxs-lookup"><span data-stu-id="97923-267">could create a new thread just for the message box window, but this thread would be unable to paint the disabled elements in the original window (remember the earlier discussion of mutual exclusion).</span></span> <span data-ttu-id="97923-268">代わりに、 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]は入れ子になったメッセージ処理システムを使用します。</span><span class="sxs-lookup"><span data-stu-id="97923-268">Instead, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uses a nested message processing system.</span></span> <span data-ttu-id="97923-269">クラス<xref:System.Windows.Threading.Dispatcher>には、という<xref:System.Windows.Threading.Dispatcher.PushFrame%2A>特殊なメソッドが含まれています。このメソッドは、アプリケーションの現在の実行ポイントを格納し、新しいメッセージループを開始します。</span><span class="sxs-lookup"><span data-stu-id="97923-269">The <xref:System.Windows.Threading.Dispatcher> class includes a special method called <xref:System.Windows.Threading.Dispatcher.PushFrame%2A>, which stores an application’s current execution point then begins a new message loop.</span></span> <span data-ttu-id="97923-270">入れ子になったメッセージループが完了すると、元<xref:System.Windows.Threading.Dispatcher.PushFrame%2A>の呼び出しの後に実行が再開されます。</span><span class="sxs-lookup"><span data-stu-id="97923-270">When the nested message loop finishes, execution resumes after the original <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> call.</span></span>  
  
 <span data-ttu-id="97923-271">この場合、は<xref:System.Windows.Threading.Dispatcher.PushFrame%2A>の<xref:System.Windows.MessageBox>呼び出し<xref:System.Windows.MessageBox.Show%2A>でプログラムコンテキストを保持し、新しいメッセージループを開始してバックグラウンドウィンドウを再描画し、メッセージボックスウィンドウへの入力を処理します。</span><span class="sxs-lookup"><span data-stu-id="97923-271">In this case, <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> maintains the program context at the call to <xref:System.Windows.MessageBox>.<xref:System.Windows.MessageBox.Show%2A>, and it starts a new message loop to repaint the background window and handle input to the message box window.</span></span> <span data-ttu-id="97923-272">ユーザーが [OK] をクリックしてポップアップウィンドウをクリアすると、入れ子になったループが終了し<xref:System.Windows.MessageBox.Show%2A>、への呼び出しの後で制御が再開されます。</span><span class="sxs-lookup"><span data-stu-id="97923-272">When the user clicks OK and clears the pop-up window, the nested loop exits and control resumes after the call to <xref:System.Windows.MessageBox.Show%2A>.</span></span>  
  
### <a name="stale-routed-events"></a><span data-ttu-id="97923-273">古いルーティングイベント</span><span class="sxs-lookup"><span data-stu-id="97923-273">Stale Routed Events</span></span>  
 <span data-ttu-id="97923-274">のルーティングイベントシステムは[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 、イベントが発生したときにツリー全体に通知します。</span><span class="sxs-lookup"><span data-stu-id="97923-274">The routed event system in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] notifies entire trees when events are raised.</span></span>  
  
 [!code-xaml[InputOvw#ThreadingArticleStaticRoutedEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml#threadingarticlestaticroutedevent)]  
  
 <span data-ttu-id="97923-275">マウスの左ボタンが楕円上で押されると`handler2` 、が実行されます。</span><span class="sxs-lookup"><span data-stu-id="97923-275">When the left mouse button is pressed over the ellipse, `handler2` is executed.</span></span> <span data-ttu-id="97923-276">が終了すると、を使用`handler1`して<xref:System.Windows.Controls.Canvas>オブジェクトを処理するオブジェクトにイベントが渡されます。 `handler2`</span><span class="sxs-lookup"><span data-stu-id="97923-276">After `handler2` finishes, the event is passed along to the <xref:System.Windows.Controls.Canvas> object, which uses `handler1` to process it.</span></span> <span data-ttu-id="97923-277">このエラーは、 `handler2`がイベントオブジェクトを処理済みとして明示的にマークしていない場合にのみ発生します。</span><span class="sxs-lookup"><span data-stu-id="97923-277">This happens only if `handler2` does not explicitly mark the event object as handled.</span></span>  
  
 <span data-ttu-id="97923-278">このイベントの処理`handler2`には多くの時間がかかる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="97923-278">It’s possible that `handler2` will take a great deal of time processing this event.</span></span> <span data-ttu-id="97923-279">`handler2`は、 <xref:System.Windows.Threading.Dispatcher.PushFrame%2A>を使用して、時間を返さない入れ子になったメッセージループを開始する場合があります。</span><span class="sxs-lookup"><span data-stu-id="97923-279">`handler2` might use <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> to begin a nested message loop that doesn’t return for hours.</span></span> <span data-ttu-id="97923-280">が`handler2` 、このメッセージループが完了したときにイベントを処理済みとしてマークしていない場合、イベントは非常に古い場合でも、ツリーに渡されます。</span><span class="sxs-lookup"><span data-stu-id="97923-280">If `handler2` does not mark the event as handled when this message loop is complete, the event is passed up the tree even though it is very old.</span></span>  
  
### <a name="reentrancy-and-locking"></a><span data-ttu-id="97923-281">再入とロック</span><span class="sxs-lookup"><span data-stu-id="97923-281">Reentrancy and Locking</span></span>  
 <span data-ttu-id="97923-282">のロックメカニズムは、 [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)]まったく同じように動作しません。ロックを要求するときに、スレッドが完全に操作を停止することが予想される場合があります。</span><span class="sxs-lookup"><span data-stu-id="97923-282">The locking mechanism of the [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] doesn’t behave exactly as one might imagine; one might expect a thread to cease operation completely when requesting a lock.</span></span> <span data-ttu-id="97923-283">実際には、スレッドは、優先度の高いメッセージを受信して処理し続けます。</span><span class="sxs-lookup"><span data-stu-id="97923-283">In actuality, the thread continues to receive and process high-priority messages.</span></span> <span data-ttu-id="97923-284">これにより、デッドロックを防止し、インターフェイスの応答性を最小限にすることができますが、軽度のバグが生じる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="97923-284">This helps prevent deadlocks and make interfaces minimally responsive, but it introduces the possibility for subtle bugs.</span></span>  <span data-ttu-id="97923-285">ほとんどの場合、この点について知る必要はありませんが、まれな状況 (通常[!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)]はウィンドウメッセージや COM STA コンポーネントが関係します) では、このことについて理解しておく価値があります。</span><span class="sxs-lookup"><span data-stu-id="97923-285">The vast majority of the time you don’t need to know anything about this, but under rare circumstances (usually involving [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] window messages or COM STA components) this can be worth knowing.</span></span>  
  
 <span data-ttu-id="97923-286">多くのインターフェイスは、 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]が複数のスレッドによってアクセスされることがないという前提で開発者が作業するため、スレッドセーフを考慮して構築されていません。</span><span class="sxs-lookup"><span data-stu-id="97923-286">Most interfaces are not built with thread safety in mind because developers work under the assumption that a [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] is never accessed by more than one thread.</span></span> <span data-ttu-id="97923-287">この場合、1つのスレッドが予期しない時間に環境を変更する可能性があるため<xref:System.Windows.Threading.DispatcherObject> 、相互排他機構が解決されるという不適切な影響が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="97923-287">In this case, that single thread may make environmental changes at unexpected times, causing those ill effects that the <xref:System.Windows.Threading.DispatcherObject> mutual exclusion mechanism is supposed to solve.</span></span> <span data-ttu-id="97923-288">次の擬似コードを考えてみましょう。</span><span class="sxs-lookup"><span data-stu-id="97923-288">Consider the following pseudocode:</span></span>  
  
 <span data-ttu-id="97923-289">![スレッド処理の再入を示す図。](./media/threading-model/threading-reentrancy.png "Threadingreentrancy 入")</span><span class="sxs-lookup"><span data-stu-id="97923-289">![Diagram that shows threading reentrancy.](./media/threading-model/threading-reentrancy.png "ThreadingReentrancy")</span></span>  
  
 <span data-ttu-id="97923-290">ほとんどの場合、このような予期しない再入に[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]よって問題が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="97923-290">Most of the time that’s the right thing, but there are times in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] where such unexpected reentrancy can really cause problems.</span></span> <span data-ttu-id="97923-291">そのため、特定のキー回[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]で<xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>、はを呼び出します。これにより、通常[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]の[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]ロックではなく再入可能なロックを使用するように、そのスレッドのロック命令が変更されます。</span><span class="sxs-lookup"><span data-stu-id="97923-291">So, at certain key times, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] calls <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>, which changes the lock instruction for that thread to use the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] reentrancy-free lock, instead of the usual [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] lock.</span></span>  
  
 <span data-ttu-id="97923-292">では、チーム[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]がこの動作を選択したのはなぜですか。</span><span class="sxs-lookup"><span data-stu-id="97923-292">So why did the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] team choose this behavior?</span></span> <span data-ttu-id="97923-293">これは、COM STA オブジェクトと終了スレッドで実行する必要がありました。</span><span class="sxs-lookup"><span data-stu-id="97923-293">It had to do with COM STA objects and the finalization thread.</span></span> <span data-ttu-id="97923-294">オブジェクトがガベージコレクションされると、 `Finalize`そのメソッドは[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]スレッドではなく、専用のファイナライザースレッドで実行されます。</span><span class="sxs-lookup"><span data-stu-id="97923-294">When an object is garbage collected, its `Finalize` method is run on the dedicated finalizer thread, not the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="97923-295">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]スレッド上で作成された COM STA オブジェクトは[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]スレッド上でのみ破棄されるため、問題が発生しています。</span><span class="sxs-lookup"><span data-stu-id="97923-295">And therein lies the problem, because a COM STA object that was created on the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread can only be disposed on the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="97923-296">は、に相当<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>します (この場合は Win32's `SendMessage`を使用します)。 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]</span><span class="sxs-lookup"><span data-stu-id="97923-296">The [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] does the equivalent of a <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> (in this case using Win32’s `SendMessage`).</span></span> <span data-ttu-id="97923-297">しかし、 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]スレッドがビジーの場合は、ファイナライザースレッドが停止し、COM STA オブジェクトを破棄できないため、深刻なメモリリークが発生します。</span><span class="sxs-lookup"><span data-stu-id="97923-297">But if the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread is busy, the finalizer thread is stalled and the COM STA object can’t be disposed, which creates a serious memory leak.</span></span> <span data-ttu-id="97923-298">そうする[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]ことで、チームはロックを機能させるための困難な呼び出しを行っていました。</span><span class="sxs-lookup"><span data-stu-id="97923-298">So the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] team made the tough call to make locks work the way they do.</span></span>  
  
 <span data-ttu-id="97923-299">の[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]タスクでは、メモリリークを再導入ずに、予期しない再入を避けることができます。これは、どこでも再入をブロックしないためです。</span><span class="sxs-lookup"><span data-stu-id="97923-299">The task for [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is to avoid unexpected reentrancy without reintroducing the memory leak, which is why we don’t block reentrancy everywhere.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="97923-300">関連項目</span><span class="sxs-lookup"><span data-stu-id="97923-300">See also</span></span>

- [<span data-ttu-id="97923-301">実行時間の長い計算サンプルを使用したシングルスレッドアプリケーション</span><span class="sxs-lookup"><span data-stu-id="97923-301">Single-Threaded Application with Long-Running Calculation Sample</span></span>](https://go.microsoft.com/fwlink/?LinkID=160038)
