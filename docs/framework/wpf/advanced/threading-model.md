---
title: スレッド モデル
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- text on buttons [WPF], updating
- message processing [WPF], nested
- blocking operations [WPF]
- Common Language Runtime (CLR), locking mechanism
- locking mechanism of Common Language Runtime (CLR)
- threading model [WPF]
- Word [WPF], spelling checking
- button text [WPF], updating
- spelling checking in Word [WPF]
- asynchronous behavior [WPF], exposing
- nested message processing [WPF]
- reentrancy [WPF]
ms.assetid: 02d8fd00-8d7c-4604-874c-58e40786770b
ms.openlocfilehash: 15115cc0ed14cb5605100ebe47abd5cd4dc02ec0
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/04/2018
---
# <a name="threading-model"></a><span data-ttu-id="9d530-102">スレッド モデル</span><span class="sxs-lookup"><span data-stu-id="9d530-102">Threading Model</span></span>
[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]<span data-ttu-id="9d530-103"> スレッド処理の問題の開発者を保存する設計されています。</span><span class="sxs-lookup"><span data-stu-id="9d530-103"> is designed to save developers from the difficulties of threading.</span></span> <span data-ttu-id="9d530-104">その結果、ほとんどの[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]開発者は、複数のスレッドを使用するインターフェイスを記述する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="9d530-104">As a result, the majority of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] developers won't have to write an interface that uses more than one thread.</span></span> <span data-ttu-id="9d530-105">マルチ スレッド プログラムは複雑でデバッグが困難であるため、避けてシングル スレッドが存在する場合。</span><span class="sxs-lookup"><span data-stu-id="9d530-105">Because multithreaded programs are complex and difficult to debug, they should be avoided when single-threaded solutions exist.</span></span>  
  
 <span data-ttu-id="9d530-106">関係なくどの程度設計上、ただし、いいえ[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]フレームワークができるソリューションを提供する、シングル スレッドの問題のすべての種類。</span><span class="sxs-lookup"><span data-stu-id="9d530-106">No matter how well architected, however, no [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] framework will ever be able to provide a single-threaded solution for every sort of problem.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="9d530-107"> 閉じるは、複数のスレッドを向上させるような状況はまだあります[!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)]の応答性またはアプリケーションのパフォーマンスです。</span><span class="sxs-lookup"><span data-stu-id="9d530-107"> comes close, but there are still situations where multiple threads improve [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] responsiveness or application performance.</span></span> <span data-ttu-id="9d530-108">いくつかの背景情報の資料を紹介した後は、このペーパーは、これらの状況について説明し、最後にいくつかの低レベルの詳細の詳細についてはします。</span><span class="sxs-lookup"><span data-stu-id="9d530-108">After discussing some background material, this paper explores some of these situations and then concludes with a discussion of some lower-level details.</span></span>  
  

  
> [!NOTE]
>  <span data-ttu-id="9d530-109">このトピックでは、スレッドを使用して、<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>非同期呼び出しのメソッドです。</span><span class="sxs-lookup"><span data-stu-id="9d530-109">This topic discusses threading by using the <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method for asynchronous calls.</span></span> <span data-ttu-id="9d530-110">呼び出しての非同期呼び出しを行うことも、<xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A>メソッドで、実行、<xref:System.Action>または<xref:System.Func%601>をパラメーターとして。</span><span class="sxs-lookup"><span data-stu-id="9d530-110">You can also make asynchronous calls by calling the <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method, which take an <xref:System.Action> or <xref:System.Func%601> as a parameter.</span></span>  <span data-ttu-id="9d530-111"><xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A>メソッドを返します、<xref:System.Windows.Threading.DispatcherOperation>または<xref:System.Windows.Threading.DispatcherOperation%601>を持つ、<xref:System.Windows.Threading.DispatcherOperation.Task%2A>プロパティです。</span><span class="sxs-lookup"><span data-stu-id="9d530-111">The <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method returns a <xref:System.Windows.Threading.DispatcherOperation> or <xref:System.Windows.Threading.DispatcherOperation%601>, which has a <xref:System.Windows.Threading.DispatcherOperation.Task%2A> property.</span></span> <span data-ttu-id="9d530-112">使用することができます、`await`いずれかのキーワード、<xref:System.Windows.Threading.DispatcherOperation>または関連付けられた<xref:System.Threading.Tasks.Task>です。</span><span class="sxs-lookup"><span data-stu-id="9d530-112">You can use the `await` keyword with either the <xref:System.Windows.Threading.DispatcherOperation> or the associated <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="9d530-113"><xref:System.Threading.Tasks.Task> または <xref:System.Windows.Threading.DispatcherOperation> によって返される <xref:System.Windows.Threading.DispatcherOperation%601> を同期的に待機する必要がある場合、<xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A> 拡張メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9d530-113">If you need to wait synchronously for the <xref:System.Threading.Tasks.Task> that is returned by a <xref:System.Windows.Threading.DispatcherOperation> or <xref:System.Windows.Threading.DispatcherOperation%601>, call the <xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A> extension method.</span></span>  <span data-ttu-id="9d530-114">呼び出す<xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>デッドロックが発生します。</span><span class="sxs-lookup"><span data-stu-id="9d530-114">Calling <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> will result in a deadlock.</span></span> <span data-ttu-id="9d530-115">使用しての詳細については、<xref:System.Threading.Tasks.Task>非同期操作を実行するタスクの並列化を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9d530-115">For more information about using a <xref:System.Threading.Tasks.Task> to perform asynchronous operations, see Task Parallelism.</span></span>  <span data-ttu-id="9d530-116"><xref:System.Windows.Threading.Dispatcher.Invoke%2A>メソッドにも使用するオーバー ロードが、<xref:System.Action>または<xref:System.Func%601>をパラメーターとして。</span><span class="sxs-lookup"><span data-stu-id="9d530-116">The <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method also has overloads that take an <xref:System.Action> or <xref:System.Func%601> as a parameter.</span></span>  <span data-ttu-id="9d530-117">使用することができます、<xref:System.Windows.Threading.Dispatcher.Invoke%2A>をデリゲートに渡すことで同期させるメソッドを呼び出す<xref:System.Action>または<xref:System.Func%601>です。</span><span class="sxs-lookup"><span data-stu-id="9d530-117">You can use the <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method to make synchronous calls by passing in a delegate, <xref:System.Action> or <xref:System.Func%601>.</span></span>  
  
<a name="threading_overview"></a>   
## <a name="overview-and-the-dispatcher"></a><span data-ttu-id="9d530-118">概要、およびディスパッチャー</span><span class="sxs-lookup"><span data-stu-id="9d530-118">Overview and the Dispatcher</span></span>  
 <span data-ttu-id="9d530-119">通常、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]アプリケーションが 2 つのスレッドの開始: 表示および管理用に別の処理の 1 つ、[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]です。</span><span class="sxs-lookup"><span data-stu-id="9d530-119">Typically, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications start with two threads: one for handling rendering and another for managing the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="9d530-120">レンダリング スレッドが効率的に実行中にバック グラウンドで非表示、[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]スレッドの入力を受け取り、イベントを処理、画面の描画およびアプリケーション コードを実行します。</span><span class="sxs-lookup"><span data-stu-id="9d530-120">The rendering thread effectively runs hidden in the background while the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread receives input, handles events, paints the screen, and runs application code.</span></span> <span data-ttu-id="9d530-121">ほとんどのアプリケーションが 1 つを使用して[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]スレッドが、状況によってがいくつかの使用を推奨します。</span><span class="sxs-lookup"><span data-stu-id="9d530-121">Most applications use a single [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread, although in some situations it is best to use several.</span></span> <span data-ttu-id="9d530-122">について説明しますこの例を使用して後で。</span><span class="sxs-lookup"><span data-stu-id="9d530-122">We’ll discuss this with an example later.</span></span>  
  
 <span data-ttu-id="9d530-123">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]スレッドのキューの作業と呼ばれるオブジェクト内の項目、<xref:System.Windows.Threading.Dispatcher>です。</span><span class="sxs-lookup"><span data-stu-id="9d530-123">The [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread queues work items inside an object called a <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="9d530-124"><xref:System.Windows.Threading.Dispatcher> は作業項目を優先順位に従って選択し、それぞれを最後まで実行します。</span><span class="sxs-lookup"><span data-stu-id="9d530-124">The <xref:System.Windows.Threading.Dispatcher> selects work items on a priority basis and runs each one to completion.</span></span>  <span data-ttu-id="9d530-125">すべて[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]スレッドは少なくとも 1 つである必要があります<xref:System.Windows.Threading.Dispatcher>、および各<xref:System.Windows.Threading.Dispatcher>正確に 1 つのスレッドでの作業項目を実行することができます。</span><span class="sxs-lookup"><span data-stu-id="9d530-125">Every [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread must have at least one <xref:System.Windows.Threading.Dispatcher>, and each <xref:System.Windows.Threading.Dispatcher> can execute work items in exactly one thread.</span></span>  
  
 <span data-ttu-id="9d530-126">最大化する応答性の高い、使いやすいアプリケーションを構築することが重要、<xref:System.Windows.Threading.Dispatcher>小さな作業項目を保持することでスループットです。</span><span class="sxs-lookup"><span data-stu-id="9d530-126">The trick to building responsive, user-friendly applications is to maximize the <xref:System.Windows.Threading.Dispatcher> throughput by keeping the work items small.</span></span> <span data-ttu-id="9d530-127">により、この項目は達しませんにとどまっている古い、<xref:System.Windows.Threading.Dispatcher>キュー処理を待機しています。</span><span class="sxs-lookup"><span data-stu-id="9d530-127">This way items never get stale sitting in the <xref:System.Windows.Threading.Dispatcher> queue waiting for processing.</span></span> <span data-ttu-id="9d530-128">入力と応答の間に遅延ユーザーはストレスを感じることができます。</span><span class="sxs-lookup"><span data-stu-id="9d530-128">Any perceivable delay between input and response can frustrate a user.</span></span>  
  
 <span data-ttu-id="9d530-129">方法、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]アプリケーション大規模な操作を処理する必要がありますか。</span><span class="sxs-lookup"><span data-stu-id="9d530-129">How then are [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications supposed to handle big operations?</span></span> <span data-ttu-id="9d530-130">場合、コードを使用するか、大量の計算では、または、いくつかのリモート サーバー上のデータベースのクエリを実行する必要がありますか。</span><span class="sxs-lookup"><span data-stu-id="9d530-130">What if your code involves a large calculation or needs to query a database on some remote server?</span></span> <span data-ttu-id="9d530-131">まま、別のスレッドで大規模な操作を処理する、応答が通常は、[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]内の項目に傾向が空きスレッド、<xref:System.Windows.Threading.Dispatcher>キュー。</span><span class="sxs-lookup"><span data-stu-id="9d530-131">Usually, the answer is to handle the big operation in a separate thread, leaving the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread free to tend to items in the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="9d530-132">大規模な操作が完了したら、その結果を報告できるに戻す、[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]のスレッドを表示します。</span><span class="sxs-lookup"><span data-stu-id="9d530-132">When the big operation is complete, it can report its result back to the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread for display.</span></span>  
  
 <span data-ttu-id="9d530-133">従来、[!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)]により[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]は作成元のスレッドのみがアクセスする要素。</span><span class="sxs-lookup"><span data-stu-id="9d530-133">Historically, [!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)] allows [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elements to be accessed only by the thread that created them.</span></span> <span data-ttu-id="9d530-134">つまりが完了すると、いくつか実行時間の長いタスクを担当するバック グラウンド スレッドにテキスト ボックスを更新できません。</span><span class="sxs-lookup"><span data-stu-id="9d530-134">This means that a background thread in charge of some long-running task cannot update a text box when it is finished.</span></span> [!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)]<span data-ttu-id="9d530-135"> これは、整合性を確保ため[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]コンポーネントです。</span><span class="sxs-lookup"><span data-stu-id="9d530-135"> does this to ensure the integrity of [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] components.</span></span> <span data-ttu-id="9d530-136">リスト ボックスでしたにくい描画中に、バック グラウンド スレッドによってその内容が更新された場合。</span><span class="sxs-lookup"><span data-stu-id="9d530-136">A list box could look strange if its contents were updated by a background thread during painting.</span></span>  
  
 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="9d530-137"> この調整を適用する組み込みの相互排他メカニズムがあります。</span><span class="sxs-lookup"><span data-stu-id="9d530-137"> has a built-in mutual exclusion mechanism that enforces this coordination.</span></span> <span data-ttu-id="9d530-138">ほとんどのクラス[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]から派生<xref:System.Windows.Threading.DispatcherObject>です。</span><span class="sxs-lookup"><span data-stu-id="9d530-138">Most classes in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] derive from <xref:System.Windows.Threading.DispatcherObject>.</span></span> <span data-ttu-id="9d530-139">構築時に、<xref:System.Windows.Threading.DispatcherObject>への参照を格納、<xref:System.Windows.Threading.Dispatcher>現在実行中のスレッドにリンクします。</span><span class="sxs-lookup"><span data-stu-id="9d530-139">At construction, a <xref:System.Windows.Threading.DispatcherObject> stores a reference to the <xref:System.Windows.Threading.Dispatcher> linked to the currently running thread.</span></span> <span data-ttu-id="9d530-140">実際には、<xref:System.Windows.Threading.DispatcherObject>それを作成したスレッドを関連付けます。</span><span class="sxs-lookup"><span data-stu-id="9d530-140">In effect, the <xref:System.Windows.Threading.DispatcherObject> associates with the thread that creates it.</span></span> <span data-ttu-id="9d530-141">プログラムの実行中、<xref:System.Windows.Threading.DispatcherObject>そのパブリックを呼び出すことができます<xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A>メソッドです。</span><span class="sxs-lookup"><span data-stu-id="9d530-141">During program execution, a <xref:System.Windows.Threading.DispatcherObject> can call its public <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> method.</span></span> <span data-ttu-id="9d530-142"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> 調べ、 <xref:System.Windows.Threading.Dispatcher> 、現在のスレッドに関連付けられているし、比較する、<xref:System.Windows.Threading.Dispatcher>構築中に格納されている参照します。</span><span class="sxs-lookup"><span data-stu-id="9d530-142"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> examines the <xref:System.Windows.Threading.Dispatcher> associated with the current thread and compares it to the <xref:System.Windows.Threading.Dispatcher> reference stored during construction.</span></span> <span data-ttu-id="9d530-143">一致しない場合は、<xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A>例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="9d530-143">If they don’t match, <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> throws an exception.</span></span> <span data-ttu-id="9d530-144"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> 属するすべてのメソッドの開始時に呼び出されるものでは、<xref:System.Windows.Threading.DispatcherObject>です。</span><span class="sxs-lookup"><span data-stu-id="9d530-144"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> is intended to be called at the beginning of every method belonging to a <xref:System.Windows.Threading.DispatcherObject>.</span></span>  
  
 <span data-ttu-id="9d530-145">1 つのスレッドを変更できるだけの場合、 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]、方法はバック グラウンド スレッドと対話するユーザーですか?</span><span class="sxs-lookup"><span data-stu-id="9d530-145">If only one thread can modify the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)], how do background threads interact with the user?</span></span> <span data-ttu-id="9d530-146">バック グラウンド スレッドを求めることができます、[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]スレッドの代理で操作を実行します。</span><span class="sxs-lookup"><span data-stu-id="9d530-146">A background thread can ask the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread to perform an operation on its behalf.</span></span> <span data-ttu-id="9d530-147">これは、含む作業項目を登録することで、<xref:System.Windows.Threading.Dispatcher>の[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]スレッドです。</span><span class="sxs-lookup"><span data-stu-id="9d530-147">It does this by registering a work item with the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="9d530-148"><xref:System.Windows.Threading.Dispatcher>クラスは作業項目を登録するための 2 つのメソッドを提供します。<xref:System.Windows.Threading.Dispatcher.Invoke%2A>と<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>です。</span><span class="sxs-lookup"><span data-stu-id="9d530-148">The <xref:System.Windows.Threading.Dispatcher> class provides two methods for registering work items: <xref:System.Windows.Threading.Dispatcher.Invoke%2A> and <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</span></span> <span data-ttu-id="9d530-149">どちらの方法では、デリゲートの実行をスケジュールします。</span><span class="sxs-lookup"><span data-stu-id="9d530-149">Both methods schedule a delegate for execution.</span></span> <span data-ttu-id="9d530-150"><xref:System.Windows.Threading.Dispatcher.Invoke%2A> – の同期呼び出しは、つまりまで返されません、[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]スレッドが実際にはデリゲートの実行を終了します。</span><span class="sxs-lookup"><span data-stu-id="9d530-150"><xref:System.Windows.Threading.Dispatcher.Invoke%2A> is a synchronous call – that is, it doesn’t return until the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread actually finishes executing the delegate.</span></span> <span data-ttu-id="9d530-151"><xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> 非同期と直ちに返されます。</span><span class="sxs-lookup"><span data-stu-id="9d530-151"><xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> is asynchronous and returns immediately.</span></span>  
  
 <span data-ttu-id="9d530-152"><xref:System.Windows.Threading.Dispatcher>優先順位によって、キューに、要素を並べ替えます。</span><span class="sxs-lookup"><span data-stu-id="9d530-152">The <xref:System.Windows.Threading.Dispatcher> orders the elements in its queue by priority.</span></span> <span data-ttu-id="9d530-153">要素を追加するときに指定できる 10 のレベルがある、<xref:System.Windows.Threading.Dispatcher>キュー。</span><span class="sxs-lookup"><span data-stu-id="9d530-153">There are ten levels that may be specified when adding an element to the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="9d530-154">これらの優先順位はで保持されます、<xref:System.Windows.Threading.DispatcherPriority>列挙します。</span><span class="sxs-lookup"><span data-stu-id="9d530-154">These priorities are maintained in the <xref:System.Windows.Threading.DispatcherPriority> enumeration.</span></span> <span data-ttu-id="9d530-155">に関する詳細情報<xref:System.Windows.Threading.DispatcherPriority>レベルは含まれて、[!INCLUDE[TLA2#tla_winfxsdk](../../../../includes/tla2sharptla-winfxsdk-md.md)]ドキュメント。</span><span class="sxs-lookup"><span data-stu-id="9d530-155">Detailed information about <xref:System.Windows.Threading.DispatcherPriority> levels can be found in the [!INCLUDE[TLA2#tla_winfxsdk](../../../../includes/tla2sharptla-winfxsdk-md.md)] documentation.</span></span>  
  
<a name="samples"></a>   
## <a name="threads-in-action-the-samples"></a><span data-ttu-id="9d530-156">スレッドの動作: サンプル</span><span class="sxs-lookup"><span data-stu-id="9d530-156">Threads in Action: The Samples</span></span>  
  
<a name="prime_number"></a>   
### <a name="a-single-threaded-application-with-a-long-running-calculation"></a><span data-ttu-id="9d530-157">実行時間の長い計算でシングル スレッド アプリケーション</span><span class="sxs-lookup"><span data-stu-id="9d530-157">A Single-Threaded Application with a Long-Running Calculation</span></span>  
 <span data-ttu-id="9d530-158">ほとんど[!INCLUDE[TLA#tla_gui#plural](../../../../includes/tlasharptla-guisharpplural-md.md)]大部分のユーザーの操作への応答で生成されるイベントの待機中にアイドル状態の時間を費やしています。</span><span class="sxs-lookup"><span data-stu-id="9d530-158">Most [!INCLUDE[TLA#tla_gui#plural](../../../../includes/tlasharptla-guisharpplural-md.md)] spend a large portion of their time idle while waiting for events that are generated in response to user interactions.</span></span> <span data-ttu-id="9d530-159">慎重なプログラミング アイドル時間する建設的に使用できますの応答性に影響を与えず、[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]です。</span><span class="sxs-lookup"><span data-stu-id="9d530-159">With careful programming this idle time can be used constructively, without affecting the responsiveness of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="9d530-160">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]で行われている操作を中断する入力を許可しないスレッド モデル、[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]スレッドです。</span><span class="sxs-lookup"><span data-stu-id="9d530-160">The [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] threading model doesn’t allow input to interrupt an operation happening in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="9d530-161">つまりに戻るにことを確認する必要があります、<xref:System.Windows.Threading.Dispatcher>古い前に、入力イベントの保留中の処理を定期的にします。</span><span class="sxs-lookup"><span data-stu-id="9d530-161">This means you must be sure to return to the <xref:System.Windows.Threading.Dispatcher> periodically to process pending input events before they get stale.</span></span>  
  
 <span data-ttu-id="9d530-162">次に例を示します。</span><span class="sxs-lookup"><span data-stu-id="9d530-162">Consider the following example:</span></span>  
  
 <span data-ttu-id="9d530-163">![含まれる素数のスクリーン ショット](../../../../docs/framework/wpf/advanced/media/threadingprimenumberscreenshot.PNG "ThreadingPrimeNumberScreenShot")</span><span class="sxs-lookup"><span data-stu-id="9d530-163">![Prime numbers screen shot](../../../../docs/framework/wpf/advanced/media/threadingprimenumberscreenshot.PNG "ThreadingPrimeNumberScreenShot")</span></span>  
  
 <span data-ttu-id="9d530-164">この単純なアプリケーションは、素数を検索して 3 から上方にカウントします。</span><span class="sxs-lookup"><span data-stu-id="9d530-164">This simple application counts upwards from three, searching for prime numbers.</span></span> <span data-ttu-id="9d530-165">ユーザーがクリックしたとき、**開始**ボタン、検索を開始します。</span><span class="sxs-lookup"><span data-stu-id="9d530-165">When the user clicks the **Start** button, the search begins.</span></span> <span data-ttu-id="9d530-166">プログラムでは、素数を検出すると、その探索でユーザー インターフェイスを更新します。</span><span class="sxs-lookup"><span data-stu-id="9d530-166">When the program finds a prime, it updates the user interface with its discovery.</span></span> <span data-ttu-id="9d530-167">任意の時点では、ユーザーは、検索を停止できます。</span><span class="sxs-lookup"><span data-stu-id="9d530-167">At any point, the user can stop the search.</span></span>  
  
 <span data-ttu-id="9d530-168">単純なのでが素数の検索が永続的ないくつかの問題を提示に進んでください。</span><span class="sxs-lookup"><span data-stu-id="9d530-168">Although simple enough, the prime number search could go on forever, which presents some difficulties.</span></span>  <span data-ttu-id="9d530-169">ボタンの click イベント ハンドラー内で検索全体を処理した場合は与えられません、[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]スレッドが他のイベントを処理します。</span><span class="sxs-lookup"><span data-stu-id="9d530-169">If we handled the entire search inside of the click event handler of the button, we would never give the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread a chance to handle other events.</span></span> <span data-ttu-id="9d530-170">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]入力やプロセスに対応できないというメッセージです。</span><span class="sxs-lookup"><span data-stu-id="9d530-170">The [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] would be unable to respond to input or process messages.</span></span> <span data-ttu-id="9d530-171">再描画し、ボタンのクリックに応答しません。</span><span class="sxs-lookup"><span data-stu-id="9d530-171">It would never repaint and never respond to button clicks.</span></span>  
  
 <span data-ttu-id="9d530-172">個別のスレッドでの素数の検索を実施してでしたが、同期の問題に対処する必要がありますが、します。</span><span class="sxs-lookup"><span data-stu-id="9d530-172">We could conduct the prime number search in a separate thread, but then we would need to deal with synchronization issues.</span></span> <span data-ttu-id="9d530-173">シングル スレッドのアプローチで直接更新することが検出された最大の素数を一覧表示するラベル。</span><span class="sxs-lookup"><span data-stu-id="9d530-173">With a single-threaded approach, we can directly update the label that lists the largest prime found.</span></span>  
  
 <span data-ttu-id="9d530-174">管理しやすいチャンクに計算のタスクを中断して定期的に戻ることが、<xref:System.Windows.Threading.Dispatcher>およびイベントを処理します。</span><span class="sxs-lookup"><span data-stu-id="9d530-174">If we break up the task of calculation into manageable chunks, we can periodically return to the <xref:System.Windows.Threading.Dispatcher> and process events.</span></span> <span data-ttu-id="9d530-175">紹介[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]を再描画して、入力を処理することです。</span><span class="sxs-lookup"><span data-stu-id="9d530-175">We can give [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] an opportunity to repaint and process input.</span></span>  
  
 <span data-ttu-id="9d530-176">計算とイベント処理の間での処理時間を分割する最善の方法はから計算を管理する、<xref:System.Windows.Threading.Dispatcher>です。</span><span class="sxs-lookup"><span data-stu-id="9d530-176">The best way to split processing time between calculation and event handling is to manage calculation from the <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="9d530-177">使用して、<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>メソッド内の素数のチェックをスケジュールお同じキューを[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]からイベントが描画されます。</span><span class="sxs-lookup"><span data-stu-id="9d530-177">By using the <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method, we can schedule prime number checks in the same queue that [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] events are drawn from.</span></span> <span data-ttu-id="9d530-178">この例では、一度に 1 つの素数のチェックのみをスケジュールします。</span><span class="sxs-lookup"><span data-stu-id="9d530-178">In our example, we schedule only a single prime number check at a time.</span></span> <span data-ttu-id="9d530-179">素数のチェックが完了したら、すぐに次のチェックをスケジュールします。</span><span class="sxs-lookup"><span data-stu-id="9d530-179">After the prime number check is complete, we schedule the next check immediately.</span></span> <span data-ttu-id="9d530-180">このチェックが保留にした場合のみ進みます[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]イベントが処理されました。</span><span class="sxs-lookup"><span data-stu-id="9d530-180">This check proceeds only after pending [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] events have been handled.</span></span>  
  
 <span data-ttu-id="9d530-181">![ディスパッチャー キューの図](../../../../docs/framework/wpf/advanced/media/threadingdispatcherqueue.PNG "ThreadingDispatcherQueue")</span><span class="sxs-lookup"><span data-stu-id="9d530-181">![Dispatcher queue illustration](../../../../docs/framework/wpf/advanced/media/threadingdispatcherqueue.PNG "ThreadingDispatcherQueue")</span></span>  
  
 [!INCLUDE[TLA#tla_word](../../../../includes/tlasharptla-word-md.md)]<span data-ttu-id="9d530-182"> スペル チェックこのメカニズムを使用して実現しています。</span><span class="sxs-lookup"><span data-stu-id="9d530-182"> accomplishes spell checking using this mechanism.</span></span> <span data-ttu-id="9d530-183">スペル チェックのアイドル時間を使用して、バック グラウンドで行われますが、[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]スレッドです。</span><span class="sxs-lookup"><span data-stu-id="9d530-183">Spell checking is done in the background using the idle time of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="9d530-184">コードを見てをみましょう。</span><span class="sxs-lookup"><span data-stu-id="9d530-184">Let's take a look at the code.</span></span>  
  
 <span data-ttu-id="9d530-185">次の例では、ユーザー インターフェイスを作成する XAML を示します。</span><span class="sxs-lookup"><span data-stu-id="9d530-185">The following example shows the XAML that creates the user interface.</span></span>  
  
 [!code-xaml[ThreadingPrimeNumbers#ThreadingPrimeNumberXAML](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml#threadingprimenumberxaml)]  
  
 <span data-ttu-id="9d530-186">次の例では、分離コードを示します。</span><span class="sxs-lookup"><span data-stu-id="9d530-186">The following example shows the code-behind.</span></span>  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumbercodebehind)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumbercodebehind)]  
  
 <span data-ttu-id="9d530-187">次の例では、対応するイベント ハンドラー、<xref:System.Windows.Controls.Button>です。</span><span class="sxs-lookup"><span data-stu-id="9d530-187">The following example shows the event handler for the <xref:System.Windows.Controls.Button>.</span></span>  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberstartorstop)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberstartorstop)]  
  
 <span data-ttu-id="9d530-188">テキストの更新だけでなく、<xref:System.Windows.Controls.Button>の最初の素数のチェックをスケジュール設定するデリゲートを追加することで、このハンドラーは、<xref:System.Windows.Threading.Dispatcher>キュー。</span><span class="sxs-lookup"><span data-stu-id="9d530-188">Besides updating the text on the <xref:System.Windows.Controls.Button>, this handler is responsible for scheduling the first prime number check by adding a delegate to the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="9d530-189">このイベント ハンドラーには、作業が完了した後、<xref:System.Windows.Threading.Dispatcher>このデリゲートの実行を選択します。</span><span class="sxs-lookup"><span data-stu-id="9d530-189">Sometime after this event handler has completed its work, the <xref:System.Windows.Threading.Dispatcher> will select this delegate for execution.</span></span>  
  
 <span data-ttu-id="9d530-190">既に説明したよう、<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>は、<xref:System.Windows.Threading.Dispatcher>メンバー デリゲートの実行をスケジュールするために使用します。</span><span class="sxs-lookup"><span data-stu-id="9d530-190">As we mentioned earlier, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> is the <xref:System.Windows.Threading.Dispatcher> member used to schedule a delegate for execution.</span></span> <span data-ttu-id="9d530-191">この場合、ユーザーが選択、<xref:System.Windows.Threading.DispatcherPriority.SystemIdle>優先度。</span><span class="sxs-lookup"><span data-stu-id="9d530-191">In this case, we choose the <xref:System.Windows.Threading.DispatcherPriority.SystemIdle> priority.</span></span> <span data-ttu-id="9d530-192"><xref:System.Windows.Threading.Dispatcher>を処理する重要なイベントがない場合にのみ、このデリゲートは実行されます。</span><span class="sxs-lookup"><span data-stu-id="9d530-192">The <xref:System.Windows.Threading.Dispatcher> will execute this delegate only when there are no important events to process.</span></span> [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]<span data-ttu-id="9d530-193"> 応答性がチェックの番号よりも重要です。</span><span class="sxs-lookup"><span data-stu-id="9d530-193"> responsiveness is more important than number checking.</span></span> <span data-ttu-id="9d530-194">番号のチェックのルーチンを表す新しいデリゲートを渡します。</span><span class="sxs-lookup"><span data-stu-id="9d530-194">We also pass a new delegate representing the number-checking routine.</span></span>  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberchecknextnumber)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberchecknextnumber)]  
  
 <span data-ttu-id="9d530-195">このメソッドは、次の数が奇数の素数を確認します。</span><span class="sxs-lookup"><span data-stu-id="9d530-195">This method checks if the next odd number is prime.</span></span> <span data-ttu-id="9d530-196">メソッドが直接更新の主要なである場合、 `bigPrime` <xref:System.Windows.Controls.TextBlock>探索を反映するようにします。</span><span class="sxs-lookup"><span data-stu-id="9d530-196">If it is prime, the method directly updates the `bigPrime`<xref:System.Windows.Controls.TextBlock> to reflect its discovery.</span></span> <span data-ttu-id="9d530-197">これは、計算は、コンポーネントの作成に使用された同じスレッドで発生しているため実行できます。</span><span class="sxs-lookup"><span data-stu-id="9d530-197">We can do this because the calculation is occurring in the same thread that was used to create the component.</span></span> <span data-ttu-id="9d530-198">計算に使用する別のスレッド、選択したより複雑な同期機構を使用し、更新プログラムを実行する必要が、[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]スレッドです。</span><span class="sxs-lookup"><span data-stu-id="9d530-198">Had we chosen to use a separate thread for the calculation, we would have to use a more complicated synchronization mechanism and execute the update in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="9d530-199">このような状況は、次について説明します。</span><span class="sxs-lookup"><span data-stu-id="9d530-199">We’ll demonstrate this situation next.</span></span>  
  
 <span data-ttu-id="9d530-200">このサンプルの完全なソース コードについては、[実行時間の長い計算のサンプルを使用して、シングル スレッド アプリケーション](http://go.microsoft.com/fwlink/?LinkID=160038)</span><span class="sxs-lookup"><span data-stu-id="9d530-200">For the complete source code for this sample, see the [Single-Threaded Application with Long-Running Calculation Sample](http://go.microsoft.com/fwlink/?LinkID=160038)</span></span>  
  
<a name="weather_sim"></a>   
### <a name="handling-a-blocking-operation-with-a-background-thread"></a><span data-ttu-id="9d530-201">バック グラウンド スレッドでブロック操作の処理</span><span class="sxs-lookup"><span data-stu-id="9d530-201">Handling a Blocking Operation with a Background Thread</span></span>  
 <span data-ttu-id="9d530-202">グラフィカル アプリケーションでのブロック操作の処理は難しくなります。</span><span class="sxs-lookup"><span data-stu-id="9d530-202">Handling blocking operations in a graphical application can be difficult.</span></span> <span data-ttu-id="9d530-203">アプリケーションが停止したように表示されるので、イベント ハンドラーからブロッキング メソッドを呼び出すしたくありません。</span><span class="sxs-lookup"><span data-stu-id="9d530-203">We don’t want to call blocking methods from event handlers because the application will appear to freeze up.</span></span> <span data-ttu-id="9d530-204">別のスレッドを使用してこれらの操作を処理が完了したら、おと同期するために、[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]スレッドの直接変更できないため、[!INCLUDE[TLA2#tla_gui](../../../../includes/tla2sharptla-gui-md.md)]ワーカー スレッドからです。</span><span class="sxs-lookup"><span data-stu-id="9d530-204">We can use a separate thread to handle these operations, but when we’re done, we have to synchronize with the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread because we can’t directly modify the [!INCLUDE[TLA2#tla_gui](../../../../includes/tla2sharptla-gui-md.md)] from our worker thread.</span></span> <span data-ttu-id="9d530-205">使用して<xref:System.Windows.Threading.Dispatcher.Invoke%2A>または<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>にデリゲートを挿入する、<xref:System.Windows.Threading.Dispatcher>の[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]スレッドです。</span><span class="sxs-lookup"><span data-stu-id="9d530-205">We can use <xref:System.Windows.Threading.Dispatcher.Invoke%2A> or <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> to insert delegates into the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="9d530-206">最終的に、これらのデリゲートを変更する権限を持つ実行は[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]要素。</span><span class="sxs-lookup"><span data-stu-id="9d530-206">Eventually, these delegates will be executed with permission to modify [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elements.</span></span>  
  
 <span data-ttu-id="9d530-207">この例では、天気予報を取得するリモート プロシージャ コールを模倣します。</span><span class="sxs-lookup"><span data-stu-id="9d530-207">In this example, we mimic a remote procedure call that retrieves a weather forecast.</span></span> <span data-ttu-id="9d530-208">この呼び出しを実行する個別のワーカー スレッドを使用し、スケジュールで更新メソッド、<xref:System.Windows.Threading.Dispatcher>の[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]スレッドの完了時にします。</span><span class="sxs-lookup"><span data-stu-id="9d530-208">We use a separate worker thread to execute this call, and we schedule an update method in the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread when we’re finished.</span></span>  
  
 <span data-ttu-id="9d530-209">![UI スクリーン ショットを気象条件](../../../../docs/framework/wpf/advanced/media/threadingweatheruiscreenshot.PNG "ThreadingWeatherUIScreenShot")</span><span class="sxs-lookup"><span data-stu-id="9d530-209">![Weather UI screen shot](../../../../docs/framework/wpf/advanced/media/threadingweatheruiscreenshot.PNG "ThreadingWeatherUIScreenShot")</span></span>  
  
 [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherCodeBehind](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweathercodebehind)]
 [!code-vb[ThreadingWeatherForecast#ThreadingWeatherCodeBehind](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweathercodebehind)]  
  
 <span data-ttu-id="9d530-210">記録する詳細情報の一部を次に示します。</span><span class="sxs-lookup"><span data-stu-id="9d530-210">The following are some of the details to be noted.</span></span>  
  
-   <span data-ttu-id="9d530-211">ボタンのハンドラーを作成します。</span><span class="sxs-lookup"><span data-stu-id="9d530-211">Creating the Button Handler</span></span>  
  
     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherbuttonhandler)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherbuttonhandler)]  
  
 <span data-ttu-id="9d530-212">ボタンをクリックすると、お時計の図が表示され、それをアニメーション化を開始します。</span><span class="sxs-lookup"><span data-stu-id="9d530-212">When the button is clicked, we display the clock drawing and start animating it.</span></span> <span data-ttu-id="9d530-213">ここには、ボタンが無効にします。</span><span class="sxs-lookup"><span data-stu-id="9d530-213">We disable the button.</span></span> <span data-ttu-id="9d530-214">呼び出すお、`FetchWeatherFromServer`メソッドで新しいスレッドとし、戻り値を許可する、<xref:System.Windows.Threading.Dispatcher>天気予報を収集するを待つためにイベントを処理します。</span><span class="sxs-lookup"><span data-stu-id="9d530-214">We invoke the `FetchWeatherFromServer` method in a new thread, and then we return, allowing the <xref:System.Windows.Threading.Dispatcher> to process events while we wait to collect the weather forecast.</span></span>  
  
-   <span data-ttu-id="9d530-215">天気の取得</span><span class="sxs-lookup"><span data-stu-id="9d530-215">Fetching the Weather</span></span>  
  
     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherfetchweather)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherfetchweather)]  
  
 <span data-ttu-id="9d530-216">煩雑にならないように、この例ではネットワーク用のコードでは、実際がありません。</span><span class="sxs-lookup"><span data-stu-id="9d530-216">To keep things simple, we don’t actually have any networking code in this example.</span></span> <span data-ttu-id="9d530-217">代わりに、4 秒間スリープ状態に新しいスレッドを配置することでネットワーク アクセスの遅延をシミュレートします。</span><span class="sxs-lookup"><span data-stu-id="9d530-217">Instead, we simulate the delay of network access by putting our new thread to sleep for four seconds.</span></span> <span data-ttu-id="9d530-218">このとき、元の[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]スレッドがまだ実行されていると、イベントに応答しています。</span><span class="sxs-lookup"><span data-stu-id="9d530-218">In this time, the original [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread is still running and responding to events.</span></span> <span data-ttu-id="9d530-219">アニメーションの実行と、最小化残す、このメッセージを表示し、最大化するには、ボタンも引き続き機能します。</span><span class="sxs-lookup"><span data-stu-id="9d530-219">To show this, we’ve left an animation running, and the minimize and maximize buttons also continue to work.</span></span>  
  
 <span data-ttu-id="9d530-220">報告する時間の遅延が完了したら、際、天気予報をランダムに選択したことには、[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]スレッドです。</span><span class="sxs-lookup"><span data-stu-id="9d530-220">When the delay is finished, and we’ve randomly selected our weather forecast, it’s time to report back to the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="9d530-221">この作業を行うへの呼び出しをスケジュールすることによって`UpdateUserInterface`で、[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]スレッドのスレッドを使用して<xref:System.Windows.Threading.Dispatcher>です。</span><span class="sxs-lookup"><span data-stu-id="9d530-221">We do this by scheduling a call to `UpdateUserInterface` in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread using that thread’s <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="9d530-222">このスケジュールされたメソッドの呼び出しを天気を説明する文字列を渡します。</span><span class="sxs-lookup"><span data-stu-id="9d530-222">We pass a string describing the weather to this scheduled method call.</span></span>  
  
-   <span data-ttu-id="9d530-223">更新します [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</span><span class="sxs-lookup"><span data-stu-id="9d530-223">Updating the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</span></span>  
  
     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherupdateui)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherupdateui)]  
  
 <span data-ttu-id="9d530-224">ときに、<xref:System.Windows.Threading.Dispatcher>で、[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]スレッドに時間がある、スケジュールされた呼び出し実行`UpdateUserInterface`です。</span><span class="sxs-lookup"><span data-stu-id="9d530-224">When the <xref:System.Windows.Threading.Dispatcher> in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread has time, it executes the scheduled call to `UpdateUserInterface`.</span></span> <span data-ttu-id="9d530-225">このメソッドは、時計のアニメーションを停止し、天気を表すイメージを選択します。</span><span class="sxs-lookup"><span data-stu-id="9d530-225">This method stops the clock animation and chooses an image to describe the weather.</span></span> <span data-ttu-id="9d530-226">イメージが表示され、「フェッチ予測」ボタンを復元します。</span><span class="sxs-lookup"><span data-stu-id="9d530-226">It displays this image and restores the "fetch forecast" button.</span></span>  
  
<a name="multi_browser"></a>   
### <a name="multiple-windows-multiple-threads"></a><span data-ttu-id="9d530-227">複数のウィンドウ、複数のスレッド</span><span class="sxs-lookup"><span data-stu-id="9d530-227">Multiple Windows, Multiple Threads</span></span>  
 <span data-ttu-id="9d530-228">いくつか[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]アプリケーションが複数のトップレベル ウィンドウを必要とします。</span><span class="sxs-lookup"><span data-stu-id="9d530-228">Some [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications require multiple top-level windows.</span></span> <span data-ttu-id="9d530-229">完全に 1 つのスレッドもかまわない/<xref:System.Windows.Threading.Dispatcher>複数の windows では複数のスレッドもを管理するための組み合わせが的確にしないでください。</span><span class="sxs-lookup"><span data-stu-id="9d530-229">It is perfectly acceptable for one Thread/<xref:System.Windows.Threading.Dispatcher> combination to manage multiple windows, but sometimes several threads do a better job.</span></span> <span data-ttu-id="9d530-230">これは、windows の 1 つで、スレッドを占有する可能性がある場合は特に当てはまります。</span><span class="sxs-lookup"><span data-stu-id="9d530-230">This is especially true if there is any chance that one of the windows will monopolize the thread.</span></span>  
  
 [!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)]<span data-ttu-id="9d530-231"> エクスプ ローラーは、この方法で動作します。</span><span class="sxs-lookup"><span data-stu-id="9d530-231"> Explorer works in this fashion.</span></span> <span data-ttu-id="9d530-232">新しい各エクスプ ローラー ウィンドウが元のプロセスに属するが、独立したスレッドの制御下で作成されます。</span><span class="sxs-lookup"><span data-stu-id="9d530-232">Each new Explorer window belongs to the original process, but it is created under the control of an independent thread.</span></span>  
  
 <span data-ttu-id="9d530-233">使用して、 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <xref:System.Windows.Controls.Frame>コントロール、ページを表示することができます。</span><span class="sxs-lookup"><span data-stu-id="9d530-233">By using a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<xref:System.Windows.Controls.Frame> control, we can display Web pages.</span></span> <span data-ttu-id="9d530-234">単純なを簡単に作成できるよう[!INCLUDE[TLA2#tla_ie](../../../../includes/tla2sharptla-ie-md.md)]置換します。</span><span class="sxs-lookup"><span data-stu-id="9d530-234">We can easily create a simple [!INCLUDE[TLA2#tla_ie](../../../../includes/tla2sharptla-ie-md.md)] substitute.</span></span> <span data-ttu-id="9d530-235">重要な機能をまず: 新しいエクスプ ローラー ウィンドウを開く機能します。</span><span class="sxs-lookup"><span data-stu-id="9d530-235">We start with an important feature: the ability to open a new explorer window.</span></span> <span data-ttu-id="9d530-236">ユーザーが、新しいウィンドウをクリックしたとき ボタン、別のスレッドでウィンドウのコピーを起動します。</span><span class="sxs-lookup"><span data-stu-id="9d530-236">When the user clicks the "new window" button, we launch a copy of our window in a separate thread.</span></span> <span data-ttu-id="9d530-237">これにより、windows のいずれかで実行時間の長いまたはブロックしている操作は、他のすべての windows をロックしません。</span><span class="sxs-lookup"><span data-stu-id="9d530-237">This way, long-running or blocking operations in one of the windows won’t lock all the other windows.</span></span>  
  
 <span data-ttu-id="9d530-238">Web ブラウザーのモデルでは実際には、独自の複雑なスレッド モデルがあります。</span><span class="sxs-lookup"><span data-stu-id="9d530-238">In reality, the Web browser model has its own complicated threading model.</span></span> <span data-ttu-id="9d530-239">ほとんどのリーダーに慣れることがあるために選択しました。</span><span class="sxs-lookup"><span data-stu-id="9d530-239">We’ve chosen it because it should be familiar to most readers.</span></span>  
  
 <span data-ttu-id="9d530-240">次の例では、コードを示します。</span><span class="sxs-lookup"><span data-stu-id="9d530-240">The following example shows the code.</span></span>  
  
 [!code-xaml[ThreadingMultipleBrowsers#ThreadingMultiBrowserXAML](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml#threadingmultibrowserxaml)]  
  
 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsercodebehind)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsercodebehind)]  
  
 <span data-ttu-id="9d530-241">このコードの次のスレッド セグメント、最も重要な部分では、このコンテキストのとおりです。</span><span class="sxs-lookup"><span data-stu-id="9d530-241">The following threading segments of this code are the most interesting to us in this context:</span></span>  
  
 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsernewwindow)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsernewwindow)]  
  
 <span data-ttu-id="9d530-242">このメソッドが呼び出されます「新しいウィンドウ」ボタンをクリックします。</span><span class="sxs-lookup"><span data-stu-id="9d530-242">This method is called when the "new window" button is clicked.</span></span> <span data-ttu-id="9d530-243">新しいスレッドを作成し、それを非同期的に起動します。</span><span class="sxs-lookup"><span data-stu-id="9d530-243">It creates a new thread and starts it asynchronously.</span></span>  
  
 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowserthreadstart)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowserthreadstart)]  
  
 <span data-ttu-id="9d530-244">このメソッドは、新しいスレッドの開始ポイントです。</span><span class="sxs-lookup"><span data-stu-id="9d530-244">This method is the starting point for the new thread.</span></span> <span data-ttu-id="9d530-245">このスレッドの制御下で、新しいウィンドウを作成します。</span><span class="sxs-lookup"><span data-stu-id="9d530-245">We create a new window under the control of this thread.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="9d530-246"> 新たに自動的に作成<xref:System.Windows.Threading.Dispatcher>を新しいスレッドを管理します。</span><span class="sxs-lookup"><span data-stu-id="9d530-246"> automatically creates a new <xref:System.Windows.Threading.Dispatcher> to manage the new thread.</span></span> <span data-ttu-id="9d530-247">開始、ウィンドウを機能させるために必要なは、<xref:System.Windows.Threading.Dispatcher>です。</span><span class="sxs-lookup"><span data-stu-id="9d530-247">All we have to do to make the window functional is to start the <xref:System.Windows.Threading.Dispatcher>.</span></span>  
  
<a name="stumbling_points"></a>   
## <a name="technical-details-and-stumbling-points"></a><span data-ttu-id="9d530-248">技術的な詳細と障害点</span><span class="sxs-lookup"><span data-stu-id="9d530-248">Technical Details and Stumbling Points</span></span>  
  
### <a name="writing-components-using-threading"></a><span data-ttu-id="9d530-249">スレッドを使用するコンポーネントを記述</span><span class="sxs-lookup"><span data-stu-id="9d530-249">Writing Components Using Threading</span></span>  
 <span data-ttu-id="9d530-250">Microsoft .NET Framework 開発者ガイドは、コンポーネントがそのクライアントへの非同期動作を公開する方法のパターンを説明します (を参照してください[イベント ベースの非同期パターン概要](../../../../docs/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md))。</span><span class="sxs-lookup"><span data-stu-id="9d530-250">The Microsoft .NET Framework Developer's Guide describes a pattern for how a component can expose asynchronous behavior to its clients (see [Event-based Asynchronous Pattern Overview](../../../../docs/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md)).</span></span> <span data-ttu-id="9d530-251">たとえば、パッケージ化する場合、`FetchWeatherFromServer`を再利用可能なノングラフィック コンポーネントにメソッドです。</span><span class="sxs-lookup"><span data-stu-id="9d530-251">For instance, suppose we wanted to package the `FetchWeatherFromServer` method into a reusable, nongraphical component.</span></span> <span data-ttu-id="9d530-252">次の標準の Microsoft .NET Framework パターンには、次のようなこれはなります。</span><span class="sxs-lookup"><span data-stu-id="9d530-252">Following the standard Microsoft .NET Framework pattern, this would look something like the following.</span></span>  
  
 [!code-csharp[CommandingOverviewSnippets#ThreadingArticleWeatherComponent1](../../../../samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent1)]
 [!code-vb[CommandingOverviewSnippets#ThreadingArticleWeatherComponent1](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent1)]  
  
 <span data-ttu-id="9d530-253">`GetWeatherAsync` 使用など、バック グラウンド スレッドを作成する前に説明した手法のいずれかを非同期に作業を行うには、呼び出し元スレッドをブロックしていません。</span><span class="sxs-lookup"><span data-stu-id="9d530-253">`GetWeatherAsync` would use one of the techniques described earlier, such as creating a background thread, to do the work asynchronously, not blocking the calling thread.</span></span>  
  
 <span data-ttu-id="9d530-254">このパターンの最も重要な部分の 1 つを呼び出して、 *MethodName* `Completed`メソッドを呼び出した同じスレッドで、 *MethodName* `Async`で始まるメソッド。</span><span class="sxs-lookup"><span data-stu-id="9d530-254">One of the most important parts of this pattern is calling the *MethodName*`Completed` method on the same thread that called the *MethodName*`Async` method to begin with.</span></span> <span data-ttu-id="9d530-255">次を使用して[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]格納することにより、非常に簡単に<xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>— ノングラフィック コンポーネントでしたのみで使用されますが、 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 、アプリケーションではなく[!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)]または[!INCLUDE[TLA#tla_aspnet](../../../../includes/tlasharptla-aspnet-md.md)]プログラムです。</span><span class="sxs-lookup"><span data-stu-id="9d530-255">You could do this using [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] fairly easily, by storing <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>—but then the nongraphical component could only be used in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications, not in [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] or [!INCLUDE[TLA#tla_aspnet](../../../../includes/tlasharptla-aspnet-md.md)] programs.</span></span>  
  
 <span data-ttu-id="9d530-256"><xref:System.Windows.Threading.DispatcherSynchronizationContext>クラスこのニーズに対応 — ということの簡素化されたバージョンとして<xref:System.Windows.Threading.Dispatcher>を他の動作を[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]フレームワークもします。</span><span class="sxs-lookup"><span data-stu-id="9d530-256">The <xref:System.Windows.Threading.DispatcherSynchronizationContext> class addresses this need—think of it as a simplified version of <xref:System.Windows.Threading.Dispatcher> that works with other [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] frameworks as well.</span></span>  
  
 [!code-csharp[CommandingOverviewSnippets#ThreadingArticleWeatherComponent2](../../../../samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent2)]
 [!code-vb[CommandingOverviewSnippets#ThreadingArticleWeatherComponent2](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent2)]  
  
### <a name="nested-pumping"></a><span data-ttu-id="9d530-257">ポンピング入れ子になった</span><span class="sxs-lookup"><span data-stu-id="9d530-257">Nested Pumping</span></span>  
 <span data-ttu-id="9d530-258">ないを完全にロックして可能な場合があります、[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]スレッドです。</span><span class="sxs-lookup"><span data-stu-id="9d530-258">Sometimes it is not feasible to completely lock up the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="9d530-259">について考えてみます、<xref:System.Windows.MessageBox.Show%2A>のメソッド、<xref:System.Windows.MessageBox>クラスです。</span><span class="sxs-lookup"><span data-stu-id="9d530-259">Let’s consider the <xref:System.Windows.MessageBox.Show%2A> method of the <xref:System.Windows.MessageBox> class.</span></span> <span data-ttu-id="9d530-260"><xref:System.Windows.MessageBox.Show%2A> [ok] ボタンをクリックするまでを返しません。</span><span class="sxs-lookup"><span data-stu-id="9d530-260"><xref:System.Windows.MessageBox.Show%2A> doesn’t return until the user clicks the OK button.</span></span> <span data-ttu-id="9d530-261">対話するためにメッセージ ループが必要なウィンドウは、ただし、作成します。</span><span class="sxs-lookup"><span data-stu-id="9d530-261">It does, however, create a window that must have a message loop in order to be interactive.</span></span> <span data-ttu-id="9d530-262">ユーザーが [ok] をクリックするを待つ、中に、元のアプリケーション ウィンドウはユーザー入力に応答しません。</span><span class="sxs-lookup"><span data-stu-id="9d530-262">While we are waiting for the user to click OK, the original application window does not respond to user input.</span></span> <span data-ttu-id="9d530-263">ただし、引き続き必要が描画メッセージを処理します。</span><span class="sxs-lookup"><span data-stu-id="9d530-263">It does, however, continue to process paint messages.</span></span> <span data-ttu-id="9d530-264">元のウィンドウには、取り除いたときにそれ自体が再描画します。</span><span class="sxs-lookup"><span data-stu-id="9d530-264">The original window redraws itself when covered and revealed.</span></span>  
  
 <span data-ttu-id="9d530-265">![[OK] ボタンを含む MessageBox](../../../../docs/framework/wpf/advanced/media/threadingnestedpumping.png "ThreadingNestedPumping")</span><span class="sxs-lookup"><span data-stu-id="9d530-265">![MessageBox with an "OK" button](../../../../docs/framework/wpf/advanced/media/threadingnestedpumping.png "ThreadingNestedPumping")</span></span>  
  
 <span data-ttu-id="9d530-266">一部のスレッドは、メッセージ ボックス ウィンドウを担当する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9d530-266">Some thread must be in charge of the message box window.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="9d530-267"> 新しいスレッド、メッセージ ボックス ウィンドウを作成してが、このスレッドは元のウィンドウで無効になっている要素を描画することはできません (相互排他の以前のディスカッションを注意してください)。</span><span class="sxs-lookup"><span data-stu-id="9d530-267"> could create a new thread just for the message box window, but this thread would be unable to paint the disabled elements in the original window (remember the earlier discussion of mutual exclusion).</span></span> <span data-ttu-id="9d530-268">代わりに、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]処理システム入れ子になったメッセージを使用します。</span><span class="sxs-lookup"><span data-stu-id="9d530-268">Instead, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uses a nested message processing system.</span></span> <span data-ttu-id="9d530-269"><xref:System.Windows.Threading.Dispatcher>クラスと呼ばれる特殊なメソッドが含まれています。 <xref:System.Windows.Threading.Dispatcher.PushFrame%2A>、新しいメッセージ ループを開始し、アプリケーションの現在の実行ポイントを格納します。</span><span class="sxs-lookup"><span data-stu-id="9d530-269">The <xref:System.Windows.Threading.Dispatcher> class includes a special method called <xref:System.Windows.Threading.Dispatcher.PushFrame%2A>, which stores an application’s current execution point then begins a new message loop.</span></span> <span data-ttu-id="9d530-270">入れ子になったメッセージ ループが終了すると、元の後に実行が再開されます。<xref:System.Windows.Threading.Dispatcher.PushFrame%2A>呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9d530-270">When the nested message loop finishes, execution resumes after the original <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> call.</span></span>  
  
 <span data-ttu-id="9d530-271">ここでは、<xref:System.Windows.Threading.Dispatcher.PushFrame%2A>への呼び出しでプログラムのコンテキストを保持<xref:System.Windows.MessageBox>.<xref:System.Windows.MessageBox.Show%2A>をバック グラウンド ウィンドウを再描画し、メッセージ ボックス ウィンドウへの入力を処理する新しいメッセージ ループを開始するとします。</span><span class="sxs-lookup"><span data-stu-id="9d530-271">In this case, <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> maintains the program context at the call to <xref:System.Windows.MessageBox>.<xref:System.Windows.MessageBox.Show%2A>, and it starts a new message loop to repaint the background window and handle input to the message box window.</span></span> <span data-ttu-id="9d530-272">ユーザーが [ok] をクリックして、ポップアップ ウィンドウをクリア、入れ子になったループの終了し、呼び出しの後にコントロールが再開されます<xref:System.Windows.MessageBox.Show%2A>です。</span><span class="sxs-lookup"><span data-stu-id="9d530-272">When the user clicks OK and clears the pop-up window, the nested loop exits and control resumes after the call to <xref:System.Windows.MessageBox.Show%2A>.</span></span>  
  
### <a name="stale-routed-events"></a><span data-ttu-id="9d530-273">古いイベントのルーティング</span><span class="sxs-lookup"><span data-stu-id="9d530-273">Stale Routed Events</span></span>  
 <span data-ttu-id="9d530-274">ルーティング イベント システム[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]イベントが発生したときに、ツリー全体に通知します。</span><span class="sxs-lookup"><span data-stu-id="9d530-274">The routed event system in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] notifies entire trees when events are raised.</span></span>  
  
 [!code-xaml[InputOvw#ThreadingArticleStaticRoutedEvent](../../../../samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml#threadingarticlestaticroutedevent)]  
  
 <span data-ttu-id="9d530-275">楕円の上でマウスの左ボタンが押されたときに`handler2`を実行します。</span><span class="sxs-lookup"><span data-stu-id="9d530-275">When the left mouse button is pressed over the ellipse, `handler2` is executed.</span></span> <span data-ttu-id="9d530-276">後に`handler2`が終了したら、イベントに渡されます、<xref:System.Windows.Controls.Canvas>を使用してオブジェクト`handler1`それを処理します。</span><span class="sxs-lookup"><span data-stu-id="9d530-276">After `handler2` finishes, the event is passed along to the <xref:System.Windows.Controls.Canvas> object, which uses `handler1` to process it.</span></span> <span data-ttu-id="9d530-277">これは場合にのみ発生`handler2`は明示的にマーク イベント オブジェクト処理済みとして。</span><span class="sxs-lookup"><span data-stu-id="9d530-277">This happens only if `handler2` does not explicitly mark the event object as handled.</span></span>  
  
 <span data-ttu-id="9d530-278">可能であればを`handler2`かなりのこのイベントの処理時間がかかります。</span><span class="sxs-lookup"><span data-stu-id="9d530-278">It’s possible that `handler2` will take a great deal of time processing this event.</span></span> <span data-ttu-id="9d530-279">`handler2` 使用して<xref:System.Windows.Threading.Dispatcher.PushFrame%2A>を返さないため、時間を入れ子になったメッセージ ループを開始します。</span><span class="sxs-lookup"><span data-stu-id="9d530-279">`handler2` might use <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> to begin a nested message loop that doesn’t return for hours.</span></span> <span data-ttu-id="9d530-280">場合`handler2`イベントは、このメッセージ ループするときに処理するように完了のマークは、非常に古いなっても、ツリーをイベントが渡されます。</span><span class="sxs-lookup"><span data-stu-id="9d530-280">If `handler2` does not mark the event as handled when this message loop is complete, the event is passed up the tree even though it is very old.</span></span>  
  
### <a name="reentrancy-and-locking"></a><span data-ttu-id="9d530-281">再入およびロック</span><span class="sxs-lookup"><span data-stu-id="9d530-281">Reentrancy and Locking</span></span>  
 <span data-ttu-id="9d530-282">ロック メカニズム、[!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)]とまったく同じように動作しない想像のいずれかです。 期待されるスレッドのロックを要求するときに完全に操作を停止します。</span><span class="sxs-lookup"><span data-stu-id="9d530-282">The locking mechanism of the [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] doesn’t behave exactly as one might imagine; one might expect a thread to cease operation completely when requesting a lock.</span></span> <span data-ttu-id="9d530-283">実際で、スレッドは、優先度の高いメッセージ受信して処理を続行します。</span><span class="sxs-lookup"><span data-stu-id="9d530-283">In actuality, the thread continues to receive and process high-priority messages.</span></span> <span data-ttu-id="9d530-284">これにより、デッドロックを回避し、インターフェイスの最小応答は軽度のバグの可能性が導入されています。</span><span class="sxs-lookup"><span data-stu-id="9d530-284">This helps prevent deadlocks and make interfaces minimally responsive, but it introduces the possibility for subtle bugs.</span></span>  <span data-ttu-id="9d530-285">まれな状況が、これに関する知識は必要はありません時間の大部分 (通常、[!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)]ウィンドウ メッセージまたは COM STA コンポーネント) これは、知っておくと便利です。</span><span class="sxs-lookup"><span data-stu-id="9d530-285">The vast majority of the time you don’t need to know anything about this, but under rare circumstances (usually involving [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] window messages or COM STA components) this can be worth knowing.</span></span>  
  
 <span data-ttu-id="9d530-286">開発者は、あると仮定して操作するため、ほとんどのインターフェイスがスレッド セーフを考慮にビルドされないを[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]複数のスレッドからはアクセスできません。</span><span class="sxs-lookup"><span data-stu-id="9d530-286">Most interfaces are not built with thread safety in mind because developers work under the assumption that a [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] is never accessed by more than one thread.</span></span> <span data-ttu-id="9d530-287">この場合は、1 つのスレッドが、予期しない時期環境の変更を行うことがあります原因でこれらが間違っている効果、<xref:System.Windows.Threading.DispatcherObject>相互排他メカニズムを解決する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9d530-287">In this case, that single thread may make environmental changes at unexpected times, causing those ill effects that the <xref:System.Windows.Threading.DispatcherObject> mutual exclusion mechanism is supposed to solve.</span></span> <span data-ttu-id="9d530-288">次の疑似コードについて考えてみます。</span><span class="sxs-lookup"><span data-stu-id="9d530-288">Consider the following pseudocode:</span></span>  
  
 <span data-ttu-id="9d530-289">![スレッド処理再入のダイアグラム](../../../../docs/framework/wpf/advanced/media/threadingreentrancy.png "ThreadingReentrancy")</span><span class="sxs-lookup"><span data-stu-id="9d530-289">![Threading reentrancy diagram](../../../../docs/framework/wpf/advanced/media/threadingreentrancy.png "ThreadingReentrancy")</span></span>  
  
 <span data-ttu-id="9d530-290">ほとんどの時間を正しいことですが、時間[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]でこのような予期しない再入本当に問題が発生します。</span><span class="sxs-lookup"><span data-stu-id="9d530-290">Most of the time that’s the right thing, but there are times in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] where such unexpected reentrancy can really cause problems.</span></span> <span data-ttu-id="9d530-291">特定のキー時刻に[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]呼び出し<xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>、ロックの命令を使用するには、そのスレッドの変更、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]ではなく、通常、再入のないロック[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]ロックします。</span><span class="sxs-lookup"><span data-stu-id="9d530-291">So, at certain key times, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] calls <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>, which changes the lock instruction for that thread to use the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] reentrancy-free lock, instead of the usual [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] lock.</span></span>  
  
 <span data-ttu-id="9d530-292">では、どうしてでした、[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]チームは、この動作を選択しますか?</span><span class="sxs-lookup"><span data-stu-id="9d530-292">So why did the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] team choose this behavior?</span></span> <span data-ttu-id="9d530-293">COM STA オブジェクトと、終了処理スレッドを行うにがありました。</span><span class="sxs-lookup"><span data-stu-id="9d530-293">It had to do with COM STA objects and the finalization thread.</span></span> <span data-ttu-id="9d530-294">オブジェクトがガベージ コレクトされるときにその`Finalize`メソッドがない専用ファイナライザー スレッドで実行、[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]スレッドです。</span><span class="sxs-lookup"><span data-stu-id="9d530-294">When an object is garbage collected, its `Finalize` method is run on the dedicated finalizer thread, not the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="9d530-295">その中に問題があります、オブジェクトの COM STA で作成された、[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]でスレッドを破棄することができますのみ、[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]スレッドです。</span><span class="sxs-lookup"><span data-stu-id="9d530-295">And therein lies the problem, because a COM STA object that was created on the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread can only be disposed on the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="9d530-296">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]等しく、 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> (ここでは Win32 を使用して`SendMessage`)。</span><span class="sxs-lookup"><span data-stu-id="9d530-296">The [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] does the equivalent of a <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> (in this case using Win32’s `SendMessage`).</span></span> <span data-ttu-id="9d530-297">場合は、[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]スレッドがビジー状態で、ファイナライザー スレッドが停止しているし、深刻なメモリ リークが発生、COM STA オブジェクトを破棄することはできません。</span><span class="sxs-lookup"><span data-stu-id="9d530-297">But if the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread is busy, the finalizer thread is stalled and the COM STA object can’t be disposed, which creates a serious memory leak.</span></span> <span data-ttu-id="9d530-298">そのため、[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]チーム呼び出しを行った、難しいロック動作をさせるようにします。</span><span class="sxs-lookup"><span data-stu-id="9d530-298">So the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] team made the tough call to make locks work the way they do.</span></span>  
  
 <span data-ttu-id="9d530-299">タスクを[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]させず、メモリ リーク、再入 everywhere をブロックしない理由は、予期しない再入を避けることができます。</span><span class="sxs-lookup"><span data-stu-id="9d530-299">The task for [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is to avoid unexpected reentrancy without reintroducing the memory leak, which is why we don’t block reentrancy everywhere.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="9d530-300">関連項目</span><span class="sxs-lookup"><span data-stu-id="9d530-300">See Also</span></span>  
 [<span data-ttu-id="9d530-301">実行時間の長い計算のサンプルを使用して、シングル スレッド アプリケーション</span><span class="sxs-lookup"><span data-stu-id="9d530-301">Single-Threaded Application with Long-Running Calculation Sample</span></span>](http://go.microsoft.com/fwlink/?LinkID=160038)
