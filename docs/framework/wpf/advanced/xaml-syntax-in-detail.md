---
title: "XAML 構文の詳細"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-wpf
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- XML [WPF], namespaces
- XAML [WPF], parsing of attributes
- parsing of attributes [WPF]
- XAML [WPF], markup extensions
- attached properties [WPF]
- tag syntax [XAML]
- markup extensions [WPF]
- XAML [WPF], object element syntax
- XAML [WPF], syntax terminology
- attached events [WPF]
- lookup semantics [WPF]
- XAML [WPF], attached events
- XAML [WPF], content syntax
- XAML [WPF], lookup semantics
- content syntax [WPF]
- object element syntax [WPF]
- syntax terminology [XAML]
- XAML [WPF], attached properties
- attributes [XAML], parsing
- XAML [WPF], tag syntax
- XAML [WPF], attribute syntax
- property element syntax [WPF]
- terminology [XAML]
- namespaces [WPF], XML
- attribute syntax [XAML]
- XAML [WPF], property element syntax
ms.assetid: 67cce290-ca26-4c41-a797-b68aabc45479
caps.latest.revision: "26"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.workload: dotnet
ms.openlocfilehash: 88e66210fd8066e82a11d07ea0cfeb83808d646c
ms.sourcegitcommit: 16186c34a957fdd52e5db7294f291f7530ac9d24
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/22/2017
---
# <a name="xaml-syntax-in-detail"></a><span data-ttu-id="a9eb0-102">XAML 構文の詳細</span><span class="sxs-lookup"><span data-stu-id="a9eb0-102">XAML Syntax In Detail</span></span>
<span data-ttu-id="a9eb0-103">このトピックでは、XAML 構文の要素の記述に使用する用語を定義します。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-103">This topic defines the terms that are used to describe the elements of XAML syntax.</span></span> <span data-ttu-id="a9eb0-104">これらの条項は、具体的には、XAML や、XAML 言語レベルのサポート、System.Xaml で有効になっている基本的な XAML の概念を使用する他のフレームワークの WPF のドキュメントのどちらも、このドキュメントの残りの部分全体でよく使用されます。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-104">These terms are used frequently throughout the remainder of this documentation, both for WPF documentation specifically and for the other frameworks that use XAML or the basic XAML concepts enabled by the XAML language support at the System.Xaml level.</span></span> <span data-ttu-id="a9eb0-105">このトピックのトピックで導入された基本的な用語を詳述[XAML の概要 (WPF)](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md)です。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-105">This topic expands on the basic terminology introduced in the topic [XAML Overview (WPF)](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md).</span></span>  
  

  
<a name="the_xaml_language_specification"></a>   
## <a name="the-xaml-language-specification"></a><span data-ttu-id="a9eb0-106">XAML 言語仕様</span><span class="sxs-lookup"><span data-stu-id="a9eb0-106">The XAML Language Specification</span></span>  
 <span data-ttu-id="a9eb0-107">ここで定義された XAML 構文の用語の定義または、XAML 言語仕様内で参照されてもします。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-107">The XAML syntax terminology defined here is also defined or referenced within the XAML language specification.</span></span> <span data-ttu-id="a9eb0-108">XAML は、XML に基づく言語は、やに依存してまたは XML の構造的な規則について詳しく説明します。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-108">XAML is a language based on XML and follows or expands upon XML structural rules.</span></span> <span data-ttu-id="a9eb0-109">用語の一部はから共有または XML 言語または XML ドキュメント オブジェクト モデルを記述する場合によく使用する用語に基づきます。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-109">Some of the terminology is shared from or is based on the terminology commonly used when describing the XML language or the XML document object model.</span></span>  
  
 <span data-ttu-id="a9eb0-110">XAML 言語仕様の詳細については、ダウンロード[ \[MS-XAML\] ](http://go.microsoft.com/fwlink/?LinkId=114525) Microsoft ダウンロード センターからです。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-110">For more information about the XAML language specification, download [\[MS-XAML\]](http://go.microsoft.com/fwlink/?LinkId=114525) from the Microsoft Download Center.</span></span>  
  
<a name="xaml_and_clr"></a>   
## <a name="xaml-and-clr"></a><span data-ttu-id="a9eb0-111">XAML と CLR</span><span class="sxs-lookup"><span data-stu-id="a9eb0-111">XAML and CLR</span></span>  
 <span data-ttu-id="a9eb0-112">XAML は、マークアップ言語です。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-112">XAML is a markup language.</span></span> <span data-ttu-id="a9eb0-113">[!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)]により、ランタイムの実行、名によって、黙示、します。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-113">The [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)], as implied by its name, enables runtime execution.</span></span> <span data-ttu-id="a9eb0-114">XAML は単独で、CLR ランタイムによって直接使用される一般的な言語のいずれか。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-114">XAML is not by itself one of the common languages that is directly consumed by the CLR runtime.</span></span> <span data-ttu-id="a9eb0-115">代わりに、XAML の独自の型システムをサポートするいると考えることができます。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-115">Instead, you can think of XAML as supporting its own type system.</span></span> <span data-ttu-id="a9eb0-116">WPF によって使用される特定の XAML の解析を行ってシステムは、CLR および CLR 型システムで作成されています。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-116">The particular XAML parsing system that is used by WPF is built on the CLR and the CLR type system.</span></span> <span data-ttu-id="a9eb0-117">XAML の型は、wpf XAML が解析される際に、実行時の表現をインスタンス化する CLR 型にマップされます。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-117">XAML types are mapped to CLR types to instantiate a run time representation when the XAML for WPF is parsed.</span></span> <span data-ttu-id="a9eb0-118">このため、このドキュメントの構文のディスカッションの残りの部分は、XAML 言語仕様で同等の構文の説明がない場合でも、CLR 型システムへの参照を含まれます。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-118">For this reason, the remainder of discussion of syntax in this document will include references to the CLR type system, even though the equivalent syntax discussions in the XAML language specification do not.</span></span> <span data-ttu-id="a9eb0-119">(あたり、XAML 言語仕様レベルでは、XAML の型でしたにマップするその他の型システム、CLR であるはありませんが、作成して、別の XAML パーサーの使用が必要となります。)</span><span class="sxs-lookup"><span data-stu-id="a9eb0-119">(Per the XAML language specification level, XAML types could be mapped to any other type system, which does not have to be the CLR, but that would require the creation and use of a different XAML parser.)</span></span>  
  
#### <a name="members-of-types-and-class-inheritance"></a><span data-ttu-id="a9eb0-120">型のメンバーとクラスの継承</span><span class="sxs-lookup"><span data-stu-id="a9eb0-120">Members of Types and Class Inheritance</span></span>  
 <span data-ttu-id="a9eb0-121">プロパティおよびの XAML メンバーとして表示されるときに、そのイベント、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]型が基本型から継承された多くの場合。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-121">Properties and events as they appear as XAML members of a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] type are often inherited from base types.</span></span> <span data-ttu-id="a9eb0-122">たとえば、次の例:`<Button Background="Blue" .../>`です。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-122">For example, consider this example: `<Button Background="Blue" .../>`.</span></span> <span data-ttu-id="a9eb0-123"><xref:System.Windows.Controls.Control.Background%2A>プロパティは使用されません直ちに宣言されたプロパティで、<xref:System.Windows.Controls.Button>クラス、クラス定義、リフレクション結果、またはドキュメントを確認する場合は。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-123">The <xref:System.Windows.Controls.Control.Background%2A> property is not an immediately declared property on the <xref:System.Windows.Controls.Button> class, if you were to look at the class definition, reflection results, or the documentation.</span></span> <span data-ttu-id="a9eb0-124">代わりに、<xref:System.Windows.Controls.Control.Background%2A>ベースから継承された<xref:System.Windows.Controls.Control>クラスです。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-124">Instead, <xref:System.Windows.Controls.Control.Background%2A> is inherited from the base <xref:System.Windows.Controls.Control> class.</span></span>  
  
 <span data-ttu-id="a9eb0-125">クラスの継承の動作の[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]XAML 要素は重要な従来の XML マークアップをスキーマによって課される解釈します。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-125">The class inheritance behavior of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML elements is a significant departure from a schema-enforced interpretation of XML markup.</span></span> <span data-ttu-id="a9eb0-126">クラスの継承は中間の基本クラスは抽象クラスで特に場合、またはインターフェイスが含まれている場合、複雑になることができます。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-126">Class inheritance can become complex, particularly when intermediate base classes are abstract, or when interfaces are involved.</span></span> <span data-ttu-id="a9eb0-127">これは、1 つがある理由が XAML 要素およびその使用可能属性のセットを正確かつ完全には、スキーマ型を使用して表示するが困難に通常使用される[!INCLUDE[TLA2#tla_xml](../../../../includes/tla2sharptla-xml-md.md)]プログラミングでは、DTD または XSD 形式などです。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-127">This is one reason that the set of XAML elements and their permissible attributes is difficult to represent accurately and completely using the schema types that are typically used for [!INCLUDE[TLA2#tla_xml](../../../../includes/tla2sharptla-xml-md.md)] programming, such as DTD or XSD format.</span></span> <span data-ttu-id="a9eb0-128">別の理由がその拡張機能と XAML 言語自体の型マッピングの機能の使用可能な型とメンバーのすべての固定表現の完全性を妨げるものでいます。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-128">Another reason is that extensibility and type-mapping features of the XAML language itself preclude completeness of any fixed representation of the permissible types and members.</span></span>  
  
<a name="object_element_syntax"></a>   
## <a name="object-element-syntax"></a><span data-ttu-id="a9eb0-129">オブジェクト要素構文</span><span class="sxs-lookup"><span data-stu-id="a9eb0-129">Object Element Syntax</span></span>  
 <span data-ttu-id="a9eb0-130">*オブジェクトの要素の構文*XML 要素を宣言することによって、CLR クラスまたは構造体をインスタンス化する XAML マークアップの構文を示します。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-130">*Object element syntax* is the XAML markup syntax that instantiates a CLR class or structure by declaring an XML element.</span></span> <span data-ttu-id="a9eb0-131">この構文では、HTML などの他のマークアップ言語の要素の構文に似ています。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-131">This syntax resembles the element syntax of other markup languages such as HTML.</span></span> <span data-ttu-id="a9eb0-132">オブジェクトの要素の構文が左山かっこで始まる (\<)、クラスまたはインスタンス化されている構造体の型名ですぐにその後にします。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-132">Object element syntax begins with a left angle bracket (\<), followed immediately by the type name of the class or structure being instantiated.</span></span> <span data-ttu-id="a9eb0-133">0 個以上のスペース名の後、型、および 0 個以上の属性が宣言することも、オブジェクト要素上のそれぞれの属性名を区切る 1 つ以上のスペースを含む ="value"ペア。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-133">Zero or more spaces can follow the type name, and zero or more attributes may also be declared on the object element, with one or more spaces separating each attribute name="value" pair.</span></span> <span data-ttu-id="a9eb0-134">最後は、次のいずれかの必要があります。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-134">Finally, one of the following must be true:</span></span>  
  
-   <span data-ttu-id="a9eb0-135">要素とタグは、右の山かっこ (>) がすぐに続くフォワード スラッシュ (/) で閉じる必要があります。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-135">The element and tag must be closed by a forward slash (/) followed immediately by a right angle bracket (>).</span></span>  
  
-   <span data-ttu-id="a9eb0-136">開始タグは、右の山かっこ (>) で完了する必要があります。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-136">The opening tag must be completed by a right angle bracket (>).</span></span> <span data-ttu-id="a9eb0-137">他のオブジェクト要素、プロパティ要素、または内部のテキストは、開始タグをに従ってできます。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-137">Other object elements, property elements, or inner text, can follow the opening tag.</span></span> <span data-ttu-id="a9eb0-138">コンテンツをここで含めることが正確には通常、要素のオブジェクト モデルによって制限されます。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-138">Exactly what content may be contained here is typically constrained by the object model of the element.</span></span> <span data-ttu-id="a9eb0-139">対応するオブジェクトの要素のタグを終了する必要がありますも適切な入れ子でが存在し、その他の開始と終了タグのペアとのバランスをとる。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-139">The equivalent closing tag for the object element must also exist, in proper nesting and balance with other opening and closing tag pairs.</span></span>  
  
 <span data-ttu-id="a9eb0-140">.NET によって実装される XAML では、型、プロパティまたはイベント、および XAML 名前空間の CLR 名前空間とアセンブリに属性にオブジェクトの要素をマップするルールのセットがあります。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-140">XAML as implemented by .NET has a set of rules that map object elements into types, attributes into properties or events, and XAML namespaces to CLR namespaces plus assembly.</span></span> <span data-ttu-id="a9eb0-141">WPF と .NET Framework では、XAML オブジェクト要素にマップされる[!INCLUDE[TLA#tla_net](../../../../includes/tlasharptla-net-md.md)]で定義されている型参照アセンブリ、およびそれらの型のメンバー、属性にマップします。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-141">For WPF and the .NET Framework, XAML object elements map to [!INCLUDE[TLA#tla_net](../../../../includes/tlasharptla-net-md.md)] types as defined in referenced assemblies, and the attributes map to members of those types.</span></span> <span data-ttu-id="a9eb0-142">XAML での CLR 型を参照するときにもその型の継承されたメンバーへのアクセスがあります。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-142">When you reference a CLR type in XAML, you have access to the inherited members of that type as well.</span></span>  
  
 <span data-ttu-id="a9eb0-143">たとえば、次の例は、オブジェクト要素の構文の新しいインスタンスをインスタンス化する、<xref:System.Windows.Controls.Button>クラス、およびも指定して、<xref:System.Windows.FrameworkElement.Name%2A>属性とその属性の値。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-143">For example, the following example is object element syntax that instantiates a new instance of the <xref:System.Windows.Controls.Button> class, and also specifies a <xref:System.Windows.FrameworkElement.Name%2A> attribute and a value for that attribute:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxOE](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#syntaxoe)]  
  
 <span data-ttu-id="a9eb0-144">次の例は、XAML コンテンツ プロパティの構文を含むオブジェクト要素の構文です。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-144">The following example is object element syntax that also includes XAML content property syntax.</span></span> <span data-ttu-id="a9eb0-145">その内部テキ スト内に含まれる設定に使用される、 <xref:System.Windows.Controls.TextBox> XAML コンテンツ プロパティ、<xref:System.Windows.Controls.TextBox.Text%2A>です。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-145">The inner text contained within will be used to set the <xref:System.Windows.Controls.TextBox> XAML content property, <xref:System.Windows.Controls.TextBox.Text%2A>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#ThisIsATextBox](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#thisisatextbox)]  
  
### <a name="content-models"></a><span data-ttu-id="a9eb0-146">コンテンツ モデル</span><span class="sxs-lookup"><span data-stu-id="a9eb0-146">Content Models</span></span>  
 <span data-ttu-id="a9eb0-147">クラスは、構文の観点から XAML オブジェクト要素として、使用法をサポートする場合がありますがその要素はのみが正しく機能アプリケーションやページで、全体的なコンテンツ モデルまたは要素ツリーの適切な位置に配置されている場合。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-147">A class might support a usage as a XAML object element in terms of the syntax, but that element will only function properly in an application or page when it is placed in an expected position of an overall content model or element tree.</span></span> <span data-ttu-id="a9eb0-148">たとえば、<xref:System.Windows.Controls.MenuItem>通常のみに配置するの子として、<xref:System.Windows.Controls.Primitives.MenuBase>などのクラスを派生<xref:System.Windows.Controls.Menu>です。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-148">For example, a <xref:System.Windows.Controls.MenuItem> should typically only be placed as a child of a <xref:System.Windows.Controls.Primitives.MenuBase> derived class such as <xref:System.Windows.Controls.Menu>.</span></span> <span data-ttu-id="a9eb0-149">コンテンツ コントロールやその他のクラスのページで、「解説」の一部として特定要素モデルが記載されている[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]XAML 要素として使用できるクラスです。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-149">Content models for specific elements are documented as part of the remarks on the class pages for controls and other [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes that can be used as XAML elements.</span></span>  
  
<a name="properties_of_object_elements"></a>   
## <a name="properties-of-object-elements"></a><span data-ttu-id="a9eb0-150">オブジェクトの要素のプロパティ</span><span class="sxs-lookup"><span data-stu-id="a9eb0-150">Properties of Object Elements</span></span>  
 <span data-ttu-id="a9eb0-151">XAML のプロパティは、さまざまな使用できる構文によって設定されます。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-151">Properties in XAML are set by a variety of possible syntaxes.</span></span> <span data-ttu-id="a9eb0-152">特定のプロパティの構文を使用できますが、に応じて変わります、基になる型システム プロパティの特性は、設定します。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-152">Which syntax can be used for a particular property will vary, based on the underlying type system characteristics of the property that you are setting.</span></span>  
  
 <span data-ttu-id="a9eb0-153">プロパティの値を設定または追加する機能の特性オブジェクトに、実行時のオブジェクト グラフ内に存在するためです。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-153">By setting values of properties, you add features or characteristics to objects as they exist in the run time object graph.</span></span> <span data-ttu-id="a9eb0-154">オブジェクトの要素から作成されたオブジェクトの初期状態は、既定のコンス トラクターの動作に基づきます。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-154">The initial state of the created object from a object element is based on the default constructor behavior.</span></span> <span data-ttu-id="a9eb0-155">通常、アプリケーションは、完全に既定のインスタンスの任意のオブジェクト以外に使用されます。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-155">Typically, your application will use something other than a completely default instance of any given object.</span></span>  
  
<a name="attribute_syntax_properties"></a>   
## <a name="attribute-syntax-properties"></a><span data-ttu-id="a9eb0-156">属性構文 (プロパティ)</span><span class="sxs-lookup"><span data-stu-id="a9eb0-156">Attribute Syntax (Properties)</span></span>  
 <span data-ttu-id="a9eb0-157">属性構文は、既存のオブジェクト要素の属性を宣言することで、プロパティの値を設定する XAML マークアップの構文です。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-157">Attribute syntax is the XAML markup syntax that sets a value for a property by declaring an attribute on an existing object element.</span></span> <span data-ttu-id="a9eb0-158">属性名は、関連するオブジェクトの要素をサポートするクラスのプロパティの CLR メンバー名と一致する必要があります。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-158">The attribute name must match the CLR member name of the property of the class that backs the relevant object element.</span></span> <span data-ttu-id="a9eb0-159">属性名には、代入演算子 (=) が続きます。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-159">The attribute name is followed by an assignment operator (=).</span></span> <span data-ttu-id="a9eb0-160">属性値には、引用符で囲まれた文字列を指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-160">The attribute value must be a string enclosed within quotes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a9eb0-161">代替の引用符を使用して、属性内のリテラル二重引用符を配置することができます。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-161">You can use alternating quotes to place a literal quotation mark within an attribute.</span></span> <span data-ttu-id="a9eb0-162">インスタンス内に二重引用符文字を含む文字列を宣言するのに手段として単一引用符を使用することができます。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-162">For instance you can use single quotes as a means to declare a string that contains a double quote character within it.</span></span> <span data-ttu-id="a9eb0-163">一重引用符または二重引用符を使用するかどうかの属性値の文字列を開いたり、閉じたりする一致するペアを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-163">Whether you use single or double quotes, you should use a matching pair for opening and closing the attribute value string.</span></span> <span data-ttu-id="a9eb0-164">ありますエスケープ シーケンスやその他の手法の特定の XAML 構文で文字の制限を回避するために使用できます。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-164">There are also escape sequences or other techniques available for working around character restrictions imposed by any particular XAML syntax.</span></span> <span data-ttu-id="a9eb0-165">参照してください[XML 文字エンティティと XAML](../../../../docs/framework/xaml-services/xml-character-entities-and-xaml.md)です。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-165">See [XML Character Entities and XAML](../../../../docs/framework/xaml-services/xml-character-entities-and-xaml.md).</span></span>  
  
 <span data-ttu-id="a9eb0-166">属性構文で、設定するためには、プロパティは、パブリックである必要があり、書き込み可能である必要があります。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-166">In order to be set through attribute syntax, a property must be public and must be writeable.</span></span> <span data-ttu-id="a9eb0-167">バッキング型システムのプロパティの値は、値型である必要があります。 または必要がありますの参照型をインスタンス化したり、関連するアクセスするときに、XAML プロセッサによって参照されているバックアップの種類。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-167">The value of the property in the backing type system must be a value type, or must be a reference type that can be instantiated or referenced by a XAML processor when accessing the relevant backing type.</span></span>  
  
 <span data-ttu-id="a9eb0-168">WPF XAML イベント属性名として参照されているイベントではパブリックであるおよびパブリック デリゲートを持つ必要があります。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-168">For WPF XAML events, the event that is referenced as the attribute name must be public and have a public delegate.</span></span>  
  
 <span data-ttu-id="a9eb0-169">プロパティまたはイベント クラスまたはオブジェクトのコンテナーの要素によってインスタンス化される構造体のメンバーである必要があります。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-169">The property or event must be a member of the class or structure that is instantiated by the containing object element.</span></span>  
  
### <a name="processing-of-attribute-values"></a><span data-ttu-id="a9eb0-170">属性値の処理</span><span class="sxs-lookup"><span data-stu-id="a9eb0-170">Processing of Attribute Values</span></span>  
 <span data-ttu-id="a9eb0-171">開始タグと終了引用符内に含まれる文字列値は、XAML プロセッサによって処理されます。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-171">The string value contained within the opening and closing quotation marks is processed by a XAML processor.</span></span> <span data-ttu-id="a9eb0-172">プロパティの場合は、既定の動作の処理を基になる CLR プロパティの型によって決まります。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-172">For properties, the default processing behavior is determined by the type of the underlying CLR property.</span></span>  
  
 <span data-ttu-id="a9eb0-173">属性の値が、次のいずれかで埋められた次の処理順序を使用します。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-173">The attribute value is filled by one of the following, using this processing order:</span></span>  
  
1.  <span data-ttu-id="a9eb0-174">XAML プロセッサでは、中かっこまたはから派生したオブジェクトの要素が検出されると<xref:System.Windows.Markup.MarkupExtension>し、参照先のマークアップ拡張機能が最初に評価を文字列として値の処理ではなく、およびマークアップ拡張機能によって返されるオブジェクトとして使用します値。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-174">If the XAML processor encounters a curly brace, or an object element that derives from <xref:System.Windows.Markup.MarkupExtension>, then the referenced markup extension is evaluated first rather than processing the value as a string, and the object returned by the markup extension is used as the value.</span></span> <span data-ttu-id="a9eb0-175">多くの場合は、既存のオブジェクト、または実行時まで評価されないし、新しくインスタンス化されたオブジェクトではない式への参照が、マークアップ拡張機能によって返されるオブジェクトになります。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-175">In many cases the object returned by a markup extension will be a reference to an existing object, or an expression that defers evaluation until run time, and is not a newly instantiated object.</span></span>  
  
2.  <span data-ttu-id="a9eb0-176">プロパティが宣言されている場合、属性付きで<xref:System.ComponentModel.TypeConverter>、またはそのプロパティの値の型が宣言されていると、属性付き<xref:System.ComponentModel.TypeConverter>属性の文字列値は変換の入力として、型コンバーターに送信され、は、コンバーターを返します、新しいオブジェクト インスタンス。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-176">If the property is declared with an attributed <xref:System.ComponentModel.TypeConverter>, or the value type of that property is declared with an attributed <xref:System.ComponentModel.TypeConverter>, the string value of the attribute is submitted to the type converter as a conversion input, and the converter will return a new object instance.</span></span>  
  
3.  <span data-ttu-id="a9eb0-177">ある場合ありません<xref:System.ComponentModel.TypeConverter>プロパティの型への直接変換が試行されます。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-177">If there is no <xref:System.ComponentModel.TypeConverter>, a direct conversion to the property type is attempted.</span></span> <span data-ttu-id="a9eb0-178">この最後のレベルは、XAML 言語プリミティブ型、または列挙型 (パーサーにアクセスして、一致する値) の名前付き定数の名前のチェックの間のパーサー ネイティブ値に直接変換です。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-178">This final level is a direct conversion at the parser-native value between XAML language primitive types, or a check for the names of named constants in an enumeration (the parser then accesses the matching values).</span></span>  
  
#### <a name="enumeration-attribute-values"></a><span data-ttu-id="a9eb0-179">列挙型の属性値</span><span class="sxs-lookup"><span data-stu-id="a9eb0-179">Enumeration Attribute Values</span></span>  
 <span data-ttu-id="a9eb0-180">XAML での列挙は、XAML パーサーで本質的に処理され、列挙型の名前付き定数のいずれかの文字列名を指定することで列挙体のメンバーを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-180">Enumerations in XAML are processed intrinsically by XAML parsers, and the members of an enumeration should be specified by specifying the string name of one of the enumeration's named constants.</span></span>  
  
 <span data-ttu-id="a9eb0-181">フラグ列挙値の場合は、ネイティブな動作は、属性値の文字列を処理し、列挙値のいずれかに解決です。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-181">For nonflag enumeration values, the native behavior is to process the string of an attribute value and resolve it to one of the enumeration values.</span></span> <span data-ttu-id="a9eb0-182">形式で、列挙型を指定しない*列挙*.*値*コードの場合と、します。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-182">You do not specify the enumeration in the format *Enumeration*.*Value*, as you do in code.</span></span> <span data-ttu-id="a9eb0-183">代わりに、のみを指定した*値*、および*列挙*を設定するプロパティの型が推論されます。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-183">Instead, you specify only *Value*, and *Enumeration* is inferred by the type of the property you are setting.</span></span> <span data-ttu-id="a9eb0-184">内の属性を指定する場合、*列挙*.*値*形式が正しく解決されません。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-184">If you specify an attribute in the *Enumeration*.*Value* form, it will not resolve correctly.</span></span>  
  
 <span data-ttu-id="a9eb0-185">フラグ列挙体の場合、動作がに基づいて、<xref:System.Enum.Parse%2A?displayProperty=nameWithType>メソッドです。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-185">For flagwise enumerations, the behavior is based on the <xref:System.Enum.Parse%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="a9eb0-186">フラグ列挙体の複数の値は、それぞれの値をコンマで区切って指定できます。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-186">You can specify multiple values for a flagwise enumeration by separating each value with a comma.</span></span> <span data-ttu-id="a9eb0-187">ただし、フラグはない列挙値を組み合わせることはできません。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-187">However, you cannot combine enumeration values that are not flagwise.</span></span> <span data-ttu-id="a9eb0-188">インスタンスを作成しようとするコンマ構文を使用することはできません、<xref:System.Windows.Trigger>フラグ列挙体の複数の条件で動作します。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-188">For instance, you cannot use the comma syntax to attempt to create a <xref:System.Windows.Trigger> that acts on multiple conditions of a nonflag enumeration:</span></span>  
  
```  
<!--This will not compile, because Visibility is not a flagwise enumeration.-->  
...  
<Trigger Property="Visibility" Value="Collapsed,Hidden">  
  <Setter ... />  
</Trigger>  
...  
```  
  
 <span data-ttu-id="a9eb0-189">XAML で設定可能な属性をサポートするフラグ列挙体は、WPF ではまれです。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-189">Flagwise enumerations that support attributes that are settable in XAML are rare in WPF.</span></span> <span data-ttu-id="a9eb0-190">ただし、このような 1 つの列挙は<xref:System.Windows.Media.StyleSimulations>します。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-190">However, one such enumeration is <xref:System.Windows.Media.StyleSimulations>.</span></span> <span data-ttu-id="a9eb0-191">「解説」に示した例を変更するフラグ属性のコンマ区切り構文を使用することで、インスタンスの<xref:System.Windows.Documents.Glyphs>クラスです。`StyleSimulations = "BoldSimulation"`状態になる`StyleSimulations = "BoldSimulation,ItalicSimulation"`です。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-191">You could, for instance, use the comma-delimited flagwise attribute syntax to modify the example provided in the Remarks for the <xref:System.Windows.Documents.Glyphs> class; `StyleSimulations = "BoldSimulation"` could become `StyleSimulations = "BoldSimulation,ItalicSimulation"`.</span></span> <span data-ttu-id="a9eb0-192"><xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType>1 つ以上の列挙値を指定することができますを別のプロパティにです。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-192"><xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType> is another property where more than one enumeration value can be specified.</span></span> <span data-ttu-id="a9eb0-193">ただし、このプロパティは、特殊なケースであるため、<xref:System.Windows.Input.ModifierKeys>列挙体は、独自の型コンバーターをサポートしています。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-193">However, this property happens to be a special case, because the <xref:System.Windows.Input.ModifierKeys> enumeration supports its own type converter.</span></span> <span data-ttu-id="a9eb0-194">修飾子の型コンバーターは、コンマ (,) ではなく、区切り記号として、正符号 (+) を使用します。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-194">The type converter for modifiers uses a plus sign (+) as a delimiter rather than a comma (,).</span></span> <span data-ttu-id="a9eb0-195">この変換には、"Ctrl + Alt"などの Microsoft Windows プログラミングでのキーの組み合わせを表す従来の構文がサポートしています。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-195">This conversion supports the more traditional syntax to represent key combinations in Microsoft Windows programming, such as "Ctrl+Alt".</span></span>  
  
### <a name="properties-and-event-member-name-references"></a><span data-ttu-id="a9eb0-196">プロパティとイベント メンバー名の参照</span><span class="sxs-lookup"><span data-stu-id="a9eb0-196">Properties and Event Member Name References</span></span>  
 <span data-ttu-id="a9eb0-197">属性を指定する場合は、任意のプロパティやイベントを含むオブジェクト要素のためにインスタンス化した CLR 型のメンバーとして存在するを参照できます。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-197">When specifying an attribute, you can reference any property or event that exists as a member of the CLR type you instantiated for the containing object element.</span></span>  
  
 <span data-ttu-id="a9eb0-198">または、添付プロパティを参照するか、添付イベントを含むオブジェクト要素の独立しました。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-198">Or, you can reference an attached property or attached event, independent of the containing object element.</span></span> <span data-ttu-id="a9eb0-199">(添付プロパティは、後のセクションで説明しますされます)。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-199">(Attached properties are discussed in an upcoming section.)</span></span>  
  
 <span data-ttu-id="a9eb0-200">使用して既定の名前空間を介してアクセス可能な任意のオブジェクトからすべてのイベントを付けることができます、 *typeName*.*イベント*部分修飾名です。 ルーティング イベントのハンドラーのアタッチをサポートしていますが、子要素が、親要素からルーティング イベントを処理するハンドラーは、ここでがないそのイベントのメンバー テーブルにこの構文です。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-200">You can also name any event from any object that is accessible through the default namespace by using a *typeName*.*event* partially qualified name; this syntax supports attaching handlers for routed events where the handler is intended to handle events routing from child elements, but the parent element does not also have that event in its members table.</span></span> <span data-ttu-id="a9eb0-201">この構文には、添付イベントの構文が似ていますが、イベントをここでは、true 添付イベントではありません。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-201">This syntax resembles an attached event syntax, but the event here is not a true attached event.</span></span> <span data-ttu-id="a9eb0-202">代わりに、修飾名を持つイベントを参照しています。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-202">Instead, you are referencing an event with a qualified name.</span></span> <span data-ttu-id="a9eb0-203">詳細については、次を参照してください。[ルーティング イベントの概要](../../../../docs/framework/wpf/advanced/routed-events-overview.md)です。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-203">For more information, see [Routed Events Overview](../../../../docs/framework/wpf/advanced/routed-events-overview.md).</span></span>  
  
 <span data-ttu-id="a9eb0-204">一部のシナリオでは、プロパティ名は属性名ではなく、属性の値として提供される場合があります。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-204">For some scenarios, property names are sometimes provided as the value of an attribute, rather than the attribute name.</span></span> <span data-ttu-id="a9eb0-205">プロパティ名は、フォームで指定されたプロパティなどの修飾子を含めることができますも*ownerType*.*dependencyPropertyName*です。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-205">That property name can also include qualifiers, such as the property specified in the form *ownerType*.*dependencyPropertyName*.</span></span> <span data-ttu-id="a9eb0-206">このシナリオは、XAML でスタイルまたはテンプレートを作成する場合に共通です。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-206">This scenario is common when writing styles or templates in XAML.</span></span> <span data-ttu-id="a9eb0-207">属性値として指定したプロパティ名の処理規則が異なっているし、設定されるプロパティのタイプまたは特定の WPF サブシステムの動作によって制御されます。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-207">The processing rules for property names provided as an attribute value are different, and are governed by the type of the property being set or by the behaviors of particular WPF subsystems.</span></span> <span data-ttu-id="a9eb0-208">詳細については、「[スタイルとテンプレート](../../../../docs/framework/wpf/controls/styling-and-templating.md)です。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-208">For details, see [Styling and Templating](../../../../docs/framework/wpf/controls/styling-and-templating.md).</span></span>  
  
 <span data-ttu-id="a9eb0-209">プロパティ名の別の使用方法では属性値には、プロパティ間のリレーションシップがについて説明します。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-209">Another usage for property names is when an attribute value describes a property-property relationship.</span></span> <span data-ttu-id="a9eb0-210">この機能は、データ バインディングとストーリー ボードのターゲットが使用されで有効になって、<xref:System.Windows.PropertyPath>クラスとその型コンバーター。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-210">This feature is used for data binding and for storyboard targets, and is enabled by the <xref:System.Windows.PropertyPath> class and its type converter.</span></span> <span data-ttu-id="a9eb0-211">参照セマンティクスの詳細については、次を参照してください。 [PropertyPath 構文は XAML](../../../../docs/framework/wpf/advanced/propertypath-xaml-syntax.md)です。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-211">For a more complete description of the lookup semantics, see [PropertyPath XAML Syntax](../../../../docs/framework/wpf/advanced/propertypath-xaml-syntax.md).</span></span>  
  
<a name="property_element_syntax"></a>   
## <a name="property-element-syntax"></a><span data-ttu-id="a9eb0-212">プロパティ要素構文</span><span class="sxs-lookup"><span data-stu-id="a9eb0-212">Property Element Syntax</span></span>  
 <span data-ttu-id="a9eb0-213">*プロパティ要素構文*やや要素の基本的な XML 構文規則から逸脱した構文です。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-213">*Property element syntax* is a syntax that diverges somewhat from the basic XML syntax rules for elements.</span></span> <span data-ttu-id="a9eb0-214">XML では、属性の値は、事実上文字列、可能な唯一のバリエーション文字列エンコード方式が使用されているです。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-214">In XML, the value of an attribute is a de facto string, with the only possible variation being which string encoding format is being used.</span></span> <span data-ttu-id="a9eb0-215">XAML では、他のオブジェクト要素のプロパティの値であることを割り当てることができます。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-215">In XAML, you can assign other object elements to be the value of a property.</span></span> <span data-ttu-id="a9eb0-216">この機能は、プロパティ要素構文を有効にします。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-216">This capability is enabled by the property element syntax.</span></span> <span data-ttu-id="a9eb0-217">要素タグ内の属性として指定されているプロパティではなく、プロパティが指定されて、開始要素を使用してにタグを付ける*elementTypeName*.*propertyName*フォーム内で、プロパティの値が指定されておよびプロパティ要素が閉じられるします。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-217">Instead of the property being specified as an attribute within the element tag, the property is specified using an opening element tag in *elementTypeName*.*propertyName* form, the value of the property is specified within, and then the property element is closed.</span></span>  
  
 <span data-ttu-id="a9eb0-218">具体的には、構文から始まります左山かっこ (\<)、クラスまたはプロパティ要素構文に含まれる構造体の型名ですぐにその後にします。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-218">Specifically, the syntax begins with a left angle bracket (\<), followed immediately by the type name of the class or structure that the property element syntax is contained within.</span></span> <span data-ttu-id="a9eb0-219">これが続きますすぐに 1 つのドット (.)、プロパティの名前でし、右の山かっこ (>)。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-219">This is followed immediately by a single dot (.), then by the name of a property, then by a right angle bracket (>).</span></span> <span data-ttu-id="a9eb0-220">属性の構文とそのプロパティは、指定した型の宣言されたパブリック メンバー内でが必要です。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-220">As with attribute syntax, that property must exist within the declared public members of the specified type.</span></span> <span data-ttu-id="a9eb0-221">プロパティに割り当てられる値は、プロパティ要素内に含まれます。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-221">The value to be assigned to the property is contained within the property element.</span></span> <span data-ttu-id="a9eb0-222">通常は、値が、1 つ以上のオブジェクトの要素を指定したをアドレスにプロパティ要素構文は、シナリオでは、値としてオブジェクトを指定することがあるためです。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-222">Typically, the value is given as one or more object elements, because specifying objects as values is the scenario that property element syntax is intended to address.</span></span> <span data-ttu-id="a9eb0-223">最後に、同じを指定すると同等の終了タグ*elementTypeName*.*propertyName*で適切な入れ子構造とその他の要素タグとのバランス、組み合わせを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-223">Finally, an equivalent closing tag specifying the same *elementTypeName*.*propertyName* combination must be provided, in proper nesting and balance with other element tags.</span></span>  
  
 <span data-ttu-id="a9eb0-224">たとえば、プロパティ要素構文を次に示します、<xref:System.Windows.FrameworkElement.ContextMenu%2A>のプロパティ、<xref:System.Windows.Controls.Button>です。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-224">For example, the following is property element syntax for the <xref:System.Windows.FrameworkElement.ContextMenu%2A> property of a <xref:System.Windows.Controls.Button>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#ContextMenu](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#contextmenu)]  
  
 <span data-ttu-id="a9eb0-225">プロパティ要素内の値も指定できます指定されているプロパティの型がプリミティブ値型の場合、内部テキ ストとしてなど<xref:System.String>、または名前が指定されている列挙体です。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-225">The value within a property element can also be given as inner text, in cases where the property type being specified is a primitive value type, such as <xref:System.String>, or an enumeration where a name is specified.</span></span> <span data-ttu-id="a9eb0-226">単純な属性の構文を使用することもこれらの各ケースがあるために、これら 2 つの使用方法はあまり一般的ではありません。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-226">These two usages are somewhat uncommon, because each of these cases could also use a simpler attribute syntax.</span></span> <span data-ttu-id="a9eb0-227">文字列にプロパティ要素を 1 つのシナリオは、XAML コンテンツ プロパティではない UI テキストの表示のために使用されるプロパティと、改行などの特定の空白要素はその UI テキストに表示するために必要なです。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-227">One scenario for filling a property element with a string is for properties that are not the XAML content property but still are used for representation of UI text, and particular whitespace elements such as linefeeds are required to appear in that UI text.</span></span> <span data-ttu-id="a9eb0-228">属性構文は、改行文字を保持できません。 がアクティブで重要な空白を保持する限り、プロパティ要素構文ができます (詳細については、「 [XAML での空白の処理](../../../../docs/framework/xaml-services/whitespace-processing-in-xaml.md))。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-228">Attribute syntax cannot preserve linefeeds, but property element syntax can, so long as significant whitespace preservation is active (for details, see [Whitespace Processing in XAML](../../../../docs/framework/xaml-services/whitespace-processing-in-xaml.md)).</span></span> <span data-ttu-id="a9eb0-229">別のシナリオができるように[X:uid Directive](../../../../docs/framework/xaml-services/x-uid-directive.md) property 要素に適用でき、ため、WPF をローカライズする必要がありますを値の出力 BAML またはその他の手法によって内の値をマークします。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-229">Another scenario is so that [x:Uid Directive](../../../../docs/framework/xaml-services/x-uid-directive.md) can be applied to the property element and thus mark the value within as a value that should be localized in the WPF output BAML or by other techniques.</span></span>  
  
 <span data-ttu-id="a9eb0-230">プロパティ要素は、WPF の論理ツリーでは表されません。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-230">A property element is not represented in the WPF logical tree.</span></span> <span data-ttu-id="a9eb0-231">プロパティ要素は、プロパティの設定の特定の構文だけであり、インスタンスまたはオブジェクトを持つ要素ではありません。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-231">A property element is just a particular syntax for setting a property, and is not an element that has an instance or object backing it.</span></span> <span data-ttu-id="a9eb0-232">(論理ツリーの概念の詳細については、「 [wpf ツリー](../../../../docs/framework/wpf/advanced/trees-in-wpf.md))。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-232">(For details on the logical tree concept, see [Trees in WPF](../../../../docs/framework/wpf/advanced/trees-in-wpf.md).)</span></span>  
  
 <span data-ttu-id="a9eb0-233">属性とプロパティの両方の要素の構文がサポートされている場合、プロパティの 2 つの構文では、空白の処理などの微妙なできます多少の違いの構文が、同じ結果が一般にあります。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-233">For properties where both attribute and property element syntax are supported, the two syntaxes generally have the same result, although subtleties such as whitespace handling can vary slightly between syntaxes.</span></span>  
  
<a name="collection_syntax"></a>   
## <a name="collection-syntax"></a><span data-ttu-id="a9eb0-234">コレクションの構文</span><span class="sxs-lookup"><span data-stu-id="a9eb0-234">Collection Syntax</span></span>  
 <span data-ttu-id="a9eb0-235">XAML の仕様では、XAML プロセッサの実装、値の型がコレクションのプロパティを識別する必要があります。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-235">The XAML specification requires XAML processor implementations to identify properties where the value type is a collection.</span></span> <span data-ttu-id="a9eb0-236">.NET の一般的な XAML プロセッサの実装はマネージ コードと、CLR に基づいており、次のいずれかの方法でコレクション型を示します。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-236">The general XAML processor implementation in .NET is based on managed code and the CLR, and it identifies collection types through one of the following:</span></span>  
  
-   <span data-ttu-id="a9eb0-237">型を実装して<xref:System.Collections.IList>です。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-237">Type implements <xref:System.Collections.IList>.</span></span>  
  
-   <span data-ttu-id="a9eb0-238">型を実装して<xref:System.Collections.IDictionary>です。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-238">Type implements <xref:System.Collections.IDictionary>.</span></span>  
  
-   <span data-ttu-id="a9eb0-239">型から派生して<xref:System.Array>(XAML での配列の詳細については、次を参照してください[X:array のマークアップ拡張機能](../../../../docs/framework/xaml-services/x-array-markup-extension.md)。)。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-239">Type derives from <xref:System.Array> (for more information about arrays in XAML, see [x:Array Markup Extension](../../../../docs/framework/xaml-services/x-array-markup-extension.md).)</span></span>  
  
 <span data-ttu-id="a9eb0-240">プロパティの型がコレクションの場合、推論されるコレクション型をオブジェクト要素としてのマークアップで指定する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-240">If the type of a property is a collection, then the inferred collection type does not need to be specified in the markup as an object element.</span></span> <span data-ttu-id="a9eb0-241">代わりに、コレクション内の項目となる要素は、プロパティ要素の 1 つまたは複数の子要素として指定されます。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-241">Instead, the elements that are intended to become the items in the collection are specified as one or more child elements of the property element.</span></span> <span data-ttu-id="a9eb0-242">それらの各項目が読み込み時にオブジェクトを評価し、呼び出すことによって、コレクションに追加、`Add`暗黙的コレクションのメソッドです。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-242">Each such item is evaluated to an object during loading and added to the collection by calling the `Add` method of the implied collection.</span></span> <span data-ttu-id="a9eb0-243">たとえば、<xref:System.Windows.Style.Triggers%2A>プロパティ<xref:System.Windows.Style>は特殊なコレクション型を受け取り<xref:System.Windows.TriggerCollection>を実装する<xref:System.Collections.IList>です。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-243">For example, the <xref:System.Windows.Style.Triggers%2A> property of <xref:System.Windows.Style> takes the specialized collection type <xref:System.Windows.TriggerCollection>, which implements <xref:System.Collections.IList>.</span></span> <span data-ttu-id="a9eb0-244">インスタンスを作成する必要はありません、<xref:System.Windows.TriggerCollection>マークアップ内のオブジェクトの要素。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-244">It is not necessary to instantiate a <xref:System.Windows.TriggerCollection> object element in the markup.</span></span> <span data-ttu-id="a9eb0-245">1 つ以上を指定する代わりに、<xref:System.Windows.Trigger>項目内の要素として、`Style.Triggers`プロパティ要素場所<xref:System.Windows.Trigger>(または派生クラス) は、項目の種類である必要が厳密に型指定されたと暗黙の型です。<xref:System.Windows.TriggerCollection>です。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-245">Instead, you specify one or more <xref:System.Windows.Trigger> items as elements within the `Style.Triggers` property element, where <xref:System.Windows.Trigger> (or a derived class) is the type expected as the item type for the strongly typed and implicit <xref:System.Windows.TriggerCollection>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxPECollection](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#syntaxpecollection)]  
  
 <span data-ttu-id="a9eb0-246">プロパティがコレクション型とその型の XAML コンテンツ プロパティの両方になる可能性があり、派生型、これは、このトピックの次のセクションでについて説明します。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-246">A property may be both a collection type and the XAML content property for that type and derived types, which is discussed in the next section of this topic.</span></span>  
  
 <span data-ttu-id="a9eb0-247">暗黙的コレクションの要素は、マークアップで要素としてがいない場合でも、論理ツリーで表されたメンバーを作成します。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-247">An implicit collection element creates a member in the logical tree representation, even though it does not appear in the markup as an element.</span></span> <span data-ttu-id="a9eb0-248">通常、親の型のコンス トラクターは、そのプロパティのいずれかであるコレクションのインスタンス化を実行し、最初に空のコレクションのオブジェクト ツリーの一部になります。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-248">Usually the constructor of the parent type performs the instantiation for the collection that is one of its properties, and the initially empty collection becomes part of the object tree.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a9eb0-249">リストとディクショナリのジェネリック インターフェイス (<xref:System.Collections.Generic.IList%601>と<xref:System.Collections.Generic.IDictionary%602>) コレクション検出はサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-249">The generic list and dictionary interfaces (<xref:System.Collections.Generic.IList%601> and <xref:System.Collections.Generic.IDictionary%602>) are not supported for collection detection.</span></span> <span data-ttu-id="a9eb0-250">ただし、使用することができます、<xref:System.Collections.Generic.List%601>を基底クラスとしてクラスを実装するため<xref:System.Collections.IList>直接、または<xref:System.Collections.Generic.Dictionary%602>を基底クラスとして実装するため<xref:System.Collections.IDictionary>直接です。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-250">However, you can use the <xref:System.Collections.Generic.List%601> class as a base class, because it implements <xref:System.Collections.IList> directly, or <xref:System.Collections.Generic.Dictionary%602> as a base class, because it implements <xref:System.Collections.IDictionary> directly.</span></span>  
  
 <span data-ttu-id="a9eb0-251">コレクション型の .NET リファレンス ページにあるコレクションのオブジェクト要素の意図的に省略構文が示されている場合、XAML 構文のセクションで暗黙の型のコレクション構文として。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-251">In the .NET Reference pages for collection types, this syntax with the deliberate omission of the object element for a collection is occasionally noted in the XAML syntax sections as Implicit Collection Syntax.</span></span>  
  
 <span data-ttu-id="a9eb0-252">ルート要素を除くは実際には、次の場合のいずれかである要素に別の要素の子要素として入れ子になっている XAML ファイル内のすべてのオブジェクト要素その親要素の暗黙的なコレクション プロパティのメンバー。、または要素を親要素 (XAML コンテンツ プロパティは、次のセクションで説明) の XAML コンテンツ プロパティの値を指定します。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-252">With the exception of the root element, every object element in a XAML file that is nested as a child element of another element is really an element that is one or both of the following cases: a member of an implicit collection property of its parent element, or an element that specifies the value of the XAML content property for the parent element (XAML content properties will be discussed in an upcoming section).</span></span> <span data-ttu-id="a9eb0-253">つまり、親要素と、マークアップ ページ内の子要素のリレーションシップは、ルートにある 1 つのオブジェクトとすべてのオブジェクト要素のルートの下には、親のプロパティの値を提供する 1 つのインスタンス、または、列内のアイテムのいずれか親のコレクション型プロパティ値でも lection します。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-253">In other words, the relationship of parent elements and child elements in a markup page is really a single object at the root, and every object element beneath the root is either a single instance that provides a property value of the parent, or one of the items within a collection that is also a collection-type property value of the parent.</span></span> <span data-ttu-id="a9eb0-254">このシングル ルート概念を XML に共通で、XAML を読み込むなどの Api の動作の強化は頻繁に<xref:System.Windows.Markup.XamlReader.Load%2A>です。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-254">This single-root concept is common with XML, and is frequently reinforced in the behavior of APIs that load XAML such as <xref:System.Windows.Markup.XamlReader.Load%2A>.</span></span>  
  
 <span data-ttu-id="a9eb0-255">次の例は、コレクションのオブジェクト要素の構文 (<xref:System.Windows.Media.GradientStopCollection>) を明示的に指定します。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-255">The following example is a syntax with the object element for a collection (<xref:System.Windows.Media.GradientStopCollection>) specified explicitly.</span></span>  
  
```xaml  
<LinearGradientBrush>  
  <LinearGradientBrush.GradientStops>  
    <GradientStopCollection>  
      <GradientStop Offset="0.0" Color="Red" />  
      <GradientStop Offset="1.0" Color="Blue" />  
    </GradientStopCollection>  
  </LinearGradientBrush.GradientStops>  
</LinearGradientBrush>  
```  
  
 <span data-ttu-id="a9eb0-256">ある常にコレクションを明示的に宣言することに注意してください。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-256">Note that it is not always possible to explicitly declare the collection.</span></span> <span data-ttu-id="a9eb0-257">インスタンスを宣言しようとして<xref:System.Windows.TriggerCollection>で明示的に、前に示した<xref:System.Windows.Style.Triggers%2A>の例は失敗します。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-257">For instance, attempting to declare <xref:System.Windows.TriggerCollection> explicitly in the previously shown <xref:System.Windows.Style.Triggers%2A> example would fail.</span></span> <span data-ttu-id="a9eb0-258">コレクションを明示的に宣言する場合は、コレクション クラスが既定のコンス トラクターをサポートする必要がある必要がありますと<xref:System.Windows.TriggerCollection>既定コンス トラクターがありません。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-258">Explicitly declaring the collection requires that the collection class must support a default constructor, and <xref:System.Windows.TriggerCollection> does not have a default constructor.</span></span>  
  
<a name="xaml_content_properties"></a>   
## <a name="xaml-content-properties"></a><span data-ttu-id="a9eb0-259">XAML コンテンツ プロパティ</span><span class="sxs-lookup"><span data-stu-id="a9eb0-259">XAML Content Properties</span></span>  
 <span data-ttu-id="a9eb0-260">XAML コンテンツ構文は、指定のクラスでのみ有効になっている構文、<xref:System.Windows.Markup.ContentPropertyAttribute>クラス宣言の一部として。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-260">XAML content syntax is a syntax that is only enabled on classes that specify the <xref:System.Windows.Markup.ContentPropertyAttribute> as part of their class declaration.</span></span> <span data-ttu-id="a9eb0-261"><xref:System.Windows.Markup.ContentPropertyAttribute>要素 (派生クラスを含む) の種類のコンテンツ プロパティは、プロパティ名を参照します。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-261">The <xref:System.Windows.Markup.ContentPropertyAttribute> references the property name that is the content property for that type of element (including derived classes).</span></span> <span data-ttu-id="a9eb0-262">XAML プロセッサによって処理されるとき、すべての子要素や開始タグと終了タグのオブジェクト要素の間で検出された内部テキ ストをそのオブジェクトの XAML コンテンツ プロパティの値に割り当てられますは。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-262">When processed by a XAML processor, any child elements or inner text that are found between the opening and closing tags of the object element will be assigned to be the value of the XAML content property for that object.</span></span> <span data-ttu-id="a9eb0-263">コンテンツのプロパティの明示的なプロパティ要素を指定することは、この使用法は、通常 XAML 構文セクションでは、.NET リファレンスには表示されません。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-263">You are permitted to specify explicit property elements for the content property, but this usage is not generally shown in the XAML syntax sections in the .NET reference.</span></span> <span data-ttu-id="a9eb0-264">/Verbose 明示的な手法がマークアップわかりやすくするために、またはマークアップ スタイルの問題としてが通常コンテンツ プロパティの目的をマークアップを効率化できるように、親-子として直感的に関連する要素が直接入れ子にすることができます。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-264">The explicit/verbose technique has occasional value for markup clarity or as a matter of markup style, but usually the intent of a content property is to streamline the markup so that elements that are intuitively related as parent-child can be nested directly.</span></span> <span data-ttu-id="a9eb0-265">他のプロパティ要素のプロパティ要素タグが厳密な XAML 言語の定義では; ごとには、"content"として割り当てられていません以前、XAML パーサーの処理順序で処理し、「コンテンツ」であると見なされない。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-265">Property element tags for other properties on an element are not assigned as "content" per a strict XAML language definition; they are processed previously in the XAML parser's processing order and are not considered to be "content".</span></span>  
  
### <a name="xaml-content-property-values-must-be-contiguous"></a><span data-ttu-id="a9eb0-266">XAML コンテンツ プロパティの値が連続している必要があります。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-266">XAML Content Property Values Must Be Contiguous</span></span>  
 <span data-ttu-id="a9eb0-267">XAML コンテンツ プロパティの値は、そのオブジェクト要素の前に、またはその他のすべてのプロパティ要素の後、指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-267">The value of a XAML content property must be given either entirely before or entirely after any other property elements on that object element.</span></span> <span data-ttu-id="a9eb0-268">これは、文字列、または 1 つまたは複数のオブジェクトとして、XAML コンテンツ プロパティの値が指定されているかどうか。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-268">This is true whether the value of a XAML content property is specified as a string, or as one or more objects.</span></span> <span data-ttu-id="a9eb0-269">たとえば、次のマークアップを解析できません。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-269">For example, the following markup does not parse:</span></span>  
  
```  
<Button>I am a   
  <Button.Background>Blue</Button.Background>  
  blue button</Button>  
```  
  
 <span data-ttu-id="a9eb0-270">これは基本的に法的いない場合はこの構文は、コンテンツのプロパティのプロパティ要素構文を使用して明示的に行われた、し、コンテンツのプロパティが 2 回設定するため。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-270">This is illegal essentially because if this syntax were made explicit by using property element syntax for the content property, then the content property would be set twice:</span></span>  
  
```xml  
<Button>  
  <Button.Content>I am a </Button.Content>  
  <Button.Background>Blue</Button.Background>  
  <Button.Content> blue button</Button.Content>  
</Button>  
```  
  
 <span data-ttu-id="a9eb0-271">同様に不正な例は、コンテンツ プロパティは、コレクションと、子要素のプロパティ要素が混じっているかどうかです。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-271">A similarly illegal example is if the content property is a collection, and child elements are interspersed with property elements:</span></span>  
  
```xml  
<StackPanel>  
  <Button>This example</Button>  
  <StackPanel.Resources>  
    <SolidColorBrush x:Key="BlueBrush" Color="Blue"/>  
  </StackPanel.Resources>  
  <Button>... is illegal XAML</Button>  
</StackPanel>  
```  
  
<a name="content_properties_and_collection_syntax_combined"></a>   
## <a name="content-properties-and-collection-syntax-combined"></a><span data-ttu-id="a9eb0-272">コンテンツのプロパティとコレクション構文の組み合わせ</span><span class="sxs-lookup"><span data-stu-id="a9eb0-272">Content Properties and Collection Syntax Combined</span></span>  
 <span data-ttu-id="a9eb0-273">そのまま使用するために複数のコンテンツとして 1 つのオブジェクト要素コンテンツ プロパティの型具体的には型でなければなりませんコレクション。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-273">In order to accept more than a single object element as content, the type of the content property must specifically be a collection type.</span></span> <span data-ttu-id="a9eb0-274">コレクション型のプロパティ要素構文と同様に、XAML プロセッサ必要がありますによって型が識別コレクション型。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-274">Similar to property element syntax for collection types, a XAML processor must identify types that are collection types.</span></span> <span data-ttu-id="a9eb0-275">要素に、XAML コンテンツ プロパティがあり、ユーザーが XAML コンテンツ プロパティの型がコレクションは、暗黙的なコレクション型はオブジェクト要素としてのマークアップで指定する必要はありません。 し、XAML コンテンツ プロパティはプロパティ el として指定する必要はありません。ement です。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-275">If an element has a XAML content property and the type of the XAML content property is a collection, then the implied collection type does not need to be specified in the markup as an object element and the XAML content property does not need to be specified as a property element.</span></span> <span data-ttu-id="a9eb0-276">そのため、マークアップで明らかなコンテンツ モデル今すぐ 1 つ以上の子要素、コンテンツとして割り当てられることができます。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-276">Therefore the apparent content model in the markup can now have more than one child element assigned as the content.</span></span> <span data-ttu-id="a9eb0-277">コンテンツの構文は、次の<xref:System.Windows.Controls.Panel>クラスを派生します。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-277">The following is content syntax for a <xref:System.Windows.Controls.Panel> derived class.</span></span> <span data-ttu-id="a9eb0-278">すべて<xref:System.Windows.Controls.Panel>派生クラスを確立する XAML のコンテンツ プロパティ<xref:System.Windows.Controls.Panel.Children%2A>、型の値を必要となる<xref:System.Windows.Controls.UIElementCollection>です。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-278">All <xref:System.Windows.Controls.Panel> derived classes establish the XAML content property to be <xref:System.Windows.Controls.Panel.Children%2A>, which requires a value of type <xref:System.Windows.Controls.UIElementCollection>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxContent](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page5.xaml#syntaxcontent)]  
  
 <span data-ttu-id="a9eb0-279">なおのどちらのプロパティ要素の<xref:System.Windows.Controls.Panel.Children%2A>も、要素の<xref:System.Windows.Controls.UIElementCollection>マークアップで必要なです。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-279">Note that neither the property element for <xref:System.Windows.Controls.Panel.Children%2A> nor the element for the <xref:System.Windows.Controls.UIElementCollection> is required in the markup.</span></span> <span data-ttu-id="a9eb0-280">これは、機能は、デザイン XAML の再帰的に定義する要素が含まれているように、[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]間にプロパティ要素タグなしの直接の親の子要素の関係を持つ入れ子になった要素のツリーとして表されるより直感的には、またはコレクション オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-280">This is a design feature of XAML so that recursively contained elements that define a [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] are more intuitively represented as a tree of nested elements with immediate parent-child element relationships, without intervening property element tags or collection objects.</span></span> <span data-ttu-id="a9eb0-281">実際には、<xref:System.Windows.Controls.UIElementCollection>できません明示的に指定するマークアップで、オブジェクト要素として設計します。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-281">In fact, <xref:System.Windows.Controls.UIElementCollection> cannot be specified explicitly in markup as an object element, by design.</span></span> <span data-ttu-id="a9eb0-282">そのだけ使用目的は、暗黙の型のコレクションとしてため<xref:System.Windows.Controls.UIElementCollection>はパブリックの既定のコンス トラクターを公開せず、そのため、オブジェクト要素としてインスタンス化できることはできません。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-282">Because its only intended use is as an implicit collection, <xref:System.Windows.Controls.UIElementCollection> does not expose a public default constructor and thus cannot be instantiated as an object element.</span></span>  
  
### <a name="mixing-property-elements-and-object-elements-in-an-object-with-a-content-property"></a><span data-ttu-id="a9eb0-283">プロパティ要素とコンテンツのプロパティを持つオブジェクトのオブジェクト要素の混在</span><span class="sxs-lookup"><span data-stu-id="a9eb0-283">Mixing Property Elements and Object Elements in an Object with a Content Property</span></span>  
 <span data-ttu-id="a9eb0-284">XAML の仕様では、XAML プロセッサが、XAML コンテンツ内のプロパティ オブジェクト要素の塗りつぶしに使用されるオブジェクトの要素は、連続している必要があり、いません混在させる必要がありますを適用できることを宣言します。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-284">The XAML specification declares that a XAML processor can enforce that object elements that are used to fill the XAML content property within an object element must be contiguous, and must not be mixed.</span></span> <span data-ttu-id="a9eb0-285">によってプロパティ要素とコンテンツの混合に対してこの制限が適用されます、 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML プロセッサ。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-285">This restriction against mixing property elements and content is enforced by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML processors.</span></span>  
  
 <span data-ttu-id="a9eb0-286">オブジェクトの子要素は、オブジェクト要素内の最初の即時マークアップとして持つことができます。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-286">You can have a child object element as the first immediate markup within an object element.</span></span> <span data-ttu-id="a9eb0-287">プロパティ要素を導入できます。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-287">Then you can introduce property elements.</span></span> <span data-ttu-id="a9eb0-288">または、1 つまたは複数のプロパティ要素では、コンテンツ、さらにプロパティ要素を指定することができます。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-288">Or, you can specify one or more property elements, then content, then more property elements.</span></span> <span data-ttu-id="a9eb0-289">プロパティ要素のコンテンツに依存して、さらにそのコンテンツを導入することはできません、プロパティ要素にのみ追加することができます。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-289">But once a property element follows content, you cannot introduce any further content, you can only add property elements.</span></span>  
  
 <span data-ttu-id="a9eb0-290">このコンテンツのコンテンツとして使用される内部のテキストにプロパティ要素の順序の要件は適用されません。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-290">This content / property element order requirement does not apply to inner text used as content.</span></span> <span data-ttu-id="a9eb0-291">ただし、マークアップにスタイルを内部テキ ストを重要なホワイト スペースがプロパティ要素は、内部テキ ストが混在している場合に、マークアップで視覚的に検出するが困難になるため、連続したままではまだです。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-291">However, it is still a good markup style to keep inner text contiguous, because significant whitespace will be difficult to detect visually in the markup if property elements are interspersed with inner text.</span></span>  
  
<a name="xaml_namespaces"></a>   
## <a name="xaml-namespaces"></a><span data-ttu-id="a9eb0-292">XAML 名前空間</span><span class="sxs-lookup"><span data-stu-id="a9eb0-292">XAML Namespaces</span></span>  
 <span data-ttu-id="a9eb0-293">上記の構文例の指定された既定の XAML 名前空間以外の XAML 名前空間ありません。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-293">None of the preceding syntax examples specified a XAML namespace other than the default XAML namespace.</span></span> <span data-ttu-id="a9eb0-294">一般的な[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]に指定するアプリケーション、既定の XAML 名前空間、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]名前空間。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-294">In typical [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications, the default XAML namespace is specified to be the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] namespace.</span></span> <span data-ttu-id="a9eb0-295">既定の XAML 名前空間以外の XAML 名前空間を指定し、同様の構文を引き続き使用できます。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-295">You can specify XAML namespaces other than the default XAML namespace and still use similar syntax.</span></span> <span data-ttu-id="a9eb0-296">次に、任意の場所で、クラスの名前は、既定の XAML 名前空間内でアクセス可能ではないクラス名に前指定しなければなりません XAML 名前空間のプレフィックスを持つように対応する CLR 名前空間にマップします。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-296">But then, anywhere where a class is named that is not accessible within the default XAML namespace, that class name must be preceded with the prefix of the XAML namespace as mapped to the corresponding CLR namespace.</span></span> <span data-ttu-id="a9eb0-297">たとえば、`<custom:Example/>`オブジェクト要素の構文のインスタンスをインスタンス化するには、`Example`クラス、そのクラス (および可能性のある外部アセンブリ情報をバッキング型を含む) を含む CLR 名前空間を以前にマップされて、`custom`プレフィックス。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-297">For example, `<custom:Example/>` is object element syntax to instantiate an instance of the `Example` class, where the CLR namespace containing that class (and possibly the external assembly information that contains backing types) was previously mapped to the `custom` prefix.</span></span>  
  
 <span data-ttu-id="a9eb0-298">XAML 名前空間の詳細については、次を参照してください。 [XAML 名前空間と WPF XAML のマッピングの Namespace](../../../../docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)です。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-298">For more information about XAML namespaces, see [XAML Namespaces and Namespace Mapping for WPF XAML](../../../../docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span></span>  
  
<a name="markup_extensions"></a>   
## <a name="markup-extensions"></a><span data-ttu-id="a9eb0-299">マークアップ拡張機能</span><span class="sxs-lookup"><span data-stu-id="a9eb0-299">Markup Extensions</span></span>  
 <span data-ttu-id="a9eb0-300">XAML では、通常 XAML プロセッサの処理は、文字列の属性値またはオブジェクトの要素からエスケープを有効にし、バッキング クラスに処理を延期するエンティティをプログラミングするマークアップ拡張機能を定義します。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-300">XAML defines a markup extension programming entity that enables an escape from the normal XAML processor handling of string attribute values or object elements, and defers the processing to a backing class.</span></span> <span data-ttu-id="a9eb0-301">始め中かっこ ({})、右中かっこ (}) 以外の文字で後に、属性の構文を使用するときに、XAML プロセッサにマークアップ拡張機能を識別する文字。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-301">The character that identifies a markup extension to a XAML processor when using attribute syntax is the opening curly brace ({), followed by any character other than a closing curly brace (}).</span></span> <span data-ttu-id="a9eb0-302">始め中かっこの後の最初の文字列には、その部分文字列が真のクラス名の一部である場合に、"Extension"を参照が、部分文字列を含めない場合があります、特定の拡張機能の動作に提供するクラスを参照する必要があります。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-302">The first string following the opening curly brace must reference the class that provides the particular extension behavior, where the reference may omit the substring "Extension" if that substring is part of the true class name.</span></span> <span data-ttu-id="a9eb0-303">その後、1 つのスペースが表示されますし後続の各文字を使用して入力として拡張機能の実装で中かっこが発生するまでです。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-303">Thereafter, a single space may appear, and then each succeeding character is used as input by the extension implementation, up until the closing curly brace is encountered.</span></span>  
  
 <span data-ttu-id="a9eb0-304">.NET の XAML 実装を使用して、<xref:System.Windows.Markup.MarkupExtension>すべてでサポートされているマークアップ拡張機能の基礎として抽象クラス[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]他のフレームワークまたはテクノロジとします。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-304">The .NET XAML implementation uses the <xref:System.Windows.Markup.MarkupExtension> abstract class as the basis for all of the markup extensions supported by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] as well as other frameworks or technologies.</span></span> <span data-ttu-id="a9eb0-305">マークアップ拡張機能を[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]具体的には実装が他の既存のオブジェクトを参照するか、実行時に評価されるオブジェクトへの遅延の参照を作成する手段を提供する多くの場合、対象としています。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-305">The markup extensions that [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] specifically implements are often intended to provide a means to reference other existing objects, or to make deferred references to objects that will be evaluated at run time.</span></span> <span data-ttu-id="a9eb0-306">指定して、単純な WPF データ バインディングを行うなど、`{Binding}`通常受け取る特定のプロパティ値の代わりに、マークアップ拡張機能です。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-306">For example, a simple WPF data binding is accomplished by specifying the `{Binding}` markup extension in place of the value that a particular property would ordinarily take.</span></span> <span data-ttu-id="a9eb0-307">WPF のマークアップ拡張機能の多くは、属性の構文を利用できないプロパティの属性の構文が有効にします。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-307">Many of the WPF markup extensions enable an attribute syntax for properties where an attribute syntax would not otherwise be possible.</span></span> <span data-ttu-id="a9eb0-308">たとえば、<xref:System.Windows.Style>オブジェクトは、比較的複雑な型を入れ子になった一連のオブジェクトとプロパティを含むです。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-308">For example, a <xref:System.Windows.Style> object is a relatively complex type that contains a nested series of objects and properties.</span></span> <span data-ttu-id="a9eb0-309">WPF のスタイルでは、通常のリソースとして定義されます、 <xref:System.Windows.ResourceDictionary>、し、リソースを要求する WPF のマークアップの 2 つの拡張機能のいずれかで参照します。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-309">Styles in WPF are typically defined as a resource in a <xref:System.Windows.ResourceDictionary>, and then referenced through one of the two WPF markup extensions that request a resource.</span></span> <span data-ttu-id="a9eb0-310">マークアップ拡張機能リソースの検索するプロパティ値の評価を延期し、値を提供できるように、<xref:System.Windows.FrameworkElement.Style%2A>プロパティの型を取得<xref:System.Windows.Style>で、属性の例を次の構文。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-310">The markup extension defers the evaluation of the property value to a resource lookup and enables providing the value of the <xref:System.Windows.FrameworkElement.Style%2A> property, taking type <xref:System.Windows.Style>, in attribute syntax as in the following example:</span></span>  
  
 `<Button Style="{StaticResource MyStyle}">My button</Button>`  
  
 <span data-ttu-id="a9eb0-311">ここでは、`StaticResource`を識別、<xref:System.Windows.StaticResourceExtension>マークアップ拡張機能の実装を提供するクラス。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-311">Here, `StaticResource` identifies the <xref:System.Windows.StaticResourceExtension> class providing the markup extension implementation.</span></span> <span data-ttu-id="a9eb0-312">次の文字列`MyStyle`、既定以外の入力として使用される<xref:System.Windows.StaticResourceExtension>コンス トラクター、拡張子の文字列から取得したように、パラメーターが、要求されたを宣言<xref:System.Windows.ResourceKey>です。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-312">The next string `MyStyle` is used as the input for the non-default <xref:System.Windows.StaticResourceExtension> constructor, where the parameter as taken from the extension string declares the requested <xref:System.Windows.ResourceKey>.</span></span> <span data-ttu-id="a9eb0-313">`MyStyle`できると予想される、 [X:key](../../../../docs/framework/xaml-services/x-key-directive.md)の値、<xref:System.Windows.Style>リソースとして定義します。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-313">`MyStyle` is expected to be the [x:Key](../../../../docs/framework/xaml-services/x-key-directive.md) value of a <xref:System.Windows.Style> defined as a resource.</span></span> <span data-ttu-id="a9eb0-314">[StaticResource マークアップ拡張機能](../../../../docs/framework/wpf/advanced/staticresource-markup-extension.md)使用状況が提供するリソースを使用することを要求、<xref:System.Windows.Style>読み込み時に静的リソースの検索ロジックを使用してプロパティ値。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-314">The [StaticResource Markup Extension](../../../../docs/framework/wpf/advanced/staticresource-markup-extension.md) usage requests that the resource be used to provide the <xref:System.Windows.Style> property value through static resource lookup logic at load time.</span></span>  
  
 <span data-ttu-id="a9eb0-315">マークアップ拡張機能の詳細については、 「[マークアップ拡張機能と WPF XAML](../../../../docs/framework/wpf/advanced/markup-extensions-and-wpf-xaml.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-315">For more information about markup extensions, see [Markup Extensions and WPF XAML](../../../../docs/framework/wpf/advanced/markup-extensions-and-wpf-xaml.md).</span></span> <span data-ttu-id="a9eb0-316">マークアップ拡張機能とその他の XAML プログラミングの一般的な .NET の XAML 実装で有効になっている機能の参照、次を参照してください[XAML Namespace (x:)。言語機能](../../../../docs/framework/xaml-services/xaml-namespace-x-language-features.md)します。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-316">For a reference of markup extensions and other XAML programming features enabled in the general .NET XAML implementation, see [XAML Namespace (x:) Language Features](../../../../docs/framework/xaml-services/xaml-namespace-x-language-features.md).</span></span> <span data-ttu-id="a9eb0-317">WPF 固有のマークアップ拡張機能を参照してください。 [WPF XAML 拡張](../../../../docs/framework/wpf/advanced/wpf-xaml-extensions.md)です。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-317">For WPF-specific markup extensions, see [WPF XAML Extensions](../../../../docs/framework/wpf/advanced/wpf-xaml-extensions.md).</span></span>  
  
<a name="attached_properties"></a>   
## <a name="attached-properties"></a><span data-ttu-id="a9eb0-318">アタッチされるプロパティ</span><span class="sxs-lookup"><span data-stu-id="a9eb0-318">Attached Properties</span></span>  
 <span data-ttu-id="a9eb0-319">アタッチされるプロパティは、XAML のプロパティを所有しているし、特定の型によって定義されたで導入されたプログラミングの概念の任意の要素の属性またはプロパティ要素としてが設定されています。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-319">Attached properties are a programming concept introduced in XAML whereby properties can be owned and defined by a particular type, but set as attributes or property elements on any element.</span></span> <span data-ttu-id="a9eb0-320">主に、すべての要素の間で広く共有オブジェクト モデルを必要とせず、親要素に情報を報告するマークアップ構造内の子要素を有効にするのにはアタッチされるプロパティを意図しています。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-320">The primary scenario that attached properties are intended for is to enable child elements in a markup structure to report information to a parent element without requiring an extensively shared object model across all elements.</span></span> <span data-ttu-id="a9eb0-321">逆に、アタッチされるプロパティは、子要素に情報を報告する親要素によって使用できます。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-321">Conversely, attached properties can be used by parent elements to report information to child elements.</span></span> <span data-ttu-id="a9eb0-322">アタッチされるプロパティと、独自に作成する方法の目的に関する詳細情報には、プロパティが接続されているを参照してください[添付プロパティの概要](../../../../docs/framework/wpf/advanced/attached-properties-overview.md)です。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-322">For more information on the purpose of attached properties and how to create your own attached properties, see [Attached Properties Overview](../../../../docs/framework/wpf/advanced/attached-properties-overview.md).</span></span>  
  
 <span data-ttu-id="a9eb0-323">添付プロパティを指定することも一見プロパティ要素構文に似た構文を使用して、 *typeName*.*propertyName*の組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-323">Attached properties use a syntax that superficially resembles property element syntax, in that you also specify a *typeName*.*propertyName* combination.</span></span> <span data-ttu-id="a9eb0-324">次の 2 つの重要な違いがあります。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-324">There are two important differences:</span></span>  
  
-   <span data-ttu-id="a9eb0-325">使用することができます、 *typeName*.*propertyName*属性構文で添付プロパティを設定する場合は偶数の組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-325">You can use the *typeName*.*propertyName* combination even when setting an attached property through attribute syntax.</span></span> <span data-ttu-id="a9eb0-326">添付プロパティが場合のみ、プロパティ名を修飾する属性の構文の要件です。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-326">Attached properties are the only case where qualifying the property name is a requirement in an attribute syntax.</span></span>  
  
-   <span data-ttu-id="a9eb0-327">添付プロパティのプロパティ要素構文を使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-327">You can also use property element syntax for attached properties.</span></span> <span data-ttu-id="a9eb0-328">ただし、一般的なプロパティ要素構文を*typeName*プロパティ要素が含まれるオブジェクトの要素を指定します。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-328">However, for typical property element syntax, the *typeName* you specify is the object element that contains the property element.</span></span> <span data-ttu-id="a9eb0-329">添付プロパティを参照している場合、 *typeName*を含むオブジェクト要素ではなく、添付プロパティを定義するクラスです。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-329">If you are referring to an attached property, then the *typeName* is the class that defines the attached property, not the containing object element.</span></span>  
  
<a name="attached_events"></a>   
## <a name="attached-events"></a><span data-ttu-id="a9eb0-330">アタッチされるイベント</span><span class="sxs-lookup"><span data-stu-id="a9eb0-330">Attached Events</span></span>  
 <span data-ttu-id="a9eb0-331">アタッチされるイベントは、XAML でイベントを特定の型によって定義できますが、任意のオブジェクト要素のハンドラーをアタッチすることがありますで導入された別のプログラミング概念です。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-331">Attached events are another programming concept introduced in XAML where events can be defined by a specific type, but handlers may be attached on any object element.</span></span> <span data-ttu-id="a9eb0-332">実装では、WOF 添付イベントを定義する型が、サービスを定義する静的な型を多くの場合、および添付イベントが、ルーティングされたイベントで別名、サービスを公開する型によって公開される場合があります。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-332">In the WOF implementation, often the type that defines an attached event is a static type that defines a service, and sometimes those attached events are exposed by a routed event alias in types that expose the service.</span></span> <span data-ttu-id="a9eb0-333">添付イベントのハンドラーは、属性構文で指定します。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-333">Handlers for attached events are specified through attribute syntax.</span></span> <span data-ttu-id="a9eb0-334">許可する添付イベントのアタッチされたイベントは、属性の構文が展開した状態、 *typeName*.*eventName*使用法、場所*typeName*を提供するクラスは、`Add`と`Remove`添付イベント インフラストラクチャのイベント ハンドラーのアクセサーおよび*eventName*イベントの名前を指定します。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-334">As with attached events, the attribute syntax is expanded for attached events to allow a *typeName*.*eventName* usage, where *typeName* is the class that provides `Add` and `Remove` event handler accessors for the attached event infrastructure, and *eventName* is the event name.</span></span>  
  
<a name="anatomy_of_a_xaml_page_root_element"></a>   
## <a name="anatomy-of-a-xaml-root-element"></a><span data-ttu-id="a9eb0-335">XAML ルート要素の構造</span><span class="sxs-lookup"><span data-stu-id="a9eb0-335">Anatomy of a XAML Root Element</span></span>  
 <span data-ttu-id="a9eb0-336">次の表は、一般的な XAML ルート要素は、のルート要素の特定の属性の表示を示しています。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-336">The following table shows a typical XAML root element broken down, showing the specific attributes of a root element:</span></span>  
  
|||  
|-|-|  
|`<Page`|<span data-ttu-id="a9eb0-337">ルート要素の開始オブジェクト要素</span><span class="sxs-lookup"><span data-stu-id="a9eb0-337">Opening object element of the root element</span></span>|  
|`xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"`|<span data-ttu-id="a9eb0-338">既定値 ([!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]) の XAML 名前空間</span><span class="sxs-lookup"><span data-stu-id="a9eb0-338">The default ([!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]) XAML namespace</span></span>|  
|`xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"`|<span data-ttu-id="a9eb0-339">XAML 言語の XAML 名前空間</span><span class="sxs-lookup"><span data-stu-id="a9eb0-339">The XAML language XAML namespace</span></span>|  
|`x:Class="ExampleNamespace.ExampleCode"`|<span data-ttu-id="a9eb0-340">部分クラスのマークアップを分離コードに接続する部分クラス宣言の定義</span><span class="sxs-lookup"><span data-stu-id="a9eb0-340">The partial class declaration that connects markup to any code-behind defined for the partial class</span></span>|  
|`>`|<span data-ttu-id="a9eb0-341">ルートのオブジェクト要素の終了。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-341">End of object element for the root.</span></span> <span data-ttu-id="a9eb0-342">要素には、子要素が含まれているために、オブジェクトはまだ閉じられていません</span><span class="sxs-lookup"><span data-stu-id="a9eb0-342">Object is not closed yet because the element contains child elements</span></span>|  
  
<a name="optional_and_nonrecommended_xaml_usages"></a>   
## <a name="optional-and-nonrecommended-xaml-usages"></a><span data-ttu-id="a9eb0-343">省略可能な非推奨の XAML の使用方法</span><span class="sxs-lookup"><span data-stu-id="a9eb0-343">Optional and Nonrecommended XAML Usages</span></span>  
 <span data-ttu-id="a9eb0-344">次のセクションでは、技術的には XAML プロセッサによってサポートされているが、詳細度または他の見た目問題に干渉する場合の人間が判読できる残りの XAML ファイルを生成する XAML の使用方法を説明する、XAML ソースを含むアプリケーションの開発.</span><span class="sxs-lookup"><span data-stu-id="a9eb0-344">The following sections describe XAML usages that are technically supported by XAML processors, but that produce verbosity or other aesthetic issues that interfere with XAML files remaining human-readable when your develop applications that contain XAML sources.</span></span>  
  
### <a name="optional-property-element-usages"></a><span data-ttu-id="a9eb0-345">省略可能なプロパティ要素の使用方法</span><span class="sxs-lookup"><span data-stu-id="a9eb0-345">Optional Property Element Usages</span></span>  
 <span data-ttu-id="a9eb0-346">省略可能なプロパティ要素の使用法には、明示的に書き込む要素のコンテンツ プロパティで、XAML プロセッサは暗黙的な考慮が含まれます。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-346">Optional property element usages include explicitly writing out element content properties that the XAML processor considers implicit.</span></span> <span data-ttu-id="a9eb0-347">内容を宣言する場合など、 <xref:System.Windows.Controls.Menu>、明示的に宣言することができます、<xref:System.Windows.Controls.ItemsControl.Items%2A>のコレクション、<xref:System.Windows.Controls.Menu>として、`<Menu.Items>`プロパティ要素タグおよび配置の各<xref:System.Windows.Controls.MenuItem>内`<Menu.Items>`ではなく、暗黙的な XAML プロセッサの動作を使用するよりものすべての子要素、<xref:System.Windows.Controls.Menu>する必要があります、<xref:System.Windows.Controls.MenuItem>に配置し、<xref:System.Windows.Controls.ItemsControl.Items%2A>コレクション。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-347">For example, when you declare the contents of a <xref:System.Windows.Controls.Menu>, you could choose to explicitly declare the <xref:System.Windows.Controls.ItemsControl.Items%2A> collection of the <xref:System.Windows.Controls.Menu> as a `<Menu.Items>` property element tag, and place each <xref:System.Windows.Controls.MenuItem> within `<Menu.Items>`, rather than using the implicit XAML processor behavior that all child elements of a <xref:System.Windows.Controls.Menu> must be a <xref:System.Windows.Controls.MenuItem> and are placed in the <xref:System.Windows.Controls.ItemsControl.Items%2A> collection.</span></span> <span data-ttu-id="a9eb0-348">省略可能な使用法はマークアップで表されるオブジェクトの構造を視覚的に明確にするために役立ちます。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-348">Sometimes the optional usages can help to visually clarify the object structure as represented in the markup.</span></span> <span data-ttu-id="a9eb0-349">またはが明示的にプロパティ要素の使用が技術的には、属性値内で入れ子になったマークアップ拡張機能など、視覚的に混乱しますが、機能するマークアップを回避することがあります。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-349">Or sometimes an explicit property element usage can avoid markup that is technically functional but visually confusing, such as nested markup extensions within an attribute value.</span></span>  
  
### <a name="full-typenamemembername-qualified-attributes"></a><span data-ttu-id="a9eb0-350">修飾された完全 typeName.memberName 属性</span><span class="sxs-lookup"><span data-stu-id="a9eb0-350">Full typeName.memberName Qualified Attributes</span></span>  
 <span data-ttu-id="a9eb0-351">*TypeName*.*memberName*フォーム ルーティング イベントの場合のみより汎用的な属性は実際に動作します。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-351">The *typeName*.*memberName* form for an attribute actually works more universally than just the routed event case.</span></span> <span data-ttu-id="a9eb0-352">他の状況ではそのフォームは不要でありのみマークアップ スタイルと読みやすさの原因の場合、これを避ける必要があります。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-352">But in other situations that form is superfluous and you should avoid it, if only for reasons of markup style and readability.</span></span> <span data-ttu-id="a9eb0-353">参照、3 つ次の例で、<xref:System.Windows.Controls.Control.Background%2A>属性が完全に等価です。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-353">In the following example, each of the three references to the <xref:System.Windows.Controls.Control.Background%2A> attribute are completely equivalent:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#TypeNameProp](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#typenameprop)]  
  
 <span data-ttu-id="a9eb0-354">`Button.Background`機能するためにそのプロパティの修飾参照<xref:System.Windows.Controls.Button>が成功した (<xref:System.Windows.Controls.Control.Background%2A>コントロールから継承された) と<xref:System.Windows.Controls.Button>はオブジェクト要素のクラスまたは基底クラス。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-354">`Button.Background` works because the qualified lookup for that property on <xref:System.Windows.Controls.Button> is successful (<xref:System.Windows.Controls.Control.Background%2A> was inherited from Control) and <xref:System.Windows.Controls.Button> is the class of the object element or a base class.</span></span> <span data-ttu-id="a9eb0-355">`Control.Background`機能するため、<xref:System.Windows.Controls.Control>クラスは、実際に定義<xref:System.Windows.Controls.Control.Background%2A>と<xref:System.Windows.Controls.Control>は、<xref:System.Windows.Controls.Button>基本クラスです。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-355">`Control.Background` works because the <xref:System.Windows.Controls.Control> class actually defines <xref:System.Windows.Controls.Control.Background%2A> and <xref:System.Windows.Controls.Control> is a <xref:System.Windows.Controls.Button> base class.</span></span>  
  
 <span data-ttu-id="a9eb0-356">ただし、次*typeName*.*memberName* form の例はコメントが付けられたため表示しては機能しません。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-356">However, the following *typeName*.*memberName* form example does not work and is thus shown commented:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#TypeNameBadProp](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#typenamebadprop)]  
  
 <span data-ttu-id="a9eb0-357"><xref:System.Windows.Controls.Label>別の派生クラスは、 <xref:System.Windows.Controls.Control>、指定した場合と`Label.Background`内で、<xref:System.Windows.Controls.Label>オブジェクト要素の場合は、この使用法は有益です。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-357"><xref:System.Windows.Controls.Label> is another derived class of <xref:System.Windows.Controls.Control>, and if you had specified `Label.Background` within a <xref:System.Windows.Controls.Label> object element, this usage would have worked.</span></span> <span data-ttu-id="a9eb0-358">ただし、ため<xref:System.Windows.Controls.Label>クラスまたはの基本クラスではありません<xref:System.Windows.Controls.Button>、XAML プロセッサの動作を指定では、処理する`Label.Background`添付プロパティとして。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-358">However, because <xref:System.Windows.Controls.Label> is not the class or base class of <xref:System.Windows.Controls.Button>, the specified XAML processor behavior is to then process `Label.Background` as an attached property.</span></span> <span data-ttu-id="a9eb0-359">`Label.Background`使用可能な接続プロパティではなく、この使用法が失敗しました。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-359">`Label.Background` is not an available attached property, and this usage fails.</span></span>  
  
### <a name="basetypenamemembername-property-elements"></a><span data-ttu-id="a9eb0-360">baseTypeName.memberName プロパティ要素</span><span class="sxs-lookup"><span data-stu-id="a9eb0-360">baseTypeName.memberName Property Elements</span></span>  
 <span data-ttu-id="a9eb0-361">操作方法、似たような方法で、 *typeName*.*memberName*フォームの動作属性の構文については、 *baseTypeName*.*memberName*構文のプロパティ要素構文に動作します。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-361">In an analogous way to how the *typeName*.*memberName* form works for attribute syntax, a *baseTypeName*.*memberName* syntax works for property element syntax.</span></span> <span data-ttu-id="a9eb0-362">たとえば、次の構文が動作します。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-362">For instance, the following syntax works:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#GoofyPE](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofype)]  
  
 <span data-ttu-id="a9eb0-363">ここでは、プロパティ要素は、として指定されました`Control.Background`にプロパティ要素が含まれている場合でも`Button`です。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-363">Here, the property element was given as `Control.Background` even though the property element was contained in `Button`.</span></span>  
  
 <span data-ttu-id="a9eb0-364">同じように、 *typeName*.*memberName*属性に関しては、フォーム*baseTypeName*.*memberName*マークアップでは、不適切なスタイルは、これを避ける必要があります。</span><span class="sxs-lookup"><span data-stu-id="a9eb0-364">But just like *typeName*.*memberName* form for attributes, *baseTypeName*.*memberName* is poor style in markup, and you should avoid it.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="a9eb0-365">参照</span><span class="sxs-lookup"><span data-stu-id="a9eb0-365">See Also</span></span>  
 [<span data-ttu-id="a9eb0-366">XAML の概要 (WPF)</span><span class="sxs-lookup"><span data-stu-id="a9eb0-366">XAML Overview (WPF)</span></span>](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md)  
 [<span data-ttu-id="a9eb0-367">XAML 名前空間 (x:) 言語機能</span><span class="sxs-lookup"><span data-stu-id="a9eb0-367">XAML Namespace (x:) Language Features</span></span>](../../../../docs/framework/xaml-services/xaml-namespace-x-language-features.md)  
 [<span data-ttu-id="a9eb0-368">WPF XAML 拡張機能</span><span class="sxs-lookup"><span data-stu-id="a9eb0-368">WPF XAML Extensions</span></span>](../../../../docs/framework/wpf/advanced/wpf-xaml-extensions.md)  
 [<span data-ttu-id="a9eb0-369">依存関係プロパティの概要</span><span class="sxs-lookup"><span data-stu-id="a9eb0-369">Dependency Properties Overview</span></span>](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md)  
 [<span data-ttu-id="a9eb0-370">TypeConverters および XAML</span><span class="sxs-lookup"><span data-stu-id="a9eb0-370">TypeConverters and XAML</span></span>](../../../../docs/framework/wpf/advanced/typeconverters-and-xaml.md)  
 [<span data-ttu-id="a9eb0-371">WPF における XAML とカスタム クラス</span><span class="sxs-lookup"><span data-stu-id="a9eb0-371">XAML and Custom Classes for WPF</span></span>](../../../../docs/framework/wpf/advanced/xaml-and-custom-classes-for-wpf.md)
