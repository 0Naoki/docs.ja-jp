---
title: WPF における XAML とカスタム クラス
ms.date: 03/30/2017
helpviewer_keywords:
- custom classes in XAML [WPF]
- XAML [WPF], custom classes
- classes [WPF], custom classes in XAML
ms.assetid: e7313137-581e-4a64-8453-d44e15a6164a
ms.openlocfilehash: e71946ec06eb1b4c75f30084dfdb863d8e3b093e
ms.sourcegitcommit: 5b6d778ebb269ee6684fb57ad69a8c28b06235b9
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/08/2019
ms.locfileid: "59122357"
---
# <a name="xaml-and-custom-classes-for-wpf"></a><span data-ttu-id="300b3-102">WPF における XAML とカスタム クラス</span><span class="sxs-lookup"><span data-stu-id="300b3-102">XAML and Custom Classes for WPF</span></span>
<span data-ttu-id="300b3-103">XAML に実装されている[!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)]フレームワークは、いずれかで、カスタムのクラスまたは構造体を定義する機能をサポートしている[!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)]言語、およびしアクセス クラスの XAML マークアップを使用しています。</span><span class="sxs-lookup"><span data-stu-id="300b3-103">XAML as implemented in [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] frameworks supports the ability to define a custom class or structure in any [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] language, and then access that class using XAML markup.</span></span> <span data-ttu-id="300b3-104">組み合わせを使用できる[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]-XAML 名前空間のプレフィックスにカスタムの型をマップして、通常の種類と同じマークアップ ファイル内でカスタム型を定義します。</span><span class="sxs-lookup"><span data-stu-id="300b3-104">You can use a mixture of [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]-defined types and your custom types within the same markup file, typically by mapping the custom types to a XAML namespace prefix.</span></span> <span data-ttu-id="300b3-105">このトピックでは、XAML 要素として使用するのには、カスタム クラスが満たす必要がある要件について説明します。</span><span class="sxs-lookup"><span data-stu-id="300b3-105">This topic discusses the requirements that a custom class must satisfy to be usable as a XAML element.</span></span>  

<a name="Custom_Classes_in_Applications_vs__in_Assemblies"></a>   
## <a name="custom-classes-in-applications-or-assemblies"></a><span data-ttu-id="300b3-106">アプリケーションまたはアセンブリのカスタム クラス</span><span class="sxs-lookup"><span data-stu-id="300b3-106">Custom Classes in Applications or Assemblies</span></span>  
 <span data-ttu-id="300b3-107">2 つの方法で XAML で使用されるカスタム クラスを定義することができます。 分離コードまたはその他のプライマリを生成するコード内で[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]アプリケーション、または実行可能ファイルなどの別のアセンブリ内のクラスまたはクラス ライブラリとして使用される DLL として。</span><span class="sxs-lookup"><span data-stu-id="300b3-107">Custom classes that are used in XAML can be defined in two distinct ways: within the code-behind or other code that produces the primary [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] application, or as a class in a separate assembly, such as an executable or DLL used as a class library.</span></span> <span data-ttu-id="300b3-108">これらのアプローチのそれぞれは、特定の長所と短所にあります。</span><span class="sxs-lookup"><span data-stu-id="300b3-108">Each of these approaches has particular advantages and disadvantages.</span></span>  
  
-   <span data-ttu-id="300b3-109">クラス ライブラリを作成する利点は、このような任意のカスタム クラスが異なる多くのアプリケーション間で共有できることです。</span><span class="sxs-lookup"><span data-stu-id="300b3-109">The advantage of creating a class library is that any such custom classes can be shared across many different possible applications.</span></span> <span data-ttu-id="300b3-110">別のライブラリもアプリケーションのバージョン管理の問題を簡単に、コントロールと、目的のクラスの使用状況を XAML ページにルート要素としては、クラスの作成を簡素化します。</span><span class="sxs-lookup"><span data-stu-id="300b3-110">A separate library also makes versioning issues of applications easier to control, and simplifies creating a class where the intended class usage is as a root element on a XAML page.</span></span>  
  
-   <span data-ttu-id="300b3-111">アプリケーションのカスタム クラスを定義する利点は、この手法が比較的軽量があり、展開とテストの問題がメイン アプリケーションの実行可能ファイルを超える個別のアセンブリを導入するときに発生しましたが最小限に抑えることです。</span><span class="sxs-lookup"><span data-stu-id="300b3-111">The advantage of defining the custom classes in the application is that this technique is relatively lightweight and minimizes the deployment and testing issues encountered when you introduce separate assemblies beyond the main application executable.</span></span>  
  
-   <span data-ttu-id="300b3-112">同じまたは別のアセンブリで定義されているかどうか、カスタム クラスを XAML で要素として使用するには CLR 名前空間と XML 名前空間の間にマップする必要があります。</span><span class="sxs-lookup"><span data-stu-id="300b3-112">Whether defined in the same or different assembly, custom classes need to be mapped between CLR  namespace and XML  namespace in order to be used in XAML as elements.</span></span> <span data-ttu-id="300b3-113">参照してください[XAML 名前空間および WPF XAML の Namespace マッピング](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)します。</span><span class="sxs-lookup"><span data-stu-id="300b3-113">See [XAML Namespaces and Namespace Mapping for WPF XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span></span>  
  
<a name="Requirements_for_a_Custom_Class_as_a_XAML_Element"></a>   
## <a name="requirements-for-a-custom-class-as-a-xaml-element"></a><span data-ttu-id="300b3-114">XAML 要素としてカスタム クラスの要件</span><span class="sxs-lookup"><span data-stu-id="300b3-114">Requirements for a Custom Class as a XAML Element</span></span>  
 <span data-ttu-id="300b3-115">オブジェクト要素としてインスタンス化できるようにするには、するには、クラスは、次の要件を満たす必要があります。</span><span class="sxs-lookup"><span data-stu-id="300b3-115">In order to be able to be instantiated as an object element, your class must meet the following requirements:</span></span>  
  
-   <span data-ttu-id="300b3-116">カスタム クラスは、パブリックであるし、既定の (パラメーターなしの) パブリック コンス トラクターをサポートする必要があります。</span><span class="sxs-lookup"><span data-stu-id="300b3-116">Your custom class must be public and support a default (parameterless) public constructor.</span></span> <span data-ttu-id="300b3-117">(次の構造に関する注意事項のセクションを参照してください)。</span><span class="sxs-lookup"><span data-stu-id="300b3-117">(See following section for notes regarding structures.)</span></span>  
  
-   <span data-ttu-id="300b3-118">入れ子になったクラスは、カスタム クラスではなければなりません。</span><span class="sxs-lookup"><span data-stu-id="300b3-118">Your custom class must not be a nested class.</span></span> <span data-ttu-id="300b3-119">入れ子になったクラスおよび CLR 使用する、一般的な構文で「ドット」が他の干渉[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]や添付プロパティなどの XAML 機能。</span><span class="sxs-lookup"><span data-stu-id="300b3-119">Nested classes and the "dot" in their general CLR usage syntax interfere with other [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] and/or XAML features such as attached properties.</span></span>  
  
 <span data-ttu-id="300b3-120">オブジェクトの定義はオブジェクト要素構文を有効にするだけでなく、値の型としては、そのオブジェクトを取得するその他のパブリック プロパティのプロパティ要素構文もできます。</span><span class="sxs-lookup"><span data-stu-id="300b3-120">In addition to enabling object element syntax, your object definition also enables property element syntax for any other public properties that take that object as the value type.</span></span> <span data-ttu-id="300b3-121">これは、オブジェクトがオブジェクト要素としてインスタンス化するようになりましたことができます、このようなプロパティのプロパティ要素の値を入力できるためです。</span><span class="sxs-lookup"><span data-stu-id="300b3-121">This is because the object can now be instantiated as an object element and can fill the property element value of such a property.</span></span>  
  
### <a name="structures"></a><span data-ttu-id="300b3-122">構造体</span><span class="sxs-lookup"><span data-stu-id="300b3-122">Structures</span></span>  
 <span data-ttu-id="300b3-123">カスタムの種類は、XAML 内で構築することが常として定義する構造体[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]します。これは、ため、[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]コンパイラが暗黙的にすべてのプロパティ値を既定値を初期化する構造体の既定のコンス トラクターを作成します。</span><span class="sxs-lookup"><span data-stu-id="300b3-123">Structures that you define as custom types are always able to be constructed in XAML  in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] .This is because the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] compilers implicitly create a default constructor for a structure that initializes all property values to their defaults.</span></span> <span data-ttu-id="300b3-124">場合によっては、構造体の既定コンス トラクターの動作やオブジェクト要素の各使用は望ましくありません。</span><span class="sxs-lookup"><span data-stu-id="300b3-124">In some cases, the default construction behavior and/or object element usage for a structure is not desirable.</span></span> <span data-ttu-id="300b3-125">構造体では、fill 値および関数に概念的には、共用体に含まれる値は相互に排他的な解釈を必要があります、そのためのプロパティは設定可能な可能性があります。</span><span class="sxs-lookup"><span data-stu-id="300b3-125">This might be because the structure is intended to fill values and function conceptually as a union, where the values contained might have mutually exclusive interpretations and thus none of its properties are settable.</span></span> <span data-ttu-id="300b3-126">A[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]このような構造の例は、<xref:System.Windows.GridLength>します。</span><span class="sxs-lookup"><span data-stu-id="300b3-126">A [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] example of such a structure is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="300b3-127">一般に、このような構造は、値は、さまざまな解釈や構造体の値のモードを作成する文字列の規則を使用して、属性の形式で表現できるように、型コンバーターを実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="300b3-127">Generally, such structures should implement a type converter such that the values can be expressed in attribute form, using string conventions that create the different interpretations or modes of the structure's values.</span></span> <span data-ttu-id="300b3-128">構造体には、既定以外のコンス トラクターを使用してコード構築の同様の動作も公開する必要があります。</span><span class="sxs-lookup"><span data-stu-id="300b3-128">The structure should also expose similar behavior for code construction through a non-default constructor.</span></span>  
  
<a name="Requirements_for_Properties_of_a_Custom_Class_as_XAML"></a>   
## <a name="requirements-for-properties-of-a-custom-class-as-xaml-attributes"></a><span data-ttu-id="300b3-129">XAML の属性としてカスタム クラスのプロパティの要件</span><span class="sxs-lookup"><span data-stu-id="300b3-129">Requirements for Properties of a Custom Class as XAML Attributes</span></span>  
 <span data-ttu-id="300b3-130">プロパティは、(プリミティブ) など、値の型を参照または型を持つ既定のコンス トラクターまたは XAML プロセッサがアクセスできる専用の型コンバーターのいずれかのクラスを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="300b3-130">Properties must reference a by-value type (such as a primitive), or use a class for type that has either a default constructor or a dedicated type converter that a XAML processor can access.</span></span> <span data-ttu-id="300b3-131">CLR の XAML の実装で XAML プロセッサか検索言語プリミティブのネイティブ サポート、またはアプリケーションのを通じてこのようなコンバーター<xref:System.ComponentModel.TypeConverterAttribute>型またはメンバーの種類の定義をバックアップする</span><span class="sxs-lookup"><span data-stu-id="300b3-131">In the CLR XAML implementation, XAML processors either find such converters through native support for language primitives, or through application of <xref:System.ComponentModel.TypeConverterAttribute> to a type or member in backing type definitions</span></span>  
  
 <span data-ttu-id="300b3-132">または、プロパティは、抽象クラス型またはインターフェイスを参照できます。</span><span class="sxs-lookup"><span data-stu-id="300b3-132">Alternatively, the property may reference an abstract class type, or an interface.</span></span> <span data-ttu-id="300b3-133">抽象クラスまたはインターフェイスは、XAML を解析するための予測は、インターフェイスを実装する実際的なクラスのインスタンスまたは抽象クラスから派生した型のインスタンスでプロパティ値を入力する必要があります。</span><span class="sxs-lookup"><span data-stu-id="300b3-133">For abstract classes or interfaces, the expectation for XAML parsing is that the property value must be filled with practical class instances that implement the interface, or instances of types that derive from the abstract class.</span></span>  
  
 <span data-ttu-id="300b3-134">プロパティは、抽象クラスで宣言することができますが、抽象クラスから派生したクラスでのみ設定できます。</span><span class="sxs-lookup"><span data-stu-id="300b3-134">Properties can be declared on an abstract class, but can only be set on practical classes that derive from the abstract class.</span></span> <span data-ttu-id="300b3-135">これは、クラスのパブリックの既定のコンス トラクター クラスのオブジェクトの要素をまったく作成する必要があるためにです。</span><span class="sxs-lookup"><span data-stu-id="300b3-135">This is because creating the object element for the class at all requires a public default constructor on the class.</span></span>  
  
### <a name="typeconverter-enabled-attribute-syntax"></a><span data-ttu-id="300b3-136">TypeConverter 属性構文を有効になっています。</span><span class="sxs-lookup"><span data-stu-id="300b3-136">TypeConverter Enabled Attribute Syntax</span></span>  
 <span data-ttu-id="300b3-137">クラス レベルで専用の属性付きの型コンバーターを指定すると、適用される型変換はその型のインスタンスを作成する必要がある任意のプロパティの属性構文を使用できます。</span><span class="sxs-lookup"><span data-stu-id="300b3-137">If you provide a dedicated, attributed type converter at the class level, the applied type conversion enables attribute syntax for any property that needs to instantiate that type.</span></span> <span data-ttu-id="300b3-138">型コンバーターが、型のオブジェクト要素の使用を有効にしません。その型の既定のコンス トラクターの存在だけでは、オブジェクト要素の使用を有効します。</span><span class="sxs-lookup"><span data-stu-id="300b3-138">A type converter does not enable object element usage of the type; only the presence of a default constructor for that type enables object element usage.</span></span> <span data-ttu-id="300b3-139">そのため、型コンバーターが有効になっているプロパティは、その型自体には、オブジェクト要素構文もサポートしている場合を除き、一般にプロパティの構文では使用できません。</span><span class="sxs-lookup"><span data-stu-id="300b3-139">Therefore, properties that are type-converter enabled are generally speaking not usable in property syntax, unless the type itself also supports object element syntax.</span></span> <span data-ttu-id="300b3-140">この例外は、プロパティ要素構文では、指定しますが、プロパティ要素に文字列を含めることができますです。</span><span class="sxs-lookup"><span data-stu-id="300b3-140">The exception to this is that you can specify a property element syntax, but have the property element contain a string.</span></span> <span data-ttu-id="300b3-141">使用状況は、属性構文の使用に非常に基本的に相当し、属性の値のより堅牢な空白の処理の必要性がない場合は一般的ではありません。</span><span class="sxs-lookup"><span data-stu-id="300b3-141">That usage is really essentially equivalent to an attribute syntax usage, and such a usage is not common unless there is a need for more robust white-space handling of the attribute value.</span></span> <span data-ttu-id="300b3-142">たとえば、次に、文字列を受け取るプロパティ要素による使用と同等の属性の使用。</span><span class="sxs-lookup"><span data-stu-id="300b3-142">For example, the following is a property element usage that takes a string, and the attribute usage equivalent:</span></span>  
  
 [!code-xaml[XamlOvwSupport#GoofyTCPE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofytcpe)]  
  
 [!code-xaml[XamlOvwSupport#GoofyTCPE2](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofytcpe2)]  
  
 <span data-ttu-id="300b3-143">属性の構文が許可されているオブジェクトの要素を含むプロパティ要素構文は XAML で許可されていませんプロパティの例を使用するさまざまなプロパティ、<xref:System.Windows.Input.Cursor>型。</span><span class="sxs-lookup"><span data-stu-id="300b3-143">Examples of properties where attribute syntax is allowed but property element syntax that contains an object element is disallowed through XAML are various properties that take the <xref:System.Windows.Input.Cursor> type.</span></span> <span data-ttu-id="300b3-144"><xref:System.Windows.Input.Cursor>クラスには専用の型コンバーター <xref:System.Windows.Input.CursorConverter>、既定のコンス トラクターを公開しないため、<xref:System.Windows.FrameworkElement.Cursor%2A>プロパティのみ設定できます属性構文で場合でも、実際<xref:System.Windows.Input.Cursor>型は参照型です。</span><span class="sxs-lookup"><span data-stu-id="300b3-144">The <xref:System.Windows.Input.Cursor> class has a dedicated type converter <xref:System.Windows.Input.CursorConverter>, but does not expose a default constructor, so the <xref:System.Windows.FrameworkElement.Cursor%2A> property can only be set through attribute syntax even though the actual <xref:System.Windows.Input.Cursor> type is a reference type.</span></span>  
  
### <a name="per-property-type-converters"></a><span data-ttu-id="300b3-145">プロパティの型コンバーター</span><span class="sxs-lookup"><span data-stu-id="300b3-145">Per-Property Type Converters</span></span>  
 <span data-ttu-id="300b3-146">または、プロパティ自体は、プロパティ レベルでの型コンバーターを宣言できます。</span><span class="sxs-lookup"><span data-stu-id="300b3-146">Alternatively, the property itself may declare a type converter at the property level.</span></span> <span data-ttu-id="300b3-147">これにより、入力として受信する属性の文字列値を処理することによって、プロパティ、インラインでの型のオブジェクトをインスタンス化「ミニ言語」を<xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>操作、適切な型に基づきます。</span><span class="sxs-lookup"><span data-stu-id="300b3-147">This enables a "mini language" that instantiates objects of the type of the property inline, by processing incoming string values of the attribute as input for a <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> operation based on the appropriate type.</span></span> <span data-ttu-id="300b3-148">便利なアクセサーを提供するこれは、通常、XAML でプロパティの設定を有効にする唯一の手段ではありません。</span><span class="sxs-lookup"><span data-stu-id="300b3-148">Typically this is done to provide a convenience accessor, and not as the sole means to enable setting a property in XAML.</span></span> <span data-ttu-id="300b3-149">ただし、既存を使用する属性の型コンバーターを使用することがも[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]既定のコンス トラクターまたは、属性付きの型コンバーターのいずれかを指定しない型です。</span><span class="sxs-lookup"><span data-stu-id="300b3-149">However, it is also possible to use type converters for attributes where you want to use existing [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] types that do not supply either a default constructor or an attributed type converter.</span></span> <span data-ttu-id="300b3-150">例から、 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] API は、特定のプロパティ、<xref:System.Globalization.CultureInfo>型。</span><span class="sxs-lookup"><span data-stu-id="300b3-150">Examples from the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] API are certain properties that take the <xref:System.Globalization.CultureInfo> type.</span></span> <span data-ttu-id="300b3-151">この場合、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]既存の Microsoft .NET Framework を使用する<xref:System.Globalization.CultureInfo>より以前のバージョンのフレームワークを使用した互換性と移行のシナリオに対応する型が、<xref:System.Globalization.CultureInfo>型では、必要ながサポートされていませんでしたコンス トラクターまたは直接 XAML プロパティの値として使用できるようにする型レベルの型変換。</span><span class="sxs-lookup"><span data-stu-id="300b3-151">In this case, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] used the existing Microsoft .NET Framework <xref:System.Globalization.CultureInfo> type to better address compatibility and migration scenarios that were used in earlier versions of frameworks, but the <xref:System.Globalization.CultureInfo> type did not support the necessary constructors or type-level type conversion to be usable as a XAML property value directly.</span></span>  
  
 <span data-ttu-id="300b3-152">XAML の使用状況を持つプロパティを公開するたびにコントロールの作成者がいる場合に特に厳密に検討してください、依存関係プロパティとそのプロパティをバックアップします。</span><span class="sxs-lookup"><span data-stu-id="300b3-152">Whenever you expose a property that has a XAML usage, particularly if you are a control author, you should strongly consider backing that property with a dependency property.</span></span> <span data-ttu-id="300b3-153">これは、既存を使用する場合に特に当てはまります[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]、XAML プロセッサの実装を使用してパフォーマンスを向上させることができますので<xref:System.Windows.DependencyProperty>をバックアップします。</span><span class="sxs-lookup"><span data-stu-id="300b3-153">This is particularly true if you use the existing [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] implementation of the XAML processor, because you can improve performance by using <xref:System.Windows.DependencyProperty> backing.</span></span> <span data-ttu-id="300b3-154">依存関係プロパティには、XAML のアクセス可能なプロパティに対して期待するユーザーが付属、プロパティのプロパティ システムの機能が公開されます。</span><span class="sxs-lookup"><span data-stu-id="300b3-154">A dependency property will expose property system features for your property that users will come to expect for a XAML accessible property.</span></span> <span data-ttu-id="300b3-155">これには、アニメーション、データ バインディング、およびスタイルのサポートなどの機能が含まれます。</span><span class="sxs-lookup"><span data-stu-id="300b3-155">This includes features such as animation, data binding, and style support.</span></span> <span data-ttu-id="300b3-156">詳細については、次を参照してください。[カスタム依存関係プロパティ](custom-dependency-properties.md)と[XAML 読み込みと依存関係プロパティ](xaml-loading-and-dependency-properties.md)します。</span><span class="sxs-lookup"><span data-stu-id="300b3-156">For more information, see [Custom Dependency Properties](custom-dependency-properties.md) and [XAML Loading and Dependency Properties](xaml-loading-and-dependency-properties.md).</span></span>  
  
### <a name="writing-and-attributing-a-type-converter"></a><span data-ttu-id="300b3-157">作成と型コンバーターの割り当て</span><span class="sxs-lookup"><span data-stu-id="300b3-157">Writing and Attributing a Type Converter</span></span>  
 <span data-ttu-id="300b3-158">場合によっては必要がありますにカスタム<xref:System.ComponentModel.TypeConverter>プロパティの型の型変換を提供するクラスを派生します。</span><span class="sxs-lookup"><span data-stu-id="300b3-158">You occasionally will need to write a custom <xref:System.ComponentModel.TypeConverter> derived class to provide type conversion for your property type.</span></span> <span data-ttu-id="300b3-159">派生し、XAML の使用方法をサポートする型コンバーターを作成する方法、および適用する方法についての<xref:System.ComponentModel.TypeConverterAttribute>を参照してください[TypeConverters および XAML](typeconverters-and-xaml.md)します。</span><span class="sxs-lookup"><span data-stu-id="300b3-159">For instructions on how to derive from and create a type converter that can support XAML usages, and how to apply the <xref:System.ComponentModel.TypeConverterAttribute>, see [TypeConverters and XAML](typeconverters-and-xaml.md).</span></span>  
  
<a name="Requirements_for_Events_of_a_Custom_Class_as_XAML"></a>   
## <a name="requirements-for-xaml-event-handler-attribute-syntax-on-events-of-a-custom-class"></a><span data-ttu-id="300b3-160">XAML でカスタム クラスのイベントのイベント ハンドラー属性構文の要件</span><span class="sxs-lookup"><span data-stu-id="300b3-160">Requirements for XAML Event Handler Attribute Syntax on Events of a Custom Class</span></span>  
 <span data-ttu-id="300b3-161">として使用するのには、[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]イベント、イベントが既定のコンス トラクターをサポートするクラスのパブリック イベントとして公開する必要がありますまたはで抽象クラス イベントを派生クラスでアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="300b3-161">To be usable as a [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event, the event must be exposed as a public event on a class that supports a default constructor, or on an abstract class where the event can be accessed on derived classes.</span></span> <span data-ttu-id="300b3-162">ルーティング イベントとして簡単に使用するために、[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]イベントを明示的に実装する必要があります`add`と`remove`メソッドは、追加のハンドラーと削除、[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]イベントのシグネチャ、にこれらのハンドラーを前後<xref:System.Windows.UIElement.AddHandler%2A>と<xref:System.Windows.UIElement.RemoveHandler%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="300b3-162">In order to be used conveniently as a routed event, your [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event should implement explicit `add` and `remove` methods, which add and remove handlers for the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event signature and forward those handlers to the <xref:System.Windows.UIElement.AddHandler%2A> and <xref:System.Windows.UIElement.RemoveHandler%2A> methods.</span></span> <span data-ttu-id="300b3-163">これらのメソッドは、追加またはインスタンスに関連付けられているイベントのルーティング イベント ハンドラー ストアにハンドラーを削除します。</span><span class="sxs-lookup"><span data-stu-id="300b3-163">These methods add or remove the handlers to the routed event handler store on the instance that the event is attached to.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="300b3-164">ハンドラーを使用して、ルーティング イベントを直接登録することは<xref:System.Windows.UIElement.AddHandler%2A>は意図的に定義して、[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]ルーティング イベントを公開するイベントです。</span><span class="sxs-lookup"><span data-stu-id="300b3-164">It is possible to register handlers directly for routed events using <xref:System.Windows.UIElement.AddHandler%2A>, and to deliberately not define a [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event that exposes the routed event.</span></span> <span data-ttu-id="300b3-165">これは一般的に使用しないでイベントにハンドラーをアタッチするための XAML 属性の構文が有効になりませんし、結果として得られるクラスはその型の機能の透明度が減少 XAML ビューを提供するためです。</span><span class="sxs-lookup"><span data-stu-id="300b3-165">This is not generally recommended because the event will not enable XAML attribute syntax for attaching handlers, and your resulting class will offer a less transparent XAML view of that type's capabilities.</span></span>  
  
<a name="Collection_Properties"></a>   
## <a name="writing-collection-properties"></a><span data-ttu-id="300b3-166">コレクション プロパティの作成</span><span class="sxs-lookup"><span data-stu-id="300b3-166">Writing Collection Properties</span></span>  
 <span data-ttu-id="300b3-167">コレクション型を使用するプロパティには、コレクションに追加されるオブジェクトを指定することができる XAML 構文があります。</span><span class="sxs-lookup"><span data-stu-id="300b3-167">Properties that take a collection type have a XAML syntax that enables you to specify objects that are added to the collection.</span></span> <span data-ttu-id="300b3-168">この構文では、2 つの注目すべき機能があります。</span><span class="sxs-lookup"><span data-stu-id="300b3-168">This syntax has two notable features.</span></span>  
  
-   <span data-ttu-id="300b3-169">コレクション オブジェクトであるオブジェクトは、オブジェクト要素構文で指定する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="300b3-169">The object that is the collection object does not need to be specified in object element syntax.</span></span> <span data-ttu-id="300b3-170">コレクション型を受け取る XAML でプロパティを指定するには、そのコレクションの種類の存在は暗黙的です。</span><span class="sxs-lookup"><span data-stu-id="300b3-170">The presence of that collection type is implicit whenever you specify a property in XAML that takes a collection type.</span></span>  
  
-   <span data-ttu-id="300b3-171">マークアップでコレクションのプロパティの子要素は、コレクションのメンバーに処理されます。</span><span class="sxs-lookup"><span data-stu-id="300b3-171">Child elements of the collection property in markup are processed to become members of the collection.</span></span> <span data-ttu-id="300b3-172">通常、コレクションのメンバーにコード アクセスは、リストのディクショナリ/メソッドを通じて実行など`Add`、またはインデクサーを使用します。</span><span class="sxs-lookup"><span data-stu-id="300b3-172">Ordinarily, the code access to the members of a collection is performed through list/dictionary methods such as `Add`, or through an indexer.</span></span> <span data-ttu-id="300b3-173">XAML 構文ではメソッドまたはインデクサーをサポートしていませんが、(例外。XAML 2009 は、メソッドをサポートできますが、可能な WPF の使用法は XAML 2009 を使用して制限されます。参照してください[XAML 2009 言語機能](../../xaml-services/xaml-2009-language-features.md))。</span><span class="sxs-lookup"><span data-stu-id="300b3-173">But XAML syntax does not support methods or indexers (exception: XAML 2009 can support methods, but using XAML 2009 restricts the possible WPF usages; see [XAML 2009 Language Features](../../xaml-services/xaml-2009-language-features.md)).</span></span> <span data-ttu-id="300b3-174">コレクションは、要素のツリーを構築するための非常に一般的な要件と、宣言型の XAML でこれらのコレクションを設定する手段が必要です。</span><span class="sxs-lookup"><span data-stu-id="300b3-174">Collections are obviously a very common requirement for building a tree of elements, and you need some way to populate these collections in declarative XAML.</span></span> <span data-ttu-id="300b3-175">そのため、コレクション プロパティの子要素は、コレクション プロパティの型の値は、コレクションに追加することによって処理されます。</span><span class="sxs-lookup"><span data-stu-id="300b3-175">Therefore, child elements of a collection property are processed by adding them to the collection that is the collection property type value.</span></span>  
  
 <span data-ttu-id="300b3-176">.NET Framework XAML サービス実装および WPF XAML プロセッサは、コレクション プロパティの構成内容を次の定義を使用します。</span><span class="sxs-lookup"><span data-stu-id="300b3-176">The .NET Framework XAML Services implementation and thus the WPF XAML processor uses the following definition for what constitutes a collection property.</span></span> <span data-ttu-id="300b3-177">プロパティのプロパティの型には、次のいずれかを実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="300b3-177">The property type of the property must implement one of the following:</span></span>  
  
-   <span data-ttu-id="300b3-178">実装<xref:System.Collections.IList>します。</span><span class="sxs-lookup"><span data-stu-id="300b3-178">Implements <xref:System.Collections.IList>.</span></span>  
  
-   <span data-ttu-id="300b3-179">実装<xref:System.Collections.IDictionary>または同等のジェネリック (<xref:System.Collections.Generic.IDictionary%602>)。</span><span class="sxs-lookup"><span data-stu-id="300b3-179">Implements <xref:System.Collections.IDictionary> or the generic equivalent (<xref:System.Collections.Generic.IDictionary%602>).</span></span>  
  
-   <span data-ttu-id="300b3-180">派生した<xref:System.Array>(XAML での配列の詳細については、次を参照してください[X:array マークアップ拡張機能](../../xaml-services/x-array-markup-extension.md)。)。</span><span class="sxs-lookup"><span data-stu-id="300b3-180">Derives from <xref:System.Array> (for more information about arrays in XAML, see [x:Array Markup Extension](../../xaml-services/x-array-markup-extension.md).)</span></span>  
  
-   <span data-ttu-id="300b3-181">実装<xref:System.Windows.Markup.IAddChild>(によって定義されたインターフェイス[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)])。</span><span class="sxs-lookup"><span data-stu-id="300b3-181">Implements <xref:System.Windows.Markup.IAddChild> (an interface defined by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]).</span></span>  
  
 <span data-ttu-id="300b3-182">CLR でこれらの型のそれぞれに、`Add`メソッドは、XAML プロセッサによって、オブジェクト グラフを作成するときに、基になるコレクションに項目を追加するために使用します。</span><span class="sxs-lookup"><span data-stu-id="300b3-182">Each of these types in CLR has an `Add` method, which is used by the XAML processor to add items to the underlying collection when creating the object graph.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="300b3-183">ジェネリック`List`と`Dictionary`インターフェイス (<xref:System.Collections.Generic.IList%601>と<xref:System.Collections.Generic.IDictionary%602>) によるコレクションの検出はサポートされていません、 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML プロセッサ。</span><span class="sxs-lookup"><span data-stu-id="300b3-183">The generic `List` and `Dictionary` interfaces (<xref:System.Collections.Generic.IList%601> and <xref:System.Collections.Generic.IDictionary%602>) are not supported for collection detection by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML processor.</span></span> <span data-ttu-id="300b3-184">ただし、使用することができます、<xref:System.Collections.Generic.List%601>クラスの基底クラスとして実装するため、<xref:System.Collections.IList>を直接または<xref:System.Collections.Generic.Dictionary%602>基底クラスとして実装するため、<xref:System.Collections.IDictionary>直接します。</span><span class="sxs-lookup"><span data-stu-id="300b3-184">However, you can use the <xref:System.Collections.Generic.List%601> class as a base class, because it implements <xref:System.Collections.IList> directly, or <xref:System.Collections.Generic.Dictionary%602> as a base class, because it implements <xref:System.Collections.IDictionary> directly.</span></span>  
  
 <span data-ttu-id="300b3-185">コレクションを受け取るプロパティを宣言するときに、そのプロパティ値を型の新しいインスタンスで初期化する方法について注意してください。</span><span class="sxs-lookup"><span data-stu-id="300b3-185">When you declare a property that takes a collection, be cautious about how that property value is initialized in new instances of the type.</span></span> <span data-ttu-id="300b3-186">依存関係プロパティとしてプロパティを実装しない場合、コレクション型のコンス トラクターを呼び出すバッキング フィールドを使用してプロパティを持つは十分です。</span><span class="sxs-lookup"><span data-stu-id="300b3-186">If you are not implementing the property as a dependency property, then having the property use a backing field that calls the collection type constructor is adequate.</span></span> <span data-ttu-id="300b3-187">プロパティが依存関係プロパティの場合は、既定の型コンス トラクターの一部として、コレクション プロパティを初期化する必要があります。</span><span class="sxs-lookup"><span data-stu-id="300b3-187">If your property is a dependency property, then you may need to initialize the collection property as part of the default type constructor.</span></span> <span data-ttu-id="300b3-188">依存関係プロパティは、メタデータから既定値を受け取るし、通常たくない、静的な共有コレクションのコレクション プロパティの初期値であるためにです。</span><span class="sxs-lookup"><span data-stu-id="300b3-188">This is because a dependency property takes its default value from metadata, and you typically do not want the initial value of a collection property to be a static, shared collection.</span></span> <span data-ttu-id="300b3-189">包含型のインスタンスごとにコレクション インスタンスが必要です。</span><span class="sxs-lookup"><span data-stu-id="300b3-189">There should be a collection instance per each containing type instance.</span></span> <span data-ttu-id="300b3-190">詳細については、「[カスタム依存関係プロパティ](custom-dependency-properties.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="300b3-190">For more information, see [Custom Dependency Properties](custom-dependency-properties.md).</span></span>  
  
 <span data-ttu-id="300b3-191">コレクション プロパティには、カスタム コレクション型を実装できます。</span><span class="sxs-lookup"><span data-stu-id="300b3-191">You can implement a custom collection type for your collection property.</span></span> <span data-ttu-id="300b3-192">暗黙の型のコレクション プロパティの処理のため、カスタム コレクション型は XAML で暗黙的に使用するために既定のコンス トラクターを提供するには必要ありません。</span><span class="sxs-lookup"><span data-stu-id="300b3-192">Because of implicit collection property treatment, the custom collection type does not need to provide a default constructor in order to be used in XAML implicitly.</span></span> <span data-ttu-id="300b3-193">ただし、コレクション型の既定のコンス トラクターを必要に応じて指定できます。</span><span class="sxs-lookup"><span data-stu-id="300b3-193">However, you can optionally provide a default constructor for the collection type.</span></span> <span data-ttu-id="300b3-194">これは、価値のあるプラクティスです。</span><span class="sxs-lookup"><span data-stu-id="300b3-194">This can be a worthwhile practice.</span></span> <span data-ttu-id="300b3-195">既定のコンス トラクターを用意する場合を除き、オブジェクト要素としてコレクションを明示的に宣言することはできません。</span><span class="sxs-lookup"><span data-stu-id="300b3-195">Unless you do provide a default constructor, you cannot explicitly declare the collection as an object element.</span></span> <span data-ttu-id="300b3-196">マークアップ スタイルの問題として明示的なコレクションを表示するは、いくつかのマークアップの作成者をお勧めします。</span><span class="sxs-lookup"><span data-stu-id="300b3-196">Some markup authors might prefer to see the explicit collection as a matter of markup style.</span></span> <span data-ttu-id="300b3-197">また、既定のコンス トラクターは、プロパティの値として、コレクション型を使用する新しいオブジェクトを作成するときに、初期化要件を簡略化できます。</span><span class="sxs-lookup"><span data-stu-id="300b3-197">Also, a default constructor can simplify the initialization requirements when you create new objects that use your collection type as a property value.</span></span>  
  
<a name="XAMLCONtent"></a>   
## <a name="declaring-xaml-content-properties"></a><span data-ttu-id="300b3-198">XAML コンテンツ プロパティを宣言します。</span><span class="sxs-lookup"><span data-stu-id="300b3-198">Declaring XAML Content Properties</span></span>  
 <span data-ttu-id="300b3-199">XAML 言語の概念を定義する、[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]コンテンツのプロパティ。</span><span class="sxs-lookup"><span data-stu-id="300b3-199">The XAML language defines the concept of a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] content property.</span></span> <span data-ttu-id="300b3-200">オブジェクト構文で使用可能な各クラスには、1 つの XAML コンテンツ プロパティを持つことができます。</span><span class="sxs-lookup"><span data-stu-id="300b3-200">Each class that is usable in object syntax can have exactly one XAML content property.</span></span> <span data-ttu-id="300b3-201">クラスの XAML コンテンツ プロパティのプロパティを宣言するには、適用、<xref:System.Windows.Markup.ContentPropertyAttribute>クラス定義の一部として。</span><span class="sxs-lookup"><span data-stu-id="300b3-201">To declare a property to be the XAML content property for your class, apply the <xref:System.Windows.Markup.ContentPropertyAttribute> as part of the class definition.</span></span> <span data-ttu-id="300b3-202">として目的の XAML コンテンツ プロパティの名前を指定、<xref:System.Windows.Markup.ContentPropertyAttribute.Name%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="300b3-202">Specify the name of the intended XAML content property as the <xref:System.Windows.Markup.ContentPropertyAttribute.Name%2A> in the attribute.</span></span> <span data-ttu-id="300b3-203">プロパティを文字列として名前で指定した、リフレクション コンストラクトとしてではなくなど<xref:System.Reflection.PropertyInfo>します。</span><span class="sxs-lookup"><span data-stu-id="300b3-203">The property is specified as a string by name, not as a reflection construct such as <xref:System.Reflection.PropertyInfo>.</span></span>  
  
 <span data-ttu-id="300b3-204">XAML コンテンツ プロパティのコレクション プロパティを指定できます。</span><span class="sxs-lookup"><span data-stu-id="300b3-204">You can specify a collection property to be the XAML content property.</span></span> <span data-ttu-id="300b3-205">これにより、オブジェクト要素が介在するコレクション オブジェクトの要素またはプロパティ要素タグなし、1 つまたは複数の子要素が、そのプロパティの使用量。</span><span class="sxs-lookup"><span data-stu-id="300b3-205">This results in a usage for that property whereby the object element can have one or more child elements, without any intervening collection object elements or property element tags.</span></span> <span data-ttu-id="300b3-206">これらの要素は、XAML コンテンツ プロパティの値として扱われ、バッキング コレクションに追加されます。</span><span class="sxs-lookup"><span data-stu-id="300b3-206">These elements are then treated as the value for the XAML content property and added to the backing collection instance.</span></span>  
  
 <span data-ttu-id="300b3-207">いくつかの既存の XAML コンテンツ プロパティのプロパティの型を使用して、`Object`します。</span><span class="sxs-lookup"><span data-stu-id="300b3-207">Some existing XAML content properties use the property type of `Object`.</span></span> <span data-ttu-id="300b3-208">これにより、XAML のコンテンツなどのプリミティブが可能なプロパティ値を<xref:System.String>と 1 つの参照オブジェクトの値を取得します。</span><span class="sxs-lookup"><span data-stu-id="300b3-208">This enables a XAML content property that can take primitive values such as a <xref:System.String> as well as taking a single reference object value.</span></span> <span data-ttu-id="300b3-209">このモデルに従うと場合の種類は型の判定と使用可能な型の処理を担当します。</span><span class="sxs-lookup"><span data-stu-id="300b3-209">If you follow this model, your type is responsible for type determination as well as the handling of possible types.</span></span> <span data-ttu-id="300b3-210">一般的な理由は、<xref:System.Object>コンテンツの種類は、(これが既定のプレゼンテーションの処理を受け取る) を文字列としてオブジェクトのコンテンツの追加の両方を簡単な手段をサポートするまたは高度な手段を追加するオブジェクトの既定以外のプレゼンテーションを指定するコンテンツまたは追加のデータ。</span><span class="sxs-lookup"><span data-stu-id="300b3-210">The typical reason for an <xref:System.Object> content type is to support both a simple means of adding object content as a string (which receives a default presentation treatment), or an advanced means of adding object content that specifies a non-default presentation or additional data.</span></span>  
  
<a name="Serializing"></a>   
## <a name="serializing-xaml"></a><span data-ttu-id="300b3-211">XAML のシリアル化</span><span class="sxs-lookup"><span data-stu-id="300b3-211">Serializing XAML</span></span>  
 <span data-ttu-id="300b3-212">場合など、特定のシナリオがコントロールの作成者は、XAML でインスタンス化できる任意のオブジェクト表現が同等の XAML マークアップにシリアル化もできるようにすることもできます。</span><span class="sxs-lookup"><span data-stu-id="300b3-212">For certain scenarios, such as if you are a control author, you may also want to assure that any object representation that can be instantiated in XAML can also be serialized back to equivalent XAML markup.</span></span> <span data-ttu-id="300b3-213">シリアル化の要件は、このトピックでは説明しません。</span><span class="sxs-lookup"><span data-stu-id="300b3-213">Serialization requirements are not described in this topic.</span></span> <span data-ttu-id="300b3-214">参照してください[概要の作成を管理して](../controls/control-authoring-overview.md)と[要素のツリーおよびシリアル化](element-tree-and-serialization.md)します。</span><span class="sxs-lookup"><span data-stu-id="300b3-214">See [Control Authoring Overview](../controls/control-authoring-overview.md) and [Element Tree and Serialization](element-tree-and-serialization.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="300b3-215">関連項目</span><span class="sxs-lookup"><span data-stu-id="300b3-215">See also</span></span>

- [<span data-ttu-id="300b3-216">XAML の概要 (WPF)</span><span class="sxs-lookup"><span data-stu-id="300b3-216">XAML Overview (WPF)</span></span>](xaml-overview-wpf.md)
- [<span data-ttu-id="300b3-217">カスタム依存関係プロパティ</span><span class="sxs-lookup"><span data-stu-id="300b3-217">Custom Dependency Properties</span></span>](custom-dependency-properties.md)
- [<span data-ttu-id="300b3-218">コントロールの作成の概要</span><span class="sxs-lookup"><span data-stu-id="300b3-218">Control Authoring Overview</span></span>](../controls/control-authoring-overview.md)
- [<span data-ttu-id="300b3-219">基本要素の概要</span><span class="sxs-lookup"><span data-stu-id="300b3-219">Base Elements Overview</span></span>](base-elements-overview.md)
- [<span data-ttu-id="300b3-220">XAML 読み込みと依存関係プロパティ</span><span class="sxs-lookup"><span data-stu-id="300b3-220">XAML Loading and Dependency Properties</span></span>](xaml-loading-and-dependency-properties.md)
