---
title: Win32 と WPF 間でのメッセージ ループの共有
ms.date: 03/30/2017
helpviewer_keywords:
- Win32 code [WPF], sharing message loops
- message loops [WPF]
- sharing message loops [WPF]
- interoperability [WPF], Win32
ms.assetid: 39ee888c-e5ec-41c8-b11f-7b851a554442
ms.openlocfilehash: 35a908cc26e6b70c9acd8732521837f2b20eaf5b
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/04/2018
---
# <a name="sharing-message-loops-between-win32-and-wpf"></a><span data-ttu-id="cfa97-102">Win32 と WPF 間でのメッセージ ループの共有</span><span class="sxs-lookup"><span data-stu-id="cfa97-102">Sharing Message Loops Between Win32 and WPF</span></span>
<span data-ttu-id="cfa97-103">このトピックとの相互運用のメッセージ ループを実装する方法について説明[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]、既存を使用していずれかのメッセージ ループ危険にさらされる<xref:System.Windows.Threading.Dispatcher>または上に個別のメッセージ ループを作成することで、[!INCLUDE[TLA#tla_win32](../../../../includes/tlasharptla-win32-md.md)]面を相互運用コード。</span><span class="sxs-lookup"><span data-stu-id="cfa97-103">This topic describes how to implement a message loop for interoperation with [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], either by using existing message loop exposure in <xref:System.Windows.Threading.Dispatcher> or by creating a separate message loop on the [!INCLUDE[TLA#tla_win32](../../../../includes/tlasharptla-win32-md.md)] side of your interoperation code.</span></span>  
  
## <a name="componentdispatcher-and-the-message-loop"></a><span data-ttu-id="cfa97-104">ComponentDispatcher とメッセージ ループ</span><span class="sxs-lookup"><span data-stu-id="cfa97-104">ComponentDispatcher and the Message Loop</span></span>  
 <span data-ttu-id="cfa97-105">相互運用とキーボード イベントのサポートについては、通常のシナリオは、実装する<xref:System.Windows.Interop.IKeyboardInputSink>、または既にを実装するクラスからサブクラスを作成する<xref:System.Windows.Interop.IKeyboardInputSink>など<xref:System.Windows.Interop.HwndSource>または<xref:System.Windows.Interop.HwndHost>です。</span><span class="sxs-lookup"><span data-stu-id="cfa97-105">A normal scenario for interoperation and keyboard event support is to implement <xref:System.Windows.Interop.IKeyboardInputSink>, or to subclass from classes that already implement <xref:System.Windows.Interop.IKeyboardInputSink>, such as <xref:System.Windows.Interop.HwndSource> or <xref:System.Windows.Interop.HwndHost>.</span></span> <span data-ttu-id="cfa97-106">ただし、キーボード シンクのサポートでは、相互運用の境界を越えてメッセージを送受信するときにする必要がありますすべてのメッセージ ループの要件は対処できません。</span><span class="sxs-lookup"><span data-stu-id="cfa97-106">However, keyboard sink support does not address all possible message loop needs you might have when sending and receiving messages across your interoperation boundaries.</span></span> <span data-ttu-id="cfa97-107">アプリケーション メッセージ ループのアーキテクチャを形式化する[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]提供、<xref:System.Windows.Interop.ComponentDispatcher>クラスは、次に、メッセージ ループの単純なプロトコルを定義します。</span><span class="sxs-lookup"><span data-stu-id="cfa97-107">To help formalize an application message loop architecture, [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] provides the <xref:System.Windows.Interop.ComponentDispatcher> class, which defines a simple protocol for a message loop to follow.</span></span>  
  
 <span data-ttu-id="cfa97-108"><xref:System.Windows.Interop.ComponentDispatcher> いくつかのメンバーを公開する静的クラスです。</span><span class="sxs-lookup"><span data-stu-id="cfa97-108"><xref:System.Windows.Interop.ComponentDispatcher> is a static class that exposes several members.</span></span> <span data-ttu-id="cfa97-109">各メソッドのスコープは暗黙的に呼び出し元のスレッドに関連付けられています。</span><span class="sxs-lookup"><span data-stu-id="cfa97-109">The scope of each method is implicitly tied to the calling thread.</span></span> <span data-ttu-id="cfa97-110">メッセージ ループは、その中の一部を呼び出す必要があります[!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)](として、次のセクションで定義) の重要な時間帯にします。</span><span class="sxs-lookup"><span data-stu-id="cfa97-110">A message loop must call some of those [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] at critical times (as defined in the next section).</span></span>  
  
 <span data-ttu-id="cfa97-111"><xref:System.Windows.Interop.ComponentDispatcher> その他のコンポーネント (など、キーボード シンク) がリッスンできるイベントを提供します。</span><span class="sxs-lookup"><span data-stu-id="cfa97-111"><xref:System.Windows.Interop.ComponentDispatcher> provides events that other components (such as the keyboard sink) can listen for.</span></span> <span data-ttu-id="cfa97-112"><xref:System.Windows.Threading.Dispatcher>クラスの適切なすべての呼び出し<xref:System.Windows.Interop.ComponentDispatcher>適切な順序のメソッドです。</span><span class="sxs-lookup"><span data-stu-id="cfa97-112">The <xref:System.Windows.Threading.Dispatcher> class calls all the appropriate <xref:System.Windows.Interop.ComponentDispatcher> methods in an appropriate sequence.</span></span> <span data-ttu-id="cfa97-113">独自のメッセージ ループを実装している場合は、コードを呼び出す<xref:System.Windows.Interop.ComponentDispatcher>メソッドと同様にします。</span><span class="sxs-lookup"><span data-stu-id="cfa97-113">If you are implementing your own message loop, your code is responsible for calling <xref:System.Windows.Interop.ComponentDispatcher> methods in a similar fashion.</span></span>  
  
 <span data-ttu-id="cfa97-114">呼び出す<xref:System.Windows.Interop.ComponentDispatcher>メソッドのスレッドでそのスレッドで登録されたイベント ハンドラーを呼び出すだけです。</span><span class="sxs-lookup"><span data-stu-id="cfa97-114">Calling <xref:System.Windows.Interop.ComponentDispatcher> methods on a thread will only invoke event handlers that were registered on that thread.</span></span>  
  
## <a name="writing-message-loops"></a><span data-ttu-id="cfa97-115">メッセージ ループの記述</span><span class="sxs-lookup"><span data-stu-id="cfa97-115">Writing Message Loops</span></span>  
 <span data-ttu-id="cfa97-116">次のチェックリストは、<xref:System.Windows.Interop.ComponentDispatcher>独自のメッセージ ループを記述する場合に使用するメンバー。</span><span class="sxs-lookup"><span data-stu-id="cfa97-116">The following is a checklist of <xref:System.Windows.Interop.ComponentDispatcher> members you will use if you write your own message loop:</span></span>  
  
-   <span data-ttu-id="cfa97-117"><xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A>: メッセージ ループは、このスレッドがモーダルであることを示すを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="cfa97-117"><xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A>: your message loop should call this to indicate that the thread is modal.</span></span>  
  
-   <span data-ttu-id="cfa97-118"><xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A>: メッセージ ループには、このスレッドが nonmodal を元に戻すことを示すために呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="cfa97-118"><xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A>:your message loop should call this to indicate that the thread has reverted to nonmodal.</span></span>  
  
-   <span data-ttu-id="cfa97-119"><xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A>: メッセージ ループがあることを示すこのを呼び出す必要があります<xref:System.Windows.Interop.ComponentDispatcher>を発生させる、<xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle>イベント。</span><span class="sxs-lookup"><span data-stu-id="cfa97-119"><xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A>: your message loop should call this to indicate that <xref:System.Windows.Interop.ComponentDispatcher> should raise the <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> event.</span></span> <span data-ttu-id="cfa97-120"><xref:System.Windows.Interop.ComponentDispatcher> 生成しませんが、<xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle>場合<xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A>は`true`を呼び出すメッセージ ループもかまいませんが、<xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A>場合でも<xref:System.Windows.Interop.ComponentDispatcher>モーダルの状態のときに応答できません。</span><span class="sxs-lookup"><span data-stu-id="cfa97-120"><xref:System.Windows.Interop.ComponentDispatcher> will not raise <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> if <xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A> is `true`, but message loops may choose to call <xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A> even if <xref:System.Windows.Interop.ComponentDispatcher> cannot respond to it while in modal state.</span></span>  
  
-   <span data-ttu-id="cfa97-121"><xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A>: メッセージ ループは、新しいメッセージが使用できることを示すためにこれを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="cfa97-121"><xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A>: your message loop should call this to indicate that a new message is available.</span></span> <span data-ttu-id="cfa97-122">戻り値を示しますリスナーがあるかどうか、<xref:System.Windows.Interop.ComponentDispatcher>イベントは、メッセージを処理します。</span><span class="sxs-lookup"><span data-stu-id="cfa97-122">The return value indicates whether a listener to a <xref:System.Windows.Interop.ComponentDispatcher> event handled the message.</span></span> <span data-ttu-id="cfa97-123">場合<xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A>返します`true`(処理)、ディスパッチャーは何もさらに、メッセージを使用します。</span><span class="sxs-lookup"><span data-stu-id="cfa97-123">If <xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A> returns `true` (handled), the dispatcher should do nothing further with the message.</span></span> <span data-ttu-id="cfa97-124">場合は、戻り値は`false`、ディスパッチャーの呼び出しが予期されて、[!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)]関数`TranslateMessage`、まず`DispatchMessage`です。</span><span class="sxs-lookup"><span data-stu-id="cfa97-124">If the return value is `false`, the dispatcher is expected to call the [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] function `TranslateMessage`, then call `DispatchMessage`.</span></span>  
  
## <a name="using-componentdispatcher-and-existing-message-handling"></a><span data-ttu-id="cfa97-125">ComponentDispatcher を使用して、既存のメッセージの処理</span><span class="sxs-lookup"><span data-stu-id="cfa97-125">Using ComponentDispatcher and Existing Message Handling</span></span>  
 <span data-ttu-id="cfa97-126">次のチェックリストは、<xref:System.Windows.Interop.ComponentDispatcher>固有に依存する場合に使用するメンバー[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]メッセージ ループします。</span><span class="sxs-lookup"><span data-stu-id="cfa97-126">The following is a checklist of <xref:System.Windows.Interop.ComponentDispatcher> members you will use if you rely on the inherent [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] message loop.</span></span>  
  
-   <span data-ttu-id="cfa97-127"><xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A>: アプリケーションをモーダルになったかどうかを返します (モーダル メッセージ ループのプッシュなど)。</span><span class="sxs-lookup"><span data-stu-id="cfa97-127"><xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A>: returns whether the application has gone modal (e.g., a modal message loop has been pushed).</span></span> <span data-ttu-id="cfa97-128"><xref:System.Windows.Interop.ComponentDispatcher> クラスの数を保持しているために、この状態を追跡できます<xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A>と<xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A>メッセージ ループからの呼び出しです。</span><span class="sxs-lookup"><span data-stu-id="cfa97-128"><xref:System.Windows.Interop.ComponentDispatcher> can track this state because the class maintains a count of <xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A> and <xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A> calls from the message loop.</span></span>  
  
-   <span data-ttu-id="cfa97-129"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> および<xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage>イベント デリゲートの呼び出しの標準的な規則に従います。</span><span class="sxs-lookup"><span data-stu-id="cfa97-129"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> and <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> events follow the standard rules for delegate invocations.</span></span> <span data-ttu-id="cfa97-130">不特定の順序でデリゲートが呼び出され、処理済みとして、最初の 1 つがメッセージをマークした場合でも、すべてのデリゲートが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="cfa97-130">Delegates are invoked in an unspecified order, and all delegates are invoked even if the first one marks the message as handled.</span></span>  
  
-   <span data-ttu-id="cfa97-131"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle>: アイドル プロセスを実行するには適切で効率的な期間を示します (その他の保留中のメッセージ、スレッドはありません)。</span><span class="sxs-lookup"><span data-stu-id="cfa97-131"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle>: indicates an appropriate and efficient time to do idle processing (there are no other pending messages for the thread).</span></span> <span data-ttu-id="cfa97-132"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> 発生しません。 スレッドがモーダルの場合。</span><span class="sxs-lookup"><span data-stu-id="cfa97-132"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> will not be raised if the thread is modal.</span></span>  
  
-   <span data-ttu-id="cfa97-133"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>: メッセージ ポンプを処理するすべてのメッセージに対して発生します。</span><span class="sxs-lookup"><span data-stu-id="cfa97-133"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>: raised for all messages that the message pump processes.</span></span>  
  
-   <span data-ttu-id="cfa97-134"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage>: 中に処理されていないすべてのメッセージに対して発生<xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>です。</span><span class="sxs-lookup"><span data-stu-id="cfa97-134"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage>: raised for all messages that were not handled during <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>.</span></span>  
  
 <span data-ttu-id="cfa97-135">メッセージと見なされますの後に処理される場合、<xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>イベントまたは<xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage>イベントを`handled`イベント データの参照によって渡されたパラメーターが`true`です。</span><span class="sxs-lookup"><span data-stu-id="cfa97-135">A message is considered handled if after the <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> event or <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> event, the `handled` parameter passed by reference in event data is `true`.</span></span> <span data-ttu-id="cfa97-136">場合、イベント ハンドラーは、メッセージを無視する必要があります`handled`は`true`別のハンドラーが最初にメッセージを処理するため、します。</span><span class="sxs-lookup"><span data-stu-id="cfa97-136">Event handlers should ignore the message if `handled` is `true`, because that means the different handler handled the message first.</span></span> <span data-ttu-id="cfa97-137">両方のイベントをイベント ハンドラーは、メッセージを変更することができます。</span><span class="sxs-lookup"><span data-stu-id="cfa97-137">Event handlers to both events may modify the message.</span></span> <span data-ttu-id="cfa97-138">変更したメッセージと元変更されていないメッセージではなく、ディスパッチャーをディスパッチする必要があります。</span><span class="sxs-lookup"><span data-stu-id="cfa97-138">The dispatcher should dispatch the modified message and not the original unchanged message.</span></span> <span data-ttu-id="cfa97-139"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> すべてのリスナーがアーキテクチャの意図に配信されるトップレベル ウィンドウのみが対象となるメッセージをメッセージに応答コードを呼び出す必要がある HWND を含むことです。</span><span class="sxs-lookup"><span data-stu-id="cfa97-139"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> is delivered to all listeners, but the architectural intention is that only the top-level window containing the HWND at which the messages targeted should invoke code in response to the message.</span></span>  
  
## <a name="how-hwndsource-treats-componentdispatcher-events"></a><span data-ttu-id="cfa97-140">HwndSource が ComponentDispatcher イベントを処理する方法</span><span class="sxs-lookup"><span data-stu-id="cfa97-140">How HwndSource Treats ComponentDispatcher Events</span></span>  
 <span data-ttu-id="cfa97-141">場合、 <xref:System.Windows.Interop.HwndSource> (親のない HWND)、トップレベル ウィンドウが登録されます<xref:System.Windows.Interop.ComponentDispatcher>です。</span><span class="sxs-lookup"><span data-stu-id="cfa97-141">If the <xref:System.Windows.Interop.HwndSource> is a top-level window (no parent HWND), it will register with <xref:System.Windows.Interop.ComponentDispatcher>.</span></span> <span data-ttu-id="cfa97-142">場合<xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage>発生するのメッセージを使用する場合と、<xref:System.Windows.Interop.HwndSource>または、子ウィンドウ<xref:System.Windows.Interop.HwndSource>呼び出しその<xref:System.Windows.Interop.HwndSource.System%23Windows%23Interop%23IKeyboardInputSink%23TranslateAccelerator%2A>、 <xref:System.Windows.Interop.IKeyboardInputSink.TranslateChar%2A>、<xref:System.Windows.Interop.IKeyboardInputSink.OnMnemonic%2A>キーボード シンクのシーケンス。</span><span class="sxs-lookup"><span data-stu-id="cfa97-142">If <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> is raised, and if the message is intended for the <xref:System.Windows.Interop.HwndSource> or child windows, <xref:System.Windows.Interop.HwndSource> calls its <xref:System.Windows.Interop.HwndSource.System%23Windows%23Interop%23IKeyboardInputSink%23TranslateAccelerator%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.TranslateChar%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.OnMnemonic%2A> keyboard sink sequence.</span></span>  
  
 <span data-ttu-id="cfa97-143">場合、<xref:System.Windows.Interop.HwndSource>トップレベル ウィンドウ (HWND である親を持つ) は行われません処理ではありません。</span><span class="sxs-lookup"><span data-stu-id="cfa97-143">If the <xref:System.Windows.Interop.HwndSource> is not a top-level window (has a parent HWND), there will be no handling.</span></span> <span data-ttu-id="cfa97-144">トップ レベル ウィンドウのみが、処理を行う必要がありますはどのような相互運用のシナリオの一部として上位レベルのウィンドウのキーボード シンクのサポートを有効にする必要.</span><span class="sxs-lookup"><span data-stu-id="cfa97-144">Only the top level window is expected to do the handling, and there is expected to be a top level window with keyboard sink support as part of any interoperation scenario.</span></span>  
  
 <span data-ttu-id="cfa97-145">場合<xref:System.Windows.Interop.HwndHost.WndProc%2A>上、<xref:System.Windows.Interop.HwndSource>が呼び出された最初に呼び出される適切なキーボード シンク メソッドを使用しないで、アプリケーションは、イベントを受信より高いレベルのキーボードなど<xref:System.Windows.UIElement.KeyDown>です。</span><span class="sxs-lookup"><span data-stu-id="cfa97-145">If <xref:System.Windows.Interop.HwndHost.WndProc%2A> on an <xref:System.Windows.Interop.HwndSource> is called without an appropriate keyboard sink method being called first, your application will receive the higher level keyboard events such as <xref:System.Windows.UIElement.KeyDown>.</span></span> <span data-ttu-id="cfa97-146">ただし、キーボード シンク メソッドは呼び出されません、アクセス キーのサポートなどの適切なキーボード入力モデル機能を回避します。</span><span class="sxs-lookup"><span data-stu-id="cfa97-146">However, no keyboard sink methods will be called, which circumvents desirable keyboard input model features such as access key support.</span></span> <span data-ttu-id="cfa97-147">これは、メッセージ ループでは正常に関連するスレッド上に通知されないしなかったために発生する可能性があります、 <xref:System.Windows.Interop.ComponentDispatcher>、または親 HWND が適切なキーボード シンク応答を呼び出せませんでした。</span><span class="sxs-lookup"><span data-stu-id="cfa97-147">This might happen because the message loop did not properly notify the relevant thread on the <xref:System.Windows.Interop.ComponentDispatcher>, or because the parent HWND did not invoke the proper keyboard sink responses.</span></span>  
  
 <span data-ttu-id="cfa97-148">使用してそのメッセージのフック関数を追加した場合、キーボード シンクに移動するメッセージを HWND を送信できません可能性があります、<xref:System.Windows.Interop.HwndSource.AddHook%2A>メソッドです。</span><span class="sxs-lookup"><span data-stu-id="cfa97-148">A message that goes to the keyboard sink might not be sent to the HWND if you added hooks for that message by using the <xref:System.Windows.Interop.HwndSource.AddHook%2A> method.</span></span> <span data-ttu-id="cfa97-149">直接および not に送信されるメッセージ ポンプ レベルでメッセージが処理される可能性がありますが、`DispatchMessage`関数。</span><span class="sxs-lookup"><span data-stu-id="cfa97-149">The message might have been handled at the message pump level directly and not submitted to the `DispatchMessage` function.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="cfa97-150">関連項目</span><span class="sxs-lookup"><span data-stu-id="cfa97-150">See Also</span></span>  
 <xref:System.Windows.Interop.ComponentDispatcher>  
 <xref:System.Windows.Interop.IKeyboardInputSink>  
 [<span data-ttu-id="cfa97-151">WPF と Win32 の相互運用性</span><span class="sxs-lookup"><span data-stu-id="cfa97-151">WPF and Win32 Interoperation</span></span>](../../../../docs/framework/wpf/advanced/wpf-and-win32-interoperation.md)  
 [<span data-ttu-id="cfa97-152">スレッド モデル</span><span class="sxs-lookup"><span data-stu-id="cfa97-152">Threading Model</span></span>](../../../../docs/framework/wpf/advanced/threading-model.md)  
 [<span data-ttu-id="cfa97-153">入力の概要</span><span class="sxs-lookup"><span data-stu-id="cfa97-153">Input Overview</span></span>](../../../../docs/framework/wpf/advanced/input-overview.md)
