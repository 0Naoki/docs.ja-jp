---
title: "WPF XAML 名前スコープ"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-wpf
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- namescopes [WPF]
- styles [WPF], namescopes in
- templates [WPF], namescopes in
- APIs [WPF], name-related
- name-related APIs
- XAML [WPF], namescopes
- classes [WPF], FrameworkContentElement
ms.assetid: 52bbf4f2-15fc-40d4-837b-bb4c21ead7d4
caps.latest.revision: "19"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.openlocfilehash: 22b0354a0821021239140527793dc34e3911a733
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/21/2017
---
# <a name="wpf-xaml-namescopes"></a><span data-ttu-id="b4451-102">WPF XAML 名前スコープ</span><span class="sxs-lookup"><span data-stu-id="b4451-102">WPF XAML Namescopes</span></span>
<span data-ttu-id="b4451-103">XAML 名前スコープを識別する概念のオブジェクトを XAML で定義されています。</span><span class="sxs-lookup"><span data-stu-id="b4451-103">XAML namescopes are a concept that identifies objects that are defined in XAML.</span></span> <span data-ttu-id="b4451-104">XAML 名前スコープ内の名前は、オブジェクト ツリー内のオブジェクトの XAML で定義された名前と、対応するインスタンス間のリレーションシップを確立するために使用できます。</span><span class="sxs-lookup"><span data-stu-id="b4451-104">The names in a XAML namescope can be used to establish relationships between the XAML-defined names of objects and their instance equivalents in an object tree.</span></span> <span data-ttu-id="b4451-105">XAML 名前スコープ通常、 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML アプリケーションのルート個々 の XAML ページを読み込むときに、マネージ コードは作成されます。</span><span class="sxs-lookup"><span data-stu-id="b4451-105">Typically, XAML namescopes in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] managed code are created when loading the individual XAML page roots for a XAML application.</span></span> <span data-ttu-id="b4451-106">プログラミング オブジェクトとしての XAML 名前スコープが定義されている、<xref:System.Windows.Markup.INameScope>インターフェイスし、実際のクラスによって実装されても<xref:System.Windows.NameScope>します。</span><span class="sxs-lookup"><span data-stu-id="b4451-106">XAML namescopes as the programming object are defined by the <xref:System.Windows.Markup.INameScope> interface and are also implemented by the practical class <xref:System.Windows.NameScope>.</span></span>  
  
  
  
<a name="Namescopes_in_Loaded_XAML_Applications"></a>   
## <a name="namescopes-in-loaded-xaml-applications"></a><span data-ttu-id="b4451-107">読み込まれた XAML アプリケーションにおける名前スコープ</span><span class="sxs-lookup"><span data-stu-id="b4451-107">Namescopes in Loaded XAML Applications</span></span>  
 <span data-ttu-id="b4451-108">広範なプログラミングまたはコンピューター サイエンスのコンテキストでは、プログラミングの概念が含まれる場合、一意の識別子またはオブジェクトにアクセスするために使用する名前の原則。</span><span class="sxs-lookup"><span data-stu-id="b4451-108">In a broader programming or computer science context, programming concepts often include the principle of a unique identifier or name that can be used to access an object.</span></span> <span data-ttu-id="b4451-109">内の境界を定義する名前スコープ識別子や名前を使用するシステムでは、その名前のオブジェクトが要求されている場合、プロセスや方法は検索するまたは識別名の一意性が強制されますの境界。</span><span class="sxs-lookup"><span data-stu-id="b4451-109">For systems that use identifiers or names, the namescope defines the boundaries within which a process or technique will search if an object of that name is requested, or the boundaries wherein uniqueness of identifying names is enforced.</span></span> <span data-ttu-id="b4451-110">次の一般原則は、XAML 名前スコープの場合は true です。</span><span class="sxs-lookup"><span data-stu-id="b4451-110">These general principles are true for XAML namescopes.</span></span> <span data-ttu-id="b4451-111">XAML 名前スコープは、WPF では、ページが読み込まれるときに、XAML ページのルート要素に作成されます。</span><span class="sxs-lookup"><span data-stu-id="b4451-111">In WPF, XAML namescopes are created on the root element for a XAML page when the page is loaded.</span></span> <span data-ttu-id="b4451-112">ページのルートから始まる XAML ページ内で指定した名前は、適切な XAML 名前スコープに追加されます。</span><span class="sxs-lookup"><span data-stu-id="b4451-112">Each name specified within the XAML page starting at the page root is added to a pertinent XAML namescope.</span></span>  
  
 <span data-ttu-id="b4451-113">WPF xaml で共通のルート要素である要素 (など<xref:System.Windows.Controls.Page>、および<xref:System.Windows.Window>) 常に XAML 名前スコープを制御します。</span><span class="sxs-lookup"><span data-stu-id="b4451-113">In WPF XAML, elements that are common root elements (such as <xref:System.Windows.Controls.Page>, and <xref:System.Windows.Window>) always control a XAML namescope.</span></span> <span data-ttu-id="b4451-114">場合など、要素<xref:System.Windows.FrameworkElement>または<xref:System.Windows.FrameworkContentElement>マークアップでは、ページのルート要素には、[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]プロセッサを追加、<xref:System.Windows.Controls.Page>暗黙的にルートように、<xref:System.Windows.Controls.Page>作業用の XAML 名前スコープを指定できます。</span><span class="sxs-lookup"><span data-stu-id="b4451-114">If an element such as <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement> is the root element of the page in markup, a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] processor adds a <xref:System.Windows.Controls.Page> root implicitly so that the <xref:System.Windows.Controls.Page> can provide a working XAML namescope.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b4451-115">WPF ビルド アクションがない場合でも、XAML 稼働環境の XAML 名前スコープを作成`Name`または`x:Name`内にある要素の属性が定義されている、[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]マークアップ。</span><span class="sxs-lookup"><span data-stu-id="b4451-115">WPF build actions create a XAML namescope for a XAML production even if no `Name` or `x:Name` attributes are defined on any elements in the [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] markup.</span></span>  
  
 <span data-ttu-id="b4451-116">XAML 名前スコープで 2 回、同じ名前を使用しようとすると、例外が発生します。</span><span class="sxs-lookup"><span data-stu-id="b4451-116">If you try to use the same name twice in any XAML namescope, an exception is raised.</span></span> <span data-ttu-id="b4451-117">分離コードがあり、コンパイルされたアプリケーションの一部を WPF xaml で例外はビルド時に、WPF ビルド アクションによって、初期のマークアップのコンパイル時に、ページに対して生成されたクラスを作成するときに発生します。</span><span class="sxs-lookup"><span data-stu-id="b4451-117">For WPF XAML that has code-behind and is part of a compiled application, the exception is raised at build time by WPF build actions, when creating the generated class for the page during the initial markup compile.</span></span> <span data-ttu-id="b4451-118">されていない XAML をマークアップ コンパイルされたすべてのビルド アクションによって、XAML が読み込まれるときに XAML 名前スコープの問題に関連する例外を発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="b4451-118">For XAML that is not markup-compiled by any build action, exceptions related to XAML namescope issues might be raised when the XAML is loaded.</span></span> <span data-ttu-id="b4451-119">XAML デザイナーでは、デザイン時に XAML 名前スコープの問題も予測可能性があります。</span><span class="sxs-lookup"><span data-stu-id="b4451-119">XAML designers might also anticipate XAML namescope issues at design time.</span></span>  
  
### <a name="adding-objects-to-runtime-object-trees"></a><span data-ttu-id="b4451-120">オブジェクトをランタイム オブジェクト ツリーに追加します。</span><span class="sxs-lookup"><span data-stu-id="b4451-120">Adding Objects to Runtime Object Trees</span></span>  
 <span data-ttu-id="b4451-121">XAML が解析した時点では、WPF XAML 名前スコープが作成され、定義の時点を表します。</span><span class="sxs-lookup"><span data-stu-id="b4451-121">The moment that XAML is parsed represents the moment in time that a WPF XAML namescope is created and defined.</span></span> <span data-ttu-id="b4451-122">オブジェクトをオブジェクト ツリーの時点にそのツリーが生成される XAML が解析された後で追加した場合、`Name`または`x:Name`新しいオブジェクトの値が XAML 名前スコープ内の情報を自動的に更新されません。</span><span class="sxs-lookup"><span data-stu-id="b4451-122">If you add an object to an object tree at a point in time after the XAML that produced that tree was parsed, a `Name` or `x:Name` value on the new object does not automatically update the information in a XAML namescope.</span></span> <span data-ttu-id="b4451-123">XAML が読み込まれた後に、WPF XAML 名前スコープにオブジェクトの名前を追加するには、適切な実装を呼び出す必要があります<xref:System.Windows.Markup.INameScope.RegisterName%2A>XAML 名前スコープを定義するオブジェクトのルートである通常 XAML ページ。</span><span class="sxs-lookup"><span data-stu-id="b4451-123">To add a name for an object into a WPF XAML namescope after XAML is loaded, you must call the appropriate implementation of <xref:System.Windows.Markup.INameScope.RegisterName%2A> on the object that defines the XAML namescope, which is typically the XAML page root.</span></span> <span data-ttu-id="b4451-124">名前が登録されていない場合、追加するオブジェクトで参照できません名前メソッドによってなど<xref:System.Windows.FrameworkElement.FindName%2A>、およびアニメーションのターゲットの名前を使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="b4451-124">If the name is not registered, the added object cannot be referenced by name through methods such as <xref:System.Windows.FrameworkElement.FindName%2A>, and you cannot use that name for animation targeting.</span></span>  
  
 <span data-ttu-id="b4451-125">アプリケーション開発者向けの最も一般的なシナリオは、使用する<xref:System.Windows.FrameworkElement.RegisterName%2A>ページの現在のルートに XAML 名前スコープに名前を登録します。</span><span class="sxs-lookup"><span data-stu-id="b4451-125">The most common scenario for application developers is that you will use <xref:System.Windows.FrameworkElement.RegisterName%2A> to register names into the XAML namescope on the current root of the page.</span></span> <span data-ttu-id="b4451-126"><xref:System.Windows.FrameworkElement.RegisterName%2A>ストーリー ボードの重要なシナリオの一部のアニメーションでそのターゲット オブジェクトです。</span><span class="sxs-lookup"><span data-stu-id="b4451-126"><xref:System.Windows.FrameworkElement.RegisterName%2A> is part of an important scenario for storyboards that target objects for animations.</span></span> <span data-ttu-id="b4451-127">詳細については、次を参照してください。[ストーリー ボードの概要](../../../../docs/framework/wpf/graphics-multimedia/storyboards-overview.md)です。</span><span class="sxs-lookup"><span data-stu-id="b4451-127">For more information, see [Storyboards Overview](../../../../docs/framework/wpf/graphics-multimedia/storyboards-overview.md).</span></span>  
  
 <span data-ttu-id="b4451-128">呼び出す場合<xref:System.Windows.FrameworkElement.RegisterName%2A>XAML 名前スコープを定義するオブジェクト以外のオブジェクト、名前はまだ登録内で、呼び出し元のオブジェクトが保持されている XAML 名前スコープに呼び出したいた場合と<xref:System.Windows.FrameworkElement.RegisterName%2A>オブジェクトを定義する XAML 名前スコープにします。</span><span class="sxs-lookup"><span data-stu-id="b4451-128">If you call <xref:System.Windows.FrameworkElement.RegisterName%2A> on an object other than the object that defines the XAML namescope, the name is still registered to the XAML namescope that the calling object is held within, as if you had called <xref:System.Windows.FrameworkElement.RegisterName%2A> on the XAML namescope defining object.</span></span>  
  
### <a name="xaml-namescopes-in-code"></a><span data-ttu-id="b4451-129">コード内の XAML 名前スコープ</span><span class="sxs-lookup"><span data-stu-id="b4451-129">XAML Namescopes in Code</span></span>  
 <span data-ttu-id="b4451-130">作成し、コード内の XAML 名前スコープを使用できます。</span><span class="sxs-lookup"><span data-stu-id="b4451-130">You can create and then use XAML namescopes in code.</span></span> <span data-ttu-id="b4451-131">Api と XAML 名前スコープの作成に関連する概念は、純粋なコードの使用状況、に対しても同じため、XAML プロセッサに対して[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]XAML 自体を処理するときに、これらの Api と概念を使用します。</span><span class="sxs-lookup"><span data-stu-id="b4451-131">The APIs and the concepts involved in XAML namescope creation are the same even for a pure code usage, because the XAML processor for [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uses these APIs and concepts when it processes XAML itself.</span></span> <span data-ttu-id="b4451-132">概念と API は、XAML では部分的または完全は定義された通常のオブジェクト ツリー内で名前によってオブジェクトを検索できないために主に存在します。</span><span class="sxs-lookup"><span data-stu-id="b4451-132">The concepts and API exist mainly for the purpose of being able to find objects by name within an object tree that is typically defined partially or entirely in XAML.</span></span>  
  
 <span data-ttu-id="b4451-133">XAML 名前スコープを定義するオブジェクトを実装する必要があります、プログラムによって作成されたアプリケーションと読み込まれた XAML からではなく、 <xref:System.Windows.Markup.INameScope>、または、<xref:System.Windows.FrameworkElement>または<xref:System.Windows.FrameworkContentElement>で XAML 名前スコープの作成をサポートするために派生したクラス、そのインスタンス。</span><span class="sxs-lookup"><span data-stu-id="b4451-133">For applications that are created programmatically, and not from loaded XAML, the object that defines a XAML namescope must implement <xref:System.Windows.Markup.INameScope>, or be a <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement> derived class, in order to support creation of a XAML namescope on its instances.</span></span>  
  
 <span data-ttu-id="b4451-134">また、読み込みおよび XAML プロセッサで処理されないを任意の要素のオブジェクトの XAML 名前スコープは作成または既定で初期化します。</span><span class="sxs-lookup"><span data-stu-id="b4451-134">Also, for any element that is not loaded and processed by a XAML processor, the XAML namescope for the object is not created or initialized by default.</span></span> <span data-ttu-id="b4451-135">明示的に名前を後で登録するその他のオブジェクトの新しい XAML 名前スコープを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b4451-135">You must explicitly create a new XAML namescope for any object that you intend to register names into subsequently.</span></span> <span data-ttu-id="b4451-136">XAML 名前スコープを作成するには、静的なを呼び出す<xref:System.Windows.NameScope.SetNameScope%2A>メソッドです。</span><span class="sxs-lookup"><span data-stu-id="b4451-136">To create a XAML namescope, you call the static <xref:System.Windows.NameScope.SetNameScope%2A> method.</span></span> <span data-ttu-id="b4451-137">としてそれを所有するオブジェクトを指定して、`dependencyObject`パラメーター、および新しい<xref:System.Windows.NameScope.%23ctor%2A>としてコンス トラクターの呼び出し、`value`パラメーター。</span><span class="sxs-lookup"><span data-stu-id="b4451-137">Specify the object that will own it as the `dependencyObject` parameter, and a new <xref:System.Windows.NameScope.%23ctor%2A> constructor call as the `value` parameter.</span></span>  
  
 <span data-ttu-id="b4451-138">オブジェクト設定されている場合`dependencyObject`の<xref:System.Windows.NameScope.SetNameScope%2A>されませんが、<xref:System.Windows.Markup.INameScope>実装では、<xref:System.Windows.FrameworkElement>または<xref:System.Windows.FrameworkContentElement>、呼び出し元<xref:System.Windows.FrameworkElement.RegisterName%2A>で任意の子要素は効果がありません。</span><span class="sxs-lookup"><span data-stu-id="b4451-138">If the object provided as `dependencyObject` for <xref:System.Windows.NameScope.SetNameScope%2A> is not a <xref:System.Windows.Markup.INameScope> implementation, <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>, calling <xref:System.Windows.FrameworkElement.RegisterName%2A> on any child elements will have no effect.</span></span> <span data-ttu-id="b4451-139">新しい XAML 名前スコープを明示的に作成に失敗した場合、呼び出し<xref:System.Windows.FrameworkElement.RegisterName%2A>で例外が発生します。</span><span class="sxs-lookup"><span data-stu-id="b4451-139">If you fail to create the new XAML namescope explicitly, then calls to <xref:System.Windows.FrameworkElement.RegisterName%2A> will raise an exception.</span></span>  
  
 <span data-ttu-id="b4451-140">コード内の XAML 名前スコープの Api を使用しての例は、次を参照してください。[名前スコープを定義する](../../../../docs/framework/wpf/graphics-multimedia/how-to-define-a-name-scope.md)です。</span><span class="sxs-lookup"><span data-stu-id="b4451-140">For an example of using XAML namescope APIs in code, see [Define a Name Scope](../../../../docs/framework/wpf/graphics-multimedia/how-to-define-a-name-scope.md).</span></span>  
  
<a name="Namescopes_in_Styles_and_Templates"></a>   
## <a name="xaml-namescopes-in-styles-and-templates"></a><span data-ttu-id="b4451-141">スタイルとテンプレートで XAML 名前スコープ</span><span class="sxs-lookup"><span data-stu-id="b4451-141">XAML Namescopes in Styles and Templates</span></span>  
 <span data-ttu-id="b4451-142">スタイルおよびテンプレート[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]を再利用し、簡単な方法でコンテンツを再適用する機能を提供します。</span><span class="sxs-lookup"><span data-stu-id="b4451-142">Styles and templates in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] provide the ability to reuse and reapply content in a straightforward way.</span></span> <span data-ttu-id="b4451-143">ただし、スタイルとテンプレートを含めることも要素テンプレート レベルで定義された XAML 名前。</span><span class="sxs-lookup"><span data-stu-id="b4451-143">However, styles and templates might also include elements with XAML names defined at the template level.</span></span> <span data-ttu-id="b4451-144">同じテンプレートをページに複数回使用可能性があります。</span><span class="sxs-lookup"><span data-stu-id="b4451-144">That same template might be used multiple times in a page.</span></span> <span data-ttu-id="b4451-145">このため、スタイルおよびテンプレート スタイルまたはテンプレートの適用先のオブジェクト ツリーの任意の場所の独立した独自の XAML 名前スコープを定義します。</span><span class="sxs-lookup"><span data-stu-id="b4451-145">For this reason, styles and templates both define their own XAML namescopes, independent of whatever location in an object tree where the style or template is applied.</span></span>  
  
 <span data-ttu-id="b4451-146">次に例を示します。</span><span class="sxs-lookup"><span data-stu-id="b4451-146">Consider the following example:</span></span>  
  
 [!code-xaml[XamlOvwSupport#NameScopeTemplates](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page6.xaml#namescopetemplates)]  
  
 <span data-ttu-id="b4451-147">ここでは、同じテンプレートは、2 つの異なるボタンに適用されます。</span><span class="sxs-lookup"><span data-stu-id="b4451-147">Here, the same template is applied to two different buttons.</span></span> <span data-ttu-id="b4451-148">テンプレートは、不連続の XAML 名前スコープを持っていなかった場合、`TheBorder`テンプレートで使用される名前は XAML 名前スコープで、名前の競合が発生します。</span><span class="sxs-lookup"><span data-stu-id="b4451-148">If templates did not have discrete XAML namescopes, the `TheBorder` name used in the template would cause a name collision in the XAML namescope.</span></span> <span data-ttu-id="b4451-149">テンプレートの各インスタンスは、ため、この例の場合、各インスタンス化されたテンプレートの XAML 名前スコープに、名を正確に 1 つ含まれます、独自の XAML 名前スコープを持ちます。</span><span class="sxs-lookup"><span data-stu-id="b4451-149">Each instantiation of the template has its own XAML namescope, so in this example each instantiated template's XAML namescope would contain exactly one name.</span></span>  
  
 <span data-ttu-id="b4451-150">スタイルは、ストーリー ボードの一部が割り当てられている特定の名前を持つことができますようにほとんどの場合も、独自の XAML 名前スコープを定義します。</span><span class="sxs-lookup"><span data-stu-id="b4451-150">Styles also define their own XAML namescope, mostly so that parts of storyboards can have particular names assigned.</span></span> <span data-ttu-id="b4451-151">これらの名前では、テンプレートをコントロールのカスタマイズの一部として再定義した場合でも、その名前を持つ要素が対象とするコントロール固有の動作が有効にします。</span><span class="sxs-lookup"><span data-stu-id="b4451-151">These names enable control specific behaviors that will target elements of that name, even if the template was re-defined as part of control customization.</span></span>  
  
 <span data-ttu-id="b4451-152">により、別の XAML 名前スコープ、テンプレートの名前付きの要素を検索するは、テンプレート化されていない名前を持つページ内の要素を検索するよりも難しいです。</span><span class="sxs-lookup"><span data-stu-id="b4451-152">Because of the separate XAML namescopes, finding named elements in a template is more challenging than finding a non-templated named element in a page.</span></span> <span data-ttu-id="b4451-153">取得することによって、テンプレートを適用したを決定する必要があります最初、<xref:System.Windows.Controls.Control.Template%2A>テンプレートが適用されているコントロールのプロパティの値。</span><span class="sxs-lookup"><span data-stu-id="b4451-153">You first need to determine the applied template, by getting the <xref:System.Windows.Controls.Control.Template%2A> property value of the control where the template is applied.</span></span> <span data-ttu-id="b4451-154">その後のテンプレート バージョンを呼び出す<xref:System.Windows.FrameworkTemplate.FindName%2A>テンプレートが 2 番目のパラメーターとして適用された、制御を渡すことです。</span><span class="sxs-lookup"><span data-stu-id="b4451-154">Then, you call the template version of <xref:System.Windows.FrameworkTemplate.FindName%2A>, passing the control where the template was applied as the second parameter.</span></span>  
  
 <span data-ttu-id="b4451-155">コントロールの作成者は、コントロール自体で定義されている動作の対象を特定のテンプレートを適用した内の要素をという名前がここでは、規則を生成している場合を使えば、<xref:System.Windows.FrameworkElement.GetTemplateChild%2A>コントロール実装コードからメソッドです。</span><span class="sxs-lookup"><span data-stu-id="b4451-155">If you are a control author and you are generating a convention where a particular named element in an applied template is the target for a behavior that is defined by the control itself, you can use the <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> method from your control implementation code.</span></span> <span data-ttu-id="b4451-156"><xref:System.Windows.FrameworkElement.GetTemplateChild%2A>のみコントロールの作成者へのアクセス権を持つメソッドは保護されています。</span><span class="sxs-lookup"><span data-stu-id="b4451-156">The <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> method is protected, so only the control author has access to it.</span></span>  
  
 <span data-ttu-id="b4451-157">テンプレート、および、テンプレートが適用されている XAML 名前スコープを取得する必要があります内で作業する場合の値を取得<xref:System.Windows.FrameworkElement.TemplatedParent%2A>、まず<xref:System.Windows.FrameworkElement.FindName%2A>があります。</span><span class="sxs-lookup"><span data-stu-id="b4451-157">If you are working from within a template, and need to get to the XAML namescope where the template is applied, get the value of <xref:System.Windows.FrameworkElement.TemplatedParent%2A>, and then call <xref:System.Windows.FrameworkElement.FindName%2A> there.</span></span> <span data-ttu-id="b4451-158">テンプレート内での作業の例になりますイベント ハンドラーの実装を記述するかどうか、適用されたテンプレート内の要素からイベントを発生させる場所。</span><span class="sxs-lookup"><span data-stu-id="b4451-158">An example of working within the template would be if you are writing the event handler implementation where the event will be raised from an element in an applied template.</span></span>  
  
<a name="Namescopes_and_Name_related_APIs"></a>   
## <a name="xaml-namescopes-and-name-related-apis"></a><span data-ttu-id="b4451-159">XAML 名前空間と名前に関連する Api</span><span class="sxs-lookup"><span data-stu-id="b4451-159">XAML Namescopes and Name-related APIs</span></span>  
 <span data-ttu-id="b4451-160"><xref:System.Windows.FrameworkElement><xref:System.Windows.FrameworkElement.FindName%2A>、<xref:System.Windows.FrameworkElement.RegisterName%2A>と<xref:System.Windows.FrameworkElement.UnregisterName%2A>メソッドです。</span><span class="sxs-lookup"><span data-stu-id="b4451-160"><xref:System.Windows.FrameworkElement> has <xref:System.Windows.FrameworkElement.FindName%2A>, <xref:System.Windows.FrameworkElement.RegisterName%2A> and <xref:System.Windows.FrameworkElement.UnregisterName%2A> methods.</span></span> <span data-ttu-id="b4451-161">これらのメソッドを呼び出すオブジェクトに、XAML 名前空間が所有している場合、メソッドは、関連する XAML 名前スコープのメソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="b4451-161">If the object you call these methods on owns a XAML namescope, the methods call into the methods of the relevant XAML namescope.</span></span> <span data-ttu-id="b4451-162">それ以外の場合、親要素がオンになって、XAML 名前空間を所有するいると、XAML 名前空間が見つかるまでこのプロセスは、再帰的に (動作のために、XAML プロセッサ、存在が保証されるルートにある XAML 名前スコープ)。</span><span class="sxs-lookup"><span data-stu-id="b4451-162">Otherwise, the parent element is checked to see if it owns a XAML namescope, and this process continues recursively until a XAML namescope is found (because of the XAML processor behavior, there is guaranteed to be a XAML namescope at the root).</span></span> <span data-ttu-id="b4451-163"><xref:System.Windows.FrameworkContentElement>例外が、類似の動作がありますをありません<xref:System.Windows.FrameworkContentElement>XAML 名前スコープを所有することです。</span><span class="sxs-lookup"><span data-stu-id="b4451-163"><xref:System.Windows.FrameworkContentElement> has analogous behaviors, with the exception that no <xref:System.Windows.FrameworkContentElement> will ever own a XAML namescope.</span></span> <span data-ttu-id="b4451-164">メソッドが上に存在<xref:System.Windows.FrameworkContentElement>呼び出しを最終的に転送できるように、<xref:System.Windows.FrameworkElement>親要素です。</span><span class="sxs-lookup"><span data-stu-id="b4451-164">The methods exist on <xref:System.Windows.FrameworkContentElement> so that the calls can be forwarded eventually to a <xref:System.Windows.FrameworkElement> parent element.</span></span>  
  
 <span data-ttu-id="b4451-165"><xref:System.Windows.NameScope.SetNameScope%2A>既存のオブジェクトに新しい XAML 名前スコープをマップに使用されます。</span><span class="sxs-lookup"><span data-stu-id="b4451-165"><xref:System.Windows.NameScope.SetNameScope%2A> is used to map a new XAML namescope to an existing object.</span></span> <span data-ttu-id="b4451-166">呼び出すことができます<xref:System.Windows.NameScope.SetNameScope%2A>も複数回リセットまたは XAML をオフにするためにスコープがするではありません一般的な使用方法です。</span><span class="sxs-lookup"><span data-stu-id="b4451-166">You can call <xref:System.Windows.NameScope.SetNameScope%2A> more than once in order to reset or clear the XAML namescope, but that is not a common usage.</span></span> <span data-ttu-id="b4451-167">また、<xref:System.Windows.NameScope.GetNameScope%2A>コードからは通常使用されません。</span><span class="sxs-lookup"><span data-stu-id="b4451-167">Also, <xref:System.Windows.NameScope.GetNameScope%2A> is not typically used from code.</span></span>  
  
### <a name="xaml-namescope-implementations"></a><span data-ttu-id="b4451-168">XAML 名前スコープの実装</span><span class="sxs-lookup"><span data-stu-id="b4451-168">XAML Namescope Implementations</span></span>  
 <span data-ttu-id="b4451-169">次のクラスを実装<xref:System.Windows.Markup.INameScope>直接。</span><span class="sxs-lookup"><span data-stu-id="b4451-169">The following classes implement <xref:System.Windows.Markup.INameScope> directly:</span></span>  
  
-   <xref:System.Windows.NameScope>  
  
-   <xref:System.Windows.Style>  
  
-   <xref:System.Windows.ResourceDictionary>  
  
-   <xref:System.Windows.FrameworkTemplate>  
  
 <span data-ttu-id="b4451-170"><xref:System.Windows.ResourceDictionary>XAML の名前や名前スコープ; を使用しません。使用してキー代わりに、ディクショナリの実装になっているためです。</span><span class="sxs-lookup"><span data-stu-id="b4451-170"><xref:System.Windows.ResourceDictionary> does not use XAML names or namescopes ; it uses keys instead, because it is a dictionary implementation.</span></span> <span data-ttu-id="b4451-171">唯一の理由<xref:System.Windows.ResourceDictionary>実装<xref:System.Windows.Markup.INameScope>true XAML 名前スコープの違いをわかりやすくユーザー コードに例外が発生にできるようにする方法とは、<xref:System.Windows.ResourceDictionary>キーを処理および XAML 名前スコープに適用されなかったことを確実にも、<xref:System.Windows.ResourceDictionary>親要素です。</span><span class="sxs-lookup"><span data-stu-id="b4451-171">The only reason that <xref:System.Windows.ResourceDictionary> implements <xref:System.Windows.Markup.INameScope> is so it can raise exceptions to user code that help clarify the distinction between a true XAML namescope and how a <xref:System.Windows.ResourceDictionary> handles keys, and also to assure that XAML namescopes are not applied to a <xref:System.Windows.ResourceDictionary> by parent elements.</span></span>  
  
 <span data-ttu-id="b4451-172"><xref:System.Windows.FrameworkTemplate>および<xref:System.Windows.Style>実装<xref:System.Windows.Markup.INameScope>明示的なインターフェイスの定義を使用します。</span><span class="sxs-lookup"><span data-stu-id="b4451-172"><xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style> implement <xref:System.Windows.Markup.INameScope> through explicit interface definitions.</span></span> <span data-ttu-id="b4451-173">明示的な実装を介してアクセスされるときに通常の動作にこれらの XAML 名前スコープを許可する、<xref:System.Windows.Markup.INameScope>インターフェイスは XAML 名前スコープが伝達される方法で[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]内部プロセスです。</span><span class="sxs-lookup"><span data-stu-id="b4451-173">The explicit implementations allow these XAML namescopes to behave conventionally when they are accessed through the <xref:System.Windows.Markup.INameScope> interface, which is how XAML namescopes are communicated by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] internal processes.</span></span> <span data-ttu-id="b4451-174">明示的なインターフェイスの定義がの従来の API サーフェイスの一部ではないが、<xref:System.Windows.FrameworkTemplate>と<xref:System.Windows.Style>頻度の低いを呼び出す必要があるため、<xref:System.Windows.Markup.INameScope>メソッド<xref:System.Windows.FrameworkTemplate>と<xref:System.Windows.Style>はその他の API を使用して直接、または代わりにように<xref:System.Windows.FrameworkElement.GetTemplateChild%2A>です。</span><span class="sxs-lookup"><span data-stu-id="b4451-174">But the explicit interface definitions are not part of the conventional API surface of <xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style>, because you seldom need to call the <xref:System.Windows.Markup.INameScope> methods on <xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style> directly, and instead would use other API such as <xref:System.Windows.FrameworkElement.GetTemplateChild%2A>.</span></span>  
  
 <span data-ttu-id="b4451-175">次のクラスを使用して、独自の XAML 名前スコープを定義する、<xref:System.Windows.NameScope?displayProperty=nameWithType>ヘルパー クラスおよびその XAML 名前スコープの実装を通じてへの接続、<xref:System.Windows.NameScope.NameScope%2A?displayProperty=nameWithType>添付プロパティ。</span><span class="sxs-lookup"><span data-stu-id="b4451-175">The following classes define their own XAML namescope, by using the <xref:System.Windows.NameScope?displayProperty=nameWithType> helper class and connecting to its XAML namescope implementation through the <xref:System.Windows.NameScope.NameScope%2A?displayProperty=nameWithType> attached property:</span></span>  
  
-   <xref:System.Windows.FrameworkElement>  
  
-   <xref:System.Windows.FrameworkContentElement>  
  
## <a name="see-also"></a><span data-ttu-id="b4451-176">関連項目</span><span class="sxs-lookup"><span data-stu-id="b4451-176">See Also</span></span>  
 [<span data-ttu-id="b4451-177">XAML 名前空間および WPF XAML の名前空間の割り当て</span><span class="sxs-lookup"><span data-stu-id="b4451-177">XAML Namespaces and Namespace Mapping for WPF XAML</span></span>](../../../../docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)  
 [<span data-ttu-id="b4451-178">x:Name ディレクティブ</span><span class="sxs-lookup"><span data-stu-id="b4451-178">x:Name Directive</span></span>](../../../../docs/framework/xaml-services/x-name-directive.md)
