---
title: 読み取り専用の依存関係プロパティ
ms.date: 03/30/2017
helpviewer_keywords:
- dependency properties [WPF], read-only
- read-only dependency properties [WPF]
ms.assetid: f23d6ec9-3780-4c09-a2ff-b2f0a2deddf1
ms.openlocfilehash: aa6893b100311ead74f610dd20f327d130dff74a
ms.sourcegitcommit: 24a4a8eb6d8cfe7b8549fb6d823076d7c697e0c6
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 07/23/2019
ms.locfileid: "68401655"
---
# <a name="read-only-dependency-properties"></a><span data-ttu-id="8a39d-102">読み取り専用の依存関係プロパティ</span><span class="sxs-lookup"><span data-stu-id="8a39d-102">Read-Only Dependency Properties</span></span>
<span data-ttu-id="8a39d-103">このトピックでは、既存の読み取り専用の依存関係プロパティ、カスタムの読み取り専用の依存関係プロパティを作成するシナリオと手法など、読み取り専用の依存関係プロパティについて説明します。</span><span class="sxs-lookup"><span data-stu-id="8a39d-103">This topic describes read-only dependency properties, including existing read-only dependency properties and the scenarios and techniques for creating a custom read-only dependency property.</span></span>  

<a name="prerequisites"></a>   
## <a name="prerequisites"></a><span data-ttu-id="8a39d-104">必須コンポーネント</span><span class="sxs-lookup"><span data-stu-id="8a39d-104">Prerequisites</span></span>  
 <span data-ttu-id="8a39d-105">このトピックでは、依存関係プロパティの実装の基本シナリオとカスタム依存関係プロパティへのメタデータの適用方法を理解していることを前提とします。</span><span class="sxs-lookup"><span data-stu-id="8a39d-105">This topic assumes that you understand the basic scenarios of implementing a dependency property, and how metadata is applied to a custom dependency property.</span></span> <span data-ttu-id="8a39d-106">詳細については、「[カスタム依存関係プロパティ](custom-dependency-properties.md)」および「[依存関係プロパティのメタデータ](dependency-property-metadata.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8a39d-106">See [Custom Dependency Properties](custom-dependency-properties.md) and [Dependency Property Metadata](dependency-property-metadata.md) for context.</span></span>  
  
<a name="existing"></a>   
## <a name="existing-read-only-dependency-properties"></a><span data-ttu-id="8a39d-107">既存の読み取り専用の依存関係プロパティ</span><span class="sxs-lookup"><span data-stu-id="8a39d-107">Existing Read-Only Dependency Properties</span></span>  
 <span data-ttu-id="8a39d-108">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] フレームワークで定義されている依存関係プロパティの一部は読み取り専用です。</span><span class="sxs-lookup"><span data-stu-id="8a39d-108">Some of the dependency properties defined in the [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] framework are read-only.</span></span> <span data-ttu-id="8a39d-109">読み取り専用の依存関係プロパティを指定する一般的な理由は、それらが状態決定に使用されるプロパティであるにも関わらず、その状態は多くの要因の影響を受け、プロパティをその状態に設定するだけではユーザー インターフェイス設計の観点から望ましくないことにあります。</span><span class="sxs-lookup"><span data-stu-id="8a39d-109">The typical reason for specifying a read-only dependency property is that these are properties that should be used for state determination, but where that state is influenced by a multitude of factors, but just setting the property to that state isn't desirable from a user interface design perspective.</span></span> <span data-ttu-id="8a39d-110">たとえば、プロパティ<xref:System.Windows.UIElement.IsMouseOver%2A>は、実際にはマウス入力から判断された状態を示しているだけです。</span><span class="sxs-lookup"><span data-stu-id="8a39d-110">For example, the property <xref:System.Windows.UIElement.IsMouseOver%2A> is really just surfacing state as determined from the mouse input.</span></span> <span data-ttu-id="8a39d-111">実際にマウス入力を行わずにプログラムでこの値を設定しようとすると、予期しない結果になり、不整合が生じる原因になります。</span><span class="sxs-lookup"><span data-stu-id="8a39d-111">Any attempt to set this value programmatically by circumventing the true mouse input would be unpredictable and would cause inconsistency.</span></span>  
  
 <span data-ttu-id="8a39d-112">設定可能ではないため、読み取り専用の依存関係プロパティは、依存関係プロパティがソリューションを通常提供するシナリオの多くには適切ではありません (データ バインディング、直接スタイル設定可能な値、検証、アニメーション、継承など)。</span><span class="sxs-lookup"><span data-stu-id="8a39d-112">By virtue of not being settable, read-only dependency properties aren't appropriate for many of the scenarios for which dependency properties normally offer a solution (namely: data binding, directly stylable to a value, validation, animation, inheritance).</span></span> <span data-ttu-id="8a39d-113">それでも、設定不可能な読み取り専用依存関係プロパティには、プロパティ システムの依存関係プロパティによってサポートされるいくつかの追加機能があります。</span><span class="sxs-lookup"><span data-stu-id="8a39d-113">Despite not being settable, read-only dependency properties still have some of the additional capabilities supported by dependency properties in the property system.</span></span> <span data-ttu-id="8a39d-114">その他の機能のうち最も重要なのは、読み取り専用の依存関係プロパティはスタイルのプロパティ トリガーとして使用できることです。</span><span class="sxs-lookup"><span data-stu-id="8a39d-114">The most important remaining capability is that the read-only dependency property can still be used as a property trigger in a style.</span></span> <span data-ttu-id="8a39d-115">通常の共通言語ランタイム (CLR) プロパティを使用してトリガーを有効にすることはできません。依存関係プロパティである必要があります。</span><span class="sxs-lookup"><span data-stu-id="8a39d-115">You can't enable triggers with a normal common language runtime (CLR) property; it needs to be a dependency property.</span></span> <span data-ttu-id="8a39d-116">前述<xref:System.Windows.UIElement.IsMouseOver%2A>のプロパティは、コントロールのスタイルを定義するのに非常に便利なシナリオの完全な例です。ここでは、複合要素の背景、前景、類似のプロパティなど、コントロールは、ユーザーがコントロールの定義済みの領域の上にマウスを置いたときに変更されます。</span><span class="sxs-lookup"><span data-stu-id="8a39d-116">The aforementioned <xref:System.Windows.UIElement.IsMouseOver%2A> property is a perfect example of a scenario where it might be quite useful to define a style for a control, where some visible property such as a background, foreground, or similar properties of composited elements within the control will change when the user places a mouse over some defined region of your control.</span></span> <span data-ttu-id="8a39d-117">読み取り専用の依存関係プロパティの変化は、プロパティ システム固有の無効化プロセスによって検出して報告することもでき、これは実際にはプロパティ トリガー機能を内部的にサポートします。</span><span class="sxs-lookup"><span data-stu-id="8a39d-117">Changes in a read-only dependency property can also be detected and reported by the property system's inherent invalidation processes, and this in fact supports the property trigger functionality internally.</span></span>  
  
<a name="new"></a>   
## <a name="creating-custom-read-only-dependency-properties"></a><span data-ttu-id="8a39d-118">読み取り専用のカスタム依存関係プロパティの作成</span><span class="sxs-lookup"><span data-stu-id="8a39d-118">Creating Custom Read-Only Dependency Properties</span></span>  
 <span data-ttu-id="8a39d-119">多くの一般的な依存関係プロパティのシナリオで読み取り専用依存関係プロパティが機能しない理由に関する前のセクションを参照してください。</span><span class="sxs-lookup"><span data-stu-id="8a39d-119">Make sure to read the section above regarding why read-only dependency properties won't work for many typical dependency-property scenarios.</span></span> <span data-ttu-id="8a39d-120">ただし、適切なシナリオがある場合は、独自の読み取り専用依存関係プロパティを作成してもかまいません。</span><span class="sxs-lookup"><span data-stu-id="8a39d-120">But if you have an appropriate scenario, you may wish to create your own read-only dependency property.</span></span>  
  
 <span data-ttu-id="8a39d-121">読み取り専用の依存関係プロパティを作成するプロセスの大部分は、「[カスタム依存関係プロパティ](custom-dependency-properties.md)」と「[依存関係プロパティの実装](how-to-implement-a-dependency-property.md)」のトピックの説明と同じです。</span><span class="sxs-lookup"><span data-stu-id="8a39d-121">Much of the process of creating a read-only dependency property is the same as is described in the [Custom Dependency Properties](custom-dependency-properties.md) and [Implement a Dependency Property](how-to-implement-a-dependency-property.md) topics.</span></span> <span data-ttu-id="8a39d-122">ただし、次の 3 つの重要な違いがあります。</span><span class="sxs-lookup"><span data-stu-id="8a39d-122">There are three important differences:</span></span>  
  
- <span data-ttu-id="8a39d-123">プロパティを登録するときに、 <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A>プロパティの登録に通常<xref:System.Windows.DependencyProperty.Register%2A>のメソッドの代わりにメソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="8a39d-123">When registering your property, call the <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> method instead of the normal <xref:System.Windows.DependencyProperty.Register%2A> method for property registration.</span></span>  
  
- <span data-ttu-id="8a39d-124">CLR "ラッパー" プロパティを実装する場合は、ラッパーに set 実装が含まれていないことを確認してください。これにより、公開するパブリックラッパーの読み取り専用状態に矛盾が生じないようにします。</span><span class="sxs-lookup"><span data-stu-id="8a39d-124">When implementing the CLR "wrapper" property, make sure that the wrapper too doesn't have a set implementation, so that there is no inconsistency in read-only state for the public wrapper you expose.</span></span>  
  
- <span data-ttu-id="8a39d-125">読み取り専用の登録によって返されるオブジェクト<xref:System.Windows.DependencyPropertyKey>は<xref:System.Windows.DependencyProperty>ではなくです。</span><span class="sxs-lookup"><span data-stu-id="8a39d-125">The object returned by the read-only registration is <xref:System.Windows.DependencyPropertyKey> rather than <xref:System.Windows.DependencyProperty>.</span></span> <span data-ttu-id="8a39d-126">やはりこのフィールドをメンバーとして格納する必要がありますが、通常は、型のパブリック メンバーにはしません。</span><span class="sxs-lookup"><span data-stu-id="8a39d-126">You should still store this field as a member but typically you would not make it a public member of the type.</span></span>  
  
 <span data-ttu-id="8a39d-127">読み取り専用の依存関係プロパティを補足するために使用するプライベートのフィールドまたは値はすべて、適当なロジックを使用して完全に書き込み可能にしてかまいません。</span><span class="sxs-lookup"><span data-stu-id="8a39d-127">Whatever private field or value you have backing your read-only dependency property can of course be fully writable using whatever logic you decide.</span></span> <span data-ttu-id="8a39d-128">ただし、最初に、またはランタイムロジックの一部としてプロパティを設定する最も簡単な方法は、プロパティシステムを回避し、プライベートバッキングフィールドを直接設定するのではなく、プロパティシステムの Api を使用することです。</span><span class="sxs-lookup"><span data-stu-id="8a39d-128">However, the most straightforward way to set the property either initially or as part of runtime logic is to use the property system's APIs, rather than circumventing the property system and setting the private backing field directly.</span></span> <span data-ttu-id="8a39d-129">特に、型<xref:System.Windows.DependencyObject.SetValue%2A> <xref:System.Windows.DependencyPropertyKey>のパラメーターを受け取るのシグネチャがあります。</span><span class="sxs-lookup"><span data-stu-id="8a39d-129">In particular, there is a signature of <xref:System.Windows.DependencyObject.SetValue%2A> that accepts a parameter of type <xref:System.Windows.DependencyPropertyKey>.</span></span> <span data-ttu-id="8a39d-130">アプリケーションロジック内でプログラムを使用してこの値を設定する方法と場所は、依存関係プロパティを<xref:System.Windows.DependencyPropertyKey>最初に登録したときに作成されたに対するアクセスを設定する方法に影響します。</span><span class="sxs-lookup"><span data-stu-id="8a39d-130">How and where you set this value programmatically within your application logic will affect how you may wish to set access on the <xref:System.Windows.DependencyPropertyKey> created when you first registered the dependency property.</span></span> <span data-ttu-id="8a39d-131">このロジックすべてをクラス内で処理する場合はプライベートにでき、アセンブリの他の部分から設定する必要がある場合は内部に設定します。</span><span class="sxs-lookup"><span data-stu-id="8a39d-131">If you handle this logic all within the class you could make it private, or if you require it to be set from other portions of the assembly you might set it internal.</span></span> <span data-ttu-id="8a39d-132">1つの方法と<xref:System.Windows.DependencyObject.SetValue%2A>して、格納されているプロパティ値を変更する必要があることをクラスインスタンスに通知する、関連するイベントのクラスイベントハンドラー内でを呼び出す方法があります。</span><span class="sxs-lookup"><span data-stu-id="8a39d-132">One approach is to call <xref:System.Windows.DependencyObject.SetValue%2A> within a class event handler of a relevant event that informs a class instance that the stored property value needs to be changed.</span></span> <span data-ttu-id="8a39d-133">もう1つの方法は、登録時にこれら<xref:System.Windows.PropertyChangedCallback>の<xref:System.Windows.CoerceValueCallback>プロパティのメタデータの一部としてペアとコールバックを使用して、依存関係プロパティを関連付けることです。</span><span class="sxs-lookup"><span data-stu-id="8a39d-133">Another approach is to tie dependency properties together by using paired <xref:System.Windows.PropertyChangedCallback> and <xref:System.Windows.CoerceValueCallback> callbacks as part of those properties' metadata during registration.</span></span>  
  
 <span data-ttu-id="8a39d-134"><xref:System.Windows.DependencyPropertyKey>はプライベートであり、コードの外部のプロパティシステムによって伝達されないため、読み取り専用の依存関係プロパティには、読み取り/書き込み依存関係プロパティよりもセキュリティを設定する方が適しています。</span><span class="sxs-lookup"><span data-stu-id="8a39d-134">Because the <xref:System.Windows.DependencyPropertyKey> is private, and is not propagated by the property system outside of your code, a read-only dependency property does have better setting security than a read-write dependency property.</span></span> <span data-ttu-id="8a39d-135">読み取り/書き込み依存関係プロパティの場合は、識別するフィールドは明示的または暗黙的にパブリックであり、したがってプロパティは広範に設定可能です。</span><span class="sxs-lookup"><span data-stu-id="8a39d-135">For a read-write dependency property, the identifying field is explicitly or implicitly public and thus the property is widely settable.</span></span> <span data-ttu-id="8a39d-136">詳細については、「[依存関係プロパティのセキュリティ](dependency-property-security.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8a39d-136">For more specifics, see [Dependency Property Security](dependency-property-security.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="8a39d-137">関連項目</span><span class="sxs-lookup"><span data-stu-id="8a39d-137">See also</span></span>

- [<span data-ttu-id="8a39d-138">依存関係プロパティの概要</span><span class="sxs-lookup"><span data-stu-id="8a39d-138">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="8a39d-139">カスタム依存関係プロパティ</span><span class="sxs-lookup"><span data-stu-id="8a39d-139">Custom Dependency Properties</span></span>](custom-dependency-properties.md)
- [<span data-ttu-id="8a39d-140">スタイルとテンプレート</span><span class="sxs-lookup"><span data-stu-id="8a39d-140">Styling and Templating</span></span>](../controls/styling-and-templating.md)
