---
title: "読み取り専用の依存関係プロパティ"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-wpf
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- dependency properties [WPF], read-only
- read-only dependency properties [WPF]
ms.assetid: f23d6ec9-3780-4c09-a2ff-b2f0a2deddf1
caps.latest.revision: "8"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.workload: dotnet
ms.openlocfilehash: 31e4080416d5eb4fdfe5c33ec2b65e1dced6d012
ms.sourcegitcommit: 16186c34a957fdd52e5db7294f291f7530ac9d24
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/22/2017
---
# <a name="read-only-dependency-properties"></a><span data-ttu-id="2a074-102">読み取り専用の依存関係プロパティ</span><span class="sxs-lookup"><span data-stu-id="2a074-102">Read-Only Dependency Properties</span></span>
<span data-ttu-id="2a074-103">このトピックでは、既存の読み取り専用の依存関係プロパティ、カスタムの読み取り専用の依存関係プロパティを作成するシナリオと手法など、読み取り専用の依存関係プロパティについて説明します。</span><span class="sxs-lookup"><span data-stu-id="2a074-103">This topic describes read-only dependency properties, including existing read-only dependency properties and the scenarios and techniques for creating a custom read-only dependency property.</span></span>  
  

  
<a name="prerequisites"></a>   
## <a name="prerequisites"></a><span data-ttu-id="2a074-104">必須コンポーネント</span><span class="sxs-lookup"><span data-stu-id="2a074-104">Prerequisites</span></span>  
 <span data-ttu-id="2a074-105">このトピックでは、依存関係プロパティの実装の基本シナリオとカスタム依存関係プロパティへのメタデータの適用方法を理解していることを前提とします。</span><span class="sxs-lookup"><span data-stu-id="2a074-105">This topic assumes that you understand the basic scenarios of implementing a dependency property, and how metadata is applied to a custom dependency property.</span></span> <span data-ttu-id="2a074-106">詳細については、「[カスタム依存関係プロパティ](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md)」および「[依存関係プロパティのメタデータ](../../../../docs/framework/wpf/advanced/dependency-property-metadata.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="2a074-106">See [Custom Dependency Properties](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md) and [Dependency Property Metadata](../../../../docs/framework/wpf/advanced/dependency-property-metadata.md) for context.</span></span>  
  
<a name="existing"></a>   
## <a name="existing-read-only-dependency-properties"></a><span data-ttu-id="2a074-107">既存の読み取り専用の依存関係プロパティ</span><span class="sxs-lookup"><span data-stu-id="2a074-107">Existing Read-Only Dependency Properties</span></span>  
 <span data-ttu-id="2a074-108">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] フレームワークで定義されている依存関係プロパティの一部は読み取り専用です。</span><span class="sxs-lookup"><span data-stu-id="2a074-108">Some of the dependency properties defined in the [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] framework are read-only.</span></span> <span data-ttu-id="2a074-109">読み取り専用の依存関係プロパティを指定する一般的な理由は、それらが状態決定に使用されるプロパティであるにも関わらず、その状態は多くの要因の影響を受け、プロパティをその状態に設定するだけではユーザー インターフェイス設計の観点から望ましくないことにあります。</span><span class="sxs-lookup"><span data-stu-id="2a074-109">The typical reason for specifying a read-only dependency property is that these are properties that should be used for state determination, but where that state is influenced by a multitude of factors, but just setting the property to that state isn't desirable from a user interface design perspective.</span></span> <span data-ttu-id="2a074-110">たとえば、このプロパティ<xref:System.Windows.UIElement.IsMouseOver%2A>マウス入力から決定された状態の表示が実際には。</span><span class="sxs-lookup"><span data-stu-id="2a074-110">For example, the property <xref:System.Windows.UIElement.IsMouseOver%2A> is really just surfacing state as determined from the mouse input.</span></span> <span data-ttu-id="2a074-111">実際にマウス入力を行わずにプログラムでこの値を設定しようとすると、予期しない結果になり、不整合が生じる原因になります。</span><span class="sxs-lookup"><span data-stu-id="2a074-111">Any attempt to set this value programmatically by circumventing the true mouse input would be unpredictable and would cause inconsistency.</span></span>  
  
 <span data-ttu-id="2a074-112">設定可能ではないため、読み取り専用の依存関係プロパティは、依存関係プロパティがソリューションを通常提供するシナリオの多くには適切ではありません (データ バインディング、直接スタイル設定可能な値、検証、アニメーション、継承など)。</span><span class="sxs-lookup"><span data-stu-id="2a074-112">By virtue of not being settable, read-only dependency properties aren't appropriate for many of the scenarios for which dependency properties normally offer a solution (namely: data binding, directly stylable to a value, validation, animation, inheritance).</span></span> <span data-ttu-id="2a074-113">それでも、設定不可能な読み取り専用依存関係プロパティには、プロパティ システムの依存関係プロパティによってサポートされるいくつかの追加機能があります。</span><span class="sxs-lookup"><span data-stu-id="2a074-113">Despite not being settable, read-only dependency properties still have some of the additional capabilities supported by dependency properties in the property system.</span></span> <span data-ttu-id="2a074-114">その他の機能のうち最も重要なのは、読み取り専用の依存関係プロパティはスタイルのプロパティ トリガーとして使用できることです。</span><span class="sxs-lookup"><span data-stu-id="2a074-114">The most important remaining capability is that the read-only dependency property can still be used as a property trigger in a style.</span></span> <span data-ttu-id="2a074-115">通常の [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] プロパティではトリガーを有効にできません。依存関係プロパティであることが必要です。</span><span class="sxs-lookup"><span data-stu-id="2a074-115">You can't enable triggers with a normal [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] property; it needs to be a dependency property.</span></span> <span data-ttu-id="2a074-116">前述<xref:System.Windows.UIElement.IsMouseOver%2A>プロパティ場合がありますをいくつかのコントロールのスタイルを定義するのには、非常に役にシナリオの完全な例は、背景、前景、内の合成要素のようなプロパティなどの visible プロパティ、ユーザーがコントロールのいくつかの定義済みの領域の上にマウスを置いたときに、コントロールが変更されます。</span><span class="sxs-lookup"><span data-stu-id="2a074-116">The aforementioned <xref:System.Windows.UIElement.IsMouseOver%2A> property is a perfect example of a scenario where it might be quite useful to define a style for a control, where some visible property such as a background, foreground, or similar properties of composited elements within the control will change when the user places a mouse over some defined region of your control.</span></span> <span data-ttu-id="2a074-117">読み取り専用の依存関係プロパティの変化は、プロパティ システム固有の無効化プロセスによって検出して報告することもでき、これは実際にはプロパティ トリガー機能を内部的にサポートします。</span><span class="sxs-lookup"><span data-stu-id="2a074-117">Changes in a read-only dependency property can also be detected and reported by the property system's inherent invalidation processes, and this in fact supports the property trigger functionality internally.</span></span>  
  
<a name="new"></a>   
## <a name="creating-custom-read-only-dependency-properties"></a><span data-ttu-id="2a074-118">読み取り専用のカスタム依存関係プロパティの作成</span><span class="sxs-lookup"><span data-stu-id="2a074-118">Creating Custom Read-Only Dependency Properties</span></span>  
 <span data-ttu-id="2a074-119">多くの一般的な依存関係プロパティのシナリオで読み取り専用依存関係プロパティが機能しない理由に関する前のセクションを参照してください。</span><span class="sxs-lookup"><span data-stu-id="2a074-119">Make sure to read the section above regarding why read-only dependency properties won't work for many typical dependency-property scenarios.</span></span> <span data-ttu-id="2a074-120">ただし、適切なシナリオがある場合は、独自の読み取り専用依存関係プロパティを作成してもかまいません。</span><span class="sxs-lookup"><span data-stu-id="2a074-120">But if you have an appropriate scenario, you may wish to create your own read-only dependency property.</span></span>  
  
 <span data-ttu-id="2a074-121">読み取り専用の依存関係プロパティを作成するプロセスの大部分は、「[カスタム依存関係プロパティ](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md)」と「[依存関係プロパティの実装](../../../../docs/framework/wpf/advanced/how-to-implement-a-dependency-property.md)」のトピックの説明と同じです。</span><span class="sxs-lookup"><span data-stu-id="2a074-121">Much of the process of creating a read-only dependency property is the same as is described in the [Custom Dependency Properties](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md) and [Implement a Dependency Property](../../../../docs/framework/wpf/advanced/how-to-implement-a-dependency-property.md) topics.</span></span> <span data-ttu-id="2a074-122">ただし、次の 3 つの重要な違いがあります。</span><span class="sxs-lookup"><span data-stu-id="2a074-122">There are three important differences:</span></span>  
  
-   <span data-ttu-id="2a074-123">プロパティを登録するときに呼び出す、<xref:System.Windows.DependencyProperty.RegisterReadOnly%2A>メソッド、標準ではなく<xref:System.Windows.DependencyProperty.Register%2A>プロパティの登録の方法です。</span><span class="sxs-lookup"><span data-stu-id="2a074-123">When registering your property, call the <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> method instead of the normal <xref:System.Windows.DependencyProperty.Register%2A> method for property registration.</span></span>  
  
-   <span data-ttu-id="2a074-124">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] の "ラッパー" プロパティを実装するときは、ラッパーにも set 実装をしないようにして、公開するパブリック ラッパーの読み取り専用状態が矛盾しないようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="2a074-124">When implementing the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] "wrapper" property, make sure that the wrapper too doesn't have a set implementation, so that there is no inconsistency in read-only state for the public wrapper you expose.</span></span>  
  
-   <span data-ttu-id="2a074-125">読み取り専用登録によって返されるオブジェクトは<xref:System.Windows.DependencyPropertyKey>なく<xref:System.Windows.DependencyProperty>です。</span><span class="sxs-lookup"><span data-stu-id="2a074-125">The object returned by the read-only registration is <xref:System.Windows.DependencyPropertyKey> rather than <xref:System.Windows.DependencyProperty>.</span></span> <span data-ttu-id="2a074-126">やはりこのフィールドをメンバーとして格納する必要がありますが、通常は、型のパブリック メンバーにはしません。</span><span class="sxs-lookup"><span data-stu-id="2a074-126">You should still store this field as a member but typically you would not make it a public member of the type.</span></span>  
  
 <span data-ttu-id="2a074-127">読み取り専用の依存関係プロパティを補足するために使用するプライベートのフィールドまたは値はすべて、適当なロジックを使用して完全に書き込み可能にしてかまいません。</span><span class="sxs-lookup"><span data-stu-id="2a074-127">Whatever private field or value you have backing your read-only dependency property can of course be fully writable using whatever logic you decide.</span></span> <span data-ttu-id="2a074-128">ただし、初期化で、またはランタイム ロジックの一部として、プロパティを設定する最も簡単な方法は、プロパティ システムを使用しないでプライベートなバッキング フィールドを直接設定するのではなく、プロパティ システムの [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] を使用する方法です。</span><span class="sxs-lookup"><span data-stu-id="2a074-128">However, the most straightforward way to set the property either initially or as part of runtime logic is to use the property system's [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)], rather than circumventing the property system and setting the private backing field directly.</span></span> <span data-ttu-id="2a074-129">具体的には、署名がある<xref:System.Windows.DependencyObject.SetValue%2A>型のパラメーターを受け入れる<xref:System.Windows.DependencyPropertyKey>です。</span><span class="sxs-lookup"><span data-stu-id="2a074-129">In particular, there is a signature of <xref:System.Windows.DependencyObject.SetValue%2A> that accepts a parameter of type <xref:System.Windows.DependencyPropertyKey>.</span></span> <span data-ttu-id="2a074-130">この値、アプリケーション ロジック内で、プログラムによって設定方法と場所に影響を与える方法に対してアクセスを設定する場合、<xref:System.Windows.DependencyPropertyKey>依存関係プロパティを最初に登録するときに作成します。</span><span class="sxs-lookup"><span data-stu-id="2a074-130">How and where you set this value programmatically within your application logic will affect how you may wish to set access on the <xref:System.Windows.DependencyPropertyKey> created when you first registered the dependency property.</span></span> <span data-ttu-id="2a074-131">このロジックすべてをクラス内で処理する場合はプライベートにでき、アセンブリの他の部分から設定する必要がある場合は内部に設定します。</span><span class="sxs-lookup"><span data-stu-id="2a074-131">If you handle this logic all within the class you could make it private, or if you require it to be set from other portions of the assembly you might set it internal.</span></span> <span data-ttu-id="2a074-132">呼び出す方法の 1 つは、<xref:System.Windows.DependencyObject.SetValue%2A>ストアド プロパティの値が変更する必要があるクラスのインスタンスに通知する関連イベントのクラスのイベント ハンドラー内で。</span><span class="sxs-lookup"><span data-stu-id="2a074-132">One approach is to call <xref:System.Windows.DependencyObject.SetValue%2A> within a class event handler of a relevant event that informs a class instance that the stored property value needs to be changed.</span></span> <span data-ttu-id="2a074-133">別のアプローチがペアリングを使用して、依存関係プロパティを結び、<xref:System.Windows.PropertyChangedCallback>と<xref:System.Windows.CoerceValueCallback>登録時にこれらのプロパティのメタデータの一部としてコールバック。</span><span class="sxs-lookup"><span data-stu-id="2a074-133">Another approach is to tie dependency properties together by using paired <xref:System.Windows.PropertyChangedCallback> and <xref:System.Windows.CoerceValueCallback> callbacks as part of those properties' metadata during registration.</span></span>  
  
 <span data-ttu-id="2a074-134"><xref:System.Windows.DependencyPropertyKey>はプライベートであるとは反映されませんプロパティで、システムによって、コードの外部で、読み取り専用の依存関係プロパティがより読み取り/書き込みの依存関係プロパティよりもセキュリティを設定します。</span><span class="sxs-lookup"><span data-stu-id="2a074-134">Because the <xref:System.Windows.DependencyPropertyKey> is private, and is not propagated by the property system outside of your code, a read-only dependency property does have better setting security than a read-write dependency property.</span></span> <span data-ttu-id="2a074-135">読み取り/書き込み依存関係プロパティの場合は、識別するフィールドは明示的または暗黙的にパブリックであり、したがってプロパティは広範に設定可能です。</span><span class="sxs-lookup"><span data-stu-id="2a074-135">For a read-write dependency property, the identifying field is explicitly or implicitly public and thus the property is widely settable.</span></span> <span data-ttu-id="2a074-136">詳細については、「[依存関係プロパティのセキュリティ](../../../../docs/framework/wpf/advanced/dependency-property-security.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="2a074-136">For more specifics, see [Dependency Property Security](../../../../docs/framework/wpf/advanced/dependency-property-security.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="2a074-137">参照</span><span class="sxs-lookup"><span data-stu-id="2a074-137">See Also</span></span>  
 [<span data-ttu-id="2a074-138">依存関係プロパティの概要</span><span class="sxs-lookup"><span data-stu-id="2a074-138">Dependency Properties Overview</span></span>](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md)  
 [<span data-ttu-id="2a074-139">カスタム依存関係プロパティ</span><span class="sxs-lookup"><span data-stu-id="2a074-139">Custom Dependency Properties</span></span>](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md)  
 [<span data-ttu-id="2a074-140">スタイルとテンプレート</span><span class="sxs-lookup"><span data-stu-id="2a074-140">Styling and Templating</span></span>](../../../../docs/framework/wpf/controls/styling-and-templating.md)
