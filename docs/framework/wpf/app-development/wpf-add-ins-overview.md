---
title: WPF アドインの概要
ms.date: 03/30/2017
helpviewer_keywords:
- add-ins and XAML browser applications [WPF]
- add-ins overview [WPF]
- add-ins [WPF], performance
- add-ins [WPF], benefits
- .NET Framework add-in model [WPF]
- add-ins [WPF], user interface
- add-ins and the user interface [WPF]
- add-ins [WPF], architecture
- add-ins [WPF], limitations
ms.assetid: 00b4c776-29a8-4dba-b603-280a0cdc2ade
ms.openlocfilehash: 47e76a1d08f8c85eafa7758ec9fdd80d8ae8afcf
ms.sourcegitcommit: 8f95d3a37e591963ebbb9af6e90686fd5f3b8707
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/23/2019
ms.locfileid: "56746563"
---
# <a name="wpf-add-ins-overview"></a><span data-ttu-id="9dce2-102">WPF アドインの概要</span><span class="sxs-lookup"><span data-stu-id="9dce2-102">WPF Add-Ins Overview</span></span>
<a name="Introduction"></a> <span data-ttu-id="9dce2-103">.NET Framework には、開発者がアドイン機能拡張をサポートするアプリケーションの作成に使用できるアドイン モデルが含まれています。</span><span class="sxs-lookup"><span data-stu-id="9dce2-103">The .NET Framework includes an add-in model that developers can use to create applications that support add-in extensibility.</span></span> <span data-ttu-id="9dce2-104">このアドイン モデルを使用することで、アプリケーション機能に統合され、アプリケーション機能を拡張するアドインを作成できます。</span><span class="sxs-lookup"><span data-stu-id="9dce2-104">This add-in model allows the creation of add-ins that integrate with and extend application functionality.</span></span> <span data-ttu-id="9dce2-105">シナリオによっては、アプリケーションは、アドインによって提供されるユーザー インターフェイスの表示にも必要です。このトピックでは、WPF がこれらのシナリオ、その利点、および制限事項の背後にあるアーキテクチャを有効にする .NET Framework アドイン モデルを強化する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-105">In some scenarios, applications also need to display user interfaces that are provided by add-ins. This topic shows how WPF augments the .NET Framework add-in model to enable these scenarios, the architecture behind it, its benefits, and its limitations.</span></span>  
  

  
<a name="Requirements"></a>   
## <a name="prerequisites"></a><span data-ttu-id="9dce2-106">必須コンポーネント</span><span class="sxs-lookup"><span data-stu-id="9dce2-106">Prerequisites</span></span>  
 <span data-ttu-id="9dce2-107">.NET Framework アドイン モデルに関する知識が必要です。</span><span class="sxs-lookup"><span data-stu-id="9dce2-107">Familiarity with the .NET Framework add-in model is required.</span></span> <span data-ttu-id="9dce2-108">詳細については、「[アドインおよび拡張機能](/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100))」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9dce2-108">For more information, see [Add-ins and Extensibility](/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100)).</span></span>  
  
<a name="AddInsOverview"></a>   
## <a name="add-ins-overview"></a><span data-ttu-id="9dce2-109">アドインの概要</span><span class="sxs-lookup"><span data-stu-id="9dce2-109">Add-Ins Overview</span></span>  
 <span data-ttu-id="9dce2-110">新しい機能を追加するためにアプリケーションを再コンパイルして再配置する手間を省くことを目的として、アプリケーションは機能拡張メカニズムを実装し、開発者 (ファーストパーティ、サードパーティのいずれも) が元のアプリケーションに統合される別のアプリケーションを作成できるようにしています。</span><span class="sxs-lookup"><span data-stu-id="9dce2-110">In order to avoid the complexities of application recompilation and redeployment to incorporate new functionality, applications implement extensibility mechanisms that allow developers (both first-party and third-party) to create other applications that integrate with them.</span></span> <span data-ttu-id="9dce2-111">こうした拡張機能をサポートする方法としては、アドイン ("アドオン"、"プラグイン" などとも呼ばれる) の使用が最も一般的です。</span><span class="sxs-lookup"><span data-stu-id="9dce2-111">The most common way to support this type of extensibility is through the use of add-ins (also known as "add-ons" and "plug-ins").</span></span> <span data-ttu-id="9dce2-112">アドインによる機能拡張を公開する実際のアプリケーションとして、次のようなものが挙げられます。</span><span class="sxs-lookup"><span data-stu-id="9dce2-112">Examples of real-world applications that expose extensibility with add-ins include:</span></span>  
  
-   <span data-ttu-id="9dce2-113">Internet Explorer のアドオン。</span><span class="sxs-lookup"><span data-stu-id="9dce2-113">Internet Explorer add-ons.</span></span>  
  
-   <span data-ttu-id="9dce2-114">Windows Media Player のプラグイン。</span><span class="sxs-lookup"><span data-stu-id="9dce2-114">Windows Media Player plug-ins.</span></span>  
  
-   <span data-ttu-id="9dce2-115">Visual Studio のアドイン。</span><span class="sxs-lookup"><span data-stu-id="9dce2-115">Visual Studio add-ins.</span></span>  
  
 <span data-ttu-id="9dce2-116">たとえば、Windows Media Player のアドイン モデルにおいて、サードパーティの開発者は、Windows Media Player の機能をさまざまな形で拡張する "プラグイン" を実装できます。たとえば、Windows Media Player でネイティブにサポートされていないメディア形式 (DVD、MP3 など) のデコーダーおよびエンコーダー、オーディオ効果、スキンなどを作成できます。</span><span class="sxs-lookup"><span data-stu-id="9dce2-116">For example, the Windows Media Player add-in model allows third-party developers to implement "plug-ins" that extend Windows Media Player in a variety of ways, including creating decoders and encoders for media formats that are not supported natively by Windows Media Player (for example, DVD, MP3), audio effects, and skins.</span></span> <span data-ttu-id="9dce2-117">各アドイン モデルは、アプリケーション固有の機能を公開するためにビルドされますが、どのアドイン モデルにも共通するエンティティや動作がいくつかあります。</span><span class="sxs-lookup"><span data-stu-id="9dce2-117">Each add-in model is built to expose the functionality that is unique to an application, although there are several entities and behaviors that are common to all add-in models.</span></span>  
  
 <span data-ttu-id="9dce2-118">典型的な機能拡張ソリューションの主な 3 つのエンティティは、*コントラクト*、*アドイン*、および*ホスト アプリケーション*です。</span><span class="sxs-lookup"><span data-stu-id="9dce2-118">The three main entities of typical add-in extensibility solutions are *contracts*, *add-ins*, and *host applications*.</span></span> <span data-ttu-id="9dce2-119">コントラクトは、次の 2 つの方法で、アドインとホスト アプリケーションとの統合方法を定義します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-119">Contracts define how add-ins integrate with host applications in two ways:</span></span>  
  
-   <span data-ttu-id="9dce2-120">アドインは、ホスト アプリケーションによって実装される機能と統合されます。</span><span class="sxs-lookup"><span data-stu-id="9dce2-120">Add-ins integrate with functionality that is implemented by host applications.</span></span>  
  
-   <span data-ttu-id="9dce2-121">ホスト アプリケーションで、アドインを統合するための機能を公開します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-121">Host applications expose functionality for add-ins to integrate with.</span></span>  
  
 <span data-ttu-id="9dce2-122">アドインを使用するには、ホスト アプリケーションが実行時にアドインを検索して読み込む必要があります。</span><span class="sxs-lookup"><span data-stu-id="9dce2-122">In order for add-ins to be used, host applications need to find them and load them at run time.</span></span> <span data-ttu-id="9dce2-123">したがって、アドインをサポートするアプリケーションには次の機能が必要です。</span><span class="sxs-lookup"><span data-stu-id="9dce2-123">Consequently, applications that support add-ins have the following additional responsibilities:</span></span>  
  
-   <span data-ttu-id="9dce2-124">**探索**:ホスト アプリケーションによってサポートされるコントラクトに準拠しているアドインを検索します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-124">**Discovery**: Finding add-ins that adhere to contracts supported by host applications.</span></span>  
  
-   <span data-ttu-id="9dce2-125">**アクティブ化**:読み込み、実行、およびアドインとの通信を確立します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-125">**Activation**: Loading, running, and establishing communication with add-ins.</span></span>  
  
-   <span data-ttu-id="9dce2-126">**分離**:アプリケーション ドメインまたはプロセスを使用して、潜在的なセキュリティとアドインの実行の問題からアプリケーションを保護する、分離境界を確立します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-126">**Isolation**: Using either application domains or processes to establish isolation boundaries that protect applications from potential security and execution problems with add-ins.</span></span>  
  
-   <span data-ttu-id="9dce2-127">**通信**:アドインを許可して、メソッドを呼び出すと、データを渡すことによって分離境界を越えて互いと通信するアプリケーションをホストします。</span><span class="sxs-lookup"><span data-stu-id="9dce2-127">**Communication**: Allowing add-ins and host applications to communicate with each other across isolation boundaries by calling methods and passing data.</span></span>  
  
-   <span data-ttu-id="9dce2-128">**有効期間管理**:読み込みとクリーニング、予測可能な方法でアプリケーション ドメインとプロセスをアンロード (を参照してください[アプリケーション ドメイン](../../../../docs/framework/app-domains/application-domains.md))。</span><span class="sxs-lookup"><span data-stu-id="9dce2-128">**Lifetime Management**: Loading and unloading application domains and processes in a clean, predictable manner (see [Application Domains](../../../../docs/framework/app-domains/application-domains.md)).</span></span>  
  
-   <span data-ttu-id="9dce2-129">**バージョン管理**:アプリケーションをホストとアドイン通信できることも新しいバージョンのいずれかが作成されたときにすることです。</span><span class="sxs-lookup"><span data-stu-id="9dce2-129">**Versioning**: Ensuring that host applications and add-ins can still communicate when new versions of either are created.</span></span>  
  
 <span data-ttu-id="9dce2-130">このことからわかるように、堅牢なアドイン モデルの開発は簡単なことではありません。</span><span class="sxs-lookup"><span data-stu-id="9dce2-130">Ultimately, developing a robust add-in model is a non-trivial undertaking.</span></span> <span data-ttu-id="9dce2-131">このため、.NET Framework は、アドイン モデルを構築するためのインフラストラクチャを提供します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-131">For this reason, the .NET Framework provides an infrastructure for building add-in models.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9dce2-132">アドインの詳細については、「[アドインおよび拡張機能](/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100))」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9dce2-132">For more detailed information on add-ins, see [Add-ins and Extensibility](/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100)).</span></span>  
  
<a name="NETFrameworkAddInModelOverview"></a>   
## <a name="net-framework-add-in-model-overview"></a><span data-ttu-id="9dce2-133">.NET Framework アドイン モデルの概要</span><span class="sxs-lookup"><span data-stu-id="9dce2-133">.NET Framework Add-In Model Overview</span></span>  
 <span data-ttu-id="9dce2-134">.NET Framework アドイン モデルにある、<xref:System.AddIn>名前空間には、アドイン機能拡張の開発を簡略化できるように設計された型のセットが含まれています。</span><span class="sxs-lookup"><span data-stu-id="9dce2-134">The .NET Framework add-in model, found in the <xref:System.AddIn> namespace, contains a set of types that are designed to simplify the development of add-in extensibility.</span></span> <span data-ttu-id="9dce2-135">.NET Framework アドイン モデルの基本単位は、*コントラクト*アドインで相互通信、方法、ホスト アプリケーションを定義します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-135">The fundamental unit of the .NET Framework add-in model is the *contract*, which defines how a host application and an add-in communicate with each other.</span></span> <span data-ttu-id="9dce2-136">コントラクトのホスト アプリケーション固有の*ビュー*を使用して、コントラクトはホスト アプリケーションに公開されます。</span><span class="sxs-lookup"><span data-stu-id="9dce2-136">A contract is exposed to a host application using a host-application-specific *view* of the contract.</span></span> <span data-ttu-id="9dce2-137">同様に、コントラクトのアドイン固有の*ビュー*がアドインに公開されます。</span><span class="sxs-lookup"><span data-stu-id="9dce2-137">Likewise, an add-in-specific *view* of the contract is exposed to the add-in.</span></span> <span data-ttu-id="9dce2-138">*アダプター*は、ホスト アプリケーションとアドインが、コントラクトの対応するビュー間で通信するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="9dce2-138">An *adapter* is used to allow a host application and an add-in to communicate between their respective views of the contract.</span></span> <span data-ttu-id="9dce2-139">コントラクト、ビュー、およびアダプターはセグメントと見なされ、関連セグメントのセットが*パイプライン*を構成します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-139">Contracts, views, and adapters are referred to as segments, and a set of related segments constitutes a *pipeline*.</span></span> <span data-ttu-id="9dce2-140">パイプラインは、基盤となる、.NET Framework アドイン モデルでは、探索、アクティブ化、セキュリティの分離、実行の分離 (アプリケーション ドメインとプロセスの両方を使用して)、通信、有効期間管理、およびバージョン管理がサポートしています。</span><span class="sxs-lookup"><span data-stu-id="9dce2-140">Pipelines are the foundation upon which the .NET Framework add-in model supports discovery, activation, security isolation, execution isolation (using both application domains and processes), communication, lifetime management, and versioning.</span></span>  
  
 <span data-ttu-id="9dce2-141">このサポート全体を使用して、開発者はホスト アプリケーションの機能を統合するアドインをビルドできます。</span><span class="sxs-lookup"><span data-stu-id="9dce2-141">The sum of this support allows developers to build add-ins that integrate with the functionality of a host application.</span></span> <span data-ttu-id="9dce2-142">ただし、一部のシナリオでは、ホスト アプリケーションがアドインによって提供されるユーザー インターフェイスを表示する必要があります.NET Framework では、各プレゼンテーション テクノロジには、ユーザー インターフェイスを実装するための独自のモデルがあるため、.NET Framework アドイン モデルは特定のプレゼンテーション テクノロジをサポートしません。</span><span class="sxs-lookup"><span data-stu-id="9dce2-142">However, some scenarios require host applications to display user interfaces provided by add-ins. Because each presentation technology in the .NET Framework has its own model for implementing user interfaces, the .NET Framework add-in model does not support any particular presentation technology.</span></span> <span data-ttu-id="9dce2-143">代わりに、WPF は .NET Framework アドイン モデルの UI アドインのサポートを拡張します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-143">Instead, WPF extends the .NET Framework add-in model with UI support for add-ins.</span></span>  
  
<a name="WPFAddInModel"></a>   
## <a name="wpf-add-ins"></a><span data-ttu-id="9dce2-144">WPF アドイン</span><span class="sxs-lookup"><span data-stu-id="9dce2-144">WPF Add-Ins</span></span>  
 <span data-ttu-id="9dce2-145">WPF、.NET Framework アドイン モデルと組み合わせて使用するさまざまなホスト アプリケーションがアドインからのユーザー インターフェイスを表示する必要があるシナリオに対処できます。具体的には、これらのシナリオに次の 2 つのプログラミング モデルを使用した WPF によって対応します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-145">WPF, in conjunction with the .NET Framework add-in model, allows you to address a wide variety of scenarios that require host applications to display user interfaces from add-ins. In particular, these scenarios are addressed by WPF with the following two programming models:</span></span>  
  
1.  <span data-ttu-id="9dce2-146">**アドインが UI を返す**。</span><span class="sxs-lookup"><span data-stu-id="9dce2-146">**The add-in returns a UI**.</span></span> <span data-ttu-id="9dce2-147">アドインの UI を返す、ホスト アプリケーションにメソッドの呼び出しを使用して、コントラクトで定義されています。</span><span class="sxs-lookup"><span data-stu-id="9dce2-147">An add-in returns a UI to the host application via a method call, as defined by the contract.</span></span> <span data-ttu-id="9dce2-148">このシナリオは、次の場合に使用されます。</span><span class="sxs-lookup"><span data-stu-id="9dce2-148">This scenario is used in the following cases:</span></span>  
  
    -   <span data-ttu-id="9dce2-149">アドインによって返される UI の外観はいずれかのデータに依存または条件に存在する、実行時にのみなど動的にレポートを生成します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-149">The appearance of a UI that is returned by an add-in is dependent on either data or conditions that exist only at run time, such as dynamically generated reports.</span></span>  
  
    -   <span data-ttu-id="9dce2-150">アドインによって提供されるサービスの UI アドインで使用できるホスト アプリケーションの UI と異なります。</span><span class="sxs-lookup"><span data-stu-id="9dce2-150">The UI for services provided by an add-in differs from the UI of the host applications that can use the add-in.</span></span>  
  
    -   <span data-ttu-id="9dce2-151">アドインは主にサービスをホスト アプリケーションの実行し、UI を使用してホスト アプリケーションにステータスをレポートします。</span><span class="sxs-lookup"><span data-stu-id="9dce2-151">The add-in primarily performs a service for the host application, and reports status to the host application with a UI.</span></span>  
  
2.  <span data-ttu-id="9dce2-152">**アドインが UI である**。</span><span class="sxs-lookup"><span data-stu-id="9dce2-152">**The add-in is a UI**.</span></span> <span data-ttu-id="9dce2-153">アドインのコントラクトで定義されている、UI であります。</span><span class="sxs-lookup"><span data-stu-id="9dce2-153">An add-in is a UI, as defined by the contract.</span></span> <span data-ttu-id="9dce2-154">このシナリオは、次の場合に使用されます。</span><span class="sxs-lookup"><span data-stu-id="9dce2-154">This scenario is used in the following cases:</span></span>  
  
    -   <span data-ttu-id="9dce2-155">アドインは表示以外のサービス (広告など) を提供しない。</span><span class="sxs-lookup"><span data-stu-id="9dce2-155">An add-in doesn't provide services other than being displayed, such as an advertisement.</span></span>  
  
    -   <span data-ttu-id="9dce2-156">アドインによって提供されるサービスの UI は、そのアドインを電卓、カラー ピッカーなどが使用できるすべてのホスト アプリケーションに共通です。</span><span class="sxs-lookup"><span data-stu-id="9dce2-156">The UI for services provided by an add-in is common to all host applications that can use that add-in, such as a calculator or color picker.</span></span>  
  
 <span data-ttu-id="9dce2-157">これらのシナリオでは、ホスト アプリケーションとアドイン アプリケーション ドメイン間で UI オブジェクトを渡すことができますが必要です。</span><span class="sxs-lookup"><span data-stu-id="9dce2-157">These scenarios require that UI objects can be passed between host application and add-in application domains.</span></span> <span data-ttu-id="9dce2-158">以降、.NET Framework アドイン モデルはアプリケーション ドメイン間で通信するリモート処理に依存それらの間で渡されるオブジェクトはリモート処理可能にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="9dce2-158">Since the .NET Framework add-in model relies on remoting to communicate between application domains, the objects that are passed between them must be remotable.</span></span>  
  
 <span data-ttu-id="9dce2-159">リモート処理可能なオブジェクトとは、次の 1 つ以上に該当するクラスのインスタンスです。</span><span class="sxs-lookup"><span data-stu-id="9dce2-159">A remotable object is an instance of a class that does one or more of the following:</span></span>  
  
-   <span data-ttu-id="9dce2-160">派生した、<xref:System.MarshalByRefObject>クラス。</span><span class="sxs-lookup"><span data-stu-id="9dce2-160">Derives from the <xref:System.MarshalByRefObject> class.</span></span>  
  
-   <span data-ttu-id="9dce2-161">
  <xref:System.Runtime.Serialization.ISerializable> インターフェイスを実装します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-161">Implements the <xref:System.Runtime.Serialization.ISerializable> interface.</span></span>  
  
-   <span data-ttu-id="9dce2-162"><xref:System.SerializableAttribute>属性が適用されています。</span><span class="sxs-lookup"><span data-stu-id="9dce2-162">Has the <xref:System.SerializableAttribute> attribute applied.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9dce2-163">リモート処理可能な .NET Framework オブジェクトの作成に関する詳細については、次を参照してください。[オブジェクトのためのリモート処理可能](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/wcf3swha(v=vs.100))します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-163">For more information regarding the creation of remotable .NET Framework objects, see [Making Objects Remotable](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/wcf3swha(v=vs.100)).</span></span>  
  
 <span data-ttu-id="9dce2-164">WPF の UI 型は、リモート処理可能ではありません。</span><span class="sxs-lookup"><span data-stu-id="9dce2-164">The WPF UI types are not remotable.</span></span> <span data-ttu-id="9dce2-165">この問題を解決するためには、WPF は、ホスト アプリケーションから表示する WPF の UI アドインを使用して作成を有効にする .NET Framework アドイン モデルを拡張します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-165">To solve the problem, WPF extends the .NET Framework add-in model to enable WPF UI created by add-ins to be displayed from host applications.</span></span> <span data-ttu-id="9dce2-166">このサポートが 2 つの種類での WPF で提供される:<xref:System.AddIn.Contract.INativeHandleContract>インターフェイスと 2 つの静的メソッドによって実装される、<xref:System.AddIn.Pipeline.FrameworkElementAdapters>クラス:<xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A>と<xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A>します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-166">This support is provided by WPF by two types: the <xref:System.AddIn.Contract.INativeHandleContract> interface and two static methods implemented by the <xref:System.AddIn.Pipeline.FrameworkElementAdapters> class: <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A> and <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A>.</span></span> <span data-ttu-id="9dce2-167">大まかに、これらの型とメソッドは次のように使用されます。</span><span class="sxs-lookup"><span data-stu-id="9dce2-167">At a high level, these types and methods are used in the following manner:</span></span>  
  
1.  <span data-ttu-id="9dce2-168">WPF では、アドインによって提供されるユーザー インターフェイスから直接または間接的に派生クラスである<xref:System.Windows.FrameworkElement>図形、コントロール、ユーザー コントロール、レイアウト パネル、ページなどです。</span><span class="sxs-lookup"><span data-stu-id="9dce2-168">WPF requires that user interfaces provided by add-ins are classes that derive directly or indirectly from <xref:System.Windows.FrameworkElement>, such as shapes, controls, user controls, layout panels, and pages.</span></span>  
  
2.  <span data-ttu-id="9dce2-169">コントラクトは、UI がアドインとホスト アプリケーション間で渡されることを宣言する任意の場所として宣言する必要があります、 <xref:System.AddIn.Contract.INativeHandleContract> (いない、 <xref:System.Windows.FrameworkElement>)。<xref:System.AddIn.Contract.INativeHandleContract>分離境界を越えて渡すことができる追加の UI のリモート処理可能な表現です。</span><span class="sxs-lookup"><span data-stu-id="9dce2-169">Wherever the contract declares that a UI will be passed between the add-in and the host application, it must be declared as an <xref:System.AddIn.Contract.INativeHandleContract> (not a <xref:System.Windows.FrameworkElement>); <xref:System.AddIn.Contract.INativeHandleContract> is a remotable representation of the add-in UI that can be passed across isolation boundaries.</span></span>  
  
3.  <span data-ttu-id="9dce2-170">アドインのアプリケーション ドメインから渡される前に、<xref:System.Windows.FrameworkElement>としてパッケージ化されて、<xref:System.AddIn.Contract.INativeHandleContract>呼び出して<xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A>します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-170">Before being passed from the add-in's application domain, a <xref:System.Windows.FrameworkElement> is packaged as an <xref:System.AddIn.Contract.INativeHandleContract> by calling <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A>.</span></span>  
  
4.  <span data-ttu-id="9dce2-171">ホスト アプリケーションのアプリケーション ドメインに渡された後、<xref:System.AddIn.Contract.INativeHandleContract>として再パッケージ化する必要があります、<xref:System.Windows.FrameworkElement>呼び出して<xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A>します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-171">After being passed to the host application's application domain, the <xref:System.AddIn.Contract.INativeHandleContract> must be repackaged as a <xref:System.Windows.FrameworkElement> by calling <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A>.</span></span>  
  
 <span data-ttu-id="9dce2-172">どの<xref:System.AddIn.Contract.INativeHandleContract>、<xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A>と<xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A>使用は、特定のシナリオによって異なります。</span><span class="sxs-lookup"><span data-stu-id="9dce2-172">How <xref:System.AddIn.Contract.INativeHandleContract>, <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A>, and <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A> are used depends on the specific scenario.</span></span> <span data-ttu-id="9dce2-173">以降のセクションでは、各プログラミング モデルについて詳しく説明していきます。</span><span class="sxs-lookup"><span data-stu-id="9dce2-173">The following sections provide details for each programming model.</span></span>  
  
<a name="ReturnUIFromAddInContract"></a>   
## <a name="add-in-returns-a-user-interface"></a><span data-ttu-id="9dce2-174">ユーザー インターフェイスを返すアドイン</span><span class="sxs-lookup"><span data-stu-id="9dce2-174">Add-In Returns a User Interface</span></span>  
 <span data-ttu-id="9dce2-175">アドインをホスト アプリケーションに UI を返す、次が必要です。</span><span class="sxs-lookup"><span data-stu-id="9dce2-175">For an add-in to return a UI to a host application, the following are required:</span></span>  
  
1.  <span data-ttu-id="9dce2-176">ホスト アプリケーション、アドイン、およびパイプラインを作成する .NET Framework での説明に従って[アドインおよび拡張](/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100))ドキュメント。</span><span class="sxs-lookup"><span data-stu-id="9dce2-176">The host application, add-in, and pipeline must be created, as described by the .NET Framework [Add-ins and Extensibility](/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100)) documentation.</span></span>  
  
2.  <span data-ttu-id="9dce2-177">コントラクトを実装する必要があります<xref:System.AddIn.Contract.IContract>と、コントラクトに UI を返すには、型の戻り値を持つメソッドを宣言する必要があります<xref:System.AddIn.Contract.INativeHandleContract>します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-177">The contract must implement <xref:System.AddIn.Contract.IContract> and, to return a UI, the contract must declare a method with a return value of type <xref:System.AddIn.Contract.INativeHandleContract>.</span></span>  
  
3.  <span data-ttu-id="9dce2-178">UI アドインとホスト アプリケーション間で渡される必要があります直接または間接的に派生から<xref:System.Windows.FrameworkElement>します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-178">The UI that is passed between the add-in and the host application must directly or indirectly derive from <xref:System.Windows.FrameworkElement>.</span></span>  
  
4.  <span data-ttu-id="9dce2-179">アドインによって返される UI を変換する必要があります、<xref:System.Windows.FrameworkElement>を<xref:System.AddIn.Contract.INativeHandleContract>分離境界を越える前にします。</span><span class="sxs-lookup"><span data-stu-id="9dce2-179">The UI that is returned by the add-in must be converted from a <xref:System.Windows.FrameworkElement> to an <xref:System.AddIn.Contract.INativeHandleContract> before crossing the isolation boundary.</span></span>  
  
5.  <span data-ttu-id="9dce2-180">返される UI を変換する必要があります、<xref:System.AddIn.Contract.INativeHandleContract>を<xref:System.Windows.FrameworkElement>分離境界を越えた後。</span><span class="sxs-lookup"><span data-stu-id="9dce2-180">The UI that is returned must be converted from an <xref:System.AddIn.Contract.INativeHandleContract> to a <xref:System.Windows.FrameworkElement> after crossing the isolation boundary.</span></span>  
  
6.  <span data-ttu-id="9dce2-181">ホスト アプリケーションを表示、返された<xref:System.Windows.FrameworkElement>します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-181">The host application displays the returned <xref:System.Windows.FrameworkElement>.</span></span>  
  
 <span data-ttu-id="9dce2-182">UI を返すアドインを実装する方法については、例では、次を参照してください。 [UI を作成するアドインを返す](../../../../docs/framework/wpf/app-development/how-to-create-an-add-in-that-returns-a-ui.md)します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-182">For an example that demonstrates how to implement an add-in that returns a UI, see [Create an Add-In That Returns a UI](../../../../docs/framework/wpf/app-development/how-to-create-an-add-in-that-returns-a-ui.md).</span></span>  
  
<a name="AddInIsAUI"></a>   
## <a name="add-in-is-a-user-interface"></a><span data-ttu-id="9dce2-183">ユーザー インターフェイスであるアドイン</span><span class="sxs-lookup"><span data-stu-id="9dce2-183">Add-In Is a User Interface</span></span>  
 <span data-ttu-id="9dce2-184">アドインの UI である、ときに、次が必要です。</span><span class="sxs-lookup"><span data-stu-id="9dce2-184">When an add-in is a UI, the following are required:</span></span>  
  
1.  <span data-ttu-id="9dce2-185">ホスト アプリケーション、アドイン、およびパイプラインを作成する .NET Framework での説明に従って[アドインおよび拡張](/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100))ドキュメント。</span><span class="sxs-lookup"><span data-stu-id="9dce2-185">The host application, add-in, and pipeline must be created, as described by the .NET Framework [Add-ins and Extensibility](/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100)) documentation.</span></span>  
  
2.  <span data-ttu-id="9dce2-186">アドインのコントラクト インターフェイスを実装する必要があります<xref:System.AddIn.Contract.INativeHandleContract>します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-186">The contract interface for the add-in must implement <xref:System.AddIn.Contract.INativeHandleContract>.</span></span>  
  
3.  <span data-ttu-id="9dce2-187">アドイン、ホスト アプリケーションに渡される必要があります直接的または間接的に派生から<xref:System.Windows.FrameworkElement>します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-187">The add-in that is passed to the host application must directly or indirectly derive from <xref:System.Windows.FrameworkElement>.</span></span>  
  
4.  <span data-ttu-id="9dce2-188">アドインから変換する必要があります、<xref:System.Windows.FrameworkElement>を<xref:System.AddIn.Contract.INativeHandleContract>分離境界を越える前にします。</span><span class="sxs-lookup"><span data-stu-id="9dce2-188">The add-in must be converted from a <xref:System.Windows.FrameworkElement> to an <xref:System.AddIn.Contract.INativeHandleContract> before crossing the isolation boundary.</span></span>  
  
5.  <span data-ttu-id="9dce2-189">アドインから変換する必要があります、<xref:System.AddIn.Contract.INativeHandleContract>を<xref:System.Windows.FrameworkElement>分離境界を越えた後。</span><span class="sxs-lookup"><span data-stu-id="9dce2-189">The add-in must be converted from an <xref:System.AddIn.Contract.INativeHandleContract> to a <xref:System.Windows.FrameworkElement> after crossing the isolation boundary.</span></span>  
  
6.  <span data-ttu-id="9dce2-190">ホスト アプリケーションを表示、返された<xref:System.Windows.FrameworkElement>します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-190">The host application displays the returned <xref:System.Windows.FrameworkElement>.</span></span>  
  
 <span data-ttu-id="9dce2-191">UI であるアドインを実装する方法については、例では、次を参照してください。 [UI を作成するアドインは](../../../../docs/framework/wpf/app-development/how-to-create-an-add-in-that-is-a-ui.md)します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-191">For an example that demonstrates how to implement an add-in that is a UI, see [Create an Add-In That Is a UI](../../../../docs/framework/wpf/app-development/how-to-create-an-add-in-that-is-a-ui.md).</span></span>  
  
<a name="ReturningMultipleUIsFromAnAddIn"></a>   
## <a name="returning-multiple-uis-from-an-add-in"></a><span data-ttu-id="9dce2-192">複数の UI を返すアドイン</span><span class="sxs-lookup"><span data-stu-id="9dce2-192">Returning Multiple UIs from an Add-In</span></span>  
 <span data-ttu-id="9dce2-193">アドインは、多くの場合、表示するホスト アプリケーション用の複数のユーザー インターフェイスを提供します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-193">Add-ins often provide multiple user interfaces for host applications to display.</span></span> <span data-ttu-id="9dce2-194">たとえばも UI としても、ホスト アプリケーションにステータス情報を提供する UI は、アドインを検討してください。</span><span class="sxs-lookup"><span data-stu-id="9dce2-194">For example, consider an add-in that is a UI that also provides status information to the host application, also as a UI.</span></span> <span data-ttu-id="9dce2-195">このようなアドインは、[ユーザー インターフェイスを返すアドイン](#ReturnUIFromAddInContract)のモデルと[ユーザー インターフェイスであるアドイン](#AddInIsAUI)のモデルの両方の手法を組み合わせることで実装できます。</span><span class="sxs-lookup"><span data-stu-id="9dce2-195">An add-in like this can be implemented by using a combination of techniques from both the [Add-In Returns a User Interface](#ReturnUIFromAddInContract) and [Add-In Is a User Interface](#AddInIsAUI) models.</span></span>  
  
<a name="AddInsAndXBAPs"></a>   
## <a name="add-ins-and-xaml-browser-applications"></a><span data-ttu-id="9dce2-196">アドインと XAML ブラウザー アプリケーション</span><span class="sxs-lookup"><span data-stu-id="9dce2-196">Add-Ins and XAML Browser Applications</span></span>  
 <span data-ttu-id="9dce2-197">ここまでの例では、ホスト アプリケーションはスタンドアロン アプリケーションとしてインストールされています。</span><span class="sxs-lookup"><span data-stu-id="9dce2-197">In the examples so far, the host application has been an installed standalone application.</span></span> <span data-ttu-id="9dce2-198">[!INCLUDE[TLA#tla_xbap#plural](../../../../includes/tlasharptla-xbapsharpplural-md.md)] はアドインをホストすることもできますが、そのためには次に示すビルドと実装の要件を満たす必要があります。</span><span class="sxs-lookup"><span data-stu-id="9dce2-198">But [!INCLUDE[TLA#tla_xbap#plural](../../../../includes/tlasharptla-xbapsharpplural-md.md)] can also host add-ins, albeit with the following additional build and implementation requirements:</span></span>  
  
-   <span data-ttu-id="9dce2-199">パイプライン (フォルダーとアセンブリ) とアドイン アセンブリを、[!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] と同じフォルダーにある、クライアント コンピューターの [!INCLUDE[TLA#tla_clickonce](../../../../includes/tlasharptla-clickonce-md.md)] アプリケーション キャッシュにダウンロードするよう、[!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] アプリケーション マニフェストを特別に構成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9dce2-199">The [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] application manifest must be configured specially to download the pipeline (folders and assemblies) and add-in assembly to the [!INCLUDE[TLA#tla_clickonce](../../../../includes/tlasharptla-clickonce-md.md)] application cache on the client machine, in the same folder as the [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)].</span></span>  
  
-   <span data-ttu-id="9dce2-200">アドインを探索して読み込む [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] コードで、[!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] の [!INCLUDE[TLA2#tla_clickonce](../../../../includes/tla2sharptla-clickonce-md.md)] アプリケーション キャッシュを、パイプラインとアドインの場所として使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9dce2-200">The [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] code to discover and load add-ins must use the [!INCLUDE[TLA2#tla_clickonce](../../../../includes/tla2sharptla-clickonce-md.md)] application cache for the [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] as the pipeline and add-in location.</span></span>  
  
-   <span data-ttu-id="9dce2-201">[!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] は、アドインが起点サイトにある圧縮しないファイルを参照する場合、アドインを特別なセキュリティ コンテキストの下で読み込む必要があります。[!INCLUDE[TLA2#tla_xbap#plural](../../../../includes/tla2sharptla-xbapsharpplural-md.md)] によってホストされる場合、アドインが参照できるのは、ホスト アプリケーションの起点サイトにある圧縮しないファイルのみです。</span><span class="sxs-lookup"><span data-stu-id="9dce2-201">The [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] must load the add-in into a special security context if the add-in references loose files that are located at the site of origin; when hosted by [!INCLUDE[TLA2#tla_xbap#plural](../../../../includes/tla2sharptla-xbapsharpplural-md.md)], add-ins can only reference loose files that are located at the host application's site of origin.</span></span>  
  
 <span data-ttu-id="9dce2-202">これらのタスクについて、次のサブセクションで詳しく説明します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-202">These tasks are described in detail in the following subsections.</span></span>  
  
### <a name="configuring-the-pipeline-and-add-in-for-clickonce-deployment"></a><span data-ttu-id="9dce2-203">ClickOnce 配置のためのパイプラインとアドインの構成</span><span class="sxs-lookup"><span data-stu-id="9dce2-203">Configuring the Pipeline and Add-In for ClickOnce Deployment</span></span>  
 [!INCLUDE[TLA2#tla_xbap#plural](../../../../includes/tla2sharptla-xbapsharpplural-md.md)] <span data-ttu-id="9dce2-204">は、[!INCLUDE[TLA2#tla_clickonce](../../../../includes/tla2sharptla-clickonce-md.md)] 配置キャッシュの安全なフォルダーにダウンロードされ、そこから実行されます。</span><span class="sxs-lookup"><span data-stu-id="9dce2-204">are downloaded to and run from a safe folder in the [!INCLUDE[TLA2#tla_clickonce](../../../../includes/tla2sharptla-clickonce-md.md)] deployment cache.</span></span> <span data-ttu-id="9dce2-205">[!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] でアドインをホストするには、パイプラインとアドインのアセンブリも同じ安全なフォルダーにダウンロードする必要があります。</span><span class="sxs-lookup"><span data-stu-id="9dce2-205">In order for an [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] to host an add-in, the pipeline and add-in assembly must also be downloaded to the safe folder.</span></span> <span data-ttu-id="9dce2-206">このためには、パイプラインとアドインのどちらのアセンブリもダウンロード対象に含まれるよう、アプリケーション マニフェストを構成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9dce2-206">To achieve this, you need to configure the application manifest to include both the pipeline and add-in assembly for download.</span></span> <span data-ttu-id="9dce2-207">これは、[!INCLUDE[TLA2#tla_visualstu](../../../../includes/tla2sharptla-visualstu-md.md)] で実行することが最も簡単ですが、[!INCLUDE[TLA2#tla_visualstu](../../../../includes/tla2sharptla-visualstu-md.md)] でパイプラインをアセンブリとして検出するには、パイプラインとアドインのアセンブリが、ホスト [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] プロジェクトのルート フォルダーに存在する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9dce2-207">This is most easily done in [!INCLUDE[TLA2#tla_visualstu](../../../../includes/tla2sharptla-visualstu-md.md)], although the pipeline and add-in assembly needs to be in the host [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] project's root folder in order for [!INCLUDE[TLA2#tla_visualstu](../../../../includes/tla2sharptla-visualstu-md.md)] to detect the pipeline assemblies.</span></span>  
  
 <span data-ttu-id="9dce2-208">したがって、まず、パイプライン アセンブリとアドイン アセンブリの各プロジェクトのビルド出力を設定し、パイプラインとアドインのアセンブリを [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] プロジェクトのルートにビルドします。</span><span class="sxs-lookup"><span data-stu-id="9dce2-208">Consequently, the first step is to build the pipeline and add-in assembly to the [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] project's root by setting the build output of each pipeline assembly and add-in assembly projects.</span></span> <span data-ttu-id="9dce2-209">次の表は、ホストの [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] プロジェクトと同じソリューションとルートのフォルダーに格納される、パイプライン アセンブリ プロジェクトとアドイン アセンブリ プロジェクトのビルド出力パスを示します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-209">The following table shows the build output paths for pipeline assembly projects and add-in assembly project that are in the same solution and root folder as the host [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] project.</span></span>  
  
 <span data-ttu-id="9dce2-210">表 1:XBAP でホストされているパイプライン アセンブリのビルド出力パス</span><span class="sxs-lookup"><span data-stu-id="9dce2-210">Table 1: Build Output Paths for the Pipeline Assemblies That Are Hosted by an XBAP</span></span>  
  
|<span data-ttu-id="9dce2-211">パイプライン アセンブリ プロジェクト</span><span class="sxs-lookup"><span data-stu-id="9dce2-211">Pipeline assembly project</span></span>|<span data-ttu-id="9dce2-212">ビルド出力パス</span><span class="sxs-lookup"><span data-stu-id="9dce2-212">Build output path</span></span>|  
|-------------------------------|-----------------------|  
|<span data-ttu-id="9dce2-213">コントラクト</span><span class="sxs-lookup"><span data-stu-id="9dce2-213">Contract</span></span>|`..\HostXBAP\Contracts\`|  
|<span data-ttu-id="9dce2-214">アドイン ビュー</span><span class="sxs-lookup"><span data-stu-id="9dce2-214">Add-In View</span></span>|`..\HostXBAP\AddInViews\`|  
|<span data-ttu-id="9dce2-215">アドイン側のアダプター</span><span class="sxs-lookup"><span data-stu-id="9dce2-215">Add-In-Side Adapter</span></span>|`..\HostXBAP\AddInSideAdapters\`|  
|<span data-ttu-id="9dce2-216">ホスト側のアダプター</span><span class="sxs-lookup"><span data-stu-id="9dce2-216">Host-Side Adapter</span></span>|`..\HostXBAP\HostSideAdapters\`|  
|<span data-ttu-id="9dce2-217">アドイン</span><span class="sxs-lookup"><span data-stu-id="9dce2-217">Add-In</span></span>|`..\HostXBAP\AddIns\WPFAddIn1`|  
  
 <span data-ttu-id="9dce2-218">次に、パイプライン アセンブリとアドイン アセンブリを [!INCLUDE[TLA2#tla_xbap#plural](../../../../includes/tla2sharptla-xbapsharpplural-md.md)] コンテンツ ファイルとして [!INCLUDE[TLA2#tla_visualstu](../../../../includes/tla2sharptla-visualstu-md.md)] に指定します。手順は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="9dce2-218">The next step is to specify the pipeline assemblies and add-in assembly as the [!INCLUDE[TLA2#tla_xbap#plural](../../../../includes/tla2sharptla-xbapsharpplural-md.md)] content files in [!INCLUDE[TLA2#tla_visualstu](../../../../includes/tla2sharptla-visualstu-md.md)] by doing the following:</span></span>  
  
1.  <span data-ttu-id="9dce2-219">ソリューション エクスプローラーで各パイプライン フォルダーを右クリックし、**[プロジェクトに含める]** を選択して、パイプラインとアドインのアセンブリをプロジェクトに含めます。</span><span class="sxs-lookup"><span data-stu-id="9dce2-219">Including the pipeline and add-in assembly in the project by right-clicking each pipeline folder in Solution Explorer and choosing **Include In Project**.</span></span>  
  
2.  <span data-ttu-id="9dce2-220">**[プロパティ]** ウィンドウで、パイプライン アセンブリとアドイン アセンブリそれぞれについて、**[ビルド アクション]** を **[コンテンツ]** に設定します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-220">Setting the **Build Action** of each pipeline assembly and add-in assembly to **Content** from the **Properties** window.</span></span>  
  
 <span data-ttu-id="9dce2-221">最後に、パイプラインとアドインのどちらのアセンブリ ファイルもダウンロード対象に含まれるよう、アプリケーション マニフェストを構成します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-221">The final step is to configure the application manifest to include the pipeline assembly files and add-in assembly file for download.</span></span> <span data-ttu-id="9dce2-222">ファイルは、[!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] アプリケーションが占有する [!INCLUDE[TLA2#tla_clickonce](../../../../includes/tla2sharptla-clickonce-md.md)] キャッシュ内のフォルダーのルートにあるフォルダー内に存在している必要があります。</span><span class="sxs-lookup"><span data-stu-id="9dce2-222">The files should be located in folders at the root of the folder in the [!INCLUDE[TLA2#tla_clickonce](../../../../includes/tla2sharptla-clickonce-md.md)] cache that the [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] application occupies.</span></span> <span data-ttu-id="9dce2-223">この構成は、次の手順に従って、[!INCLUDE[TLA2#tla_visualstu](../../../../includes/tla2sharptla-visualstu-md.md)] で行うことができます。</span><span class="sxs-lookup"><span data-stu-id="9dce2-223">The configuration can be achieved in [!INCLUDE[TLA2#tla_visualstu](../../../../includes/tla2sharptla-visualstu-md.md)] by doing the following:</span></span>  
  
1.  <span data-ttu-id="9dce2-224">[!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] プロジェクトを右クリックして、**[プロパティ]**、**[発行]** の順にクリックし、**[アプリケーション ファイル]** をクリックします。</span><span class="sxs-lookup"><span data-stu-id="9dce2-224">Right-click the [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] project, click **Properties**, click **Publish**, and then click the **Application Files** button.</span></span>  
  
2.  <span data-ttu-id="9dce2-225">**[アプリケーション ファイル]** ダイアログ ボックスで、各パイプラインとアドインの DLL の **[発行の状況]** を **[含める (自動)]** に設定し、各パイプラインとアドインの DLL の **[ダウンロード グループ]** を **[(必須)]** に設定します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-225">In the **Application Files** dialog, set the **Publish Status** of each pipeline and add-in DLL to **Include (Auto)**, and set the **Download Group** for each pipeline and add-in DLL to **(Required)**.</span></span>  
  
### <a name="using-the-pipeline-and-add-in-from-the-application-base"></a><span data-ttu-id="9dce2-226">アプリケーション ベースからのパイプラインとアドインの使用</span><span class="sxs-lookup"><span data-stu-id="9dce2-226">Using the Pipeline and Add-In from the Application Base</span></span>  
 <span data-ttu-id="9dce2-227">パイプラインとアドインは [!INCLUDE[TLA2#tla_clickonce](../../../../includes/tla2sharptla-clickonce-md.md)] 配置用に構成されると、同じ [!INCLUDE[TLA2#tla_clickonce](../../../../includes/tla2sharptla-clickonce-md.md)] キャッシュ フォルダーに [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] としてダウンロードされます。</span><span class="sxs-lookup"><span data-stu-id="9dce2-227">When the pipeline and add-in are configured for [!INCLUDE[TLA2#tla_clickonce](../../../../includes/tla2sharptla-clickonce-md.md)] deployment, they are downloaded to the same [!INCLUDE[TLA2#tla_clickonce](../../../../includes/tla2sharptla-clickonce-md.md)] cache folder as the [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)].</span></span> <span data-ttu-id="9dce2-228">このパイプラインとアドインを [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] から使用するには、[!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] コードがそれらをアプリケーション ベースから取得する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9dce2-228">To use the pipeline and add-in from the [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)], the [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] code must get them from the application base.</span></span> <span data-ttu-id="9dce2-229">さまざまな種類とパイプラインとアドインを使用して .NET Framework アドイン モデルのメンバーは、このシナリオで特別なサポートを提供します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-229">The various types and members of the .NET Framework add-in model for using pipelines and add-ins provide special support for this scenario.</span></span> <span data-ttu-id="9dce2-230">まず、パスがで識別される、<xref:System.AddIn.Hosting.PipelineStoreLocation.ApplicationBase>列挙値。</span><span class="sxs-lookup"><span data-stu-id="9dce2-230">Firstly, the path is identified by the <xref:System.AddIn.Hosting.PipelineStoreLocation.ApplicationBase> enumeration value.</span></span> <span data-ttu-id="9dce2-231">この値を適切なアドイン メンバーのオーバーロードと併用することで、次のようなパイプラインを使用できます。</span><span class="sxs-lookup"><span data-stu-id="9dce2-231">You use this value with overloads of the pertinent add-in members for using pipelines that include the following:</span></span>  
  
-   <xref:System.AddIn.Hosting.AddInStore.FindAddIns%28System.Type%2CSystem.AddIn.Hosting.PipelineStoreLocation%29?displayProperty=nameWithType>  
  
-   <xref:System.AddIn.Hosting.AddInStore.FindAddIns%28System.Type%2CSystem.AddIn.Hosting.PipelineStoreLocation%2CSystem.String%5B%5D%29?displayProperty=nameWithType>  
  
-   <xref:System.AddIn.Hosting.AddInStore.Rebuild%28System.AddIn.Hosting.PipelineStoreLocation%29?displayProperty=nameWithType>  
  
-   <xref:System.AddIn.Hosting.AddInStore.Update%28System.AddIn.Hosting.PipelineStoreLocation%29?displayProperty=nameWithType>  
  
### <a name="accessing-the-hosts-site-of-origin"></a><span data-ttu-id="9dce2-232">ホストの起点サイトへのアクセス</span><span class="sxs-lookup"><span data-stu-id="9dce2-232">Accessing the Host's Site of Origin</span></span>  
 <span data-ttu-id="9dce2-233">アドインが起点サイトのファイルを参照できるように、アドインはホスト アプリケーションと等価なセキュリティ分離を使用して読み込む必要があります。</span><span class="sxs-lookup"><span data-stu-id="9dce2-233">To ensure that an add-in can reference files from the site of origin, the add-in must be loaded with security isolation that is equivalent to the host application.</span></span> <span data-ttu-id="9dce2-234">このセキュリティ レベルがで識別される、<xref:System.AddIn.Hosting.AddInSecurityLevel.Host?displayProperty=nameWithType>列挙の値に渡されると、<xref:System.AddIn.Hosting.AddInToken.Activate%2A>メソッド、アドインをアクティブ化します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-234">This security level is identified by the <xref:System.AddIn.Hosting.AddInSecurityLevel.Host?displayProperty=nameWithType> enumeration value, and passed to the <xref:System.AddIn.Hosting.AddInToken.Activate%2A> method when an add-in is activated.</span></span>  
  
<a name="WPFAddInModelArchitecture"></a>   
## <a name="wpf-add-in-architecture"></a><span data-ttu-id="9dce2-235">WPF アドイン アーキテクチャ</span><span class="sxs-lookup"><span data-stu-id="9dce2-235">WPF Add-In Architecture</span></span>  
 <span data-ttu-id="9dce2-236">最上位のレベルでは、前述したように、WPF により、ユーザー インターフェイスを実装する .NET Framework のアドイン (から直接または間接的に派生する<xref:System.Windows.FrameworkElement>) を使用して<xref:System.AddIn.Contract.INativeHandleContract>、<xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A>と<xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A>します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-236">At the highest level, as we've seen, WPF enables .NET Framework add-ins to implement user interfaces (that derive directly or indirectly from <xref:System.Windows.FrameworkElement>) using <xref:System.AddIn.Contract.INativeHandleContract>, <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A> and <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A>.</span></span> <span data-ttu-id="9dce2-237">ホスト アプリケーションが返されることになります、 <xref:System.Windows.FrameworkElement> UI から、ホスト アプリケーションで表示されています。</span><span class="sxs-lookup"><span data-stu-id="9dce2-237">The result is that the host application is returned a <xref:System.Windows.FrameworkElement> that is displayed from UI in the host application.</span></span>  
  
 <span data-ttu-id="9dce2-238">単純な UI アドイン シナリオでこれは、できるだけ詳しく開発者が必要です。</span><span class="sxs-lookup"><span data-stu-id="9dce2-238">For simple UI add-in scenarios, this is as much detail as a developer needs.</span></span> <span data-ttu-id="9dce2-239">特にレイアウト、リソース、およびデータ バインドなどの追加の WPF サービスを利用しようとするより複雑なシナリオは、その利点を理解する WPF が .NET Framework アドイン モデルの UI サポートを拡張する方法の詳細な知識が必要制限事項。</span><span class="sxs-lookup"><span data-stu-id="9dce2-239">For more complex scenarios, particularly those that try to utilize additional WPF services such as layout, resources, and data binding, more detailed knowledge of how WPF extends the .NET Framework add-in model with UI support is required to understand its benefits and limitations.</span></span>  
  
 <span data-ttu-id="9dce2-240">基本的には、WPF に合格しなかった UI アドインからホスト アプリケーションです。代わりに、WPF は、WPF の相互運用性を使用して、UI の Win32 ウィンドウ ハンドルを渡します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-240">Fundamentally, WPF doesn't pass a UI from an add-in to a host application; instead, WPF passes the Win32 window handle for the UI by using WPF interoperability.</span></span> <span data-ttu-id="9dce2-241">そのため、アドインからの UI は、ホスト アプリケーションに渡される、次のようにします。</span><span class="sxs-lookup"><span data-stu-id="9dce2-241">As such, when a UI from an add-in is passed to a host application, the following occurs:</span></span>  
  
-   <span data-ttu-id="9dce2-242">アドイン側では、WPF は、ホスト アプリケーションによって表示される UI のウィンドウ ハンドルを取得します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-242">On the add-in side, WPF acquires a window handle for the UI that will be displayed by the host application.</span></span> <span data-ttu-id="9dce2-243">ウィンドウ ハンドルがから派生する内部の WPF クラスによってカプセル化された<xref:System.Windows.Interop.HwndSource>実装と<xref:System.AddIn.Contract.INativeHandleContract>します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-243">The window handle is encapsulated by an internal WPF class that derives from <xref:System.Windows.Interop.HwndSource> and implements <xref:System.AddIn.Contract.INativeHandleContract>.</span></span> <span data-ttu-id="9dce2-244">このクラスのインスタンスがによって返される<xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A>はアドインのアプリケーション ドメインからホスト アプリケーションのアプリケーション ドメインにマーシャ リングとします。</span><span class="sxs-lookup"><span data-stu-id="9dce2-244">An instance of this class is returned by <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A> and is marshaled from the add-in's application domain to the host application's application domain.</span></span>  
  
-   <span data-ttu-id="9dce2-245">WPF には、ホスト アプリケーション側で、<xref:System.Windows.Interop.HwndSource>内部の WPF クラスから派生したとして<xref:System.Windows.Interop.HwndHost>消費<xref:System.AddIn.Contract.INativeHandleContract>します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-245">On the host application side, WPF repackages the <xref:System.Windows.Interop.HwndSource> as an internal WPF class that derives from <xref:System.Windows.Interop.HwndHost> and consumes <xref:System.AddIn.Contract.INativeHandleContract>.</span></span> <span data-ttu-id="9dce2-246">このクラスのインスタンスがによって返される<xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A>ホスト アプリケーションにします。</span><span class="sxs-lookup"><span data-stu-id="9dce2-246">An instance of this class is returned by <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A> to the host application.</span></span>  
  
 <span data-ttu-id="9dce2-247"><xref:System.Windows.Interop.HwndHost> 存在すると、WPF ユーザー インターフェイスから、ウィンドウ ハンドルによって識別される、ユーザー インターフェイスを表示します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-247"><xref:System.Windows.Interop.HwndHost> exists to display user interfaces, identified by window handles, from WPF user interfaces.</span></span> <span data-ttu-id="9dce2-248">詳細については、「[WPF と Win32 の相互運用性](../../../../docs/framework/wpf/advanced/wpf-and-win32-interoperation.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9dce2-248">For more information, see [WPF and Win32 Interoperation](../../../../docs/framework/wpf/advanced/wpf-and-win32-interoperation.md).</span></span>  
  
 <span data-ttu-id="9dce2-249">要約すると、 <xref:System.AddIn.Contract.INativeHandleContract>、<xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A>と<xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A>に渡されるアドインからホスト アプリケーションによってカプセル化は、WPF UI のウィンドウ ハンドルを許可する存在、<xref:System.Windows.Interop.HwndHost>ホスト アプリケーションの UI を表示します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-249">In summary, <xref:System.AddIn.Contract.INativeHandleContract>, <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A>, and <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A> exist to allow the window handle for a WPF UI to be passed from an add-in to a host application, where it is encapsulated by a <xref:System.Windows.Interop.HwndHost> and displayed the host application's UI.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9dce2-250">ホスト アプリケーションを取得するため、 <xref:System.Windows.Interop.HwndHost>、ホスト アプリケーションによって返されるオブジェクトを変換できません<xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A>アドインによって、型に実装されます (たとえば、 <xref:System.Windows.Controls.UserControl>)。</span><span class="sxs-lookup"><span data-stu-id="9dce2-250">Because the host application gets an <xref:System.Windows.Interop.HwndHost>, the host application cannot convert the object that is returned by <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A> to the type it is implemented as by the add-in (for example, a <xref:System.Windows.Controls.UserControl>).</span></span>  
  
 <span data-ttu-id="9dce2-251">その性質上、<xref:System.Windows.Interop.HwndHost>はホスト アプリケーションの使用方法に影響を与える特定の制限があります。</span><span class="sxs-lookup"><span data-stu-id="9dce2-251">By its nature, <xref:System.Windows.Interop.HwndHost> has certain limitations that affect how host applications can use them.</span></span> <span data-ttu-id="9dce2-252">ただし、WPF を拡張<xref:System.Windows.Interop.HwndHost>アドイン シナリオのいくつかの機能を使用します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-252">However, WPF extends <xref:System.Windows.Interop.HwndHost> with several capabilities for add-in scenarios.</span></span> <span data-ttu-id="9dce2-253">その利点と制約について、以下に説明します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-253">These benefits and limitations are described below.</span></span>  
  
<a name="WPFAddInModelBenefits"></a>   
## <a name="wpf-add-in-benefits"></a><span data-ttu-id="9dce2-254">WPF アドインの利点</span><span class="sxs-lookup"><span data-stu-id="9dce2-254">WPF Add-In Benefits</span></span>  
 <span data-ttu-id="9dce2-255">WPF アドインのユーザー インターフェイスがから派生する内部クラスを使用してホスト アプリケーションから表示されるため、 <xref:System.Windows.Interop.HwndHost>、それらのユーザー インターフェイスは、の機能によって制限されます<xref:System.Windows.Interop.HwndHost>レイアウトなどの WPF UI サービスに関してレンダリング、データ バインディング、スタイル、テンプレート、およびリソース。</span><span class="sxs-lookup"><span data-stu-id="9dce2-255">Because WPF add-in user interfaces are displayed from host applications using an internal class that derives from <xref:System.Windows.Interop.HwndHost>, those user interfaces are constrained by the capabilities of <xref:System.Windows.Interop.HwndHost> with respect to WPF UI services such as layout, rendering, data binding, styles, templates, and resources.</span></span> <span data-ttu-id="9dce2-256">ただし、WPF はその内部<xref:System.Windows.Interop.HwndHost>次を含む追加の機能を備えたサブクラスです。</span><span class="sxs-lookup"><span data-stu-id="9dce2-256">However, WPF augments its internal <xref:System.Windows.Interop.HwndHost> subclass with additional capabilities that include the following:</span></span>  
  
-   <span data-ttu-id="9dce2-257">ホスト アプリケーションの UI と、アドインの UI 間のタブ移動します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-257">Tabbing between a host application's UI and an add-in's UI.</span></span> <span data-ttu-id="9dce2-258">「UI であるアドイン」プログラミング モデルには、オーバーライドする追加アドイン側アダプターが必要があります<xref:System.AddIn.Pipeline.ContractBase.QueryContract%2A>アドインが完全に信頼できるか部分的に信頼されているかどうか、tab キーを有効にします。</span><span class="sxs-lookup"><span data-stu-id="9dce2-258">Note that the "add-in is a UI" programming model requires the add-in-side adapter to override <xref:System.AddIn.Pipeline.ContractBase.QueryContract%2A> to enable tabbing, whether the add-in is fully trusted or partially trusted.</span></span>  
  
-   <span data-ttu-id="9dce2-259">ホスト アプリケーションのユーザー インターフェイスから表示されるアドインのユーザー インターフェイスのアクセシビリティ要件を順守します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-259">Honoring accessibility requirements for add-in user interfaces that are displayed from host application user interfaces.</span></span>  
  
-   <span data-ttu-id="9dce2-260">WPF アプリケーションを複数のアプリケーション ドメインのシナリオで安全に実行を有効にします。</span><span class="sxs-lookup"><span data-stu-id="9dce2-260">Enabling WPF applications to run safely in multiple application domain scenarios.</span></span>  
  
-   <span data-ttu-id="9dce2-261">アドインの UI に不正なアクセスを防止 ウィンドウでは、セキュリティの分離 (つまり、部分信頼セキュリティ サンド ボックス) でアドインが実行される場合を処理します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-261">Preventing illegal access to add-in UI window handles when add-ins run with security isolation (that is, a partial-trust security sandbox).</span></span> <span data-ttu-id="9dce2-262">呼び出す<xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A>このセキュリティを確保します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-262">Calling <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A> ensures this security:</span></span>  
  
    -   <span data-ttu-id="9dce2-263">ウィンドウ ハンドルをアドインの UI の分離の境界を越えて渡す唯一の方法は"アドインが UI を返す"プログラミング モデルを呼び出す<xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A>します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-263">For the "add-in returns a UI" programming model, the only way to pass the window handle for an add-in UI across the isolation boundary is to call <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A>.</span></span>  
  
    -   <span data-ttu-id="9dce2-264">「アドインが UI を」プログラミング モデルのオーバーライド<xref:System.AddIn.Pipeline.ContractBase.QueryContract%2A>追加アドイン側アダプターと呼び出し元の<xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A>(として上記の例に示すように) を呼び出して追加アドイン側アダプターの処理として必要です`QueryContract`実装から、ホスト側アダプター。</span><span class="sxs-lookup"><span data-stu-id="9dce2-264">For the "add-in is a UI" programming model, overriding <xref:System.AddIn.Pipeline.ContractBase.QueryContract%2A> on the add-in-side adapter and calling <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A> (as shown in the preceding examples) is required, as is calling the add-in-side adapter's `QueryContract` implementation from the host-side adapter.</span></span>  
  
-   <span data-ttu-id="9dce2-265">アプリケーション ドメインの実行を何重にも保護します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-265">Providing multiple application domain execution protection.</span></span> <span data-ttu-id="9dce2-266">アプリケーション ドメインの制約に起因して、アドイン アプリケーション ドメインでスローされた未処理の例外は、分離境界が存在していても、アプリケーション全体のクラッシュにつながります。</span><span class="sxs-lookup"><span data-stu-id="9dce2-266">Due to limitations with application domains, unhandled exceptions that are thrown in add-in application domains cause the entire application to crash, even though the isolation boundary exists.</span></span> <span data-ttu-id="9dce2-267">ただし、WPF と .NET Framework アドイン モデルは、この問題を回避し、アプリケーションの安定性を向上させる簡単な方法を提供します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-267">However, WPF and the .NET Framework add-in model provide a simple way to work around this problem and improve application stability.</span></span> <span data-ttu-id="9dce2-268">UI を表示する WPF アドインを作成、<xref:System.Windows.Threading.Dispatcher>のアプリケーション ドメインは、ホスト アプリケーションが WPF アプリケーションの場合で実行されるスレッドの。</span><span class="sxs-lookup"><span data-stu-id="9dce2-268">A WPF add-in that displays a UI creates a <xref:System.Windows.Threading.Dispatcher> for the thread that the application domain runs on, if the host application is a WPF application.</span></span> <span data-ttu-id="9dce2-269">処理することにより、アプリケーション ドメインで発生するすべての未処理の例外を検出することができます、 <xref:System.Windows.Threading.Dispatcher.UnhandledException> 、WPF アドインのイベント<xref:System.Windows.Threading.Dispatcher>します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-269">You can detect all unhandled exceptions that occur in the application domain by handling the <xref:System.Windows.Threading.Dispatcher.UnhandledException> event of the WPF add-in's <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="9dce2-270">取得することができます、<xref:System.Windows.Threading.Dispatcher>から、<xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>プロパティ。</span><span class="sxs-lookup"><span data-stu-id="9dce2-270">You can get the <xref:System.Windows.Threading.Dispatcher> from the <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A> property.</span></span>  
  
<a name="WPFAddInModelLimitations"></a>   
## <a name="wpf-add-in-limitations"></a><span data-ttu-id="9dce2-271">WPF アドインの制約</span><span class="sxs-lookup"><span data-stu-id="9dce2-271">WPF Add-In Limitations</span></span>  
 <span data-ttu-id="9dce2-272">WPF によって提供される既定の動作に追加するメリットを超える<xref:System.Windows.Interop.HwndSource>、 <xref:System.Windows.Interop.HwndHost>、およびウィンドウのハンドル、ホスト アプリケーションから表示されるアドインのユーザー インターフェイスの制限があります。</span><span class="sxs-lookup"><span data-stu-id="9dce2-272">Beyond the benefits that WPF adds to the default behaviors supplied by <xref:System.Windows.Interop.HwndSource>, <xref:System.Windows.Interop.HwndHost>, and window handles, there are also limitations for add-in user interfaces that are displayed from host applications:</span></span>  
  
-   <span data-ttu-id="9dce2-273">ホスト アプリケーションから表示されるアドインのユーザー インターフェイスでは、ホスト アプリケーションのクリッピング動作が反映されません。</span><span class="sxs-lookup"><span data-stu-id="9dce2-273">Add-in user interfaces displayed from a host application do not respect the host application's clipping behavior.</span></span>  
  
-   <span data-ttu-id="9dce2-274">相互運用性シナリオの*空域*の概念もアドインに適用されます (「[技術領域の概要](../../../../docs/framework/wpf/advanced/technology-regions-overview.md)」を参照)。</span><span class="sxs-lookup"><span data-stu-id="9dce2-274">The concept of *airspace* in interoperability scenarios also applies to add-ins (see [Technology Regions Overview](../../../../docs/framework/wpf/advanced/technology-regions-overview.md)).</span></span>  
  
-   <span data-ttu-id="9dce2-275">リソースの継承、データ バインディング、およびコマンドを実行するは自動的に追加で使用できるなど、ホスト アプリケーションの UI のサービスのユーザー インターフェイス。</span><span class="sxs-lookup"><span data-stu-id="9dce2-275">A host application's UI services, such as resource inheritance, data binding, and commanding, are not automatically available to add-in user interfaces.</span></span> <span data-ttu-id="9dce2-276">これらのサービスをアドインに提供するには、パイプラインを更新する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9dce2-276">To provide these services to the add-in, you need to update the pipeline.</span></span>  
  
-   <span data-ttu-id="9dce2-277">アドインの UI ことはできません回転、拡大縮小、傾斜、またはそれ以外の場合、変換によって影響を受ける (を参照してください[変換の概要](../../../../docs/framework/wpf/graphics-multimedia/transforms-overview.md))。</span><span class="sxs-lookup"><span data-stu-id="9dce2-277">An add-in UI cannot be rotated, scaled, skewed, or otherwise affected by a transformation (see [Transforms Overview](../../../../docs/framework/wpf/graphics-multimedia/transforms-overview.md)).</span></span>  
  
-   <span data-ttu-id="9dce2-278">描画からの操作によって表示されるアドインのユーザー インターフェイス内のコンテンツ、<xref:System.Drawing>アルファ ブレンド名前空間を含めることができます。</span><span class="sxs-lookup"><span data-stu-id="9dce2-278">Content inside add-in user interfaces that is rendered by drawing operations from the <xref:System.Drawing> namespace can include alpha blending.</span></span> <span data-ttu-id="9dce2-279">ただし、アドインの UI とホスト アプリケーションが含まれる UI 不透明になります。 100% でなければなりませんつまり、`Opacity`両方のプロパティを 1 に設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9dce2-279">However, both an add-in UI and the host application UI that contains it must be 100% opaque; in other words, the `Opacity` property on both must be set to 1.</span></span>  
  
-   <span data-ttu-id="9dce2-280">場合、<xref:System.Windows.Window.AllowsTransparency%2A>アドインの UI を含むホスト アプリケーションのウィンドウのプロパティに設定されて`true`、アドインは表示されません。</span><span class="sxs-lookup"><span data-stu-id="9dce2-280">If the <xref:System.Windows.Window.AllowsTransparency%2A> property of a window in the host application that contains an add-in UI is set to `true`, the add-in is invisible.</span></span> <span data-ttu-id="9dce2-281">これは、アドインの UI が 100% 不透明である場合でも当てはまります (つまり、`Opacity`プロパティが 1 の値を持つ)。</span><span class="sxs-lookup"><span data-stu-id="9dce2-281">This is true even if the add-in UI is 100% opaque (that is, the `Opacity` property has a value of 1).</span></span>  
  
-   <span data-ttu-id="9dce2-282">アドインの UI は、同じトップレベル ウィンドウ内の他の WPF 要素の上に表示する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9dce2-282">An add-in UI must appear on top of other WPF elements in the same top-level window.</span></span>  
  
-   <span data-ttu-id="9dce2-283">アドインの UI の一部をレンダリングできませんを使用して、<xref:System.Windows.Media.VisualBrush>します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-283">No portion of an add-in's UI can be rendered using a <xref:System.Windows.Media.VisualBrush>.</span></span> <span data-ttu-id="9dce2-284">代わりに、アドインは、コントラクトによって定義されたメソッドを使用してホスト アプリケーションに渡すことができるビットマップを作成する生成された UI のスナップショットをかかる場合があります。</span><span class="sxs-lookup"><span data-stu-id="9dce2-284">Instead, the add-in may take a snapshot of the generated UI to create a bitmap that can be passed to the host application using methods defined by the contract.</span></span>  
  
-   <span data-ttu-id="9dce2-285">メディア ファイルを再生することはできません、<xref:System.Windows.Controls.MediaElement>アドインの UI にします。</span><span class="sxs-lookup"><span data-stu-id="9dce2-285">Media files cannot be played from a <xref:System.Windows.Controls.MediaElement> in an add-in UI.</span></span>  
  
-   <span data-ttu-id="9dce2-286">アドインの UI の生成されたマウス イベントが受信も、ホスト アプリケーションによって生成されると、`IsMouseOver`ホスト アプリケーションの UI のプロパティの値を持つ`false`します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-286">Mouse events generated for the add-in UI are neither received nor raised by the host application, and the `IsMouseOver` property for host application UI has a value of `false`.</span></span>  
  
-   <span data-ttu-id="9dce2-287">アドインの UI でコントロールの間でフォーカスが移動したとき、`GotFocus`と`LostFocus`イベントが受信も、ホスト アプリケーションによって発生します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-287">When focus shifts between controls in an add-in UI, the `GotFocus` and `LostFocus` events are neither received nor raised by the host application.</span></span>  
  
-   <span data-ttu-id="9dce2-288">アドインの UI を含むホスト アプリケーションの部分では、印刷時に白の項目が表示されます。</span><span class="sxs-lookup"><span data-stu-id="9dce2-288">The portion of a host application that contains an add-in UI appears white when printed.</span></span>  
  
-   <span data-ttu-id="9dce2-289">すべてのディスパッチャー (を参照してください<xref:System.Windows.Threading.Dispatcher>)、アドインによって作成された UI する必要がありますが手動でシャット ダウン、オーナー アドインがアンロードの直前、ホスト アプリケーションが実行を継続する場合。</span><span class="sxs-lookup"><span data-stu-id="9dce2-289">All dispatchers (see <xref:System.Windows.Threading.Dispatcher>) created by the add-in UI must be shut down manually before the owner add-in is unloaded if the host application continues execution.</span></span> <span data-ttu-id="9dce2-290">コントラクトは、アドインができるため、そのディスパッチャーをシャット ダウンするアドインの UI、アンロードする前に、アドインをホスト アプリケーションを許可するメソッドを実装できます。</span><span class="sxs-lookup"><span data-stu-id="9dce2-290">The contract can implement methods that allow the host application to signal the add-in before the add-in is unloaded, thereby allowing the add-in UI to shut down its dispatchers.</span></span>  
  
-   <span data-ttu-id="9dce2-291">アドインの UI がある場合、<xref:System.Windows.Controls.InkCanvas>または含まれている、 <xref:System.Windows.Controls.InkCanvas>、アドインをアンロードすることはできません。</span><span class="sxs-lookup"><span data-stu-id="9dce2-291">If an add-in UI is an <xref:System.Windows.Controls.InkCanvas> or contains an <xref:System.Windows.Controls.InkCanvas>, you cannot unload the add-in.</span></span>  
  
<a name="PerformanceOptimization"></a>   
## <a name="performance-optimization"></a><span data-ttu-id="9dce2-292">パフォーマンスの最適化</span><span class="sxs-lookup"><span data-stu-id="9dce2-292">Performance Optimization</span></span>  
 <span data-ttu-id="9dce2-293">既定では、複数のアプリケーション ドメインを使用している場合の各アプリケーションに必要なさまざまな .NET Framework アセンブリがすべて読み込まれますそのアプリケーションのドメインにします。</span><span class="sxs-lookup"><span data-stu-id="9dce2-293">By default, when multiple application domains are used, the various .NET Framework assemblies required by each application are all loaded into that application's domain.</span></span> <span data-ttu-id="9dce2-294">その結果、新しいアプリケーション ドメインを作成してその中でアプリケーションを開始するために必要な時間がパフォーマンスに影響します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-294">As a result, the time required for creating new application domains and starting applications in them might affect performance.</span></span> <span data-ttu-id="9dce2-295">ただし、.NET Framework は、既に読み込まれている場合は、アプリケーション ドメイン間でアセンブリを共有するアプリケーションに指示して開始時間を短縮するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="9dce2-295">However, the .NET Framework provides a way for you to reduce start times by instructing applications to share assemblies across application domains if they are already loaded.</span></span> <span data-ttu-id="9dce2-296">使用してこれを行う、<xref:System.LoaderOptimizationAttribute>属性には、エントリ ポイント メソッドに適用する必要があります (`Main`)。</span><span class="sxs-lookup"><span data-stu-id="9dce2-296">You do this by using the <xref:System.LoaderOptimizationAttribute> attribute, which must be applied to the entry point method (`Main`).</span></span> <span data-ttu-id="9dce2-297">この場合、アプリケーション定義を実装するコードのみを使用する必要があります (「[アプリケーション管理の概要](../../../../docs/framework/wpf/app-development/application-management-overview.md)」を参照)。</span><span class="sxs-lookup"><span data-stu-id="9dce2-297">In this case, you must use only code to implement your application definition (see [Application Management Overview](../../../../docs/framework/wpf/app-development/application-management-overview.md)).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="9dce2-298">関連項目</span><span class="sxs-lookup"><span data-stu-id="9dce2-298">See also</span></span>
- <xref:System.LoaderOptimizationAttribute>
- <span data-ttu-id="9dce2-299">[アドインおよび拡張機能](/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100))</span><span class="sxs-lookup"><span data-stu-id="9dce2-299">[Add-ins and Extensibility](/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100))</span></span>
- [<span data-ttu-id="9dce2-300">アプリケーション ドメイン</span><span class="sxs-lookup"><span data-stu-id="9dce2-300">Application Domains</span></span>](../../../../docs/framework/app-domains/application-domains.md)
- <span data-ttu-id="9dce2-301">[.NET framework リモート処理の概要](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/kwdt6w2k(v=vs.100))</span><span class="sxs-lookup"><span data-stu-id="9dce2-301">[.NET Framework Remoting Overview](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/kwdt6w2k(v=vs.100))</span></span>
- <span data-ttu-id="9dce2-302">[オブジェクトをリモート処理可能](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/wcf3swha(v=vs.100))</span><span class="sxs-lookup"><span data-stu-id="9dce2-302">[Making Objects Remotable](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/wcf3swha(v=vs.100))</span></span>
- [<span data-ttu-id="9dce2-303">方法トピック</span><span class="sxs-lookup"><span data-stu-id="9dce2-303">How-to Topics</span></span>](../../../../docs/framework/wpf/app-development/how-to-topics.md)
