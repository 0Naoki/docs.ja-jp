---
title: 入れ子になっているグラフィックス コンテナーの使用
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- graphics [Windows Forms], nested containers
- graphics [Windows Forms], clipping
- graphics [Windows Forms], transformations in nested objects
ms.assetid: a0d9f178-43a4-4323-bb5a-d3e3f77ae6c1
ms.openlocfilehash: 6bbf7918ccff184e597204b35aa005ab17d8d8af
ms.sourcegitcommit: 0be8a279af6d8a43e03141e349d3efd5d35f8767
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/18/2019
ms.locfileid: "59104300"
---
# <a name="using-nested-graphics-containers"></a><span data-ttu-id="cf9b9-102">入れ子になっているグラフィックス コンテナーの使用</span><span class="sxs-lookup"><span data-stu-id="cf9b9-102">Using Nested Graphics Containers</span></span>
[!INCLUDE[ndptecgdiplus](../../../../includes/ndptecgdiplus-md.md)] <span data-ttu-id="cf9b9-103">置換またはで状態の一部を強化を一時的に使用できるコンテナーを提供します、<xref:System.Drawing.Graphics>オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="cf9b9-103">provides containers that you can use to temporarily replace or augment part of the state in a <xref:System.Drawing.Graphics> object.</span></span> <span data-ttu-id="cf9b9-104">呼び出すことでコンテナーを作成する、<xref:System.Drawing.Graphics.BeginContainer%2A>のメソッドを<xref:System.Drawing.Graphics>オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="cf9b9-104">You create a container by calling the <xref:System.Drawing.Graphics.BeginContainer%2A> method of a <xref:System.Drawing.Graphics> object.</span></span> <span data-ttu-id="cf9b9-105">呼び出すことができます<xref:System.Drawing.Graphics.BeginContainer%2A>繰り返しを入れ子になったコンテナーを形成します。</span><span class="sxs-lookup"><span data-stu-id="cf9b9-105">You can call <xref:System.Drawing.Graphics.BeginContainer%2A> repeatedly to form nested containers.</span></span> <span data-ttu-id="cf9b9-106">呼び出しごとに<xref:System.Drawing.Graphics.BeginContainer%2A>への呼び出しと組み合わせて使用する必要があります<xref:System.Drawing.Graphics.EndContainer%2A>します。</span><span class="sxs-lookup"><span data-stu-id="cf9b9-106">Each call to <xref:System.Drawing.Graphics.BeginContainer%2A> must be paired with a call to <xref:System.Drawing.Graphics.EndContainer%2A>.</span></span>  
  
## <a name="transformations-in-nested-containers"></a><span data-ttu-id="cf9b9-107">入れ子になったコンテナー内の変換</span><span class="sxs-lookup"><span data-stu-id="cf9b9-107">Transformations in Nested Containers</span></span>  
 <span data-ttu-id="cf9b9-108">次の例では、作成、<xref:System.Drawing.Graphics>オブジェクトおよびコンテナー内で<xref:System.Drawing.Graphics>オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="cf9b9-108">The following example creates a <xref:System.Drawing.Graphics> object and a container within that <xref:System.Drawing.Graphics> object.</span></span> <span data-ttu-id="cf9b9-109">ワールド変換、<xref:System.Drawing.Graphics>オブジェクトが x 方向に 100 の翻訳単位と y 軸方向に 80 単位。</span><span class="sxs-lookup"><span data-stu-id="cf9b9-109">The world transformation of the <xref:System.Drawing.Graphics> object is a translation 100 units in the x direction and 80 units in the y direction.</span></span> <span data-ttu-id="cf9b9-110">コンテナーのワールド変換は、30 度回転します。</span><span class="sxs-lookup"><span data-stu-id="cf9b9-110">The world transformation of the container is a 30-degree rotation.</span></span> <span data-ttu-id="cf9b9-111">コードの呼び出しを行う`DrawRectangle(pen, -60, -30, 120, 60)`2 回クリックします。</span><span class="sxs-lookup"><span data-stu-id="cf9b9-111">The code makes the call `DrawRectangle(pen, -60, -30, 120, 60)` twice.</span></span> <span data-ttu-id="cf9b9-112">最初の呼び出し<xref:System.Drawing.Graphics.DrawRectangle%2A>コンテナー内では、呼び出しの間には、呼び出し<xref:System.Drawing.Graphics.BeginContainer%2A>と<xref:System.Drawing.Graphics.EndContainer%2A>します。</span><span class="sxs-lookup"><span data-stu-id="cf9b9-112">The first call to <xref:System.Drawing.Graphics.DrawRectangle%2A> is inside the container; that is, the call is in between the calls to <xref:System.Drawing.Graphics.BeginContainer%2A> and <xref:System.Drawing.Graphics.EndContainer%2A>.</span></span> <span data-ttu-id="cf9b9-113">2 番目の呼び出し<xref:System.Drawing.Graphics.DrawRectangle%2A>への呼び出し後は<xref:System.Drawing.Graphics.EndContainer%2A>します。</span><span class="sxs-lookup"><span data-stu-id="cf9b9-113">The second call to <xref:System.Drawing.Graphics.DrawRectangle%2A> is after the call to <xref:System.Drawing.Graphics.EndContainer%2A>.</span></span>  
  
 [!code-csharp[System.Drawing.MiscLegacyTopics#61](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.MiscLegacyTopics/CS/Class1.cs#61)]
 [!code-vb[System.Drawing.MiscLegacyTopics#61](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.MiscLegacyTopics/VB/Class1.vb#61)]  
  
 <span data-ttu-id="cf9b9-114">上記のコードでは、コンテナー内から描画する四角形が変換されるまずコンテナー (回転) のワールド変換をしのワールド変換して、<xref:System.Drawing.Graphics>オブジェクト (変換)。</span><span class="sxs-lookup"><span data-stu-id="cf9b9-114">In the preceding code, the rectangle drawn from inside the container is transformed first by the world transformation of the container (rotation) and then by the world transformation of the <xref:System.Drawing.Graphics> object (translation).</span></span> <span data-ttu-id="cf9b9-115">ワールド変換によってのみ、コンテナーの外部から描画する四角形が変換される、<xref:System.Drawing.Graphics>オブジェクト (変換)。</span><span class="sxs-lookup"><span data-stu-id="cf9b9-115">The rectangle drawn from outside the container is transformed only by the world transformation of the <xref:System.Drawing.Graphics> object (translation).</span></span> <span data-ttu-id="cf9b9-116">次の図は、2 つの四角形を示します。</span><span class="sxs-lookup"><span data-stu-id="cf9b9-116">The following illustration shows the two rectangles:</span></span> 
  
 ![入れ子になったコンテナーを示す図。](./media/using-nested-graphics-containers/nested-containers-illustration.png)  
  
## <a name="clipping-in-nested-containers"></a><span data-ttu-id="cf9b9-118">入れ子になったコンテナーのクリッピング</span><span class="sxs-lookup"><span data-stu-id="cf9b9-118">Clipping in Nested Containers</span></span>  
 <span data-ttu-id="cf9b9-119">次の例では、入れ子になったコンテナーのクリッピング領域を処理します。</span><span class="sxs-lookup"><span data-stu-id="cf9b9-119">The following example demonstrates how nested containers handle clipping regions.</span></span> <span data-ttu-id="cf9b9-120">このコードを作成、<xref:System.Drawing.Graphics>オブジェクトおよびコンテナー内で<xref:System.Drawing.Graphics>オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="cf9b9-120">The code creates a <xref:System.Drawing.Graphics> object and a container within that <xref:System.Drawing.Graphics> object.</span></span> <span data-ttu-id="cf9b9-121">クリッピング領域、<xref:System.Drawing.Graphics>オブジェクトは、四角形であり、コンテナーのクリッピング領域は楕円。</span><span class="sxs-lookup"><span data-stu-id="cf9b9-121">The clipping region of the <xref:System.Drawing.Graphics> object is a rectangle, and the clipping region of the container is an ellipse.</span></span> <span data-ttu-id="cf9b9-122">コードは、2 つの呼び出し、<xref:System.Drawing.Graphics.DrawLine%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="cf9b9-122">The code makes two calls to the <xref:System.Drawing.Graphics.DrawLine%2A> method.</span></span> <span data-ttu-id="cf9b9-123">最初の呼び出し<xref:System.Drawing.Graphics.DrawLine%2A>、コンテナーと、2 番目の呼び出しの内部<xref:System.Drawing.Graphics.DrawLine%2A>がコンテナーの範囲外です (呼び出しの後<xref:System.Drawing.Graphics.EndContainer%2A>)。</span><span class="sxs-lookup"><span data-stu-id="cf9b9-123">The first call to <xref:System.Drawing.Graphics.DrawLine%2A> is inside the container, and the second call to <xref:System.Drawing.Graphics.DrawLine%2A> is outside the container (after the call to <xref:System.Drawing.Graphics.EndContainer%2A>).</span></span> <span data-ttu-id="cf9b9-124">最初の行が 2 つのクリッピング領域の交差部分によって切り取られます。</span><span class="sxs-lookup"><span data-stu-id="cf9b9-124">The first line is clipped by the intersection of the two clipping regions.</span></span> <span data-ttu-id="cf9b9-125">クリッピング四角形領域によってのみ、2 行目のクリップ、<xref:System.Drawing.Graphics>オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="cf9b9-125">The second line is clipped only by the rectangular clipping region of the <xref:System.Drawing.Graphics> object.</span></span>  
  
 [!code-csharp[System.Drawing.MiscLegacyTopics#62](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.MiscLegacyTopics/CS/Class1.cs#62)]
 [!code-vb[System.Drawing.MiscLegacyTopics#62](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.MiscLegacyTopics/VB/Class1.vb#62)]  
  
 <span data-ttu-id="cf9b9-126">次の図は、2 つのクリップされた行を示しています。</span><span class="sxs-lookup"><span data-stu-id="cf9b9-126">The following illustration shows the two clipped lines:</span></span>
  
 ![クリップされた行を含む入れ子になったコンテナーを示す図。](./media/using-nested-graphics-containers/nested-container-clipped-lines.png)  
  
 <span data-ttu-id="cf9b9-128">2 つの例に示すとおり、変換、およびクリッピング領域は入れ子になったコンテナーで累積されます。</span><span class="sxs-lookup"><span data-stu-id="cf9b9-128">As the two preceding examples show, transformations and clipping regions are cumulative in nested containers.</span></span> <span data-ttu-id="cf9b9-129">コンテナーのワールド変換を設定した場合、<xref:System.Drawing.Graphics>オブジェクト、両方の変換は、コンテナー内から描画された項目に適用されます。</span><span class="sxs-lookup"><span data-stu-id="cf9b9-129">If you set the world transformations of the container and the <xref:System.Drawing.Graphics> object, both transformations will apply to items drawn from inside the container.</span></span> <span data-ttu-id="cf9b9-130">コンテナーの変換が適用されている最初との変換になります、<xref:System.Drawing.Graphics>オブジェクトが適用されます。</span><span class="sxs-lookup"><span data-stu-id="cf9b9-130">The transformation of the container will be applied first, and the transformation of the <xref:System.Drawing.Graphics> object will be applied second.</span></span> <span data-ttu-id="cf9b9-131">コンテナーのクリッピング領域を設定した場合、<xref:System.Drawing.Graphics>オブジェクト、コンテナーの内部から描画された項目は、重なる部分の 2 つのクリッピング領域のクリップされます。</span><span class="sxs-lookup"><span data-stu-id="cf9b9-131">If you set the clipping regions of the container and the <xref:System.Drawing.Graphics> object, items drawn from inside the container will be clipped by the intersection of the two clipping regions.</span></span>  
  
## <a name="quality-settings-in-nested-containers"></a><span data-ttu-id="cf9b9-132">入れ子になったコンテナーの画質の設定</span><span class="sxs-lookup"><span data-stu-id="cf9b9-132">Quality Settings in Nested Containers</span></span>  
 <span data-ttu-id="cf9b9-133">品質の設定 (<xref:System.Drawing.Graphics.SmoothingMode%2A>、<xref:System.Drawing.Graphics.TextRenderingHint%2A>など) で入れ子になったコンテナーは累積的な以外ではなく、コンテナーの品質設定を一時的に交換の品質設定を<xref:System.Drawing.Graphics>オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="cf9b9-133">Quality settings (<xref:System.Drawing.Graphics.SmoothingMode%2A>, <xref:System.Drawing.Graphics.TextRenderingHint%2A>, and the like) in nested containers are not cumulative; rather, the quality settings of the container temporarily replace the quality settings of a <xref:System.Drawing.Graphics> object.</span></span> <span data-ttu-id="cf9b9-134">新しいコンテナーを作成するときに、そのコンテナーの品質設定は、既定値に設定されます。</span><span class="sxs-lookup"><span data-stu-id="cf9b9-134">When you create a new container, the quality settings for that container are set to default values.</span></span> <span data-ttu-id="cf9b9-135">たとえば、ある、<xref:System.Drawing.Graphics>のスムージング モードを使ってオブジェクト<xref:System.Drawing.Drawing2D.SmoothingMode.AntiAlias>します。</span><span class="sxs-lookup"><span data-stu-id="cf9b9-135">For example, suppose you have a <xref:System.Drawing.Graphics> object with a smoothing mode of <xref:System.Drawing.Drawing2D.SmoothingMode.AntiAlias>.</span></span> <span data-ttu-id="cf9b9-136">コンテナーを作成するときに、コンテナー内のスムージング モードが既定のモードをスムージングに。</span><span class="sxs-lookup"><span data-stu-id="cf9b9-136">When you create a container, the smoothing mode inside the container is the default smoothing mode.</span></span> <span data-ttu-id="cf9b9-137">自由に、コンテナーのスムージング モードを設定して、モードを設定するに従って、コンテナー内から抽出されたすべての項目が描画されます。</span><span class="sxs-lookup"><span data-stu-id="cf9b9-137">You are free to set the smoothing mode of the container, and any items drawn from inside the container will be drawn according to the mode you set.</span></span> <span data-ttu-id="cf9b9-138">アイテムへの呼び出しの後に描画<xref:System.Drawing.Graphics.EndContainer%2A>スムージング モードに従ってが描画されます (<xref:System.Drawing.Drawing2D.SmoothingMode.AntiAlias>) への呼び出しの前にあった<xref:System.Drawing.Graphics.BeginContainer%2A>します。</span><span class="sxs-lookup"><span data-stu-id="cf9b9-138">Items drawn after the call to <xref:System.Drawing.Graphics.EndContainer%2A> will be drawn according to the smoothing mode (<xref:System.Drawing.Drawing2D.SmoothingMode.AntiAlias>) that was in place before the call to <xref:System.Drawing.Graphics.BeginContainer%2A>.</span></span>  
  
## <a name="several-layers-of-nested-containers"></a><span data-ttu-id="cf9b9-139">入れ子になったコンテナーの複数のレイヤー</span><span class="sxs-lookup"><span data-stu-id="cf9b9-139">Several Layers of Nested Containers</span></span>  
 <span data-ttu-id="cf9b9-140">内の 1 つのコンテナーに限定されない、<xref:System.Drawing.Graphics>オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="cf9b9-140">You are not limited to one container in a <xref:System.Drawing.Graphics> object.</span></span> <span data-ttu-id="cf9b9-141">コンテナーのシーケンスを作成することができます、前の入れ子になった各、ワールド変換、クリッピング領域、およびこれらの入れ子になったコンテナーのそれぞれの品質設定を指定することができます。</span><span class="sxs-lookup"><span data-stu-id="cf9b9-141">You can create a sequence of containers, each nested in the preceding, and you can specify the world transformation, clipping region, and quality settings of each of those nested containers.</span></span> <span data-ttu-id="cf9b9-142">最も内側のコンテナーから描画メソッドを呼び出す場合は、最も外側のコンテナーで最も内側のコンテナーで開始および終了の順序で、変換が適用されます。</span><span class="sxs-lookup"><span data-stu-id="cf9b9-142">If you call a drawing method from inside the innermost container, the transformations will be applied in order, starting with the innermost container and ending with the outermost container.</span></span> <span data-ttu-id="cf9b9-143">最も内側のコンテナーから描画された項目は、重なる部分のすべてのクリッピング領域のクリップされます。</span><span class="sxs-lookup"><span data-stu-id="cf9b9-143">Items drawn from inside the innermost container will be clipped by the intersection of all the clipping regions.</span></span>  
  
 <span data-ttu-id="cf9b9-144">次の例では、作成、<xref:System.Drawing.Graphics>オブジェクトし、そのテキストのレンダリング ヒント設定<xref:System.Drawing.Drawing2D.SmoothingMode.AntiAlias>します。</span><span class="sxs-lookup"><span data-stu-id="cf9b9-144">The following example creates a <xref:System.Drawing.Graphics> object and sets its text rendering hint to <xref:System.Drawing.Drawing2D.SmoothingMode.AntiAlias>.</span></span> <span data-ttu-id="cf9b9-145">コード内で他の入れ子になった 1 つ、2 つのコンテナーを作成します。</span><span class="sxs-lookup"><span data-stu-id="cf9b9-145">The code creates two containers, one nested within the other.</span></span> <span data-ttu-id="cf9b9-146">設定されている外側のコンテナーのテキストのレンダリング ヒント<xref:System.Drawing.Text.TextRenderingHint.SingleBitPerPixel>、内側のコンテナーのテキストのレンダリング ヒントに設定されていると<xref:System.Drawing.Drawing2D.SmoothingMode.AntiAlias>します。</span><span class="sxs-lookup"><span data-stu-id="cf9b9-146">The text rendering hint of the outer container is set to <xref:System.Drawing.Text.TextRenderingHint.SingleBitPerPixel>, and the text rendering hint of the inner container is set to <xref:System.Drawing.Drawing2D.SmoothingMode.AntiAlias>.</span></span> <span data-ttu-id="cf9b9-147">コードが 3 つの文字列を描画します。 外側のコンテナーから、からの内部コンテナーから 1 つ、<xref:System.Drawing.Graphics>オブジェクト自体。</span><span class="sxs-lookup"><span data-stu-id="cf9b9-147">The code draws three strings: one from the inner container, one from the outer container, and one from the <xref:System.Drawing.Graphics> object itself.</span></span>  
  
 [!code-csharp[System.Drawing.MiscLegacyTopics#63](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.MiscLegacyTopics/CS/Class1.cs#63)]
 [!code-vb[System.Drawing.MiscLegacyTopics#63](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.MiscLegacyTopics/VB/Class1.vb#63)]  
  
 <span data-ttu-id="cf9b9-148">次の図は、3 つの文字列を示します。</span><span class="sxs-lookup"><span data-stu-id="cf9b9-148">The following illustration shows the three strings.</span></span> <span data-ttu-id="cf9b9-149">描画および内部のコンテナーから、文字列、<xref:System.Drawing.Graphics>によってオブジェクトが滑らかにします。</span><span class="sxs-lookup"><span data-stu-id="cf9b9-149">The strings drawn from the inner container and from the <xref:System.Drawing.Graphics> object are smoothed by antialiasing.</span></span> <span data-ttu-id="cf9b9-150">外側のコンテナーから抽出された文字列が滑らかになってアンチ エイリアスによって、<xref:System.Drawing.Graphics.TextRenderingHint%2A>プロパティに設定されて<xref:System.Drawing.Text.TextRenderingHint.SingleBitPerPixel>します。</span><span class="sxs-lookup"><span data-stu-id="cf9b9-150">The string drawn from the outer container is not smoothed by antialiasing because the <xref:System.Drawing.Graphics.TextRenderingHint%2A> property is set to <xref:System.Drawing.Text.TextRenderingHint.SingleBitPerPixel>.</span></span>  
  
 ![入れ子になったコンテナーから抽出された文字列を示す図。](./media/using-nested-graphics-containers/nested-containers-three-strings.png)  
  
## <a name="see-also"></a><span data-ttu-id="cf9b9-152">関連項目</span><span class="sxs-lookup"><span data-stu-id="cf9b9-152">See also</span></span>

- <xref:System.Drawing.Graphics>
- [<span data-ttu-id="cf9b9-153">Graphics オブジェクトの状態の管理</span><span class="sxs-lookup"><span data-stu-id="cf9b9-153">Managing the State of a Graphics Object</span></span>](managing-the-state-of-a-graphics-object.md)
