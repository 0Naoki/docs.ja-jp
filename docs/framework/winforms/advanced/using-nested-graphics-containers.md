---
title: "入れ子になっているグラフィックス コンテナーの使用"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-winforms
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords:
- graphics [Windows Forms], nested containers
- graphics [Windows Forms], clipping
- graphics [Windows Forms], transformations in nested objects
ms.assetid: a0d9f178-43a4-4323-bb5a-d3e3f77ae6c1
caps.latest.revision: "13"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.openlocfilehash: 10c5a1b077e4339f17093e5eb935416bb1ae3d1b
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/21/2017
---
# <a name="using-nested-graphics-containers"></a><span data-ttu-id="49c70-102">入れ子になっているグラフィックス コンテナーの使用</span><span class="sxs-lookup"><span data-stu-id="49c70-102">Using Nested Graphics Containers</span></span>
[!INCLUDE[ndptecgdiplus](../../../../includes/ndptecgdiplus-md.md)]<span data-ttu-id="49c70-103">置換またはで状態の一部を強化を一時的に使用できるコンテナーを提供する<xref:System.Drawing.Graphics>オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="49c70-103"> provides containers that you can use to temporarily replace or augment part of the state in a <xref:System.Drawing.Graphics> object.</span></span> <span data-ttu-id="49c70-104">呼び出して、コンテナーを作成した、<xref:System.Drawing.Graphics.BeginContainer%2A>のメソッド、<xref:System.Drawing.Graphics>オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="49c70-104">You create a container by calling the <xref:System.Drawing.Graphics.BeginContainer%2A> method of a <xref:System.Drawing.Graphics> object.</span></span> <span data-ttu-id="49c70-105">呼び出すことができます<xref:System.Drawing.Graphics.BeginContainer%2A>繰り返しを入れ子になったコンテナーを形成します。</span><span class="sxs-lookup"><span data-stu-id="49c70-105">You can call <xref:System.Drawing.Graphics.BeginContainer%2A> repeatedly to form nested containers.</span></span> <span data-ttu-id="49c70-106">各呼び出し<xref:System.Drawing.Graphics.BeginContainer%2A>への呼び出しと組み合わせる必要がある<xref:System.Drawing.Graphics.EndContainer%2A>です。</span><span class="sxs-lookup"><span data-stu-id="49c70-106">Each call to <xref:System.Drawing.Graphics.BeginContainer%2A> must be paired with a call to <xref:System.Drawing.Graphics.EndContainer%2A>.</span></span>  
  
## <a name="transformations-in-nested-containers"></a><span data-ttu-id="49c70-107">入れ子になったコンテナー内の変換</span><span class="sxs-lookup"><span data-stu-id="49c70-107">Transformations in Nested Containers</span></span>  
 <span data-ttu-id="49c70-108">次の例を作成、<xref:System.Drawing.Graphics>オブジェクトとそのコンテナー<xref:System.Drawing.Graphics>オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="49c70-108">The following example creates a <xref:System.Drawing.Graphics> object and a container within that <xref:System.Drawing.Graphics> object.</span></span> <span data-ttu-id="49c70-109">ワールド変換、<xref:System.Drawing.Graphics>オブジェクトが x 軸方向に 100 の翻訳単位であり、y 方向では 80 単位です。</span><span class="sxs-lookup"><span data-stu-id="49c70-109">The world transformation of the <xref:System.Drawing.Graphics> object is a translation 100 units in the x direction and 80 units in the y direction.</span></span> <span data-ttu-id="49c70-110">コンテナーのワールド変換は、30 ° 回転します。</span><span class="sxs-lookup"><span data-stu-id="49c70-110">The world transformation of the container is a 30-degree rotation.</span></span> <span data-ttu-id="49c70-111">呼び出しは、コードは`DrawRectangle(pen, -60, -30, 120, 60)`2 回クリックします。</span><span class="sxs-lookup"><span data-stu-id="49c70-111">The code makes the call `DrawRectangle(pen, -60, -30, 120, 60)` twice.</span></span> <span data-ttu-id="49c70-112">最初に呼び出す<xref:System.Drawing.Graphics.DrawRectangle%2A>; コンテナー内の呼び出しは、呼び出しの間に<xref:System.Drawing.Graphics.BeginContainer%2A>と<xref:System.Drawing.Graphics.EndContainer%2A>です。</span><span class="sxs-lookup"><span data-stu-id="49c70-112">The first call to <xref:System.Drawing.Graphics.DrawRectangle%2A> is inside the container; that is, the call is in between the calls to <xref:System.Drawing.Graphics.BeginContainer%2A> and <xref:System.Drawing.Graphics.EndContainer%2A>.</span></span> <span data-ttu-id="49c70-113">2 番目の呼び出し<xref:System.Drawing.Graphics.DrawRectangle%2A>への呼び出し後は<xref:System.Drawing.Graphics.EndContainer%2A>します。</span><span class="sxs-lookup"><span data-stu-id="49c70-113">The second call to <xref:System.Drawing.Graphics.DrawRectangle%2A> is after the call to <xref:System.Drawing.Graphics.EndContainer%2A>.</span></span>  
  
 [!code-csharp[System.Drawing.MiscLegacyTopics#61](../../../../samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.MiscLegacyTopics/CS/Class1.cs#61)]
 [!code-vb[System.Drawing.MiscLegacyTopics#61](../../../../samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.MiscLegacyTopics/VB/Class1.vb#61)]  
  
 <span data-ttu-id="49c70-114">上記のコードでは、コンテナー内から描画する四角形が最初に変換 (回転) コンテナーのワールド変換とのワールド変換、<xref:System.Drawing.Graphics>オブジェクト (変換)。</span><span class="sxs-lookup"><span data-stu-id="49c70-114">In the preceding code, the rectangle drawn from inside the container is transformed first by the world transformation of the container (rotation) and then by the world transformation of the <xref:System.Drawing.Graphics> object (translation).</span></span> <span data-ttu-id="49c70-115">ワールド変換でのみ、コンテナーの外部から描画された四角形を変換、<xref:System.Drawing.Graphics>オブジェクト (変換)。</span><span class="sxs-lookup"><span data-stu-id="49c70-115">The rectangle drawn from outside the container is transformed only by the world transformation of the <xref:System.Drawing.Graphics> object (translation).</span></span> <span data-ttu-id="49c70-116">次の図は、次の 2 つの四角形を示します。</span><span class="sxs-lookup"><span data-stu-id="49c70-116">The following illustration shows the two rectangles.</span></span>  
  
 <span data-ttu-id="49c70-117">![コンテナーを入れ子になった](../../../../docs/framework/winforms/advanced/media/csnestedcontainers1.png "csnestedcontainers1")</span><span class="sxs-lookup"><span data-stu-id="49c70-117">![Nested Containers](../../../../docs/framework/winforms/advanced/media/csnestedcontainers1.png "csnestedcontainers1")</span></span>  
  
## <a name="clipping-in-nested-containers"></a><span data-ttu-id="49c70-118">入れ子になったコンテナー内の領域</span><span class="sxs-lookup"><span data-stu-id="49c70-118">Clipping in Nested Containers</span></span>  
 <span data-ttu-id="49c70-119">次の例では、入れ子になったコンテナー クリッピング領域を処理します。</span><span class="sxs-lookup"><span data-stu-id="49c70-119">The following example demonstrates how nested containers handle clipping regions.</span></span> <span data-ttu-id="49c70-120">このコードを作成、<xref:System.Drawing.Graphics>オブジェクトとそのコンテナー<xref:System.Drawing.Graphics>オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="49c70-120">The code creates a <xref:System.Drawing.Graphics> object and a container within that <xref:System.Drawing.Graphics> object.</span></span> <span data-ttu-id="49c70-121">クリッピング領域、<xref:System.Drawing.Graphics>オブジェクトは、四角形であり、コンテナーのクリッピング領域は楕円を描画します。</span><span class="sxs-lookup"><span data-stu-id="49c70-121">The clipping region of the <xref:System.Drawing.Graphics> object is a rectangle, and the clipping region of the container is an ellipse.</span></span> <span data-ttu-id="49c70-122">2 つの呼び出しは、コードは、<xref:System.Drawing.Graphics.DrawLine%2A>メソッドです。</span><span class="sxs-lookup"><span data-stu-id="49c70-122">The code makes two calls to the <xref:System.Drawing.Graphics.DrawLine%2A> method.</span></span> <span data-ttu-id="49c70-123">最初の呼び出し<xref:System.Drawing.Graphics.DrawLine%2A>、コンテナー、および 2 番目の呼び出し内部にある<xref:System.Drawing.Graphics.DrawLine%2A>がコンテナーの範囲外です (呼び出しの後に<xref:System.Drawing.Graphics.EndContainer%2A>)。</span><span class="sxs-lookup"><span data-stu-id="49c70-123">The first call to <xref:System.Drawing.Graphics.DrawLine%2A> is inside the container, and the second call to <xref:System.Drawing.Graphics.DrawLine%2A> is outside the container (after the call to <xref:System.Drawing.Graphics.EndContainer%2A>).</span></span> <span data-ttu-id="49c70-124">最初の行が 2 つのクリッピング領域の交差点で切り取られます。</span><span class="sxs-lookup"><span data-stu-id="49c70-124">The first line is clipped by the intersection of the two clipping regions.</span></span> <span data-ttu-id="49c70-125">2 番目の行はの四角形のクリッピング領域によってのみクリップ、<xref:System.Drawing.Graphics>オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="49c70-125">The second line is clipped only by the rectangular clipping region of the <xref:System.Drawing.Graphics> object.</span></span>  
  
 [!code-csharp[System.Drawing.MiscLegacyTopics#62](../../../../samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.MiscLegacyTopics/CS/Class1.cs#62)]
 [!code-vb[System.Drawing.MiscLegacyTopics#62](../../../../samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.MiscLegacyTopics/VB/Class1.vb#62)]  
  
 <span data-ttu-id="49c70-126">次の図は、次の 2 つのクリップされた行を示します。</span><span class="sxs-lookup"><span data-stu-id="49c70-126">The following illustration shows the two clipped lines.</span></span>  
  
 <span data-ttu-id="49c70-127">![コンテナーを入れ子になった](../../../../docs/framework/winforms/advanced/media/nestedcontainers2.png "nestedcontainers2")</span><span class="sxs-lookup"><span data-stu-id="49c70-127">![Nested Container](../../../../docs/framework/winforms/advanced/media/nestedcontainers2.png "nestedcontainers2")</span></span>  
  
 <span data-ttu-id="49c70-128">2 つの例のように変換およびクリッピング領域は入れ子になったコンテナーに累積されます。</span><span class="sxs-lookup"><span data-stu-id="49c70-128">As the two preceding examples show, transformations and clipping regions are cumulative in nested containers.</span></span> <span data-ttu-id="49c70-129">コンテナーのワールド変換を設定した場合、<xref:System.Drawing.Graphics>オブジェクトの両方の変換は、コンテナー内から描画された項目に適用されます。</span><span class="sxs-lookup"><span data-stu-id="49c70-129">If you set the world transformations of the container and the <xref:System.Drawing.Graphics> object, both transformations will apply to items drawn from inside the container.</span></span> <span data-ttu-id="49c70-130">コンテナーの変換はされ、適用されている最初の変換、<xref:System.Drawing.Graphics>オブジェクトが適用されます。</span><span class="sxs-lookup"><span data-stu-id="49c70-130">The transformation of the container will be applied first, and the transformation of the <xref:System.Drawing.Graphics> object will be applied second.</span></span> <span data-ttu-id="49c70-131">コンテナーのクリッピング領域を設定した場合、<xref:System.Drawing.Graphics>オブジェクト、2 つのクリッピング領域の交差部分では、コンテナー内から描画された項目、クリップされます。</span><span class="sxs-lookup"><span data-stu-id="49c70-131">If you set the clipping regions of the container and the <xref:System.Drawing.Graphics> object, items drawn from inside the container will be clipped by the intersection of the two clipping regions.</span></span>  
  
## <a name="quality-settings-in-nested-containers"></a><span data-ttu-id="49c70-132">入れ子になったコンテナーの画質の設定</span><span class="sxs-lookup"><span data-stu-id="49c70-132">Quality Settings in Nested Containers</span></span>  
 <span data-ttu-id="49c70-133">品質の設定 (<xref:System.Drawing.Graphics.SmoothingMode%2A>、<xref:System.Drawing.Graphics.TextRenderingHint%2A>など) では入れ子になったコンテナーは累積されません。 代わりに、コンテナーの品質設定を一時的に交換の品質設定、<xref:System.Drawing.Graphics>オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="49c70-133">Quality settings (<xref:System.Drawing.Graphics.SmoothingMode%2A>, <xref:System.Drawing.Graphics.TextRenderingHint%2A>, and the like) in nested containers are not cumulative; rather, the quality settings of the container temporarily replace the quality settings of a <xref:System.Drawing.Graphics> object.</span></span> <span data-ttu-id="49c70-134">新しいコンテナーを作成するときに、そのコンテナーの品質設定は、既定値に設定されます。</span><span class="sxs-lookup"><span data-stu-id="49c70-134">When you create a new container, the quality settings for that container are set to default values.</span></span> <span data-ttu-id="49c70-135">たとえば、ある場合、<xref:System.Drawing.Graphics>のスムージング モードを使ってオブジェクト<xref:System.Drawing.Drawing2D.SmoothingMode.AntiAlias>です。</span><span class="sxs-lookup"><span data-stu-id="49c70-135">For example, suppose you have a <xref:System.Drawing.Graphics> object with a smoothing mode of <xref:System.Drawing.Drawing2D.SmoothingMode.AntiAlias>.</span></span> <span data-ttu-id="49c70-136">コンテナーを作成するときに、コンテナー内のスムージング モードは既定のスムージング モードです。</span><span class="sxs-lookup"><span data-stu-id="49c70-136">When you create a container, the smoothing mode inside the container is the default smoothing mode.</span></span> <span data-ttu-id="49c70-137">自由に、コンテナーのスムージング モードを設定し、設定されているモードに従って、コンテナー内から描画された任意の項目を描画するか。</span><span class="sxs-lookup"><span data-stu-id="49c70-137">You are free to set the smoothing mode of the container, and any items drawn from inside the container will be drawn according to the mode you set.</span></span> <span data-ttu-id="49c70-138">呼び出しの後に描画された項目<xref:System.Drawing.Graphics.EndContainer%2A>スムージング モードに基づいて描画されます (<xref:System.Drawing.Drawing2D.SmoothingMode.AntiAlias>) を呼び出す前に有効になっていたを<xref:System.Drawing.Graphics.BeginContainer%2A>です。</span><span class="sxs-lookup"><span data-stu-id="49c70-138">Items drawn after the call to <xref:System.Drawing.Graphics.EndContainer%2A> will be drawn according to the smoothing mode (<xref:System.Drawing.Drawing2D.SmoothingMode.AntiAlias>) that was in place before the call to <xref:System.Drawing.Graphics.BeginContainer%2A>.</span></span>  
  
## <a name="several-layers-of-nested-containers"></a><span data-ttu-id="49c70-139">入れ子になったコンテナーの複数のレイヤー</span><span class="sxs-lookup"><span data-stu-id="49c70-139">Several Layers of Nested Containers</span></span>  
 <span data-ttu-id="49c70-140">1 つのコンテナーに限定されない、<xref:System.Drawing.Graphics>オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="49c70-140">You are not limited to one container in a <xref:System.Drawing.Graphics> object.</span></span> <span data-ttu-id="49c70-141">コンテナーのシーケンスを作成することができます、それぞれ、上記の入れ子になったおよびワールド変換、クリッピング領域、およびその入れ子になったコンテナーのそれぞれの品質設定を指定することができます。</span><span class="sxs-lookup"><span data-stu-id="49c70-141">You can create a sequence of containers, each nested in the preceding, and you can specify the world transformation, clipping region, and quality settings of each of those nested containers.</span></span> <span data-ttu-id="49c70-142">メソッドを呼び出す場合、描画から最も内側のコンテナー、変換は、最も外側のコンテナーで最も内側のコンテナーで開始および終了の順序で適用されます。</span><span class="sxs-lookup"><span data-stu-id="49c70-142">If you call a drawing method from inside the innermost container, the transformations will be applied in order, starting with the innermost container and ending with the outermost container.</span></span> <span data-ttu-id="49c70-143">最も内側のコンテナーから描画された項目は、すべてのクリッピング領域の交差点でクリッピングされます。</span><span class="sxs-lookup"><span data-stu-id="49c70-143">Items drawn from inside the innermost container will be clipped by the intersection of all the clipping regions.</span></span>  
  
 <span data-ttu-id="49c70-144">次の例を作成、<xref:System.Drawing.Graphics>オブジェクトし、レンダリングのヒントをテキストに設定<xref:System.Drawing.Drawing2D.SmoothingMode.AntiAlias>です。</span><span class="sxs-lookup"><span data-stu-id="49c70-144">The following example creates a <xref:System.Drawing.Graphics> object and sets its text rendering hint to <xref:System.Drawing.Drawing2D.SmoothingMode.AntiAlias>.</span></span> <span data-ttu-id="49c70-145">コードでは、いずれかの入れ子、他の 2 つのコンテナーを作成します。</span><span class="sxs-lookup"><span data-stu-id="49c70-145">The code creates two containers, one nested within the other.</span></span> <span data-ttu-id="49c70-146">外側のコンテナーのテキスト レンダリングのヒントに設定されている<xref:System.Drawing.Text.TextRenderingHint.SingleBitPerPixel>、内側のコンテナーのテキスト レンダリングのヒントに設定されていると<xref:System.Drawing.Drawing2D.SmoothingMode.AntiAlias>です。</span><span class="sxs-lookup"><span data-stu-id="49c70-146">The text rendering hint of the outer container is set to <xref:System.Drawing.Text.TextRenderingHint.SingleBitPerPixel>, and the text rendering hint of the inner container is set to <xref:System.Drawing.Drawing2D.SmoothingMode.AntiAlias>.</span></span> <span data-ttu-id="49c70-147">コードは、3 つの文字列を描画: から内側のコンテナー、外側のコンテナーから、1 つから 1 つ、<xref:System.Drawing.Graphics>オブジェクト自体です。</span><span class="sxs-lookup"><span data-stu-id="49c70-147">The code draws three strings: one from the inner container, one from the outer container, and one from the <xref:System.Drawing.Graphics> object itself.</span></span>  
  
 [!code-csharp[System.Drawing.MiscLegacyTopics#63](../../../../samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.MiscLegacyTopics/CS/Class1.cs#63)]
 [!code-vb[System.Drawing.MiscLegacyTopics#63](../../../../samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.MiscLegacyTopics/VB/Class1.vb#63)]  
  
 <span data-ttu-id="49c70-148">次の図は、3 つの文字列を示します。</span><span class="sxs-lookup"><span data-stu-id="49c70-148">The following illustration shows the three strings.</span></span> <span data-ttu-id="49c70-149">描画および内側のコンテナーから、文字列、<xref:System.Drawing.Graphics>によってオブジェクトが滑らかにします。</span><span class="sxs-lookup"><span data-stu-id="49c70-149">The strings drawn from the inner container and from the <xref:System.Drawing.Graphics> object are smoothed by antialiasing.</span></span> <span data-ttu-id="49c70-150">外側のコンテナーから描画された文字列がによって滑らかになっているため、<xref:System.Drawing.Graphics.TextRenderingHint%2A>プロパティに設定されている<xref:System.Drawing.Text.TextRenderingHint.SingleBitPerPixel>です。</span><span class="sxs-lookup"><span data-stu-id="49c70-150">The string drawn from the outer container is not smoothed by antialiasing because the <xref:System.Drawing.Graphics.TextRenderingHint%2A> property is set to <xref:System.Drawing.Text.TextRenderingHint.SingleBitPerPixel>.</span></span>  
  
 <span data-ttu-id="49c70-151">![コンテナーを入れ子になった](../../../../docs/framework/winforms/advanced/media/nestedcontainers3.png "nestedcontainers3")</span><span class="sxs-lookup"><span data-stu-id="49c70-151">![Nested Containers](../../../../docs/framework/winforms/advanced/media/nestedcontainers3.png "nestedcontainers3")</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="49c70-152">関連項目</span><span class="sxs-lookup"><span data-stu-id="49c70-152">See Also</span></span>  
 <xref:System.Drawing.Graphics>  
 [<span data-ttu-id="49c70-153">Graphics オブジェクトの状態の管理</span><span class="sxs-lookup"><span data-stu-id="49c70-153">Managing the State of a Graphics Object</span></span>](../../../../docs/framework/winforms/advanced/managing-the-state-of-a-graphics-object.md)
