---
title: "ラッパー コードの保護"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- security [.NET Framework], wrapper code
- wrapper code, securing
- secure coding, wrapper code
- code security, wrapper code
ms.assetid: 1df6c516-5bba-48bd-b450-1070e04b7389
caps.latest.revision: "11"
author: mairaw
ms.author: mairaw
manager: wpickett
ms.workload: dotnet
ms.openlocfilehash: 5e29a2bdd0bfa338d0266c0841e11aa2ac366529
ms.sourcegitcommit: 16186c34a957fdd52e5db7294f291f7530ac9d24
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/22/2017
---
# <a name="securing-wrapper-code"></a>ラッパー コードの保護
[!INCLUDE[net_security_note](../../../includes/net-security-note-md.md)]  
  
 ラッパー コードで、使用しているコードよりもラッパーの信頼が高い場合には特に、特有のセキュリティ脆弱性が生じる恐れがあります。 呼び出し元の制限されたアクセス許可が適切なセキュリティ チェックに含まれないと、呼び出し元のために実行されるすべての処理が、悪用される可能性のある潜在的な脆弱性となります。  
  
 呼び出し元自体で実行できない処理をラッパーによって行うことがないようにしてください。 完全なスタック ウォーク要求とは対照的に、限定的なセキュリティ チェックしか行われずに何らかの処理が行われる場合に、この状況は特に危険です。 単一レベルのチェックが行われる場合、実際の呼び出し元と対象の API 要素との間にラッパー コードを挿入することによって、本来は成功すべきではないセキュリティ チェックが簡単に成功してしまう原因となる可能性があり、セキュリティが弱体化します。  
  
## <a name="delegates"></a>デリゲート  
 デリゲートのセキュリティは、.NET Framework のバージョンによって異なります。  このセクションでは、各種デリゲートの動作と、関連するセキュリティ上の考慮事項について説明します。  
  
### <a name="in-version-10-and-11-of-the-net-framework"></a>.NET Framework バージョン 1.0 および 1.1 の場合  
 .NET Framework バージョン 1.0 および 1.1 は、デリゲートの作成者とデリゲートの呼び出し元に対して、次のセキュリティ アクションを実行します。  
  
-   デリゲートが作成されると、デリゲート対象メソッドのセキュリティ リンク要求が、デリゲート作成者の許可セットに対して実行されます。  セキュリティ アクションを満たすことができないと、<xref:System.Security.SecurityException> が結果として生じます。  
  
-   デリゲートが呼び出されると、デリゲート呼び出し元の既存のセキュリティ要求が実行されます。  
  
 ご使用のコードで <xref:System.Delegate> を取得するときに、それを呼び出すことができる信頼性の低いコードから取得する場合には、その信頼性の低いコードによってアクセス許可がエスカレートされることがないようにしてください。 デリゲートを取得して後ほど使用するとき、デリゲートを作成したコードは呼び出しスタック上にはなく、デリゲートのコードまたはデリゲートを行うコードが保護された操作を試みる場合にアクセス許可がテストされないことになります。 ご使用のコードと呼び出し元のコードに作成者よりも高い特権がある場合、作成者は呼び出しスタックの一部になることなく、呼び出しパスを編成できます。  
  
### <a name="in-version-20-and-later-versions-of-the-net-framework"></a>バージョン 2.0 および .NET Framework の以降のバージョン  
 以前のバージョンとは異なりバージョン 2.0 と .NET Framework の以降のバージョンを実行、デリゲート作成者に対してセキュリティ アクション デリゲートが作成され、呼び出されるとします。  
  
-   デリゲートが作成されると、デリゲート対象メソッドのセキュリティ リンク要求が、デリゲート作成者の許可セットに対して実行されます。  セキュリティ アクションを満たすことができないと、<xref:System.Security.SecurityException> が結果として生じます。  
  
-   デリゲート作成時に、デリゲート作成者の許可セットも取得され、デリゲートと一緒に格納されます。  
  
-   デリゲートが呼び出されると、デリゲート作成者と呼び出し元が属するアセンブリが異なる場合には、現在のコンテキストの任意の要求に対して、デリゲート作成者の取得された許可セットが最初に評価されます。  次に、デリゲート呼び出し元の既存のセキュリティ要求が実行されます。  
  
## <a name="link-demands-and-wrappers"></a>リンク要求とラッパー  
 リンク要求に関する特別な保護がセキュリティ インフラストラクチャで強化されましたが、依然としてコード内で脆弱性の原因となる可能性があります。  
  
 完全に信頼されたコードは、プロパティ、イベント、またはによって保護されているメソッドを呼び出す場合、 [LinkDemand](../../../docs/framework/misc/link-demands.md)場合、呼び出しが成功した、 **LinkDemand**呼び出し元の権限チェックが満たしています。 さらに、完全に信頼されたコードがクラスを公開している場合を受け取る、プロパティの名前、および呼び出し、**取得**アクセサーへの呼び出し、リフレクションを使用して、**取得**いなくても、ユーザー コードではアクセサーは成功このプロパティにアクセスする権限を持っていません。 これは、ため、 **LinkDemand**のみ直前の呼び出し元を完全に信頼されたコードを確認します。 基本的に、完全に信頼できるコードは、ユーザー コードに代わって呼び出す権限があり、その際、ユーザー コードに呼び出すための権限があるかどうかの確認は行いません。  
  
 このようなセキュリティ ホールを防ぐため、共通言語ランタイム拡張メソッド、コンス トラクター、プロパティ、またはによって保護されているイベントに対する間接呼び出しの完全なスタックのウォーク要求にチェック、 **LinkDemand**です。 この保護により若干のパフォーマンス コストが発生し、セキュリティ チェックのセマンティクスが変更されます。より高速な単一レベルのチェックに合格していた場合にも完全なスタック ウォーク要求が失敗する可能性があります。  
  
## <a name="assembly-loading-wrappers"></a>アセンブリ読み込みラッパー  
 マネージ コードの読み込みに使用されるいくつかのメソッド (<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> など) は、呼び出し元の証拠に基づいてアセンブリを読み込みます。 これらのメソッドのいずれかをラップする場合、セキュリティ システムがアセンブリを読み込むとき、ラッパーに対する呼び出し元のアクセス許可ではなく、ご使用のコードのアクセス許可を使用できることがあります。 信頼性の低いコードに対して、ラッパーへの呼び出し元のアクセス許可より高いアクセス許可が付与されているコードの読み込みを許可しないでください。  
  
 完全な信頼のあるコード、または潜在的な呼び出し元 (インターネット アクセス許可レベルの呼び出し元など) よりも信頼が高いコードであっても、こうした方法でセキュリティが弱体化する可能性があります。 コードをバイト配列を受け取るに渡すパブリック メソッドがある場合**Assembly.Load**これにより、アセンブリを作成する、呼び出し元の代わりに、セッキュリティが破らその可能性があります。  
  
 この問題は、次の API 要素に当てはまります。  
  
-   <xref:System.AppDomain.DefineDynamicAssembly%2A?displayProperty=nameWithType>  
  
-   <xref:System.AppDomain.Load%2A?displayProperty=nameWithType>  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>  
  
-   <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>  
  
## <a name="demand-vs-linkdemand"></a>Demand とLinkDemand  
 宣言型セキュリティには 2 種類のセキュリティ チェックがあり、どちらも似ていますが、実行するチェックがかなり異なります。 選択を誤るとセキュリティの脆弱性やパフォーマンスの低下を招くことがあるため、両方の形式について理解する必要があります。  
  
 宣言型のセキュリティには、次のセキュリティ チェックがあります。  
  
-   <xref:System.Security.Permissions.SecurityAction.Demand> はコード アクセス セキュリティのスタック ウォークを指定します。 スタック上の各呼び出し元が合格するには、指定のアクセス許可または ID が必要です。 **必要に応じて**スタックは異なる呼び出し元を含めることがあるために、呼び出しごとに生じます。 メソッドを繰り返し呼び出す場合は、このセキュリティ チェックが毎回行われます。 **必要に応じて**おびき寄せによる攻撃に対して優れた保護とは、これを使用して取得しようとしています。 未承認のコードが検出されます。  
  
-   [LinkDemand](../../../docs/framework/misc/link-demands.md) ・ イン タイム (JIT) コンパイル時に発生し、直前の呼び出し元のみをチェックします。 このセキュリティ チェックでは、呼び出し元の呼び出し元はチェックされません。 このチェックに合格すると、呼び出し元が何度も呼び出す場合であってもさらにセキュリティ オーバーヘッドが生じることはありません。 ただし、おびき寄せによる攻撃からの保護機能はありません。 **LinkDemand**テストに成功し、コードを参照するすべてのコードを呼び出す権限のあるコードを使用して悪意のあるコードを許可することでセキュリティ使用できなくなる可能性ことができます。 したがって、使用しないで**LinkDemand**可能なすべての脆弱性を完全に回避できる場合を除き、します。  
  
    > [!NOTE]
    >  [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)]、リンク確認要求に置換された、<xref:System.Security.SecurityCriticalAttribute>属性<xref:System.Security.SecurityRuleSet.Level2>アセンブリ。 <xref:System.Security.SecurityCriticalAttribute>は完全な信頼のリンク要求に相当ただし、継承ルールにも影響します。 この変更の詳細については、次を参照してください。[透過的セキュリティ コード、レベル 2](../../../docs/framework/misc/security-transparent-code-level-2.md)です。  
  
 使用する場合に必要な特別な措置**LinkDemand**個別にプログラミングする必要があります。 適用に役立つセキュリティ システムのことができます。 どのようなミスもセキュリティを脆弱化します。 作成したコードを使用する、承認されたすべてのコード側で、次の措置を行うことによって追加セキュリティを実装する責任があります。  
  
-   呼び出し元のコードがクラスまたはアセンブリにアクセスするのを制限します。  
  
-   呼び出されるコードに現れる呼び出し元のコードで同じセキュリティ チェックを配置し、呼び出し元にその実行義務を課します。 たとえば、メソッドを呼び出すコードを記述する場合で保護されている、 **LinkDemand**の<xref:System.Security.Permissions.SecurityPermission>で、<xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode>フラグが指定の方法も確認してください、 **LinkDemand** (または**デマンド**より強力な) このアクセス許可。 例外は、コードが使用するかどうか、 **LinkDemand**-と判断した限定された方法で保護されたメソッドは、安全なコード内の他のセキュリティ保護機能 (demand など) を指定します。 前述の例外的なケースでは、呼び出し側で、基になるコードでのセキュリティ保護の脆弱性に対処する必要があります。  
  
-   呼び出し元のコードが、呼び出し先のコードに成り代わって、保護されているコードを呼び出すことがないようにしてください。 つまり、呼び出し元は承認されたコードに対して、保護されているコードに特定のパラメーターを渡したり、結果を送り返させたりすることはできません。  
  
### <a name="interfaces-and-link-demands"></a>インターフェイスとリンク要求  
 仮想メソッド、プロパティ、またはイベントと場合**LinkDemand**基底クラス メソッドをオーバーライドし、基本クラスのメソッドも必要があります、同じ**LinkDemand**有効にするために、オーバーライド対象メソッドの。 悪意のあるコードが、基本型にキャスト バックを行い、基本クラスのメソッドを呼び出す可能性があります。 リンク要求を、<xref:System.Security.AllowPartiallyTrustedCallersAttribute> アセンブリ レベル属性を持たないアセンブリに暗黙的に追加できるという点にも注意してください。  
  
 インターフェイス メソッドでリンク要求も指定されている場合は、メソッドの実装をリンク要求で保護するのは良い方法です。 リンク要求をインターフェイスと一緒に使用する場合、以下の点に注意してください。  
  
-   配置した場合、 **LinkDemand** 、インターフェイス メソッドを実装するクラスのパブリック メソッドで、 **LinkDemand**インターフェイスにキャストし、メソッドを呼び出す場合は適用されません。 この場合、インターフェイスに対してリンクされているため、 **LinkDemand**インターフェイスでは受け入れられます。  
  
 セキュリティの問題に関して次の項目をレビューします。  
  
-   インターフェイス メソッドでのリンク要求を明示的に指定します。 こうしたリンク要求が期待どおりの保護を提供することを確認します。 悪意のあるコードがキャストを使用して、前述のようにリンク要求を迂回できるかどうかを判別します。  
  
-   リンク要求が適用される仮想メソッド。  
  
-   実装する型とインターフェイス。 一貫してリンク要求を使用する必要があります。  
  
## <a name="see-also"></a>参照  
 [安全なコーディングのガイドライン](../../../docs/standard/security/secure-coding-guidelines.md)
