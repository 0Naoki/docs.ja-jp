---
title: "ラッパー コードの保護 | Microsoft Docs"
ms.custom: ""
ms.date: "03/30/2017"
ms.prod: ".net-framework"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "dotnet-clr"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "VB"
  - "CSharp"
  - "C++"
  - "jsharp"
helpviewer_keywords: 
  - "コード セキュリティ, ラッパー コード"
  - "安全なコーディング, ラッパー コード"
  - "セキュリティ [.NET Framework], ラッパー コード"
  - "ラッパー コード, セキュリティ"
ms.assetid: 1df6c516-5bba-48bd-b450-1070e04b7389
caps.latest.revision: 11
author: "mairaw"
ms.author: "mairaw"
manager: "wpickett"
caps.handback.revision: 9
---
# ラッパー コードの保護
ラッパー コードで、使用しているコードよりもラッパーの信頼が高い場合には特に、特有のセキュリティ脆弱性が生じる恐れがあります。 呼び出し元の制限されたアクセス許可が適切なセキュリティ チェックに含まれないと、呼び出し元のために実行されるすべての処理が、悪用される可能性のある潜在的な脆弱性となります。  
  
 呼び出し元自体で実行できない処理をラッパーによって行うことがないようにしてください。 完全なスタック ウォーク要求とは対照的に、限定的なセキュリティ チェックしか行われずに何らかの処理が行われる場合に、この状況は特に危険です。 単一レベルのチェックが行われる場合、実際の呼び出し元と対象の API 要素との間にラッパー コードを挿入することによって、本来は成功すべきではないセキュリティ チェックが簡単に成功してしまう原因となる可能性があり、セキュリティが弱体化します。  
  
> [!CAUTION]
>  コード アクセス セキュリティと部分的に信頼できるコード  
>   
>  .NET Framework には、コード アクセス セキュリティ \(CAS\) と呼ばれる、同一アプリケーションで実行される各種コードにさまざまな信頼レベルを強制的に適用するメカニズムが備わっています。  .NET Framework におけるコード アクセス セキュリティを、部分的に信頼できるコード、特に発生元の不明なコードのセキュリティ境界として使用しないでください。 発生元の不明なコードの読み込みと実行に関しては、他のセキュリティ対策を適切に導入することなく行わないようにしてください。  
>   
>  このポリシーは .NET Framework のすべてのバージョンに適用されますが、Silverlight に含まれる .NET Framework には適用されません。  
  
## デリゲート  
 デリゲートのセキュリティは、.NET Framework のバージョンによって異なります。  このセクションでは、各種デリゲートの動作と、関連するセキュリティ上の考慮事項について説明します。  
  
### .NET Framework バージョン 1.0 および 1.1 の場合  
 .NET Framework バージョン 1.0 および 1.1 は、デリゲートの作成者とデリゲートの呼び出し元に対して、次のセキュリティ アクションを実行します。  
  
-   デリゲートが作成されると、デリゲート対象メソッドのセキュリティ リンク要求が、デリゲート作成者の許可セットに対して実行されます。  セキュリティ アクションを満たすことができないと、<xref:System.Security.SecurityException> が結果として生じます。  
  
-   デリゲートが呼び出されると、デリゲート呼び出し元の既存のセキュリティ要求が実行されます。  
  
 ご使用のコードで <xref:System.Delegate> を取得するときに、それを呼び出すことができる信頼性の低いコードから取得する場合には、その信頼性の低いコードによってアクセス許可がエスカレートされることがないようにしてください。 デリゲートを取得して後ほど使用するとき、デリゲートを作成したコードは呼び出しスタック上にはなく、デリゲートのコードまたはデリゲートを行うコードが保護された操作を試みる場合にアクセス許可がテストされないことになります。 ご使用のコードと呼び出し元のコードに作成者よりも高い特権がある場合、作成者は呼び出しスタックの一部になることなく、呼び出しパスを編成できます。  
  
### .NET Framework バージョン 2.0 以降の場合  
 .NET Framework version 2.0 ではそれより前のバージョンとは異なり、デリゲートが作成されて呼び出されるときに、デリゲート作成者に対してセキュリティ アクションを実行します。  
  
-   デリゲートが作成されると、デリゲート対象メソッドのセキュリティ リンク要求が、デリゲート作成者の許可セットに対して実行されます。  セキュリティ アクションを満たすことができないと、<xref:System.Security.SecurityException> が結果として生じます。  
  
-   デリゲート作成時に、デリゲート作成者の許可セットも取得され、デリゲートと一緒に格納されます。  
  
-   デリゲートが呼び出されると、デリゲート作成者と呼び出し元が属するアセンブリが異なる場合には、現在のコンテキストの任意の要求に対して、デリゲート作成者の取得された許可セットが最初に評価されます。  次に、デリゲート呼び出し元の既存のセキュリティ要求が実行されます。  
  
## リンク要求とラッパー  
 リンク要求に関する特別な保護がセキュリティ インフラストラクチャで強化されましたが、依然としてコード内で脆弱性の原因となる可能性があります。  
  
 完全に信頼されるコードが、[LinkDemand](../../../docs/framework/misc/link-demands.md) によって保護されているプロパティ、イベント、メソッドを呼び出す場合、呼び出し元の **LinkDemand** アクセス許可チェックを満たしているとその呼び出しは成功します。 さらに、完全に信頼されるコードがプロパティ名を取るクラスを公開し、リフレクションを使用して**get** アクセサーを呼び出すと、**get** アクセサーに対する呼び出しは、ユーザー コードにこのプロパティにアクセスする権限がない場合であっても成功します。 これは、**LinkDemand** がチェックするのは、完全に信頼できるコードである直接の呼び出し元だけであることに起因します。 基本的に、完全に信頼できるコードは、ユーザー コードに代わって呼び出す権限があり、その際、ユーザー コードに呼び出すための権限があるかどうかの確認は行いません。  
  
 こうしたセキュリティ ホールを回避するには、共通言語ランタイムによるチェックを、**LinkDemand** によって保護されているメソッド、コンストラクター、プロパティ、イベントに対する間接呼び出しの完全なスタック ウォーク要求へと拡張します。 この保護により若干のパフォーマンス コストが発生し、セキュリティ チェックのセマンティクスが変更されます。より高速な単一レベルのチェックに合格していた場合にも完全なスタック ウォーク要求が失敗する可能性があります。  
  
> [!NOTE]
>  [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)] では、部分的に信頼されるコードが透過コードとして再定義されました。 透過性モデルは、ネイティブ コードの呼び出しなどの特権的な処理を実行できるコード \(重要なコード\) と、そのような処理を実行できないコード \(透過的なコード\) との間に、障壁を設けます。 透過性では、<xref:System.Security.Permissions.SecurityAction> を使用する代わりに、完全な信頼に関して <xref:System.Security.SecurityCriticalAttribute> を用いて完全に信頼されるコードを特定します。 この変更およびその他の変更の詳細については、「[セキュリティの変更点](../../../docs/framework/security/security-changes.md)」を参照してください。  
  
## アセンブリ読み込みラッパー  
 マネージ コードの読み込みに使用されるいくつかのメソッド \(<xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> など\) は、呼び出し元の証拠に基づいてアセンブリを読み込みます。 これらのメソッドのいずれかをラップする場合、セキュリティ システムがアセンブリを読み込むとき、ラッパーに対する呼び出し元のアクセス許可ではなく、ご使用のコードのアクセス許可を使用できることがあります。 信頼性の低いコードに対して、ラッパーへの呼び出し元のアクセス許可より高いアクセス許可が付与されているコードの読み込みを許可しないでください。  
  
 完全な信頼のあるコード、または潜在的な呼び出し元 \(インターネット アクセス許可レベルの呼び出し元など\) よりも信頼が高いコードであっても、こうした方法でセキュリティが弱体化する可能性があります。 コードに、バイト配列を取って、それを **Assembly.Load** に渡すパブリック メソッドが含まれる場合、そうした呼び出し元のためにアセンブリを作成すると、セッキュリティが破られる恐れがあります。  
  
 この問題は、次の API 要素に当てはまります。  
  
-   <xref:System.AppDomain.DefineDynamicAssembly%2A?displayProperty=fullName>  
  
-   <xref:System.AppDomain.Load%2A?displayProperty=fullName>  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=fullName>  
  
-   <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>  
  
## Demand とLinkDemand  
 宣言型セキュリティには 2 種類のセキュリティ チェックがあり、どちらも似ていますが、実行するチェックがかなり異なります。 選択を誤るとセキュリティの脆弱性やパフォーマンスの低下を招くことがあるため、両方の形式について理解する必要があります。  
  
 宣言型のセキュリティには、次のセキュリティ チェックがあります。  
  
-   <xref:System.Security.Permissions.SecurityAction> はコード アクセス セキュリティのスタック ウォークを指定します。 スタック上の各呼び出し元が合格するには、指定のアクセス許可または ID が必要です。 スタックには異なる呼び出し元が含まれている可能性があるため、**Demand** は呼び出しごとに生じます。 メソッドを繰り返し呼び出す場合は、このセキュリティ チェックが毎回行われます。**Demand** はおびき寄せによる攻撃に対して優れた保護となります。そうした攻撃によって送り込まれようとする未承認のコードが検出されます。  
  
-   [LinkDemand](../../../docs/framework/misc/link-demands.md) は JIT\(just\-in\-time\) コンパイル時に生じて、直接の呼び出し元だけをチェックします。 このセキュリティ チェックでは、呼び出し元の呼び出し元はチェックされません。 このチェックに合格すると、呼び出し元が何度も呼び出す場合であってもさらにセキュリティ オーバーヘッドが生じることはありません。 ただし、おびき寄せによる攻撃からの保護機能はありません。**LinkDemand** を使用すると、テストに合格し、ご使用のコードを参照可能なすべてのコードで、セキュリティが破られる可能性が生じます。つまり、悪意のあるコードに対して、承認済みのコードの呼び出しが許可される場合です。 そのため、可能性のあるすべての脆弱性を完全に回避できるのでない限り、**LinkDemand** を使用しないでください。  
  
    > [!NOTE]
    >  [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)] では、<xref:System.Security.SecurityRuleSet> アセンブリの <xref:System.Security.SecurityCriticalAttribute> 属性によってリンク要求が置換されています。<xref:System.Security.SecurityCriticalAttribute> は完全な信頼のリンク要求に相当しますが、継承ルールにも影響を及ぼします。 この変更の詳細については、「[透過的セキュリティ コード、レベル 2](../../../docs/framework/misc/security-transparent-code-level-2.md)」を参照してください。  
  
 **LinkDemand** を使用するときに必要な特別な措置は、個別にプログラミングする必要があります。セキュリティ システムを実施に役立てられることがあります。 どのようなミスもセキュリティを脆弱化します。 作成したコードを使用する、承認されたすべてのコード側で、次の措置を行うことによって追加セキュリティを実装する責任があります。  
  
-   呼び出し元のコードがクラスまたはアセンブリにアクセスするのを制限します。  
  
-   呼び出されるコードに現れる呼び出し元のコードで同じセキュリティ チェックを配置し、呼び出し元にその実行義務を課します。 たとえば、<xref:System.Security.Permissions.SecurityPermissionFlag> フラグを指定した <xref:System.Security.Permissions.SecurityPermission> に関して **LinkDemand** で保護されたメソッドを呼び出すコードを作成する場合、ご使用のメソッドもこのアクセス許可の **LinkDemand** \(またはより強力な **Demand**\) を実行する必要があります。 ただし、ご使用のコードで **LinkDemand** 保護されたメソッドを、安全だと判断した限定的な方法でのみ使用していて、コードに他のセキュリティ保護機能 \(Demand など\) がある場合は例外です。 前述の例外的なケースでは、呼び出し側で、基になるコードでのセキュリティ保護の脆弱性に対処する必要があります。  
  
-   呼び出し元のコードが、呼び出し先のコードに成り代わって、保護されているコードを呼び出すことがないようにしてください。 つまり、呼び出し元は承認されたコードに対して、保護されているコードに特定のパラメーターを渡したり、結果を送り返させたりすることはできません。  
  
### インターフェイスとリンク要求  
 **LinkDemand** を使用した仮想メソッド、プロパティ、イベントが基本クラス メソッドをオーバーライドする場合、オーバーライド対象メソッドで有効になるように、その基本クラス メソッドにも同じ **LinkDemand** が必要です。 悪意のあるコードが、基本型にキャスト バックを行い、基本クラスのメソッドを呼び出す可能性があります。 リンク要求を、<xref:System.Security.AllowPartiallyTrustedCallersAttribute> アセンブリ レベル属性を持たないアセンブリに暗黙的に追加できるという点にも注意してください。  
  
 インターフェイス メソッドでリンク要求も指定されている場合は、メソッドの実装をリンク要求で保護するのは良い方法です。 リンク要求をインターフェイスと一緒に使用する場合、以下の点に注意してください。  
  
-   **AllowPartiallyTrustedCallersAttribute** 属性はインターフェイスにも適用されます。  
  
-   リンク要求をインターフェイス上に配置することにより、**AllowPartiallyTrustedCallersAttribute** 属性を使用する場合など、部分的に信頼されるコードの使用から特定のインターフェイスを選択的に保護できます。  
  
-   使用しているインターフェイスが **AllowPartiallyTrustedCallersAttribute** 属性が含まれないアセンブリで定義されている場合、そのインターフェイスを部分的に信頼されるクラスで実装できます。  
  
-   インターフェイス メソッドを実装するクラスのパブリック メソッドに **LinkDemand** を配置すると、そのインターフェイスをキャストしてメソッドを呼び出すときに **LinkDemand** は実施されません。 この場合、インターフェイスに対してリンクされているため、インターフェイス上の **LinkDemand** のみが実行されます。  
  
 セキュリティの問題に関して次の項目を確認します。  
  
-   インターフェイス メソッドでのリンク要求を明示的に指定します。 こうしたリンク要求が期待どおりの保護を提供することを確認します。 悪意のあるコードがキャストを使用して、前述のようにリンク要求を迂回できるかどうかを判別します。  
  
-   リンク要求が適用される仮想メソッド。  
  
-   実装する型とインターフェイス。 一貫してリンク要求を使用する必要があります。  
  
## 参照  
 [安全なコーディングのガイドライン](../../../docs/standard/security/secure-coding-guidelines.md)