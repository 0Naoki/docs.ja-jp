---
title: "既定の XAML スキーマ コンテキストと WPF XAML スキーマ コンテキスト"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-wpf
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: 04e06a15-09b3-4210-9bdf-9a64c2eccb83
caps.latest.revision: "7"
author: wadepickett
ms.author: wpickett
manager: wpickett
ms.openlocfilehash: ccb89b67b222c11695131a1aa8423b89df1c9a70
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/18/2017
---
# <a name="default-xaml-schema-context-and-wpf-xaml-schema-context"></a><span data-ttu-id="447bd-102">既定の XAML スキーマ コンテキストと WPF XAML スキーマ コンテキスト</span><span class="sxs-lookup"><span data-stu-id="447bd-102">Default XAML Schema Context and WPF XAML Schema Context</span></span>
<span data-ttu-id="447bd-103">XAML スキーマ コンテキストが特定の XAML ボキャブラリを使用する XAML の運用環境が、オブジェクトの型マッピングが解決する方法、アセンブリが読み込まれているか、特定のリーダーとライターをなどの動作を記述とやり取りする方法を修飾するエンティティの概念設定が解釈されます。</span><span class="sxs-lookup"><span data-stu-id="447bd-103">A XAML schema context is a conceptual entity that qualifies how a XAML production that uses a particular XAML vocabulary interacts with the object writing behavior, including how type mapping resolves, how assemblies are loaded, how certain reader and writer settings are interpreted.</span></span> <span data-ttu-id="447bd-104">このトピックでは、.NET Framework XAML サービスと関連付けられている既定の XAML スキーマ コンテキスト、CLR の型システムに基づくの機能について説明します。</span><span class="sxs-lookup"><span data-stu-id="447bd-104">This topic describes the features of the .NET Framework XAML Services and the associated default XAML schema context, which is based on the CLR type system.</span></span> <span data-ttu-id="447bd-105">このトピックでは、WPF に使用される、XAML スキーマ コンテキストも説明します。</span><span class="sxs-lookup"><span data-stu-id="447bd-105">This topic also describes the XAML schema context that is used for WPF.</span></span>  
  
## <a name="default-xaml-schema-context"></a><span data-ttu-id="447bd-106">既定の XAML スキーマ コンテキスト</span><span class="sxs-lookup"><span data-stu-id="447bd-106">Default XAML Schema Context</span></span>  
 <span data-ttu-id="447bd-107">.NET framework XAML サービス 両方を実装し、既定の XAML スキーマ コンテキストを使用します。</span><span class="sxs-lookup"><span data-stu-id="447bd-107">.NET Framework XAML Services both implements and uses a default XAML schema context.</span></span> <span data-ttu-id="447bd-108">既定の XAML スキーマ コンテキストの動作が常の API で完全に表示されていない、<xref:System.Xaml.XamlSchemaContext>クラスです。</span><span class="sxs-lookup"><span data-stu-id="447bd-108">The default XAML schema context behavior is not always fully visible in the API of the <xref:System.Xaml.XamlSchemaContext> class.</span></span> <span data-ttu-id="447bd-109">ただし、多くの場合、既定の XAML スキーマ コンテキストに影響を与える動作は、観測可能なオブジェクトのメンバーなど、XAML 型システムの一般的な API を介して<xref:System.Xaml.XamlMember>または<xref:System.Xaml.XamlType>、または XAML リーダーと XAML ライターを使用しているので公開されている Api を使用既定の XAML スキーマ コンテキスト。</span><span class="sxs-lookup"><span data-stu-id="447bd-109">However, in many cases the behavior that the default XAML schema context influences is observable through common API of the XAML type system, such as members of <xref:System.Xaml.XamlMember> or <xref:System.Xaml.XamlType>, or through APIs exposed on XAML readers and XAML writers that are using the default XAML schema context.</span></span>  
  
 <span data-ttu-id="447bd-110">作成することができます、<xref:System.Xaml.XamlSchemaContext>呼び出すことによって、既定の動作をカプセル化する、<xref:System.Xaml.XamlSchemaContext>コンス トラクターです。</span><span class="sxs-lookup"><span data-stu-id="447bd-110">You can create a <xref:System.Xaml.XamlSchemaContext> that encapsulates the default behavior by calling the <xref:System.Xaml.XamlSchemaContext> constructor.</span></span> <span data-ttu-id="447bd-111">これにより、既定の XAML スキーマ コンテキストが明示的に作成されます。</span><span class="sxs-lookup"><span data-stu-id="447bd-111">This explicitly creates the default XAML schema context.</span></span> <span data-ttu-id="447bd-112">XAML リーダーまたは明示的に受け取らない Api を使用して XAML ライターを初期化する場合、同じ既定の XAML スキーマ コンテキストが暗黙的に、作成、<xref:System.Xaml.XamlSchemaContext>入力パラメーターです。</span><span class="sxs-lookup"><span data-stu-id="447bd-112">The same default XAML schema context is created implicitly, if you initialize a XAML reader or XAML writer using APIs that do not explicitly take a <xref:System.Xaml.XamlSchemaContext> input parameter.</span></span>  
  
 <span data-ttu-id="447bd-113">既定の XAML スキーマ コンテキストは、その型のマッピングの動作の CLR リフレクションに依存します。</span><span class="sxs-lookup"><span data-stu-id="447bd-113">The default XAML schema context relies on CLR reflection for its type mapping behavior.</span></span> <span data-ttu-id="447bd-114">これは、定義の CLR を調べることが含まれています。 <xref:System.Type>、および関連する<xref:System.Reflection.PropertyInfo>または<xref:System.Reflection.MethodInfo>です。</span><span class="sxs-lookup"><span data-stu-id="447bd-114">This includes examining the defining CLR <xref:System.Type>, and related <xref:System.Reflection.PropertyInfo> or <xref:System.Reflection.MethodInfo>.</span></span> <span data-ttu-id="447bd-115">また、型またはメンバーの CLR 属性は、XAML の型または型のバッキング CLR を使用して XAML メンバーの情報の詳細を入力するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="447bd-115">Also, CLR attribution on types or members is used in order to fill in the specifics for XAML type or XAML member information that uses the CLR backing type.</span></span> <span data-ttu-id="447bd-116">既定の XAML スキーマ コンテキストがなどの型システムの拡張機能の手法をしないため、`Invoker`パターン、CLR 型のシステムから、必要な情報があるためです。</span><span class="sxs-lookup"><span data-stu-id="447bd-116">The default XAML schema context does not require type system extension techniques such as the `Invoker` pattern, because the necessary information is available from the CLR type system.</span></span>  
  
 <span data-ttu-id="447bd-117">アセンブリのロジックを読み込み、既定の XAML スキーマ コンテキストは XAML 名前空間のマッピングで提供されるすべてのアセンブリ値に主に依存します。</span><span class="sxs-lookup"><span data-stu-id="447bd-117">For assembly loading logic, the default XAML schema context relies mainly on any assembly values provided in XAML namespace mappings.</span></span> <span data-ttu-id="447bd-118">また、<xref:System.Xaml.XamlReaderSettings.LocalAssembly%2A>アセンブリを読み込むには、内部型の読み込みなどのシナリオにヒントことができます。</span><span class="sxs-lookup"><span data-stu-id="447bd-118">Also, <xref:System.Xaml.XamlReaderSettings.LocalAssembly%2A> can hint an assembly to load, for scenarios such as loading internal types.</span></span>  
  
## <a name="wpf-xaml-schema-context"></a><span data-ttu-id="447bd-119">WPF XAML スキーマ コンテキスト</span><span class="sxs-lookup"><span data-stu-id="447bd-119">WPF XAML Schema Context</span></span>  
 <span data-ttu-id="447bd-120">WPF 実装には既定ではない XAML スキーマ コンテキストを実装することによってもたらされる機能の種類の興味深い例が用意されているために、WPF XAML スキーマ コンテキストはこのトピックで説明します。</span><span class="sxs-lookup"><span data-stu-id="447bd-120">The WPF XAML schema context is described in this topic because the WPF implementation provides an interesting illustration of the kinds of features that can be introduced by implementing a non-default XAML schema context.</span></span> <span data-ttu-id="447bd-121">また、XAML スキーマ コンテキストの概念では説明しません非常によく WPF XAML; に対応する WPF のドキュメントXAML スキーマ コンテキストが有効にする動作が完全に理解できるものの既定の XAML スキーマ コンテキストの動作方法の詳細については統合されている場合のみ可能性があります。</span><span class="sxs-lookup"><span data-stu-id="447bd-121">Also, the XAML schema context concept is not discussed very much in the WPF documentation that addresses WPF XAML; the behavior that the XAML schema context enables might only be fully understandable if integrated with a discussion of how the default XAML schema context works.</span></span> <span data-ttu-id="447bd-122">WPF XAML スキーマ コンテキストでは、次の動作を実装します。</span><span class="sxs-lookup"><span data-stu-id="447bd-122">The WPF XAML schema context implements the following behavior.</span></span>  
  
 <span data-ttu-id="447bd-123">**参照の上書き:** WPF が XAML のいくつかのコンテンツ モデルを持つが XAML のコンテンツ プロパティがない関数を<xref:System.Windows.Markup.ContentPropertyAttribute>に起因します。</span><span class="sxs-lookup"><span data-stu-id="447bd-123">**Lookup overrides:** WPF has a few content  models for XAML where there are XAML content properties that function without being <xref:System.Windows.Markup.ContentPropertyAttribute> attributed.</span></span> <span data-ttu-id="447bd-124"><xref:System.Xaml.XamlType.LookupContentProperty%2A>WPF の上書きは、この動作を実装します。</span><span class="sxs-lookup"><span data-stu-id="447bd-124"><xref:System.Xaml.XamlType.LookupContentProperty%2A> overrides for WPF implement this behavior.</span></span>  
  
 <span data-ttu-id="447bd-125">**WPF の式の遅延:** WPF ランタイム コンテキストが利用可能になるまでの値を遅らせる式クラスがいくつかの機能です。</span><span class="sxs-lookup"><span data-stu-id="447bd-125">**Deferral for WPF expressions:** WPF features several expression classes that defer a value until a runtime context is available.</span></span> <span data-ttu-id="447bd-126">また、テンプレートの展開は、遅延手法に依存しているランタイムの動作です。</span><span class="sxs-lookup"><span data-stu-id="447bd-126">Also, template expansion is a runtime behavior that relies on deferral techniques.</span></span>  
  
 <span data-ttu-id="447bd-127">**入力システム参照の最適化:** WPF が広範な XAML ボキャブラリとオブジェクト モデルが文字どおり数百台の WPF 定義のクラスを継承する基底クラス メンバーの定義を含むです。</span><span class="sxs-lookup"><span data-stu-id="447bd-127">**Type system lookup optimizations:** WPF has an extensive XAML vocabulary and object model, including base class member definitions that inherit to literally hundreds of WPF-defined classes.</span></span> <span data-ttu-id="447bd-128">また、いくつかのアセンブリを WPF 自体に分散します。</span><span class="sxs-lookup"><span data-stu-id="447bd-128">Also, WPF itself is spread across several assemblies.</span></span> <span data-ttu-id="447bd-129">WPF では、参照テーブルとその他の手法を使用してその型の検索を最適化します。</span><span class="sxs-lookup"><span data-stu-id="447bd-129">WPF optimizes its type lookup using lookup tables and other techniques.</span></span> <span data-ttu-id="447bd-130">これは、既定の XAML スキーマ コンテキストとその型の CLR ベースの検索パフォーマンスの向上を提供します。</span><span class="sxs-lookup"><span data-stu-id="447bd-130">This provides performance improvements over the default XAML schema context and its CLR-based type lookup.</span></span> <span data-ttu-id="447bd-131">型が参照テーブルに存在しない場合の場合は、動作は、既定の XAML スキーマ コンテキストのような XAML スキーマ コンテキストのテクニックを使用します。</span><span class="sxs-lookup"><span data-stu-id="447bd-131">In cases where types do not exist in a lookup table, the behavior uses XAML schema context techniques that are similar to the default XAML schema context.</span></span>  
  
 <span data-ttu-id="447bd-132">**XamlType と XamlMember の拡張機能:** WPF は、依存関係プロパティを持つプロパティの概念を拡張し、ルーティング イベントのイベントの概念とします。</span><span class="sxs-lookup"><span data-stu-id="447bd-132">**XamlType and XamlMember extension:** WPF extends property concepts with dependency properties, and event concepts with routed events.</span></span> <span data-ttu-id="447bd-133">WPF を拡張に、これらの概念をわかりやすくに対して XAML 処理操作、<xref:System.Xaml.XamlType>と<xref:System.Xaml.XamlMember>、依存関係プロパティをレポートおよびイベントの特性をルーティングする内部プロパティを追加します。</span><span class="sxs-lookup"><span data-stu-id="447bd-133">To give these concepts greater visibility for XAML processing operations, WPF extends <xref:System.Xaml.XamlType> and <xref:System.Xaml.XamlMember>, and adds internal properties that report dependency property and routed event characteristics.</span></span>  
  
### <a name="accessing-the-wpf-xaml-schema-context"></a><span data-ttu-id="447bd-134">WPF XAML スキーマ コンテキストにアクセスします。</span><span class="sxs-lookup"><span data-stu-id="447bd-134">Accessing the WPF XAML Schema Context</span></span>  
 <span data-ttu-id="447bd-135">かどうかは、WPF に基づいている XAML の手法を使用している<xref:System.Windows.Markup.XamlReader?displayProperty=nameWithType>または<xref:System.Windows.Markup.XamlWriter?displayProperty=nameWithType>、WPF XAML スキーマ コンテキストは既にこれらの XAML リーダーと XAML ライターの実装に使用されています。</span><span class="sxs-lookup"><span data-stu-id="447bd-135">If you are using XAML techniques that are based on the WPF <xref:System.Windows.Markup.XamlReader?displayProperty=nameWithType> or <xref:System.Windows.Markup.XamlWriter?displayProperty=nameWithType>, the WPF XAML schema context is already in use on those XAML reader and XAML writer implementations.</span></span>  
  
 <span data-ttu-id="447bd-136">WPF XAML スキーマ コンテキストとその他の XAML リーダーまたは初期化しない XAML ライターの実装を使用している場合は、作業 WPF XAML スキーマ コンテキストを取得することがありますできる<xref:System.Windows.Markup.XamlReader.GetWpfSchemaContext%2A?displayProperty=nameWithType>です。</span><span class="sxs-lookup"><span data-stu-id="447bd-136">If you are using other XAML reader or XAML writer implementations that do not initialize with the WPF XAML schema context, you may be able to get a working WPF XAML schema context from <xref:System.Windows.Markup.XamlReader.GetWpfSchemaContext%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="447bd-137">初期化の他の API を使用すると、この値を使用することができますし、<xref:System.Xaml.XamlSchemaContext>です。</span><span class="sxs-lookup"><span data-stu-id="447bd-137">You can then use this value as initialization for other API that use a <xref:System.Xaml.XamlSchemaContext>.</span></span> <span data-ttu-id="447bd-138">たとえば、でした呼び出して<xref:System.Xaml.XamlXmlReader.%23ctor%2A>初期化と WPF XAML スキーマ コンテキストのパス。</span><span class="sxs-lookup"><span data-stu-id="447bd-138">For example, you could call <xref:System.Xaml.XamlXmlReader.%23ctor%2A> for initialization and pass the WPF XAML schema context.</span></span> <span data-ttu-id="447bd-139">または、XAML 型システム操作に、WPF XAML スキーマ コンテキストを使用する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="447bd-139">Or you could use the WPF XAML schema context for XAML type system operations.</span></span> <span data-ttu-id="447bd-140">初期化を建設が挙げられます、<xref:System.Xaml.XamlType>または<xref:System.Xaml.XamlMember>、または呼び出し<xref:System.Xaml.XamlSchemaContext.GetXamlType%2A?displayProperty=nameWithType>です。</span><span class="sxs-lookup"><span data-stu-id="447bd-140">This might include construction initialization of a <xref:System.Xaml.XamlType> or <xref:System.Xaml.XamlMember>, or calling <xref:System.Xaml.XamlSchemaContext.GetXamlType%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="447bd-141">WPF XAML の特定の側面は、純粋な XAML ノード ストリームの観点からアクセスする場合 WPF フレームワークの機能の一部が処理しなかったときがまだに注意してください。</span><span class="sxs-lookup"><span data-stu-id="447bd-141">Note that if you access certain aspects of WPF XAML from a pure XAML node stream perspectives, some of the WPF framework capabilities may not have acted yet.</span></span> <span data-ttu-id="447bd-142">たとえば、コントロールの WPF テンプレートはまだ適用されません。</span><span class="sxs-lookup"><span data-stu-id="447bd-142">For example, WPF templates for controls are not yet applied.</span></span> <span data-ttu-id="447bd-143">したがって、実行時に完全ビジュアル ツリーに挿入される場合をプロパティにアクセスする可能性がありますのみが表示テンプレートが参照するプロパティ値。</span><span class="sxs-lookup"><span data-stu-id="447bd-143">Thus if you access a property that at run time might be populated with a full visual tree, you might only see a property value that references a template.</span></span> <span data-ttu-id="447bd-144">WPF のマークアップ拡張機能を提供するサービス コンテキストはできない可能性がありますもランタイム以外の場合から提供される場合に正確なと、オブジェクト グラフを書き込もうとしているときに例外が発生できます。</span><span class="sxs-lookup"><span data-stu-id="447bd-144">The service context provided for WPF markup extensions might also not be accurate if provided from a non-runtime situation, and can result in exceptions when attempting to write an object graph.</span></span>  
  
## <a name="xaml-and-assembly-loading"></a><span data-ttu-id="447bd-145">XAML およびアセンブリの読み込み</span><span class="sxs-lookup"><span data-stu-id="447bd-145">XAML and Assembly Loading</span></span>  
 <span data-ttu-id="447bd-146">アセンブリの XAML と .NET Framework XAML サービスの読み込み 'æ˜aœg' の CLR で定義された概念<xref:System.AppDomain>です。</span><span class="sxs-lookup"><span data-stu-id="447bd-146">Assembly loading for XAML and .NET Framework XAML Services integrates with the CLR-defined concept of <xref:System.AppDomain>.</span></span> <span data-ttu-id="447bd-147">XAML スキーマ コンテキストでアセンブリを読み込むかの使用状況に基づいて実行時またはデザイン時に、型を検出する方法は、解釈<xref:System.AppDomain>およびその他の要因です。</span><span class="sxs-lookup"><span data-stu-id="447bd-147">A XAML schema context interprets how to either load assemblies or find types at run time or design time, based on the use of <xref:System.AppDomain> and other factors.</span></span> <span data-ttu-id="447bd-148">ロジックは、XAML が XAML リーダーの loose XAML がかどうかによって多少異なりますは、DLL にコンパイルされた XAML `XamlBuildTask`、WPF のによって生成された BAML または`PresentationBuildTask`です。</span><span class="sxs-lookup"><span data-stu-id="447bd-148">The logic is slightly different depending on whether the XAML is loose XAML for a XAML reader, is XAML compiled into a DLL by `XamlBuildTask`, or is BAML generated by WPF's `PresentationBuildTask`.</span></span>  
  
 <span data-ttu-id="447bd-149">WPF の XAML スキーマ コンテキストが順番に使用して、WPF アプリケーション モデルと統合し、 <xref:System.AppDomain> WPF 実装の詳細については、その他の要因とします。</span><span class="sxs-lookup"><span data-stu-id="447bd-149">The XAML schema context for WPF integrates with the WPF application model, which in turn uses <xref:System.AppDomain> as well as other factors that are WPF implementation details.</span></span>  
  
#### <a name="xaml-reader-input-loose-xaml"></a><span data-ttu-id="447bd-150">XAML リーダー入力 (loose XAML)</span><span class="sxs-lookup"><span data-stu-id="447bd-150">XAML reader input (loose XAML)</span></span>  
  
1.  <span data-ttu-id="447bd-151">反復処理、XAML スキーマ コンテキスト、<xref:System.AppDomain>名前のすべての側面に一致する読み込み済みアセンブリを探して、アプリケーションのアセンブリを読み込みました最近、最もから開始します。</span><span class="sxs-lookup"><span data-stu-id="447bd-151">The XAML schema context iterates through the <xref:System.AppDomain> of the application, looking for an already-loaded assembly that matches all aspects of the name, starting from the most recently loaded assembly.</span></span> <span data-ttu-id="447bd-152">一致が見つかった場合、そのアセンブリが解像度を使用します。</span><span class="sxs-lookup"><span data-stu-id="447bd-152">If a match is found, that assembly is used for resolution.</span></span>  
  
2.  <span data-ttu-id="447bd-153">それ以外の場合、次の手法のに基づいて CLR <xref:System.Reflection.Assembly> API は、アセンブリの読み込みに使用します。</span><span class="sxs-lookup"><span data-stu-id="447bd-153">Otherwise, one of the following techniques based on CLR <xref:System.Reflection.Assembly> API are used to load an assembly:</span></span>  
  
    -   <span data-ttu-id="447bd-154">名前修飾する場合は、マッピングで、呼び出す<xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>修飾名にします。</span><span class="sxs-lookup"><span data-stu-id="447bd-154">If the name is qualified in the mapping, call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType> on the qualified name.</span></span>  
  
    -   <span data-ttu-id="447bd-155">前の手順に失敗した場合は、短い名前 (および存在する場合の公開キー トークン) を使用して呼び出す<xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>です。</span><span class="sxs-lookup"><span data-stu-id="447bd-155">If the previous step fails, use the short name (and public key token if present) to call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span></span>  
  
    -   <span data-ttu-id="447bd-156">名前が、マッピング内で修飾でない場合を呼び出す<xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType>です。</span><span class="sxs-lookup"><span data-stu-id="447bd-156">If the name is unqualified in the mapping, call <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType>.</span></span>  
  
#### <a name="xamlbuildtask"></a><span data-ttu-id="447bd-157">XamlBuildTask</span><span class="sxs-lookup"><span data-stu-id="447bd-157">XamlBuildTask</span></span>  
 <span data-ttu-id="447bd-158">`XamlBuildTask`使用は[!INCLUDE[vsindigo](../../../includes/vsindigo-md.md)]と[!INCLUDE[TLA#tla_workflow](../../../includes/tlasharptla-workflow-md.md)]です。</span><span class="sxs-lookup"><span data-stu-id="447bd-158">`XamlBuildTask` is used for [!INCLUDE[vsindigo](../../../includes/vsindigo-md.md)] and [!INCLUDE[TLA#tla_workflow](../../../includes/tlasharptla-workflow-md.md)].</span></span>  
  
 <span data-ttu-id="447bd-159">アセンブリが参照するを通じて注`XamlBuildTask`は常に完全修飾します。</span><span class="sxs-lookup"><span data-stu-id="447bd-159">Note that assembly references through `XamlBuildTask` are always fully qualified.</span></span>  
  
1.  <span data-ttu-id="447bd-160">呼び出す<xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>修飾名にします。</span><span class="sxs-lookup"><span data-stu-id="447bd-160">Call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType> on the qualified name.</span></span>  
  
2.  <span data-ttu-id="447bd-161">前の手順に失敗した場合は、短い名前 (および存在する場合の公開キー トークン) を使用して呼び出す<xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>です。</span><span class="sxs-lookup"><span data-stu-id="447bd-161">If the previous step fails, use the short name (and public key token if present) to call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span></span>  
  
#### <a name="baml-presentationbuildtask"></a><span data-ttu-id="447bd-162">BAML (PresentationBuildTask)</span><span class="sxs-lookup"><span data-stu-id="447bd-162">BAML (PresentationBuildTask)</span></span>  
 <span data-ttu-id="447bd-163">BAML のアセンブリの読み込みに 2 つの側面があります。 コンポーネントとして BAML を含む最初のアセンブリの読み込みと BAML 生産によって参照されている型の型のバッキング アセンブリを読み込みます。</span><span class="sxs-lookup"><span data-stu-id="447bd-163">There are two aspects to assembly-loading for BAML: loading the initial assembly that contains the BAML as a component, and loading the type-backing assemblies for any types referenced by the BAML production.</span></span>  
  
##### <a name="assembly-load-for-initial-markup"></a><span data-ttu-id="447bd-164">初期のマークアップのアセンブリの読み込み:</span><span class="sxs-lookup"><span data-stu-id="447bd-164">Assembly load for initial markup:</span></span>  
 <span data-ttu-id="447bd-165">マークアップを読み込むアセンブリ参照は常に修飾ではありません。</span><span class="sxs-lookup"><span data-stu-id="447bd-165">The reference to the assembly to load the markup from is always unqualified.</span></span>  
  
1.  <span data-ttu-id="447bd-166">反復処理して、WPF XAML スキーマ コンテキスト、<xref:System.AppDomain>名前のすべての側面に一致する読み込み済みアセンブリを探して、WPF アプリケーションのアセンブリを読み込みました最近、最もから開始します。</span><span class="sxs-lookup"><span data-stu-id="447bd-166">The WPF XAML schema context iterates through the <xref:System.AppDomain> of the WPF application, looking for an already-loaded assembly that matches all aspects of the name, starting from the most recently loaded assembly.</span></span> <span data-ttu-id="447bd-167">一致が見つかった場合、そのアセンブリが解像度を使用します。</span><span class="sxs-lookup"><span data-stu-id="447bd-167">If a match is found, that assembly is used for resolution.</span></span>  
  
2.  <span data-ttu-id="447bd-168">前の手順に失敗した場合は、短い名前 (および存在する場合の公開キー トークン) を使用して呼び出す<xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>です。</span><span class="sxs-lookup"><span data-stu-id="447bd-168">If the previous step fails, use the short name (and public key token if present) to call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span></span>  
  
##### <a name="assembly-references-by-baml-types"></a><span data-ttu-id="447bd-169">BAML 型でアセンブリ参照。</span><span class="sxs-lookup"><span data-stu-id="447bd-169">Assembly references by BAML types:</span></span>  
 <span data-ttu-id="447bd-170">BAML 実稼働環境で使用される型のアセンブリ参照は、ビルド タスクの出力として、完全修飾では常にします。</span><span class="sxs-lookup"><span data-stu-id="447bd-170">Assembly references for types used in the BAML production are always fully qualified, as an output of the build task.</span></span>  
  
1.  <span data-ttu-id="447bd-171">反復処理して、WPF XAML スキーマ コンテキスト、<xref:System.AppDomain>名前のすべての側面に一致する読み込み済みアセンブリを探して、WPF アプリケーションのアセンブリを読み込みました最近、最もから開始します。</span><span class="sxs-lookup"><span data-stu-id="447bd-171">The WPF XAML schema context iterates through the <xref:System.AppDomain> of the WPF application, looking for an already-loaded assembly that matches all aspects of the name, starting from the most recently loaded assembly.</span></span> <span data-ttu-id="447bd-172">一致が見つかった場合、そのアセンブリが解像度を使用します。</span><span class="sxs-lookup"><span data-stu-id="447bd-172">If a match is found, that assembly is used for resolution.</span></span>  
  
2.  <span data-ttu-id="447bd-173">それ以外の場合、アセンブリの読み込み、次の手法のいずれかを使用します。</span><span class="sxs-lookup"><span data-stu-id="447bd-173">Otherwise, one of the following techniques is used to load an assembly:</span></span>  
  
    -   <span data-ttu-id="447bd-174">呼び出す<xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>修飾名にします。</span><span class="sxs-lookup"><span data-stu-id="447bd-174">Call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType> on the qualified name.</span></span>  
  
    -   <span data-ttu-id="447bd-175">A の短い名前 + パブリック キー トークンの組み合わせ、BAML から読み込まれたアセンブリと一致する場合は、そのアセンブリを使用します。</span><span class="sxs-lookup"><span data-stu-id="447bd-175">If a short name + public key token combination match the assembly that the BAML was loaded from, use that assembly.</span></span>  
  
    -   <span data-ttu-id="447bd-176">短い名前と公開キー トークンを使用して呼び出す<xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>です。</span><span class="sxs-lookup"><span data-stu-id="447bd-176">Use short name + public key token to call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="447bd-177">関連項目</span><span class="sxs-lookup"><span data-stu-id="447bd-177">See Also</span></span>  
 [<span data-ttu-id="447bd-178">XAML ノード ストリームの構造と概念について</span><span class="sxs-lookup"><span data-stu-id="447bd-178">Understanding XAML Node Stream Structures and Concepts</span></span>](../../../docs/framework/xaml-services/understanding-xaml-node-stream-structures-and-concepts.md)
