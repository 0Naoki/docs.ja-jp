---
title: .NET Framework XAML サービスで使用するためのカスタム型の定義
ms.date: 03/30/2017
helpviewer_keywords:
- defining custom types [XAML Services]
ms.assetid: c2667cbd-2f46-4a7f-9dfc-53696e35e8e4
ms.openlocfilehash: be9c0e26574a15279ce89af2c7862abaa8713360
ms.sourcegitcommit: 5b6d778ebb269ee6684fb57ad69a8c28b06235b9
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/08/2019
ms.locfileid: "59164438"
---
# <a name="defining-custom-types-for-use-with-net-framework-xaml-services"></a><span data-ttu-id="dcae8-102">.NET Framework XAML サービスで使用するためのカスタム型の定義</span><span class="sxs-lookup"><span data-stu-id="dcae8-102">Defining Custom Types for Use with .NET Framework XAML Services</span></span>
<span data-ttu-id="dcae8-103">ビジネス オブジェクトであるカスタム型の定義または特定のフレームワークに依存関係がない型には、XAML を利用できるため、特定のベスト プラクティスがあります。</span><span class="sxs-lookup"><span data-stu-id="dcae8-103">When you define custom types that are business objects or are types that do not have a dependency on specific frameworks, there are certain best practices for XAML you can follow.</span></span> <span data-ttu-id="dcae8-104">.NET Framework XAML サービスのこれらのプラクティスに従うと、その XAML リーダーと XAML ライターできます型の XAML の特性を検出し、XAML 型システムを使用して XAML ノード ストリームで適切な表現を付けます。</span><span class="sxs-lookup"><span data-stu-id="dcae8-104">If you follow these practices, .NET Framework XAML Services and its XAML readers and XAML writers can discover the XAML characteristics of your type and give it appropriate representation in a XAML node stream using the XAML type system.</span></span> <span data-ttu-id="dcae8-105">このトピックでは、型定義、メンバーの定義、および CLR 型またはメンバーの属性の設定のベスト プラクティスについて説明します。</span><span class="sxs-lookup"><span data-stu-id="dcae8-105">This topic describes best practices for type definitions, member definitions, and CLR attributing of types or members.</span></span>  
  
## <a name="constructor-patterns-and-type-definitions-for-xaml"></a><span data-ttu-id="dcae8-106">コンス トラクター パターンと XAML の種類の定義</span><span class="sxs-lookup"><span data-stu-id="dcae8-106">Constructor Patterns and Type Definitions for XAML</span></span>  
 <span data-ttu-id="dcae8-107">XAML オブジェクト要素としてインスタンス化される、カスタム クラスは、次の要件を満たす必要があります。</span><span class="sxs-lookup"><span data-stu-id="dcae8-107">To be instantiated as an object element in XAML, a custom class must meet the following requirements:</span></span>  
  
-   <span data-ttu-id="dcae8-108">カスタムのクラスは、パブリックである必要があり、既定の (パラメーターなしの) パブリック コンス トラクターを公開する必要があります。</span><span class="sxs-lookup"><span data-stu-id="dcae8-108">The custom class must be public and must expose a default (parameterless) public constructor.</span></span> <span data-ttu-id="dcae8-109">(次の構造に関する注意事項のセクションを参照してください)。</span><span class="sxs-lookup"><span data-stu-id="dcae8-109">(See following section for notes regarding structures.)</span></span>  
  
-   <span data-ttu-id="dcae8-110">入れ子になったクラスは、カスタム クラスではなければなりません。</span><span class="sxs-lookup"><span data-stu-id="dcae8-110">The custom class must not be a nested class.</span></span> <span data-ttu-id="dcae8-111">追加の完全名のパスに「ドット」では、あいまいな場合は、名前空間のクラスの除算を作成し、添付プロパティなどの他の XAML 機能に干渉します。</span><span class="sxs-lookup"><span data-stu-id="dcae8-111">The extra "dot" in the full-name path makes the class-namespace division ambiguous, and interferes with other XAML features such as attached properties.</span></span>  
  
 <span data-ttu-id="dcae8-112">オブジェクト要素として、オブジェクトをインスタンス化することができます、作成したオブジェクトを基になる型としてオブジェクトを使用する任意のプロパティのプロパティ要素の形式を入力します。</span><span class="sxs-lookup"><span data-stu-id="dcae8-112">If an object can be instantiated as an object element, the created object can fill the property element form of any properties that take the object as their underlying type.</span></span>  
  
 <span data-ttu-id="dcae8-113">値コンバーターを有効にした場合は、これらの条件を満たしていない型のオブジェクトの値を行うことができますも。</span><span class="sxs-lookup"><span data-stu-id="dcae8-113">You can still provide object values for types that do not meet these criteria, if you enable a value converter.</span></span> <span data-ttu-id="dcae8-114">詳細については、次を参照してください。[型コンバーターと XAML のマークアップ拡張機能](type-converters-and-markup-extensions-for-xaml.md)します。</span><span class="sxs-lookup"><span data-stu-id="dcae8-114">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions-for-xaml.md).</span></span>  
  
### <a name="structures"></a><span data-ttu-id="dcae8-115">構造体</span><span class="sxs-lookup"><span data-stu-id="dcae8-115">Structures</span></span>  
 <span data-ttu-id="dcae8-116">構造体は、XAML で CLR の定義によって構築することが常にします。</span><span class="sxs-lookup"><span data-stu-id="dcae8-116">Structures are always able to be constructed in XAML, by CLR definition.</span></span> <span data-ttu-id="dcae8-117">これは、CLR コンパイラは構造体の既定のコンス トラクターを暗黙的に作成されるためです。</span><span class="sxs-lookup"><span data-stu-id="dcae8-117">This is because a CLR compiler implicitly creates a default constructor for a structure.</span></span> <span data-ttu-id="dcae8-118">このコンス トラクターでは、すべてのプロパティ値を既定値を初期化します。</span><span class="sxs-lookup"><span data-stu-id="dcae8-118">This constructor initializes all property values to their defaults.</span></span>  
  
 <span data-ttu-id="dcae8-119">場合によっては、構造体の既定の構築の動作は望ましくありません。</span><span class="sxs-lookup"><span data-stu-id="dcae8-119">In some cases, the default construction behavior for a structure is not desirable.</span></span> <span data-ttu-id="dcae8-120">構造の目的は、共用体と概念的には、値と関数を入力する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dcae8-120">This might be because the structure is intended to fill values and function conceptually as a union.</span></span> <span data-ttu-id="dcae8-121">、共用体として値を含んでいる場合、排他的な解釈があり、そのため、そのプロパティを設定できます。</span><span class="sxs-lookup"><span data-stu-id="dcae8-121">As a union, the contained values might have mutually exclusive interpretations, and therefore, none of its properties are settable.</span></span> <span data-ttu-id="dcae8-122">WPF ボキャブラリで、このような構造の例は、<xref:System.Windows.GridLength>します。</span><span class="sxs-lookup"><span data-stu-id="dcae8-122">An example of such a structure in the WPF vocabulary is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="dcae8-123">このような構造は、値は、さまざまな解釈や構造体の値のモードを作成する文字列の規則を使用して属性の形式で表現できるように、型コンバーターを実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="dcae8-123">Such structures should implement a type converter so that the values can be expressed in attribute form, by using string conventions that create the different interpretations or modes of the structure values.</span></span> <span data-ttu-id="dcae8-124">構造体には、既定以外のコンス トラクターを使用してコード構築の同様の動作も公開する必要があります。</span><span class="sxs-lookup"><span data-stu-id="dcae8-124">The structure should also expose similar behavior for code construction through a non-default constructor.</span></span>  
  
### <a name="interfaces"></a><span data-ttu-id="dcae8-125">インターフェイス</span><span class="sxs-lookup"><span data-stu-id="dcae8-125">Interfaces</span></span>  
 <span data-ttu-id="dcae8-126">インターフェイスは、基になる型のメンバーとして使用できます。</span><span class="sxs-lookup"><span data-stu-id="dcae8-126">Interfaces can be used as underlying types of members.</span></span> <span data-ttu-id="dcae8-127">XAML 型システムでは、割り当て可能な一覧を確認し、インターフェイスに割り当てることができる値として指定されているオブジェクトが必要です。</span><span class="sxs-lookup"><span data-stu-id="dcae8-127">The XAML type system checks the assignable list and expects that the object that is provided as the value can be assigned to the interface.</span></span> <span data-ttu-id="dcae8-128">方法インターフェイスの存在が必要、XAML の型として関連する割り当て可能な型は、XAML の作成要件をサポートしている限りの概念はありません。</span><span class="sxs-lookup"><span data-stu-id="dcae8-128">There is no concept of how the interface must be presented as a XAML type as long as a relevant assignable type supports the XAML construction requirements.</span></span>  
  
### <a name="factory-methods"></a><span data-ttu-id="dcae8-129">ファクトリ メソッド</span><span class="sxs-lookup"><span data-stu-id="dcae8-129">Factory Methods</span></span>  
 <span data-ttu-id="dcae8-130">ファクトリ メソッドは、XAML 2009 の機能です。</span><span class="sxs-lookup"><span data-stu-id="dcae8-130">Factory methods are a XAML 2009 feature.</span></span> <span data-ttu-id="dcae8-131">これらは、オブジェクトが既定のコンス トラクターが必要な XAML の原則を変更します。</span><span class="sxs-lookup"><span data-stu-id="dcae8-131">They modify the XAML principle that objects must have default constructors.</span></span> <span data-ttu-id="dcae8-132">ファクトリ メソッドは、このトピックに記載されていません。</span><span class="sxs-lookup"><span data-stu-id="dcae8-132">Factory methods are not documented in this topic.</span></span> <span data-ttu-id="dcae8-133">参照してください[X:factorymethod ディレクティブ](x-factorymethod-directive.md)します。</span><span class="sxs-lookup"><span data-stu-id="dcae8-133">See [x:FactoryMethod Directive](x-factorymethod-directive.md).</span></span>  
  
## <a name="enumerations"></a><span data-ttu-id="dcae8-134">列挙</span><span class="sxs-lookup"><span data-stu-id="dcae8-134">Enumerations</span></span>  
 <span data-ttu-id="dcae8-135">列挙体では、XAML のネイティブな型変換動作があります。</span><span class="sxs-lookup"><span data-stu-id="dcae8-135">Enumerations have XAML native type conversion behavior.</span></span> <span data-ttu-id="dcae8-136">XAML で指定された列挙定数の名前は、基になる列挙型に対して解決し、XAML オブジェクト ライターに列挙値を返します。</span><span class="sxs-lookup"><span data-stu-id="dcae8-136">Enumeration constant names specified in XAML are resolved against the underlying enumeration type, and return the enumeration value to a XAML object writer.</span></span>  
  
 <span data-ttu-id="dcae8-137">XAML は、ある列挙型のフラグ スタイルの使用状況をサポートしている<xref:System.FlagsAttribute>適用します。</span><span class="sxs-lookup"><span data-stu-id="dcae8-137">XAML supports a flags-style usage for enumerations with <xref:System.FlagsAttribute> applied.</span></span> <span data-ttu-id="dcae8-138">詳細については、次を参照してください。 [XAML 構文の詳細](../wpf/advanced/xaml-syntax-in-detail.md)します。</span><span class="sxs-lookup"><span data-stu-id="dcae8-138">For more information, see [XAML Syntax In Detail](../wpf/advanced/xaml-syntax-in-detail.md).</span></span> <span data-ttu-id="dcae8-139">([XAML 構文の詳細](../wpf/advanced/xaml-syntax-in-detail.md)は WPF のユーザー向けに書き込まれますが、そのトピックの情報の大部分は実装する特定のフレームワークに固有ではない XAML に関連します)。</span><span class="sxs-lookup"><span data-stu-id="dcae8-139">([XAML Syntax In Detail](../wpf/advanced/xaml-syntax-in-detail.md) is written for the WPF audience, but most of the information in that topic is relevant for XAML that is not specific to a particular implementing framework.)</span></span>  
  
## <a name="member-definitions"></a><span data-ttu-id="dcae8-140">メンバーの定義</span><span class="sxs-lookup"><span data-stu-id="dcae8-140">Member Definitions</span></span>  
 <span data-ttu-id="dcae8-141">型は、XAML の使用状況のメンバーを定義できます。</span><span class="sxs-lookup"><span data-stu-id="dcae8-141">Types can define members for XAML usage.</span></span> <span data-ttu-id="dcae8-142">その特定の種類が XAML で使用できない場合でも、XAML の使用可能なメンバーを定義する型のことができます。</span><span class="sxs-lookup"><span data-stu-id="dcae8-142">It is possible for types that define members that are XAML-usable even if that specific type is not XAML-usable.</span></span> <span data-ttu-id="dcae8-143">これは、CLR の継承によって実現します。</span><span class="sxs-lookup"><span data-stu-id="dcae8-143">This is possible because of CLR inheritance.</span></span> <span data-ttu-id="dcae8-144">限り、メンバーを継承する何らかの種類が XAML の使用法は、型をサポートし、基になる型の XAML の使用状況をサポートしているまたはネイティブの XAML 構文を使用可能なメンバー、そのメンバーが XAML で使用します。</span><span class="sxs-lookup"><span data-stu-id="dcae8-144">So long as some type that inherits the member supports XAML usage as a type, and the member supports XAML usage for its underlying type or has a native XAML syntax available, that member is XAML-usable.</span></span>  
  
### <a name="properties"></a><span data-ttu-id="dcae8-145">プロパティ</span><span class="sxs-lookup"><span data-stu-id="dcae8-145">Properties</span></span>  
 <span data-ttu-id="dcae8-146">一般的な CLR を使用して、パブリックの CLR プロパティとしてプロパティを定義するかどうかは`get`と`set`アクセサー パターンおよび言語に応じた keywording、XAML 型システムがのプロパティを適切な情報を持つメンバーとして提供されているを報告することができます<xref:System.Xaml.XamlMember>プロパティなど<xref:System.Xaml.XamlMember.IsReadPublic%2A>と<xref:System.Xaml.XamlMember.IsWritePublic%2A>します。</span><span class="sxs-lookup"><span data-stu-id="dcae8-146">If you define properties as a public CLR property using the typical CLR `get` and `set` accessor patterns and language-appropriate keywording, the XAML type system can report the property as a member with appropriate information provided for <xref:System.Xaml.XamlMember> properties, such as <xref:System.Xaml.XamlMember.IsReadPublic%2A> and <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span></span>  
  
 <span data-ttu-id="dcae8-147">特定のプロパティは、適用することで、テキスト構文を有効にできます<xref:System.ComponentModel.TypeConverterAttribute>します。</span><span class="sxs-lookup"><span data-stu-id="dcae8-147">Specific properties can enable a text syntax by applying <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="dcae8-148">詳細については、次を参照してください。[型コンバーターと XAML のマークアップ拡張機能](type-converters-and-markup-extensions-for-xaml.md)します。</span><span class="sxs-lookup"><span data-stu-id="dcae8-148">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions-for-xaml.md).</span></span>  
  
 <span data-ttu-id="dcae8-149">テキストの構文またはネイティブの XAML の変換がない場合、マークアップ拡張機能の使用、プロパティの型など、さらに間接的ながない場合は、(<xref:System.Xaml.XamlMember.TargetType%2A> XAML 入力システム) を t を扱うことにより、XAML オブジェクト ライターにインスタンスを返すことがありますarget 型を CLR 型。</span><span class="sxs-lookup"><span data-stu-id="dcae8-149">In the absence of a text syntax or native XAML conversion and in the absence of further indirection, such as a markup extension usage, the type of a property (<xref:System.Xaml.XamlMember.TargetType%2A> in the XAML type system) must be able to return an instance to a XAML object writer by treating the target type as a CLR type.</span></span>  
  
 <span data-ttu-id="dcae8-150">XAML 2009 を使用して場合[X:reference マークアップ拡張機能](x-reference-markup-extension.md)前の考慮事項を満たしていない場合は、値を指定するために使用できます。 ただし、これは、型定義の問題よりも使用率の問題の。</span><span class="sxs-lookup"><span data-stu-id="dcae8-150">If using XAML 2009, [x:Reference Markup Extension](x-reference-markup-extension.md) can be used to provide values if the previous considerations are not met; however, that is more of a usage issue than a type definition issue.</span></span>  
  
### <a name="events"></a><span data-ttu-id="dcae8-151">イベント</span><span class="sxs-lookup"><span data-stu-id="dcae8-151">Events</span></span>  
 <span data-ttu-id="dcae8-152">パブリック CLR イベントとしてイベントを定義する場合、XAML 型システムがのメンバーとしてイベントを報告できます<xref:System.Xaml.XamlMember.IsEvent%2A>として`true`します。</span><span class="sxs-lookup"><span data-stu-id="dcae8-152">If you define events as a public CLR event, the XAML type system can report the event as a member with <xref:System.Xaml.XamlMember.IsEvent%2A> as `true`.</span></span> <span data-ttu-id="dcae8-153">.NET Framework XAML サービスの機能のスコープ内では、イベント ハンドラーを配線これは特定のフレームワークと実装に残しておきます。</span><span class="sxs-lookup"><span data-stu-id="dcae8-153">Wiring the event handlers is not within the scope of .NET Framework XAML Services capabilities; this is left to specific frameworks and implementations.</span></span>  
  
### <a name="methods"></a><span data-ttu-id="dcae8-154">メソッド</span><span class="sxs-lookup"><span data-stu-id="dcae8-154">Methods</span></span>  
 <span data-ttu-id="dcae8-155">メソッドのインライン コードは、既定の XAML 機能ではありません。</span><span class="sxs-lookup"><span data-stu-id="dcae8-155">Inline code for methods is not a default XAML capability.</span></span> <span data-ttu-id="dcae8-156">ほとんどの場合で直接参照しないメソッドのメンバーから XAML、および XAML でのメソッドの役割は、特定の XAML パターンのサポートを提供するだけです。</span><span class="sxs-lookup"><span data-stu-id="dcae8-156">In most cases you do not directly reference method members from XAML, and the role of methods in XAML is only to provide support for specific XAML patterns.</span></span> <span data-ttu-id="dcae8-157">[X:factorymethod ディレクティブ](x-factorymethod-directive.md)は例外です。</span><span class="sxs-lookup"><span data-stu-id="dcae8-157">[x:FactoryMethod Directive](x-factorymethod-directive.md) is an exception.</span></span>  
  
### <a name="fields"></a><span data-ttu-id="dcae8-158">フィールド</span><span class="sxs-lookup"><span data-stu-id="dcae8-158">Fields</span></span>  
 <span data-ttu-id="dcae8-159">CLR のデザイン ガイドラインは、非静的フィールドを防止します。</span><span class="sxs-lookup"><span data-stu-id="dcae8-159">CLR design guidelines discourage nonstatic fields.</span></span> <span data-ttu-id="dcae8-160">静的フィールドは、静的フィールドの値にアクセスできるを通してのみ[X:static マークアップ拡張機能](x-static-markup-extension.md); ここではないのフィールドを公開する CLR の定義で特別な行っている[X:static](x-static-markup-extension.md)使用法。</span><span class="sxs-lookup"><span data-stu-id="dcae8-160">For static fields, you can access static field values only through [x:Static Markup Extension](x-static-markup-extension.md); in this case you are not doing anything special in the CLR definition to expose a field for [x:Static](x-static-markup-extension.md) usages.</span></span>  
  
## <a name="attachable-members"></a><span data-ttu-id="dcae8-161">アタッチ可能なメンバー</span><span class="sxs-lookup"><span data-stu-id="dcae8-161">Attachable Members</span></span>  
 <span data-ttu-id="dcae8-162">アタッチ可能なメンバーは、XAML に定義する型のアクセサー メソッド パターンを通じて公開されます。</span><span class="sxs-lookup"><span data-stu-id="dcae8-162">Attachable members are exposed to XAML through an accessor method pattern on a defining type.</span></span> <span data-ttu-id="dcae8-163">定義の型自体は、オブジェクトとして、XAML で使用する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="dcae8-163">The defining type itself does not need to be XAML-usable as an object.</span></span> <span data-ttu-id="dcae8-164">実際には、一般的なパターンでは、ロールがあるサービス クラスを宣言するアタッチ可能メンバーを所有し、関連する動作を実装が UI 表現などの他の関数は使用されません。</span><span class="sxs-lookup"><span data-stu-id="dcae8-164">In fact, a common pattern is to declare a service class whose role is to own the attachable member and implement the related behaviors, but serve no other function such as a UI representation.</span></span> <span data-ttu-id="dcae8-165">次のセクションで、プレース ホルダーの*PropertyName*アタッチ可能なメンバーの名前を表します。</span><span class="sxs-lookup"><span data-stu-id="dcae8-165">For the following sections, the placeholder *PropertyName* represents the name of your attachable member.</span></span> <span data-ttu-id="dcae8-166">その名前で有効である必要があります、 [XamlName の文法](xamlname-grammar.md)します。</span><span class="sxs-lookup"><span data-stu-id="dcae8-166">That name must be valid in the [XamlName Grammar](xamlname-grammar.md).</span></span>  
  
 <span data-ttu-id="dcae8-167">これらのパターンと型の他のメソッドの名前の衝突の注意があります。</span><span class="sxs-lookup"><span data-stu-id="dcae8-167">Be cautious of name collisions between these patterns and other methods of a type.</span></span> <span data-ttu-id="dcae8-168">パターンのいずれかに一致するメンバーが存在する場合に解釈できますアタッチ可能なメンバーの使用状況経路として XAML プロセッサによって場合でも、意図したものでした。</span><span class="sxs-lookup"><span data-stu-id="dcae8-168">If a member exists that matches one of the patterns, it can be interpreted as an attachable member usage pathway by a XAML processor even if that was not your intention.</span></span>  
  
#### <a name="the-getpropertyname-accessor"></a><span data-ttu-id="dcae8-169">GetPropertyName アクセサー</span><span class="sxs-lookup"><span data-stu-id="dcae8-169">The GetPropertyName Accessor</span></span>  
 <span data-ttu-id="dcae8-170">`Get`*PropertyName* アクセサーのシグネチャは次の形式にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="dcae8-170">The signature for the `Get`*PropertyName* accessor must be:</span></span>  
  
 `public static object Get` *<span data-ttu-id="dcae8-171">PropertyName</span><span class="sxs-lookup"><span data-stu-id="dcae8-171">PropertyName</span></span>* `(object`  `target` `)`  
  
-   <span data-ttu-id="dcae8-172">`target` オブジェクトは、実装のより具体的な型として指定することができます。</span><span class="sxs-lookup"><span data-stu-id="dcae8-172">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="dcae8-173">これを使用するには、アタッチ可能メンバーの使用状況のスコープをする使用状況、目的のスコープ外 XAML 解析エラーが表示される、無効なキャスト例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="dcae8-173">You can use this to scope the usage of your attachable member; usages outside your intended scope will throw invalid cast exceptions that are then surfaced by a XAML parse error.</span></span> <span data-ttu-id="dcae8-174">パラメーター名`target`、必須ではありませんが、名前は`target`の規約では、ほとんどの実装。</span><span class="sxs-lookup"><span data-stu-id="dcae8-174">The parameter name `target` is not a requirement, but is named `target` by convention in most implementations.</span></span>  
  
-   <span data-ttu-id="dcae8-175">戻り値は、実装のより具体的な型として指定することができます。</span><span class="sxs-lookup"><span data-stu-id="dcae8-175">The return value can be specified as a more specific type in your implementation.</span></span>  
  
 <span data-ttu-id="dcae8-176">サポートするために、 <xref:System.ComponentModel.TypeConverter> 、アタッチ可能なメンバーの属性の使用方法の有効なテキスト構文は適用<xref:System.ComponentModel.TypeConverterAttribute>を`Get` *PropertyName*アクセサー。</span><span class="sxs-lookup"><span data-stu-id="dcae8-176">To support a <xref:System.ComponentModel.TypeConverter> enabled text syntax for attribute usage of the attachable member, apply <xref:System.ComponentModel.TypeConverterAttribute> to the `Get`*PropertyName* accessor.</span></span> <span data-ttu-id="dcae8-177">適用する、`get`の代わりに、`set`直感; かもしれませんただし、この規則は、概念をサポートできますのシリアル化可能である読み取り専用のアタッチ可能なメンバー、これはデザイナーのシナリオで有用です。</span><span class="sxs-lookup"><span data-stu-id="dcae8-177">Applying to the `get` instead of the `set` may seem nonintuitive; however, this convention can support the concept of read-only attachable members that are serializable, which is useful in designer scenarios.</span></span>  
  
#### <a name="the-setpropertyname-accessor"></a><span data-ttu-id="dcae8-178">SetPropertyName アクセサー</span><span class="sxs-lookup"><span data-stu-id="dcae8-178">The SetPropertyName Accessor</span></span>  
 <span data-ttu-id="dcae8-179">セットの署名*PropertyName*アクセサーを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="dcae8-179">The signature for the Set*PropertyName* accessor must be:</span></span>  
  
 `public static void Set` *<span data-ttu-id="dcae8-180">PropertyName</span><span class="sxs-lookup"><span data-stu-id="dcae8-180">PropertyName</span></span>* `(object`  `target` `, object`  `value` `)`  
  
-   <span data-ttu-id="dcae8-181">`target`オブジェクトは、前のセクションで説明したロジックと結果が同じで、実装のより具体的な型として指定できます。</span><span class="sxs-lookup"><span data-stu-id="dcae8-181">The `target` object can be specified as a more specific type in your implementation, with same logic and consequences as described in the previous section.</span></span>  
  
-   <span data-ttu-id="dcae8-182">`value` オブジェクトは、実装のより具体的な型として指定することができます。</span><span class="sxs-lookup"><span data-stu-id="dcae8-182">The `value` object can be specified as a more specific type in your implementation.</span></span>  
  
 <span data-ttu-id="dcae8-183">このメソッドの値は属性の形式では通常、XAML の使用から生じる入力であることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="dcae8-183">Remember that the value for this method is the input coming from the XAML usage, typically in attribute form.</span></span> <span data-ttu-id="dcae8-184">属性の形式から値コンバーターが、テキスト構文のサポートおよび必要する属性を`Get` *PropertyName*アクセサー。</span><span class="sxs-lookup"><span data-stu-id="dcae8-184">From attribute form there must be value converter support for a text syntax, and you attribute on the `Get`*PropertyName* accessor.</span></span>  
  
### <a name="attachable-member-stores"></a><span data-ttu-id="dcae8-185">アタッチ可能なメンバー ストア</span><span class="sxs-lookup"><span data-stu-id="dcae8-185">Attachable Member Stores</span></span>  
 <span data-ttu-id="dcae8-186">アクセサー メソッドは通常されませんがアタッチ可能なメンバーの値をオブジェクト グラフに配置するか、オブジェクト グラフから値を取得し、適切にシリアル化する手段を提供するには不十分です。</span><span class="sxs-lookup"><span data-stu-id="dcae8-186">The accessor methods are typically not enough to provide a means to place attachable member values into an object graph, or to retrieve values out of the object graph and serialize them properly.</span></span> <span data-ttu-id="dcae8-187">この機能を提供する、`target`アクセサーの以前のシグネチャ内のオブジェクトの値を格納できる必要があります。</span><span class="sxs-lookup"><span data-stu-id="dcae8-187">To provide this functionality, the `target` objects in the previous accessor signatures must be capable of storing values.</span></span> <span data-ttu-id="dcae8-188">ストレージ メカニズムは、メンバーがアタッチ可能メンバーがないメンバー リストでターゲットにアタッチ可能なアタッチ可能なメンバーの原則と一致する必要があります。</span><span class="sxs-lookup"><span data-stu-id="dcae8-188">The storage mechanism should be consistent with the attachable member principle that the member is attachable to targets where the attachable member is not in the members list.</span></span> <span data-ttu-id="dcae8-189">.NET framework XAML サービス api のアタッチ可能なメンバー ストアについて、実装方法を提供します<xref:System.Xaml.IAttachedPropertyStore>と<xref:System.Xaml.AttachablePropertyServices>します。</span><span class="sxs-lookup"><span data-stu-id="dcae8-189">.NET Framework XAML Services provides an implementation technique for attachable member stores through the APIs <xref:System.Xaml.IAttachedPropertyStore> and <xref:System.Xaml.AttachablePropertyServices>.</span></span> <xref:System.Xaml.IAttachedPropertyStore> <span data-ttu-id="dcae8-190">ストアの実装を検出する XAML ライターによって使用され、ある型に実装する必要があります、`target`アクセサー。</span><span class="sxs-lookup"><span data-stu-id="dcae8-190">is used by the XAML writers to discover the store implementation, and should be implemented on the type that is the `target` of the accessors.</span></span> <span data-ttu-id="dcae8-191">静的な<xref:System.Xaml.AttachablePropertyServices>Api は、アクセサーの本文内で使用され、アタッチ可能メンバーを参照してください、<xref:System.Xaml.AttachableMemberIdentifier>します。</span><span class="sxs-lookup"><span data-stu-id="dcae8-191">The static <xref:System.Xaml.AttachablePropertyServices> APIs are used within the body of the accessors, and refer to the attachable member by its <xref:System.Xaml.AttachableMemberIdentifier>.</span></span>  
  
## <a name="xaml-related-clr-attributes"></a><span data-ttu-id="dcae8-192">XAML 関連の CLR 属性</span><span class="sxs-lookup"><span data-stu-id="dcae8-192">XAML-Related CLR Attributes</span></span>  
 <span data-ttu-id="dcae8-193">正しく、型、メンバー、およびアセンブリの属性を設定することは、レポートには、.NET Framework XAML サービスの XAML 型システムの情報で重要です。</span><span class="sxs-lookup"><span data-stu-id="dcae8-193">Correctly attributing your types, members, and assemblies is important in order to report XAML type system information to .NET Framework XAML Services.</span></span> <span data-ttu-id="dcae8-194">これは、型に直接基づく .NET Framework XAML サービスの XAML リーダーと XAML ライターでは、XAML システムを使用する場合、または定義またはそれらの XAML リーダーと XAML ライターに基づいている XAML 利用するフレームワークを使用する場合です。</span><span class="sxs-lookup"><span data-stu-id="dcae8-194">This is relevant if you intend your types for use with XAML systems that are directly based on .NET Framework XAML Services XAML readers and XAML writers, or if you define or use a XAML-utilizing framework that is based on those XAML readers and XAML writers.</span></span>  
  
 <span data-ttu-id="dcae8-195">カスタム型の XAML のサポートに関連する各 XAML 関連の属性の一覧については、次を参照してください。[カスタム型およびライブラリの CLR 属性を XAML-Related](xaml-related-clr-attributes-for-custom-types-and-libraries.md)します。</span><span class="sxs-lookup"><span data-stu-id="dcae8-195">For a listing of each XAML-related attribute that is relevant for XAML support of your custom types, see [XAML-Related CLR Attributes for Custom Types and Libraries](xaml-related-clr-attributes-for-custom-types-and-libraries.md).</span></span>  
  
## <a name="usage"></a><span data-ttu-id="dcae8-196">使用法</span><span class="sxs-lookup"><span data-stu-id="dcae8-196">Usage</span></span>  
 <span data-ttu-id="dcae8-197">カスタム型を使用するには、マークアップの作成者がカスタム型を含むアセンブリと CLR 名前空間のプレフィックスをマップする必要がありますが必要です。</span><span class="sxs-lookup"><span data-stu-id="dcae8-197">Usage of custom types requires that the markup author must map a prefix for the assembly and CLR namespace that contain the custom type.</span></span> <span data-ttu-id="dcae8-198">この手順は、このトピックでは説明しません。</span><span class="sxs-lookup"><span data-stu-id="dcae8-198">This procedure is not documented in this topic.</span></span>  
  
## <a name="access-level"></a><span data-ttu-id="dcae8-199">アクセス レベル</span><span class="sxs-lookup"><span data-stu-id="dcae8-199">Access Level</span></span>  
 <span data-ttu-id="dcae8-200">XAML 読み込みおよびを持つ型をインスタンス化する手段を提供する、`internal`アクセス レベル。</span><span class="sxs-lookup"><span data-stu-id="dcae8-200">XAML provides a means to load and instantiate types that have an `internal` access level.</span></span> <span data-ttu-id="dcae8-201">ユーザー コードが、独自の型を定義し、同じユーザー コードのスコープの一部でもあるマークアップからこれらのクラスのインスタンスを作成できるように、この機能は提供されています。</span><span class="sxs-lookup"><span data-stu-id="dcae8-201">This capability is provided so that user code can define its own types, and then instantiate those classes from markup that is also part of the same user code scope.</span></span>  
  
 <span data-ttu-id="dcae8-202">WPF の例は、ユーザー コードを定義するたびに、 <xref:System.Windows.Controls.UserControl> UI の動作をリファクターする方法としてではないとサポート クラスを宣言することによって出される可能性がある任意の拡張メカニズムの一部としている`public`アクセス レベル。</span><span class="sxs-lookup"><span data-stu-id="dcae8-202">An example from WPF is whenever user code defines a <xref:System.Windows.Controls.UserControl> that is intended as a way to refactor a UI behavior, but not as part of any possible extension mechanism that might be implied by declaring the supporting class with `public` access level.</span></span> <span data-ttu-id="dcae8-203">このような<xref:System.Windows.Controls.UserControl>で宣言できます`internal`バッキング コードは、元の XAML 型として参照されている同じアセンブリにコンパイルされる場合にアクセスします。</span><span class="sxs-lookup"><span data-stu-id="dcae8-203">Such a <xref:System.Windows.Controls.UserControl> can be declared with `internal` access if the backing code is compiled into the same assembly from which it is referenced as a XAML type.</span></span>  
  
 <span data-ttu-id="dcae8-204">完全な信頼での XAML の読み込みを使用しているアプリケーションの<xref:System.Xaml.XamlObjectWriter>を持つクラスを読み込んで`internal`アクセス レベルが常に有効にします。</span><span class="sxs-lookup"><span data-stu-id="dcae8-204">For an application that loads XAML under full trust and uses <xref:System.Xaml.XamlObjectWriter>, loading classes with `internal` access level is always enabled.</span></span>  
  
 <span data-ttu-id="dcae8-205">XAML を部分信頼で読み込まれるアプリケーションのアクセス レベルの特性を制御を使用して、 <xref:System.Xaml.Permissions.XamlAccessLevel> API。</span><span class="sxs-lookup"><span data-stu-id="dcae8-205">For an application that loads XAML under partial trust, you can control the access level characteristics by using the <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span></span> <span data-ttu-id="dcae8-206">また、遅延メカニズム (など、WPF テンプレート システム) できる必要があります、アクセス レベルのアクセス許可を反映し、最終的な実行時の評価; 保持するために渡すことによって内部的にこの処理は、<xref:System.Xaml.Permissions.XamlAccessLevel>情報。</span><span class="sxs-lookup"><span data-stu-id="dcae8-206">Also, deferral mechanisms (such as the WPF template system) must be able to propagate any access level permissions and preserve them for the eventual run time evaluations; this is handled internally by passing the <xref:System.Xaml.Permissions.XamlAccessLevel> information.</span></span>  
  
### <a name="wpf-implementation"></a><span data-ttu-id="dcae8-207">WPF の実装</span><span class="sxs-lookup"><span data-stu-id="dcae8-207">WPF Implementation</span></span>  
 <span data-ttu-id="dcae8-208">WPF XAML モデルを使用して、部分信頼のアクセス、BAML が部分信頼で読み込まれると、アクセスに制限されます<xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A>BAML ソースであるアセンブリ。</span><span class="sxs-lookup"><span data-stu-id="dcae8-208">WPF XAML uses a partial-trust access model where if BAML is loaded under partial trust, access is restricted to <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> for the assembly that is the BAML source.</span></span> <span data-ttu-id="dcae8-209">WPF を使用して、遅延の<xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType>アクセス レベルの情報を渡すためのメカニズムとして。</span><span class="sxs-lookup"><span data-stu-id="dcae8-209">For deferral, WPF uses <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> as a mechanism for passing the access level information.</span></span>  
  
 <span data-ttu-id="dcae8-210">WPF XAML の用語では、*内部型*は参照元の XAML も含まれており、同じアセンブリで定義されている型です。</span><span class="sxs-lookup"><span data-stu-id="dcae8-210">In WPF XAML terminology, an *internal type* is a type that is defined by the same assembly that also includes the referencing XAML.</span></span> <span data-ttu-id="dcae8-211">アセンブリを意図的に省略する XAML 名前空間を通じてこのような型をマップできる、マッピングの一部を =`xmlns:local="clr-namespace:WPFApplication1"`します。</span><span class="sxs-lookup"><span data-stu-id="dcae8-211">Such a type can be mapped through a XAML namespace that deliberately omits the assembly= portion of a mapping, for example, `xmlns:local="clr-namespace:WPFApplication1"`.</span></span>  <span data-ttu-id="dcae8-212">BAML が内部の型を参照するかどうかとが型にある`internal`アクセス レベル、これが生成されます、`GeneratedInternalTypeHelper`アセンブリのクラス。</span><span class="sxs-lookup"><span data-stu-id="dcae8-212">If BAML references an internal type and that type has `internal` access level, this generates a `GeneratedInternalTypeHelper` class for the assembly.</span></span> <span data-ttu-id="dcae8-213">避けたい場合`GeneratedInternalTypeHelper`、いずれかを使用する必要がある`public`アクセス レベル、またはする必要があります別のアセンブリに関連するクラスを考慮し、そのアセンブリが依存するようにします。</span><span class="sxs-lookup"><span data-stu-id="dcae8-213">If you want to avoid `GeneratedInternalTypeHelper`, you either must use `public` access level, or must factor the relevant class into a separate assembly and make that assembly dependent.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="dcae8-214">関連項目</span><span class="sxs-lookup"><span data-stu-id="dcae8-214">See also</span></span>

- [<span data-ttu-id="dcae8-215">カスタム型およびライブラリの XAML 関連の CLR 属性</span><span class="sxs-lookup"><span data-stu-id="dcae8-215">XAML-Related CLR Attributes for Custom Types and Libraries</span></span>](xaml-related-clr-attributes-for-custom-types-and-libraries.md)
- [<span data-ttu-id="dcae8-216">XAML サービス</span><span class="sxs-lookup"><span data-stu-id="dcae8-216">XAML Services</span></span>](index.md)
