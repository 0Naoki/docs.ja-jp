---
title: ".NET Framework XAML サービスで使用するためのカスタム型の定義"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-wpf
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords: defining custom types [XAML Services]
ms.assetid: c2667cbd-2f46-4a7f-9dfc-53696e35e8e4
caps.latest.revision: "11"
author: wadepickett
ms.author: wpickett
manager: wpickett
ms.openlocfilehash: 0b35c35be7351fdf45157153ce6ca55fc763c3ed
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/21/2017
---
# <a name="defining-custom-types-for-use-with-net-framework-xaml-services"></a><span data-ttu-id="2df61-102">.NET Framework XAML サービスで使用するためのカスタム型の定義</span><span class="sxs-lookup"><span data-stu-id="2df61-102">Defining Custom Types for Use with .NET Framework XAML Services</span></span>
<span data-ttu-id="2df61-103">ビジネス オブジェクトは、カスタム型の定義または特定のフレームワークに依存関係がない型は、するときに行うことができる XAML の運用方法があります。</span><span class="sxs-lookup"><span data-stu-id="2df61-103">When you define custom types that are business objects or are types that do not have a dependency on specific frameworks, there are certain best practices for XAML you can follow.</span></span> <span data-ttu-id="2df61-104">これらのプラクティスに従うと場合、.NET Framework XAML サービスおよびその XAML リーダーと XAML ライターを型の XAML の特性を検出し、XAML 型システムを使用して XAML ノード ストリームで適切な形式。</span><span class="sxs-lookup"><span data-stu-id="2df61-104">If you follow these practices, .NET Framework XAML Services and its XAML readers and XAML writers can discover the XAML characteristics of your type and give it appropriate representation in a XAML node stream using the XAML type system.</span></span> <span data-ttu-id="2df61-105">このトピックでは、型定義、メンバーの定義、および CLR 型またはメンバーの属性の設定のベスト プラクティスについて説明します。</span><span class="sxs-lookup"><span data-stu-id="2df61-105">This topic describes best practices for type definitions, member definitions, and CLR attributing of types or members.</span></span>  
  
## <a name="constructor-patterns-and-type-definitions-for-xaml"></a><span data-ttu-id="2df61-106">コンス トラクター パターンと XAML の種類の定義</span><span class="sxs-lookup"><span data-stu-id="2df61-106">Constructor Patterns and Type Definitions for XAML</span></span>  
 <span data-ttu-id="2df61-107">Xaml オブジェクト要素としてインスタンス化されるカスタム クラスは、次の要件を満たす必要があります。</span><span class="sxs-lookup"><span data-stu-id="2df61-107">To be instantiated as an object element in XAML, a custom class must meet the following requirements:</span></span>  
  
-   <span data-ttu-id="2df61-108">カスタムのクラスは、パブリックである必要があり、既定 (パラメーターなし) のコンス トラクターを公開する必要があります。</span><span class="sxs-lookup"><span data-stu-id="2df61-108">The custom class must be public and must expose a default (parameterless) public constructor.</span></span> <span data-ttu-id="2df61-109">(次の構造に関する注意事項のセクションを参照してください)。</span><span class="sxs-lookup"><span data-stu-id="2df61-109">(See following section for notes regarding structures.)</span></span>  
  
-   <span data-ttu-id="2df61-110">カスタム クラスでは、入れ子になったクラスをすることはできません。</span><span class="sxs-lookup"><span data-stu-id="2df61-110">The custom class must not be a nested class.</span></span> <span data-ttu-id="2df61-111">余分な氏名パスで「ドット」名前空間のクラス除算、あいまいになりアタッチされるプロパティなどの他の XAML 機能に干渉します。</span><span class="sxs-lookup"><span data-stu-id="2df61-111">The extra "dot" in the full-name path makes the class-namespace division ambiguous, and interferes with other XAML features such as attached properties.</span></span>  
  
 <span data-ttu-id="2df61-112">オブジェクトは、オブジェクト要素としてインスタンス化することができます、作成したオブジェクトは、その基になる型としてオブジェクトを使用する任意のプロパティのプロパティ要素の形式を入力できます。</span><span class="sxs-lookup"><span data-stu-id="2df61-112">If an object can be instantiated as an object element, the created object can fill the property element form of any properties that take the object as their underlying type.</span></span>  
  
 <span data-ttu-id="2df61-113">引き続き、値コンバーターを有効にした場合、オブジェクトの値をこれらの条件を満たしていない種類の指定できます。</span><span class="sxs-lookup"><span data-stu-id="2df61-113">You can still provide object values for types that do not meet these criteria, if you enable a value converter.</span></span> <span data-ttu-id="2df61-114">詳細については、次を参照してください。[型コンバーターと XAML のマークアップ拡張機能](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md)します。</span><span class="sxs-lookup"><span data-stu-id="2df61-114">For more information, see [Type Converters and Markup Extensions for XAML](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md).</span></span>  
  
### <a name="structures"></a><span data-ttu-id="2df61-115">構造体</span><span class="sxs-lookup"><span data-stu-id="2df61-115">Structures</span></span>  
 <span data-ttu-id="2df61-116">CLR の定義によって、XAML で構築する構造体は、常にできます。</span><span class="sxs-lookup"><span data-stu-id="2df61-116">Structures are always able to be constructed in XAML, by CLR definition.</span></span> <span data-ttu-id="2df61-117">CLR コンパイラが暗黙的に構造体の既定のコンス トラクターを作成するためです。</span><span class="sxs-lookup"><span data-stu-id="2df61-117">This is because a CLR compiler implicitly creates a default constructor for a structure.</span></span> <span data-ttu-id="2df61-118">このコンス トラクターでは、すべてのプロパティ値が既定値に初期化します。</span><span class="sxs-lookup"><span data-stu-id="2df61-118">This constructor initializes all property values to their defaults.</span></span>  
  
 <span data-ttu-id="2df61-119">場合によっては、構造体の既定の構築の動作は望ましくありません。</span><span class="sxs-lookup"><span data-stu-id="2df61-119">In some cases, the default construction behavior for a structure is not desirable.</span></span> <span data-ttu-id="2df61-120">構造体は値と関数を共用体として概念的に入力するためのものがあります。</span><span class="sxs-lookup"><span data-stu-id="2df61-120">This might be because the structure is intended to fill values and function conceptually as a union.</span></span> <span data-ttu-id="2df61-121">共用体型として値を含んで、排他的な解釈し、したがって、そのプロパティは設定可能なします。</span><span class="sxs-lookup"><span data-stu-id="2df61-121">As a union, the contained values might have mutually exclusive interpretations, and therefore, none of its properties are settable.</span></span> <span data-ttu-id="2df61-122">WPF ボキャブラリで、このような構造の例は<xref:System.Windows.GridLength>します。</span><span class="sxs-lookup"><span data-stu-id="2df61-122">An example of such a structure in the WPF vocabulary is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="2df61-123">このような構造は、値は、さまざまな解釈や構造体の値のモードを作成する文字列の規則を使用して、属性の形式で表すことができるように、型コンバーターを実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="2df61-123">Such structures should implement a type converter so that the values can be expressed in attribute form, by using string conventions that create the different interpretations or modes of the structure values.</span></span> <span data-ttu-id="2df61-124">構造体には、既定以外のコンス トラクターを使用してコード構築の同様の動作も公開する必要があります。</span><span class="sxs-lookup"><span data-stu-id="2df61-124">The structure should also expose similar behavior for code construction through a non-default constructor.</span></span>  
  
### <a name="interfaces"></a><span data-ttu-id="2df61-125">インターフェイス</span><span class="sxs-lookup"><span data-stu-id="2df61-125">Interfaces</span></span>  
 <span data-ttu-id="2df61-126">インターフェイスは、基になる型のメンバーとして使用できます。</span><span class="sxs-lookup"><span data-stu-id="2df61-126">Interfaces can be used as underlying types of members.</span></span> <span data-ttu-id="2df61-127">XAML 型システムでは、割り当て可能な一覧を確認し、値として指定されているオブジェクトをインターフェイスに割り当てできることが必要です。</span><span class="sxs-lookup"><span data-stu-id="2df61-127">The XAML type system checks the assignable list and expects that the object that is provided as the value can be assigned to the interface.</span></span> <span data-ttu-id="2df61-128">方法インターフェイスの存在が必要、XAML の型として関連割り当て可能な型は、XAML の作成要件をサポートしている限りの概念はありません。</span><span class="sxs-lookup"><span data-stu-id="2df61-128">There is no concept of how the interface must be presented as a XAML type as long as a relevant assignable type supports the XAML construction requirements.</span></span>  
  
### <a name="factory-methods"></a><span data-ttu-id="2df61-129">ファクトリ メソッド</span><span class="sxs-lookup"><span data-stu-id="2df61-129">Factory Methods</span></span>  
 <span data-ttu-id="2df61-130">ファクトリ メソッドは、XAML 2009 の機能です。</span><span class="sxs-lookup"><span data-stu-id="2df61-130">Factory methods are a XAML 2009 feature.</span></span> <span data-ttu-id="2df61-131">これらは、オブジェクトが必要となる既定のコンス トラクター XAML 原則を変更します。</span><span class="sxs-lookup"><span data-stu-id="2df61-131">They modify the XAML principle that objects must have default constructors.</span></span> <span data-ttu-id="2df61-132">ファクトリ メソッドは、このトピックに記載されていません。</span><span class="sxs-lookup"><span data-stu-id="2df61-132">Factory methods are not documented in this topic.</span></span> <span data-ttu-id="2df61-133">参照してください[X:factorymethod ディレクティブ](../../../docs/framework/xaml-services/x-factorymethod-directive.md)です。</span><span class="sxs-lookup"><span data-stu-id="2df61-133">See [x:FactoryMethod Directive](../../../docs/framework/xaml-services/x-factorymethod-directive.md).</span></span>  
  
## <a name="enumerations"></a><span data-ttu-id="2df61-134">列挙</span><span class="sxs-lookup"><span data-stu-id="2df61-134">Enumerations</span></span>  
 <span data-ttu-id="2df61-135">列挙体では、XAML のネイティブな型変換動作があります。</span><span class="sxs-lookup"><span data-stu-id="2df61-135">Enumerations have XAML native type conversion behavior.</span></span> <span data-ttu-id="2df61-136">XAML で指定された列挙定数の名前は、基になる列挙型に対して解決され、XAML オブジェクト ライターに、列挙値を返します。</span><span class="sxs-lookup"><span data-stu-id="2df61-136">Enumeration constant names specified in XAML are resolved against the underlying enumeration type, and return the enumeration value to a XAML object writer.</span></span>  
  
 <span data-ttu-id="2df61-137">XAML の列挙にスタイル フラグの使用状況をサポートしている<xref:System.FlagsAttribute>適用します。</span><span class="sxs-lookup"><span data-stu-id="2df61-137">XAML supports a flags-style usage for enumerations with <xref:System.FlagsAttribute> applied.</span></span> <span data-ttu-id="2df61-138">詳細については、次を参照してください。 [XAML 構文の詳細](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md)です。</span><span class="sxs-lookup"><span data-stu-id="2df61-138">For more information, see [XAML Syntax In Detail](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md).</span></span> <span data-ttu-id="2df61-139">([XAML 構文の詳細](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md)WPF ユーザーを対象に書き込まれますが、そのトピックの情報の大部分は、特定の実装のフレームワークに固有ではない xaml 関連します)。</span><span class="sxs-lookup"><span data-stu-id="2df61-139">([XAML Syntax In Detail](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md) is written for the WPF audience, but most of the information in that topic is relevant for XAML that is not specific to a particular implementing framework.)</span></span>  
  
## <a name="member-definitions"></a><span data-ttu-id="2df61-140">メンバーの定義</span><span class="sxs-lookup"><span data-stu-id="2df61-140">Member Definitions</span></span>  
 <span data-ttu-id="2df61-141">型は、XAML の使用方法のメンバーを定義できます。</span><span class="sxs-lookup"><span data-stu-id="2df61-141">Types can define members for XAML usage.</span></span> <span data-ttu-id="2df61-142">その特定の種類が XAML で使用できない場合でも、XAML の使用可能なメンバーを定義する型のことができます。</span><span class="sxs-lookup"><span data-stu-id="2df61-142">It is possible for types that define members that are XAML-usable even if that specific type is not XAML-usable.</span></span> <span data-ttu-id="2df61-143">これは、CLR の継承によって実現します。</span><span class="sxs-lookup"><span data-stu-id="2df61-143">This is possible because of CLR inheritance.</span></span> <span data-ttu-id="2df61-144">メンバーを継承するいくつかの型の型としての XAML の使用方法をサポートしていると、メンバーの基になる型の XAML の使用方法をサポートまたはネイティブ XAML 構文の使用可能な限り、そのメンバーが XAML で使用します。</span><span class="sxs-lookup"><span data-stu-id="2df61-144">So long as some type that inherits the member supports XAML usage as a type, and the member supports XAML usage for its underlying type or has a native XAML syntax available, that member is XAML-usable.</span></span>  
  
### <a name="properties"></a><span data-ttu-id="2df61-145">プロパティ</span><span class="sxs-lookup"><span data-stu-id="2df61-145">Properties</span></span>  
 <span data-ttu-id="2df61-146">一般的な CLR を使用して、パブリックの CLR プロパティとしてプロパティを定義するかどうかは`get`と`set`アクセサー パターンと言語に応じた keywording、XAML 型システムが指定されたプロパティを適切な情報を持つメンバーとしてをレポートすることができます<xref:System.Xaml.XamlMember>プロパティなど<xref:System.Xaml.XamlMember.IsReadPublic%2A>と<xref:System.Xaml.XamlMember.IsWritePublic%2A>です。</span><span class="sxs-lookup"><span data-stu-id="2df61-146">If you define properties as a public CLR property using the typical CLR `get` and `set` accessor patterns and language-appropriate keywording, the XAML type system can report the property as a member with appropriate information provided for <xref:System.Xaml.XamlMember> properties, such as <xref:System.Xaml.XamlMember.IsReadPublic%2A> and <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span></span>  
  
 <span data-ttu-id="2df61-147">特定のプロパティは、適用することで、テキスト構文を有効にできます<xref:System.ComponentModel.TypeConverterAttribute>です。</span><span class="sxs-lookup"><span data-stu-id="2df61-147">Specific properties can enable a text syntax by applying <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="2df61-148">詳細については、次を参照してください。[型コンバーターと XAML のマークアップ拡張機能](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md)します。</span><span class="sxs-lookup"><span data-stu-id="2df61-148">For more information, see [Type Converters and Markup Extensions for XAML](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md).</span></span>  
  
 <span data-ttu-id="2df61-149">テキストの構文またはネイティブの XAML の変換がない場合、さらに、間接参照、マークアップ拡張機能の使用状況など、プロパティの型がない場合 (<xref:System.Xaml.XamlMember.TargetType%2A> xaml 型システム) を t を扱うことにより、XAML オブジェクト ライターにインスタンスを返すことがありますCLR 型とターゲット型です。</span><span class="sxs-lookup"><span data-stu-id="2df61-149">In the absence of a text syntax or native XAML conversion and in the absence of further indirection, such as a markup extension usage, the type of a property (<xref:System.Xaml.XamlMember.TargetType%2A> in the XAML type system) must be able to return an instance to a XAML object writer by treating the target type as a CLR type.</span></span>  
  
 <span data-ttu-id="2df61-150">XAML 2009 を使用して場合[X:reference マークアップ拡張機能](../../../docs/framework/xaml-services/x-reference-markup-extension.md)値を指定する、前の考慮事項が満たされない場合も使用できます。 ただし、型定義の問題よりも使用状況に関する問題の詳細はします。</span><span class="sxs-lookup"><span data-stu-id="2df61-150">If using XAML 2009, [x:Reference Markup Extension](../../../docs/framework/xaml-services/x-reference-markup-extension.md) can be used to provide values if the previous considerations are not met; however, that is more of a usage issue than a type definition issue.</span></span>  
  
### <a name="events"></a><span data-ttu-id="2df61-151">イベント</span><span class="sxs-lookup"><span data-stu-id="2df61-151">Events</span></span>  
 <span data-ttu-id="2df61-152">XAML 型システムできますを持つメンバーとして、イベントを報告する場合は、パブリックの CLR イベントとイベントを定義する<xref:System.Xaml.XamlMember.IsEvent%2A>として`true`です。</span><span class="sxs-lookup"><span data-stu-id="2df61-152">If you define events as a public CLR event, the XAML type system can report the event as a member with <xref:System.Xaml.XamlMember.IsEvent%2A> as `true`.</span></span> <span data-ttu-id="2df61-153">.NET Framework XAML サービス機能のスコープ内にないため、イベント ハンドラーを配線これは、特定のフレームワークと実装に任されてです。</span><span class="sxs-lookup"><span data-stu-id="2df61-153">Wiring the event handlers is not within the scope of .NET Framework XAML Services capabilities; this is left to specific frameworks and implementations.</span></span>  
  
### <a name="methods"></a><span data-ttu-id="2df61-154">メソッド</span><span class="sxs-lookup"><span data-stu-id="2df61-154">Methods</span></span>  
 <span data-ttu-id="2df61-155">メソッドのインライン コードは、既定の XAML 機能ではありません。</span><span class="sxs-lookup"><span data-stu-id="2df61-155">Inline code for methods is not a default XAML capability.</span></span> <span data-ttu-id="2df61-156">ほとんどの場合で直接参照しないメソッドのメンバー、XAML からして、XAML でのメソッドの役割は、特定の XAML パターンのサポートを提供するだけです。</span><span class="sxs-lookup"><span data-stu-id="2df61-156">In most cases you do not directly reference method members from XAML, and the role of methods in XAML is only to provide support for specific XAML patterns.</span></span> <span data-ttu-id="2df61-157">[X:factorymethod ディレクティブ](../../../docs/framework/xaml-services/x-factorymethod-directive.md)は例外です。</span><span class="sxs-lookup"><span data-stu-id="2df61-157">[x:FactoryMethod Directive](../../../docs/framework/xaml-services/x-factorymethod-directive.md) is an exception.</span></span>  
  
### <a name="fields"></a><span data-ttu-id="2df61-158">フィールド</span><span class="sxs-lookup"><span data-stu-id="2df61-158">Fields</span></span>  
 <span data-ttu-id="2df61-159">CLR のデザイン ガイドラインは、非静的フィールドを防止します。</span><span class="sxs-lookup"><span data-stu-id="2df61-159">CLR design guidelines discourage nonstatic fields.</span></span> <span data-ttu-id="2df61-160">静的フィールドは、静的フィールドの値にアクセスできますを通してのみ[X:static マークアップ拡張機能](../../../docs/framework/xaml-services/x-static-markup-extension.md); ここでは、何もありません用のフィールドを公開する CLR の定義の特別な[X:static](../../../docs/framework/xaml-services/x-static-markup-extension.md)の使用法。</span><span class="sxs-lookup"><span data-stu-id="2df61-160">For static fields, you can access static field values only through [x:Static Markup Extension](../../../docs/framework/xaml-services/x-static-markup-extension.md); in this case you are not doing anything special in the CLR definition to expose a field for [x:Static](../../../docs/framework/xaml-services/x-static-markup-extension.md) usages.</span></span>  
  
## <a name="attachable-members"></a><span data-ttu-id="2df61-161">アタッチ可能なメンバー</span><span class="sxs-lookup"><span data-stu-id="2df61-161">Attachable Members</span></span>  
 <span data-ttu-id="2df61-162">アタッチ可能なメンバーは、XAML を定義する型のアクセサー メソッド パターンを通じて公開されます。</span><span class="sxs-lookup"><span data-stu-id="2df61-162">Attachable members are exposed to XAML through an accessor method pattern on a defining type.</span></span> <span data-ttu-id="2df61-163">定義の型自体は、オブジェクトとして、XAML で使用する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="2df61-163">The defining type itself does not need to be XAML-usable as an object.</span></span> <span data-ttu-id="2df61-164">実際には、一般的なパターンでは、ロールがあるサービス クラスを宣言する添付可能なメンバーを所有して、関連する動作を実装するだけ UI 表現などの他の関数は使用されません。</span><span class="sxs-lookup"><span data-stu-id="2df61-164">In fact, a common pattern is to declare a service class whose role is to own the attachable member and implement the related behaviors, but serve no other function such as a UI representation.</span></span> <span data-ttu-id="2df61-165">次のセクションでは、プレース ホルダーの*PropertyName*アタッチ可能なメンバーの名前を表します。</span><span class="sxs-lookup"><span data-stu-id="2df61-165">For the following sections, the placeholder *PropertyName* represents the name of your attachable member.</span></span> <span data-ttu-id="2df61-166">その名前を無効にする必要があります、 [XamlName の文法](../../../docs/framework/xaml-services/xamlname-grammar.md)です。</span><span class="sxs-lookup"><span data-stu-id="2df61-166">That name must be valid in the [XamlName Grammar](../../../docs/framework/xaml-services/xamlname-grammar.md).</span></span>  
  
 <span data-ttu-id="2df61-167">これらのパターンと型の他のメソッド間で名前の衝突の注意する必要があります。</span><span class="sxs-lookup"><span data-stu-id="2df61-167">Be cautious of name collisions between these patterns and other methods of a type.</span></span> <span data-ttu-id="2df61-168">いずれのパターンに一致するメンバーが存在する場合、として解釈できるアタッチ可能なメンバーの使用の経路、XAML プロセッサによって場合でもに設定することはありませんでした。</span><span class="sxs-lookup"><span data-stu-id="2df61-168">If a member exists that matches one of the patterns, it can be interpreted as an attachable member usage pathway by a XAML processor even if that was not your intention.</span></span>  
  
#### <a name="the-getpropertyname-accessor"></a><span data-ttu-id="2df61-169">GetPropertyName アクセサー</span><span class="sxs-lookup"><span data-stu-id="2df61-169">The GetPropertyName Accessor</span></span>  
 <span data-ttu-id="2df61-170">`Get`*PropertyName* アクセサーのシグネチャは次の形式にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="2df61-170">The signature for the `Get`*PropertyName* accessor must be:</span></span>  
  
 <span data-ttu-id="2df61-171">`public static object Get` *PropertyName* `(object`  `target` `)`</span><span class="sxs-lookup"><span data-stu-id="2df61-171">`public static object Get` *PropertyName* `(object`  `target` `)`</span></span>  
  
-   <span data-ttu-id="2df61-172">`target` オブジェクトは、実装のより具体的な型として指定することができます。</span><span class="sxs-lookup"><span data-stu-id="2df61-172">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="2df61-173">これを使用するには、アタッチ可能なメンバーの使用状況のスコープを指定する意図したスコープ外の使用方法、XAML の解析エラーによって、表示された無効なキャスト例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="2df61-173">You can use this to scope the usage of your attachable member; usages outside your intended scope will throw invalid cast exceptions that are then surfaced by a XAML parse error.</span></span> <span data-ttu-id="2df61-174">パラメーター名`target`、必須ではありませんが、名前は`target`ほとんどの実装では規約によってです。</span><span class="sxs-lookup"><span data-stu-id="2df61-174">The parameter name `target` is not a requirement, but is named `target` by convention in most implementations.</span></span>  
  
-   <span data-ttu-id="2df61-175">戻り値は、実装のより具体的な型として指定することができます。</span><span class="sxs-lookup"><span data-stu-id="2df61-175">The return value can be specified as a more specific type in your implementation.</span></span>  
  
 <span data-ttu-id="2df61-176">サポートするために、<xref:System.ComponentModel.TypeConverter>添付可能なメンバーの属性の使用方法を有効になっているテキストの構文を適用<xref:System.ComponentModel.TypeConverterAttribute>を`Get` *PropertyName*アクセサー。</span><span class="sxs-lookup"><span data-stu-id="2df61-176">To support a <xref:System.ComponentModel.TypeConverter> enabled text syntax for attribute usage of the attachable member, apply <xref:System.ComponentModel.TypeConverterAttribute> to the `Get`*PropertyName* accessor.</span></span> <span data-ttu-id="2df61-177">適用する、`get`の代わりに、`set`かもしれませんが直感; ただし、この規則は、概念をサポートできます読み取り専用添付可能なメンバーのシリアル化可能なこれはデザイナーのシナリオで役立ちます。</span><span class="sxs-lookup"><span data-stu-id="2df61-177">Applying to the `get` instead of the `set` may seem nonintuitive; however, this convention can support the concept of read-only attachable members that are serializable, which is useful in designer scenarios.</span></span>  
  
#### <a name="the-setpropertyname-accessor"></a><span data-ttu-id="2df61-178">SetPropertyName アクセサー</span><span class="sxs-lookup"><span data-stu-id="2df61-178">The SetPropertyName Accessor</span></span>  
 <span data-ttu-id="2df61-179">セットの署名*PropertyName*アクセサーを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="2df61-179">The signature for the Set*PropertyName* accessor must be:</span></span>  
  
 <span data-ttu-id="2df61-180">`public static void Set` *PropertyName* `(object`  `target` `, object`  `value` `)`</span><span class="sxs-lookup"><span data-stu-id="2df61-180">`public static void Set` *PropertyName* `(object`  `target` `, object`  `value` `)`</span></span>  
  
-   <span data-ttu-id="2df61-181">`target`オブジェクトは、前のセクションで説明したのと同じロジックの結果、実装でより具体的な種類として指定できます。</span><span class="sxs-lookup"><span data-stu-id="2df61-181">The `target` object can be specified as a more specific type in your implementation, with same logic and consequences as described in the previous section.</span></span>  
  
-   <span data-ttu-id="2df61-182">`value` オブジェクトは、実装のより具体的な型として指定することができます。</span><span class="sxs-lookup"><span data-stu-id="2df61-182">The `value` object can be specified as a more specific type in your implementation.</span></span>  
  
 <span data-ttu-id="2df61-183">このメソッドの値は、XAML の使用方法、属性の形式で通常からの入力であることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="2df61-183">Remember that the value for this method is the input coming from the XAML usage, typically in attribute form.</span></span> <span data-ttu-id="2df61-184">属性の形式から必要があります、テキスト構文の値コンバーターのサポートと属性を`Get` *PropertyName*アクセサー。</span><span class="sxs-lookup"><span data-stu-id="2df61-184">From attribute form there must be value converter support for a text syntax, and you attribute on the `Get`*PropertyName* accessor.</span></span>  
  
### <a name="attachable-member-stores"></a><span data-ttu-id="2df61-185">アタッチ可能メンバー ストア</span><span class="sxs-lookup"><span data-stu-id="2df61-185">Attachable Member Stores</span></span>  
 <span data-ttu-id="2df61-186">アクセサー メソッドは通常ありませんアタッチ可能なメンバーの値をオブジェクト グラフに配置するか、オブジェクト グラフの外部に値を取得し、シリアル化して、正しくする手段を提供するのに十分なです。</span><span class="sxs-lookup"><span data-stu-id="2df61-186">The accessor methods are typically not enough to provide a means to place attachable member values into an object graph, or to retrieve values out of the object graph and serialize them properly.</span></span> <span data-ttu-id="2df61-187">この機能を提供する、`target`上のアクセサーのシグネチャ内のオブジェクトの値を格納できる必要があります。</span><span class="sxs-lookup"><span data-stu-id="2df61-187">To provide this functionality, the `target` objects in the previous accessor signatures must be capable of storing values.</span></span> <span data-ttu-id="2df61-188">記憶域メカニズムは、メンバーは、アタッチ可能なメンバーがないメンバー リスト内のターゲットにアタッチ可能なアタッチ可能なメンバーの原則と一致する必要があります。</span><span class="sxs-lookup"><span data-stu-id="2df61-188">The storage mechanism should be consistent with the attachable member principle that the member is attachable to targets where the attachable member is not in the members list.</span></span> <span data-ttu-id="2df61-189">.NET framework XAML サービスは、実装手法で、アタッチ可能なメンバーを格納、Api を介して<xref:System.Xaml.IAttachedPropertyStore>と<xref:System.Xaml.AttachablePropertyServices>です。</span><span class="sxs-lookup"><span data-stu-id="2df61-189">.NET Framework XAML Services provides an implementation technique for attachable member stores through the APIs <xref:System.Xaml.IAttachedPropertyStore> and <xref:System.Xaml.AttachablePropertyServices>.</span></span> <span data-ttu-id="2df61-190"><xref:System.Xaml.IAttachedPropertyStore>ストアの実装を検出する XAML ライターによって使用され、ある型に実装する必要があります、`target`アクセサー。</span><span class="sxs-lookup"><span data-stu-id="2df61-190"><xref:System.Xaml.IAttachedPropertyStore> is used by the XAML writers to discover the store implementation, and should be implemented on the type that is the `target` of the accessors.</span></span> <span data-ttu-id="2df61-191">静的な<xref:System.Xaml.AttachablePropertyServices>Api は、アクセサーの本文内で使用され、アタッチ可能なメンバーを参照してください、<xref:System.Xaml.AttachableMemberIdentifier>です。</span><span class="sxs-lookup"><span data-stu-id="2df61-191">The static <xref:System.Xaml.AttachablePropertyServices> APIs are used within the body of the accessors, and refer to the attachable member by its <xref:System.Xaml.AttachableMemberIdentifier>.</span></span>  
  
## <a name="xaml-related-clr-attributes"></a><span data-ttu-id="2df61-192">XAML 関連の CLR 属性</span><span class="sxs-lookup"><span data-stu-id="2df61-192">XAML-Related CLR Attributes</span></span>  
 <span data-ttu-id="2df61-193">型、メンバー、およびアセンブリを正しく属性は、レポートには、.NET Framework XAML サービスの XAML 型システム情報を順に重要です。</span><span class="sxs-lookup"><span data-stu-id="2df61-193">Correctly attributing your types, members, and assemblies is important in order to report XAML type system information to .NET Framework XAML Services.</span></span> <span data-ttu-id="2df61-194">これは、型に直接基づく .NET Framework XAML サービスの XAML リーダーと XAML ライターでは、XAML システムを使用する場合、または定義またはそれらの XAML リーダーと XAML ライターに基づいている XAML を使用してフレームワークを使用する場合。</span><span class="sxs-lookup"><span data-stu-id="2df61-194">This is relevant if you intend your types for use with XAML systems that are directly based on .NET Framework XAML Services XAML readers and XAML writers, or if you define or use a XAML-utilizing framework that is based on those XAML readers and XAML writers.</span></span>  
  
 <span data-ttu-id="2df61-195">カスタムの型の XAML サポート対象の各 XAML 関連の属性の一覧については、次を参照してください。[カスタム型およびライブラリの CLR 属性を XAML-Related](../../../docs/framework/xaml-services/xaml-related-clr-attributes-for-custom-types-and-libraries.md)です。</span><span class="sxs-lookup"><span data-stu-id="2df61-195">For a listing of each XAML-related attribute that is relevant for XAML support of your custom types, see [XAML-Related CLR Attributes for Custom Types and Libraries](../../../docs/framework/xaml-services/xaml-related-clr-attributes-for-custom-types-and-libraries.md).</span></span>  
  
## <a name="usage"></a><span data-ttu-id="2df61-196">使用方法</span><span class="sxs-lookup"><span data-stu-id="2df61-196">Usage</span></span>  
 <span data-ttu-id="2df61-197">カスタム型の使用方法は、マークアップの作成者がカスタム型を含むアセンブリと CLR 名前空間のプレフィックスをマップする必要がある必要があります。</span><span class="sxs-lookup"><span data-stu-id="2df61-197">Usage of custom types requires that the markup author must map a prefix for the assembly and CLR namespace that contain the custom type.</span></span> <span data-ttu-id="2df61-198">このトピックでは、この手順が記載されていません。</span><span class="sxs-lookup"><span data-stu-id="2df61-198">This procedure is not documented in this topic.</span></span>  
  
## <a name="access-level"></a><span data-ttu-id="2df61-199">アクセス レベル</span><span class="sxs-lookup"><span data-stu-id="2df61-199">Access Level</span></span>  
 <span data-ttu-id="2df61-200">XAML をロードおよびを持つ型をインスタンス化する手段を提供する、`internal`アクセス レベル。</span><span class="sxs-lookup"><span data-stu-id="2df61-200">XAML provides a means to load and instantiate types that have an `internal` access level.</span></span> <span data-ttu-id="2df61-201">この機能を提供するは、ユーザー コードが独自の型を定義しても、同じユーザー コードのスコープの一部であるマークアップからこれらのクラスのインスタンスを作成できるようにします。</span><span class="sxs-lookup"><span data-stu-id="2df61-201">This capability is provided so that user code can define its own types, and then instantiate those classes from markup that is also part of the same user code scope.</span></span>  
  
 <span data-ttu-id="2df61-202">WPF の例は、ユーザー コードを定義するたびに、<xref:System.Windows.Controls.UserControl>はものでは、UI の動作をリファクターする方法としてをサポートするクラスを宣言することで暗黙的な可能性がある任意の拡張メカニズムの一部としてではなく`public`アクセス レベル。</span><span class="sxs-lookup"><span data-stu-id="2df61-202">An example from WPF is whenever user code defines a <xref:System.Windows.Controls.UserControl> that is intended as a way to refactor a UI behavior, but not as part of any possible extension mechanism that might be implied by declaring the supporting class with `public` access level.</span></span> <span data-ttu-id="2df61-203">このような<xref:System.Windows.Controls.UserControl>で宣言できる`internal`バッキング コードは、XAML の型として参照されている元の同じアセンブリにコンパイルされる場合にアクセスします。</span><span class="sxs-lookup"><span data-stu-id="2df61-203">Such a <xref:System.Windows.Controls.UserControl> can be declared with `internal` access if the backing code is compiled into the same assembly from which it is referenced as a XAML type.</span></span>  
  
 <span data-ttu-id="2df61-204">完全な信頼で XAML をロードを使用してアプリケーションの<xref:System.Xaml.XamlObjectWriter>を持つクラスを読み込む`internal`アクセス レベルが常に有効にします。</span><span class="sxs-lookup"><span data-stu-id="2df61-204">For an application that loads XAML under full trust and uses <xref:System.Xaml.XamlObjectWriter>, loading classes with `internal` access level is always enabled.</span></span>  
  
 <span data-ttu-id="2df61-205">アプリケーションで部分信頼で XAML をロードする場合を使用してアクセスのレベルの特性を制御できます、 <xref:System.Xaml.Permissions.XamlAccessLevel> API です。</span><span class="sxs-lookup"><span data-stu-id="2df61-205">For an application that loads XAML under partial trust, you can control the access level characteristics by using the <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span></span> <span data-ttu-id="2df61-206">また、(、WPF テンプレート システムなど) の遅延メカニズムできる必要がありますを任意のアクセス レベルのアクセス許可を反映してそれらを保持する最終的な実行時の評価です。これは処理内部的に渡すことによって、<xref:System.Xaml.Permissions.XamlAccessLevel>情報。</span><span class="sxs-lookup"><span data-stu-id="2df61-206">Also, deferral mechanisms (such as the WPF template system) must be able to propagate any access level permissions and preserve them for the eventual run time evaluations; this is handled internally by passing the <xref:System.Xaml.Permissions.XamlAccessLevel> information.</span></span>  
  
### <a name="wpf-implementation"></a><span data-ttu-id="2df61-207">WPF の実装</span><span class="sxs-lookup"><span data-stu-id="2df61-207">WPF Implementation</span></span>  
 <span data-ttu-id="2df61-208">XAML の WPF モデルを使用して、部分信頼のアクセス、BAML が部分信頼で読み込まれると、アクセスに制限されます<xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A>BAML ソースであるアセンブリ。</span><span class="sxs-lookup"><span data-stu-id="2df61-208">WPF XAML uses a partial-trust access model where if BAML is loaded under partial trust, access is restricted to <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> for the assembly that is the BAML source.</span></span> <span data-ttu-id="2df61-209">WPF を使用して遅延、<xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType>アクセス レベルの情報を渡すためのメカニズムとして。</span><span class="sxs-lookup"><span data-stu-id="2df61-209">For deferral, WPF uses <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> as a mechanism for passing the access level information.</span></span>  
  
 <span data-ttu-id="2df61-210">WPF XAML 用語では、*内部型*は、同じアセンブリも含まれており、参照元の XAML で定義されている型です。</span><span class="sxs-lookup"><span data-stu-id="2df61-210">In WPF XAML terminology, an *internal type* is a type that is defined by the same assembly that also includes the referencing XAML.</span></span> <span data-ttu-id="2df61-211">アセンブリを意図的に省略された XAML 名前空間を介してこのような型をマップすることができます、マッピングの一部を =`xmlns:local="clr-namespace:WPFApplication1"`です。</span><span class="sxs-lookup"><span data-stu-id="2df61-211">Such a type can be mapped through a XAML namespace that deliberately omits the assembly= portion of a mapping, for example, `xmlns:local="clr-namespace:WPFApplication1"`.</span></span>  <span data-ttu-id="2df61-212">BAML が内部の型を参照するかどうか、型がある`internal`アクセス レベル、これが生成されます、`GeneratedInternalTypeHelper`アセンブリのクラスです。</span><span class="sxs-lookup"><span data-stu-id="2df61-212">If BAML references an internal type and that type has `internal` access level, this generates a `GeneratedInternalTypeHelper` class for the assembly.</span></span> <span data-ttu-id="2df61-213">避けたい場合`GeneratedInternalTypeHelper`、いずれかを使用する必要がある`public`アクセス レベル、または必要があります別のアセンブリに関連するクラスを要素し、そのアセンブリが依存するようにします。</span><span class="sxs-lookup"><span data-stu-id="2df61-213">If you want to avoid `GeneratedInternalTypeHelper`, you either must use `public` access level, or must factor the relevant class into a separate assembly and make that assembly dependent.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="2df61-214">関連項目</span><span class="sxs-lookup"><span data-stu-id="2df61-214">See Also</span></span>  
 [<span data-ttu-id="2df61-215">カスタム型およびライブラリの XAML 関連の CLR 属性</span><span class="sxs-lookup"><span data-stu-id="2df61-215">XAML-Related CLR Attributes for Custom Types and Libraries</span></span>](../../../docs/framework/xaml-services/xaml-related-clr-attributes-for-custom-types-and-libraries.md)  
 [<span data-ttu-id="2df61-216">XAML サービス</span><span class="sxs-lookup"><span data-stu-id="2df61-216">XAML Services</span></span>](../../../docs/framework/xaml-services/index.md)
