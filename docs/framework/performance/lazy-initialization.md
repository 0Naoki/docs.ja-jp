---
title: 遅延初期化
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- lazy initialization in .NET, introduction
ms.assetid: 56b4ae5c-4745-44ff-ad78-ffe4fcde6b9b
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: ce217e2ed8e542ad0f7122970655aa32a353f51a
ms.sourcegitcommit: 0be8a279af6d8a43e03141e349d3efd5d35f8767
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/18/2019
ms.locfileid: "59182300"
---
# <a name="lazy-initialization"></a><span data-ttu-id="9c2e8-102">遅延初期化</span><span class="sxs-lookup"><span data-stu-id="9c2e8-102">Lazy Initialization</span></span>
<span data-ttu-id="9c2e8-103">オブジェクトの*遅延初期化*とは、初めて使用されるまでオブジェクトの作成が延期されることを意味します。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-103">*Lazy initialization* of an object means that its creation is deferred until it is first used.</span></span> <span data-ttu-id="9c2e8-104">(このトピックでは、*遅延初期化*と*遅延インスタンス化*を同じ意味の言葉として使っています。)遅延初期化は主に、パフォーマンスの改善、無駄な計算処理の回避、プログラムのメモリ要件の縮小を目的として利用されます。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-104">(For this topic, the terms *lazy initialization* and *lazy instantiation* are synonymous.) Lazy initialization is primarily used to improve performance, avoid wasteful computation, and reduce program memory requirements.</span></span> <span data-ttu-id="9c2e8-105">最も一般的なシナリオ:</span><span class="sxs-lookup"><span data-stu-id="9c2e8-105">These are the most common scenarios:</span></span>  
  
-   <span data-ttu-id="9c2e8-106">あるオブジェクトを作成するとコストが高いのに、プログラムでそのオブジェクトが使用されない可能性もある。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-106">When you have an object that is expensive to create, and the program might not use it.</span></span> <span data-ttu-id="9c2e8-107">たとえば、メモリ内の `Customer` オブジェクトに `Orders` プロパティがあるとします。このプロパティには、`Order` オブジェクトの大きな配列が含まれていますが、これを初期化するにはデータベースに接続する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-107">For example, assume that you have in memory a `Customer` object that has an `Orders` property that contains a large array of `Order` objects that, to be initialized, requires a database connection.</span></span> <span data-ttu-id="9c2e8-108">ユーザーが Orders データを表示しないのであれば、あるいは Orders データを計算に使用しないのであれば、システム メモリや計算処理周期を利用してそのデータを作成する理由がありません。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-108">If the user never asks to display the Orders or use the data in a computation, then there is no reason to use system memory or computing cycles to create it.</span></span> <span data-ttu-id="9c2e8-109">遅延初期化では `Lazy<Orders>` を利用して `Orders` オブジェクトを宣言することで、オブジェクトが使用されない場合のシステム リソースの無駄使いを回避できます。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-109">By using `Lazy<Orders>` to declare the `Orders` object for lazy initialization, you can avoid wasting system resources when the object is not used.</span></span>  
  
-   <span data-ttu-id="9c2e8-110">あるオブジェクトを作成するとコストが高いとき、他の高額な演算が完了するまで、そのオブジェクトの作成を延期する。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-110">When you have an object that is expensive to create, and you want to defer its creation until after other expensive operations have been completed.</span></span> <span data-ttu-id="9c2e8-111">たとえば、プログラムが起動時に複数のオブジェクト インスタンスを読み込むが、すぐに必要になるのはその中の一部のインスタンスだけという場合があります。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-111">For example, assume that your program loads several object instances when it starts, but only some of them are required immediately.</span></span> <span data-ttu-id="9c2e8-112">必要なオブジェクトが作成されるまで必要にならないオブジェクトの初期化を遅らせることで、プログラムの起動パフォーマンスを改善できます。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-112">You can improve the startup performance of the program by deferring initialization of the objects that are not required until the required objects have been created.</span></span>  
  
 <span data-ttu-id="9c2e8-113">初期化を遅延させる独自のコードを記述できますが、代わりに <xref:System.Lazy%601> を使用することが推奨されます。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-113">Although you can write your own code to perform lazy initialization, we recommend that you use <xref:System.Lazy%601> instead.</span></span> <span data-ttu-id="9c2e8-114"><xref:System.Lazy%601> とその関連型はスレッドセーフ対応であり、一貫性のある例外反映ポリシーを提供します。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-114"><xref:System.Lazy%601> and its related types also support thread-safety and provide a consistent exception propagation policy.</span></span>  
  
 <span data-ttu-id="9c2e8-115">次の表は、.NET Framework バージョン 4 で提供される、さまざまなシナリオの遅延初期化を可能にする型の一覧です。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-115">The following table lists the types that the .NET Framework version 4 provides to enable lazy initialization in different scenarios.</span></span>  
  
|<span data-ttu-id="9c2e8-116">型</span><span class="sxs-lookup"><span data-stu-id="9c2e8-116">Type</span></span>|<span data-ttu-id="9c2e8-117">説明</span><span class="sxs-lookup"><span data-stu-id="9c2e8-117">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Lazy%601>|<span data-ttu-id="9c2e8-118">あらゆるクラス ライブラリやユーザー定義の型を対象に、遅延初期化セマンティクスを提供するラッパー クラス。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-118">A wrapper class that provides lazy initialization semantics for any class library or user-defined type.</span></span>|  
|<xref:System.Threading.ThreadLocal%601>|<span data-ttu-id="9c2e8-119"><xref:System.Lazy%601> に似ていますが、スレッドローカル基準の遅延初期化セマンティクスを提供する点が異なります。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-119">Resembles <xref:System.Lazy%601> except that it provides lazy initialization semantics on a thread-local basis.</span></span> <span data-ttu-id="9c2e8-120">すべてのスレッドがその固有の値にアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-120">Every thread has access to its own unique value.</span></span>|  
|<xref:System.Threading.LazyInitializer>|<span data-ttu-id="9c2e8-121">オブジェクトの遅延初期化のために高度な `static` メソッドを提供します (Visual Basic の場合は `Shared`)。クラスのオーバーヘッドがありません。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-121">Provides advanced `static` (`Shared` in Visual Basic) methods for lazy initialization of objects without the overhead of a class.</span></span>|  
  
## <a name="basic-lazy-initialization"></a><span data-ttu-id="9c2e8-122">基本的な遅延初期化</span><span class="sxs-lookup"><span data-stu-id="9c2e8-122">Basic Lazy Initialization</span></span>  
 <span data-ttu-id="9c2e8-123">`MyType` のような、遅延初期化型を定義するには、次の例のように、`Lazy<MyType>` を使用します (Visual Basic の場合は `Lazy(Of MyType)`)。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-123">To define a lazy-initialized type, for example, `MyType`, use `Lazy<MyType>` (`Lazy(Of MyType)` in Visual Basic), as shown in the following example.</span></span> <span data-ttu-id="9c2e8-124"><xref:System.Lazy%601> コンストラクターにデリゲートが渡されない場合、値プロパティの最初のアクセスで <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> を使用することで、ラップされた型が作成されます。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-124">If no delegate is passed in the <xref:System.Lazy%601> constructor, the wrapped type is created by using <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> when the value property is first accessed.</span></span> <span data-ttu-id="9c2e8-125">型に既定のコンストラクターがない場合、実行時例外が投げられます。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-125">If the type does not have a default constructor, a run-time exception is thrown.</span></span>  
  
 <span data-ttu-id="9c2e8-126">次の例では、`Orders` は、データベースから取得された `Order` オブジェクトの配列を含むクラスであると想定しています。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-126">In the following example, assume that `Orders` is a class that contains an array of `Order` objects retrieved from a database.</span></span> <span data-ttu-id="9c2e8-127">`Customer` オブジェクトには `Orders` のインスタンスが含まれていますが、ユーザーの操作によっては、`Orders` オブジェクトからのデータは必要ないことがあります。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-127">A `Customer` object contains an instance of `Orders`, but depending on user actions, the data from the `Orders` object might not be required.</span></span>  
  
 [!code-csharp[Lazy#1](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#1)]
 [!code-vb[Lazy#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#1)]  
  
 <span data-ttu-id="9c2e8-128">次の例のように、作成時に特定のコンストラクター オーバーロードを呼び出す <xref:System.Lazy%601> コンストラクターにデリゲートを渡し、他にも初期化手順が必要であればそれを実行することもできます。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-128">You can also pass a delegate in the <xref:System.Lazy%601> constructor that invokes a specific constructor overload on the wrapped type at creation time, and perform any other initialization steps that are required, as shown in the following example.</span></span>  
  
 [!code-csharp[Lazy#2](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#2)]
 [!code-vb[Lazy#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#2)]  
  
 <span data-ttu-id="9c2e8-129">遅延オブジェクトの作成後、遅延変数の <xref:System.Lazy%601.Value%2A> プロパティが初めてアクセスされるまで、`Orders` のインスタンスは作成されません。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-129">After the Lazy object is created, no instance of `Orders` is created until the <xref:System.Lazy%601.Value%2A> property of the Lazy variable is accessed for the first time.</span></span> <span data-ttu-id="9c2e8-130">最初のアクセスで、ラップされた型が作成され、返され、今後のアクセスのために保存されます。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-130">On first access, the wrapped type is created and returned, and stored for any future access.</span></span>  
  
 [!code-csharp[Lazy#3](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#3)]
 [!code-vb[Lazy#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#3)]  
  
 <span data-ttu-id="9c2e8-131"><xref:System.Lazy%601> オブジェクトは常に、初期化に利用されたものと同じオブジェクトまたは値を返します。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-131">A <xref:System.Lazy%601> object always returns the same object or value that it was initialized with.</span></span> <span data-ttu-id="9c2e8-132">そのため、<xref:System.Lazy%601.Value%2A> プロパティは読み取り専用です。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-132">Therefore, the <xref:System.Lazy%601.Value%2A> property is read-only.</span></span> <span data-ttu-id="9c2e8-133"><xref:System.Lazy%601.Value%2A> が参照型を保存する場合、それに新しいオブジェクトを割り当てることはできません。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-133">If <xref:System.Lazy%601.Value%2A> stores a reference type, you cannot assign a new object to it.</span></span> <span data-ttu-id="9c2e8-134">(ただし、その設定可能なパブリックのフィールドとプロパティを変更できます。)<xref:System.Lazy%601.Value%2A> が値型を保存する場合、その値を変更することはできません。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-134">(However, you can change the value of its settable public fields and properties.) If <xref:System.Lazy%601.Value%2A> stores a value type, you cannot modify its value.</span></span> <span data-ttu-id="9c2e8-135">それでも、変数コンストラクターを呼び出し、新しい変数を作成することはできます。新しい引数を利用します。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-135">Nevertheless, you can create a new variable by invoking the variable constructor again by using new arguments.</span></span>  
  
 [!code-csharp[Lazy#4](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#4)]
 [!code-vb[Lazy#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#4)]  
  
 <span data-ttu-id="9c2e8-136">先に見たような新しい遅延インスタンスの場合、その <xref:System.Lazy%601.Value%2A> が初めてアクセスされるまで `Orders` はインスタンス化されません。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-136">The new lazy instance, like the earlier one, does not instantiate `Orders` until its <xref:System.Lazy%601.Value%2A> property is first accessed.</span></span>  
  
### <a name="thread-safe-initialization"></a><span data-ttu-id="9c2e8-137">スレッドセーフな初期化</span><span class="sxs-lookup"><span data-stu-id="9c2e8-137">Thread-Safe Initialization</span></span>  
 <span data-ttu-id="9c2e8-138">既定では、<xref:System.Lazy%601> オブジェクトはスレッド セーフです。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-138">By default, <xref:System.Lazy%601> objects are thread-safe.</span></span> <span data-ttu-id="9c2e8-139">つまり、コンストラクターがスレッドセーフの種類を指定しない場合、スレッドセーフな <xref:System.Lazy%601> オブジェクトが作成されます。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-139">That is, if the constructor does not specify the kind of thread safety, the <xref:System.Lazy%601> objects it creates are thread-safe.</span></span> <span data-ttu-id="9c2e8-140">マルチスレッド シナリオの場合、スレッドセーフな <xref:System.Lazy%601> オブジェクトの <xref:System.Lazy%601.Value%2A> プロパティにアクセスした最初のスレッドが、すべてのスレッドのすべての後続アクセスで、オブジェクトを初期化します。すべてのスレッドが同じデータを共有します。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-140">In multi-threaded scenarios, the first thread to access the <xref:System.Lazy%601.Value%2A> property of a thread-safe <xref:System.Lazy%601> object initializes it for all subsequent accesses on all threads, and all threads share the same data.</span></span> <span data-ttu-id="9c2e8-141">そのため、どのスレッドがオブジェクトを初期化するかは問題ではありません。競合状態に害はありません。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-141">Therefore, it does not matter which thread initializes the object, and race conditions are benign.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9c2e8-142">例外キャッシュを利用すれば、エラー状態にもこの一貫性が及びます。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-142">You can extend this consistency to error conditions by using exception caching.</span></span> <span data-ttu-id="9c2e8-143">詳細については、次のセクションの「[遅延オブジェクトの例外](../../../docs/framework/performance/lazy-initialization.md#ExceptionsInLazyObjects)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-143">For more information, see the next section, [Exceptions in Lazy Objects](../../../docs/framework/performance/lazy-initialization.md#ExceptionsInLazyObjects).</span></span>  
  
 <span data-ttu-id="9c2e8-144">次の例では、同じ `Lazy<int>` インスタンスで、3 つの別個のスレッドに対して同じ値が与えられています。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-144">The following example shows that the same `Lazy<int>` instance has the same value for three separate threads.</span></span>  
  
 [!code-csharp[Lazy#8](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#8)]
 [!code-vb[Lazy#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#8)]  
  
 <span data-ttu-id="9c2e8-145">各スレッドで別個のデータが必要であれば、このトピックの後半で説明するように、<xref:System.Threading.ThreadLocal%601> 型を使用してください。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-145">If you require separate data on each thread, use the <xref:System.Threading.ThreadLocal%601> type, as described later in this topic.</span></span>  
  
 <span data-ttu-id="9c2e8-146">一部の <xref:System.Lazy%601> コンストラクターには、`isThreadSafe` という名前のブール値パラメーターがあります。これを利用し、複数のスレッドから <xref:System.Lazy%601.Value%2A> プロパティにアクセスするかどうかを指定します。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-146">Some <xref:System.Lazy%601> constructors have a Boolean parameter named `isThreadSafe` that is used to specify whether the <xref:System.Lazy%601.Value%2A> property will be accessed from multiple threads.</span></span> <span data-ttu-id="9c2e8-147">1 つだけのスレッドからこのプロパティにアクセスする場合、適度なパフォーマンス上の利点が得られるように、`false` を渡します。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-147">If you intend to access the property from just one thread, pass in `false` to obtain a modest performance benefit.</span></span> <span data-ttu-id="9c2e8-148">複数のスレッドからプロパティにアクセスする場合、`true` を渡し、初期化時、1 つのスレッドが例外をスローするような競合状態を適切に処理するように <xref:System.Lazy%601> インスタンスに指示します。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-148">If you intend to access the property from multiple threads, pass in `true` to instruct the <xref:System.Lazy%601> instance to correctly handle race conditions in which one thread throws an exception at initialization time.</span></span>  
  
 <span data-ttu-id="9c2e8-149"><xref:System.Lazy%601> の一部のコンストラクターには、`mode` という名前の <xref:System.Threading.LazyThreadSafetyMode> パラメーターが含まれています。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-149">Some <xref:System.Lazy%601> constructors have a <xref:System.Threading.LazyThreadSafetyMode> parameter named `mode`.</span></span> <span data-ttu-id="9c2e8-150">このコンストラクターでは、スレッド セーフ モードが 1 つ増えます。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-150">These constructors provide an additional thread safety mode.</span></span> <span data-ttu-id="9c2e8-151">次の表は、スレッド セーフを指定するコンストラクター パラメーターの影響を <xref:System.Lazy%601> オブジェクトのスレッド セーフが受けるしくみをまとめたものです。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-151">The following table shows how the thread safety of a <xref:System.Lazy%601> object is affected by constructor parameters that specify thread safety.</span></span> <span data-ttu-id="9c2e8-152">各コンストラクターに含まれるこのようなパラメーターは多くても 1 つです。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-152">Each constructor has at most one such parameter.</span></span>  
  
|<span data-ttu-id="9c2e8-153">オブジェクトのスレッド セーフ</span><span class="sxs-lookup"><span data-stu-id="9c2e8-153">Thread safety of the object</span></span>|<span data-ttu-id="9c2e8-154">`LazyThreadSafetyMode` `mode` パラメーター</span><span class="sxs-lookup"><span data-stu-id="9c2e8-154">`LazyThreadSafetyMode` `mode` parameter</span></span>|<span data-ttu-id="9c2e8-155">ブール値 `isThreadSafe` パラメーター</span><span class="sxs-lookup"><span data-stu-id="9c2e8-155">Boolean `isThreadSafe` parameter</span></span>|<span data-ttu-id="9c2e8-156">スレッド セーフ パラメーターなし</span><span class="sxs-lookup"><span data-stu-id="9c2e8-156">No thread safety parameters</span></span>|  
|---------------------------------|---------------------------------------------|--------------------------------------|---------------------------------|  
|<span data-ttu-id="9c2e8-157">完全スレッドセーフ。一度に 1 つだけのスレッドが値の初期化を試行します。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-157">Fully thread-safe; only one thread at a time tries to initialize the value.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>|`true`|<span data-ttu-id="9c2e8-158">はい。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-158">Yes.</span></span>|  
|<span data-ttu-id="9c2e8-159">スレッド セーフではない。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-159">Not thread-safe.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.None>|`false`|<span data-ttu-id="9c2e8-160">該当なし。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-160">Not applicable.</span></span>|  
|<span data-ttu-id="9c2e8-161">完全スレッドセーフ。値の初期化に際し、スレッドの競合が起こります。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-161">Fully thread-safe; threads race to initialize the value.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>|<span data-ttu-id="9c2e8-162">該当なし。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-162">Not applicable.</span></span>|<span data-ttu-id="9c2e8-163">該当なし。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-163">Not applicable.</span></span>|  
  
 <span data-ttu-id="9c2e8-164">表に示されているように、`mode` パラメーターに <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> を指定することは、`isThreadSafe` パラメーターに `true` を指定することと同じであり、<xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> を指定することは `false` を指定することと同じです。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-164">As the table shows, specifying <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> for the `mode` parameter is the same as specifying `true` for the `isThreadSafe` parameter, and specifying <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> is the same as specifying `false`.</span></span>  
  
 <span data-ttu-id="9c2e8-165"><xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> を指定すると、<xref:System.Lazy%601> インスタンスの初期化を複数のスレッドが試行できます。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-165">Specifying <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> allows multiple threads to attempt to initialize the <xref:System.Lazy%601> instance.</span></span> <span data-ttu-id="9c2e8-166">1 つだけのスレッドがこの競合を征します。他のスレッドはすべて、競合を征したスレッドにより初期化された値を受け取ります。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-166">Only one thread can win this race, and all the other threads receive the value that was initialized by the successful thread.</span></span> <span data-ttu-id="9c2e8-167">初期化中、あるスレッドで例外がスローされた場合、そのスレッドは、競合を征したスレッドが設定した値を受け取ることがありません。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-167">If an exception is thrown on a thread during initialization, that thread does not receive the value set by the successful thread.</span></span> <span data-ttu-id="9c2e8-168">例外はキャッシュされません。<xref:System.Lazy%601.Value%2A> プロパティへの後続のアクセス試行で初期化が行われます。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-168">Exceptions are not cached, so a subsequent attempt to access the <xref:System.Lazy%601.Value%2A> property can result in successful initialization.</span></span> <span data-ttu-id="9c2e8-169">これは、他のモードでの例外の扱いとは異なります。それについては、次のセクションで説明します。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-169">This differs from the way exceptions are treated in other modes, which is described in the following section.</span></span> <span data-ttu-id="9c2e8-170">詳細については、<xref:System.Threading.LazyThreadSafetyMode> 列挙型のページをご覧ください。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-170">For more information, see the <xref:System.Threading.LazyThreadSafetyMode> enumeration.</span></span>  
  
<a name="ExceptionsInLazyObjects"></a>   
## <a name="exceptions-in-lazy-objects"></a><span data-ttu-id="9c2e8-171">遅延オブジェクトの例外</span><span class="sxs-lookup"><span data-stu-id="9c2e8-171">Exceptions in Lazy Objects</span></span>  
 <span data-ttu-id="9c2e8-172">前述のように、<xref:System.Lazy%601> オブジェクトは常に、初期化に使用されたものと同じオブジェクトまたは値を返します。そのため、<xref:System.Lazy%601.Value%2A> プロパティは読み取り専用です。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-172">As stated earlier, a <xref:System.Lazy%601> object always returns the same object or value that it was initialized with, and therefore the <xref:System.Lazy%601.Value%2A> property is read-only.</span></span> <span data-ttu-id="9c2e8-173">例外キャッシュを有効にすると、この不変性は例外動作にも及びます。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-173">If you enable exception caching, this immutability also extends to exception behavior.</span></span> <span data-ttu-id="9c2e8-174">遅延初期化オブジェクトを例外キャッシュを有効にし、その初期化メソッドから例外をスローする場合と、<xref:System.Lazy%601.Value%2A>プロパティへのアクセスは、まずにアクセスするすべての後続の試行で同じ例外がスローされます、<xref:System.Lazy%601.Value%2A>プロパティ.</span><span class="sxs-lookup"><span data-stu-id="9c2e8-174">If a lazy-initialized object has exception caching enabled and throws an exception from its initialization method when the <xref:System.Lazy%601.Value%2A> property is first accessed, that same exception is thrown on every subsequent attempt to access the <xref:System.Lazy%601.Value%2A> property.</span></span> <span data-ttu-id="9c2e8-175">言い換えると、マルチスレッドのシナリオであっても、ラップされた型のコンストラクターが再び呼び出されることはありません。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-175">In other words, the constructor of the wrapped type is never re-invoked, even in multithreaded scenarios.</span></span> <span data-ttu-id="9c2e8-176">そのため、<xref:System.Lazy%601> オブジェクトがあるアクセスで例外をスローし、後続のアクセスで値を返すということはありません。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-176">Therefore, the <xref:System.Lazy%601> object cannot throw an exception on one access and return a value on a subsequent access.</span></span>  
  
 <span data-ttu-id="9c2e8-177">初期化メソッド (`valueFactory` パラメーター) を取る <xref:System.Lazy%601?displayProperty=nameWithType> コンストラクターを使用すると、例外キャッシュが有効になります。たとえば、`Lazy(T)(Func(T))` コンストラクターの使用時に有効になります。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-177">Exception caching is enabled when you use any <xref:System.Lazy%601?displayProperty=nameWithType> constructor that takes an initialization method (`valueFactory` parameter); for example, it is enabled when you use the `Lazy(T)(Func(T))`constructor.</span></span> <span data-ttu-id="9c2e8-178">そのコンストラクターは <xref:System.Threading.LazyThreadSafetyMode> 値 (`mode` パラメーター) も取る場合、<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> または <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> を指定します。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-178">If the constructor also takes a <xref:System.Threading.LazyThreadSafetyMode> value (`mode` parameter), specify <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> or <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9c2e8-179">初期化メソッドを指定すると、この 2 つのモードで例外キャッシュが有効になります。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-179">Specifying an initialization method enables exception caching for these two modes.</span></span> <span data-ttu-id="9c2e8-180">初期化メソッドは非常に単純にすることができます。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-180">The initialization method can be very simple.</span></span> <span data-ttu-id="9c2e8-181">たとえば、`T` に既定のコンストラクターを呼び出すことができます。C# の場合は `new Lazy<Contents>(() => new Contents(), mode)`、Visual Basic の場合は `New Lazy(Of Contents)(Function() New Contents())` です。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-181">For example, it might call the default constructor for `T`: `new Lazy<Contents>(() => new Contents(), mode)` in C#, or `New Lazy(Of Contents)(Function() New Contents())` in Visual Basic.</span></span> <span data-ttu-id="9c2e8-182">初期化メソッドを指定しない <xref:System.Lazy%601?displayProperty=nameWithType> コンストラクターを使った場合、`T` について既定のコンストラクターからスローされる例外はキャッシュされません。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-182">If you use a <xref:System.Lazy%601?displayProperty=nameWithType> constructor that does not specify an initialization method, exceptions that are thrown by the default constructor for `T` are not cached.</span></span> <span data-ttu-id="9c2e8-183">詳細については、<xref:System.Threading.LazyThreadSafetyMode> 列挙型のページをご覧ください。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-183">For more information, see the <xref:System.Threading.LazyThreadSafetyMode> enumeration.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9c2e8-184">`isThreadSafe` コンストラクター パラメーターを `false` に設定するか、`mode` コンストラクター パラメーターを <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> に設定して <xref:System.Lazy%601> オブジェクトを作成した場合、1 つのスレッドから <xref:System.Lazy%601> オブジェクトにアクセスするか、独自の同期を提供する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-184">If you create a <xref:System.Lazy%601> object with the `isThreadSafe` constructor parameter set to `false` or the `mode` constructor parameter set to <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>, you must access the <xref:System.Lazy%601> object from a single thread or provide your own synchronization.</span></span> <span data-ttu-id="9c2e8-185">これは、例外キャッシュを含む、オブジェクトのあらゆる側面に適用されます。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-185">This applies to all aspects of the object, including exception caching.</span></span>  
  
 <span data-ttu-id="9c2e8-186">前のセクションで説明したように、<xref:System.Lazy%601> オブジェクトの作成に <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> を指定した場合、例外の処理が異なります。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-186">As noted in the previous section, <xref:System.Lazy%601> objects created by specifying <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> treat exceptions differently.</span></span> <span data-ttu-id="9c2e8-187"><xref:System.Threading.LazyThreadSafetyMode.PublicationOnly> の場合、<xref:System.Lazy%601> インスタンスの初期化にあたり、複数のスレッドが競合できます。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-187">With <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>, multiple threads can compete to initialize the <xref:System.Lazy%601> instance.</span></span> <span data-ttu-id="9c2e8-188">その場合、例外はキャッシュされません。<xref:System.Lazy%601.Value%2A> プロパティに対するアクセス試行は初期化完了まで続行されます。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-188">In this case, exceptions are not cached, and attempts to access the <xref:System.Lazy%601.Value%2A> property can continue until initialization is successful.</span></span>  
  
 <span data-ttu-id="9c2e8-189">次の表は、<xref:System.Lazy%601> コンストラクターが例外キャッシュを制御するしくみをまとめたものです。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-189">The following table summarizes the way the <xref:System.Lazy%601> constructors control exception caching.</span></span>  
  
|<span data-ttu-id="9c2e8-190">コンストラクター</span><span class="sxs-lookup"><span data-stu-id="9c2e8-190">Constructor</span></span>|<span data-ttu-id="9c2e8-191">スレッド セーフ モード</span><span class="sxs-lookup"><span data-stu-id="9c2e8-191">Thread safety mode</span></span>|<span data-ttu-id="9c2e8-192">初期化メソッドを使用します</span><span class="sxs-lookup"><span data-stu-id="9c2e8-192">Uses initialization method</span></span>|<span data-ttu-id="9c2e8-193">例外がキャッシュされます</span><span class="sxs-lookup"><span data-stu-id="9c2e8-193">Exceptions are cached</span></span>|  
|-----------------|------------------------|--------------------------------|---------------------------|  
|<span data-ttu-id="9c2e8-194">Lazy(T)()</span><span class="sxs-lookup"><span data-stu-id="9c2e8-194">Lazy(T)()</span></span>|<span data-ttu-id="9c2e8-195">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span><span class="sxs-lookup"><span data-stu-id="9c2e8-195">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span></span>|<span data-ttu-id="9c2e8-196">いいえ</span><span class="sxs-lookup"><span data-stu-id="9c2e8-196">No</span></span>|<span data-ttu-id="9c2e8-197">いいえ</span><span class="sxs-lookup"><span data-stu-id="9c2e8-197">No</span></span>|  
|<span data-ttu-id="9c2e8-198">Lazy(T)(Func(T))</span><span class="sxs-lookup"><span data-stu-id="9c2e8-198">Lazy(T)(Func(T))</span></span>|<span data-ttu-id="9c2e8-199">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span><span class="sxs-lookup"><span data-stu-id="9c2e8-199">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span></span>|<span data-ttu-id="9c2e8-200">[はい]</span><span class="sxs-lookup"><span data-stu-id="9c2e8-200">Yes</span></span>|<span data-ttu-id="9c2e8-201">[はい]</span><span class="sxs-lookup"><span data-stu-id="9c2e8-201">Yes</span></span>|  
|<span data-ttu-id="9c2e8-202">Lazy(T)(Boolean)</span><span class="sxs-lookup"><span data-stu-id="9c2e8-202">Lazy(T)(Boolean)</span></span>|<span data-ttu-id="9c2e8-203">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) または `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span><span class="sxs-lookup"><span data-stu-id="9c2e8-203">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) or `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span></span>|<span data-ttu-id="9c2e8-204">いいえ</span><span class="sxs-lookup"><span data-stu-id="9c2e8-204">No</span></span>|<span data-ttu-id="9c2e8-205">いいえ</span><span class="sxs-lookup"><span data-stu-id="9c2e8-205">No</span></span>|  
|<span data-ttu-id="9c2e8-206">Lazy(T)(Func(T), Boolean)</span><span class="sxs-lookup"><span data-stu-id="9c2e8-206">Lazy(T)(Func(T), Boolean)</span></span>|<span data-ttu-id="9c2e8-207">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) または `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span><span class="sxs-lookup"><span data-stu-id="9c2e8-207">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) or `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span></span>|<span data-ttu-id="9c2e8-208">[はい]</span><span class="sxs-lookup"><span data-stu-id="9c2e8-208">Yes</span></span>|<span data-ttu-id="9c2e8-209">[はい]</span><span class="sxs-lookup"><span data-stu-id="9c2e8-209">Yes</span></span>|  
|<span data-ttu-id="9c2e8-210">Lazy(T)(LazyThreadSafetyMode)</span><span class="sxs-lookup"><span data-stu-id="9c2e8-210">Lazy(T)(LazyThreadSafetyMode)</span></span>|<span data-ttu-id="9c2e8-211">ユーザー指定</span><span class="sxs-lookup"><span data-stu-id="9c2e8-211">User-specified</span></span>|<span data-ttu-id="9c2e8-212">いいえ</span><span class="sxs-lookup"><span data-stu-id="9c2e8-212">No</span></span>|<span data-ttu-id="9c2e8-213">いいえ</span><span class="sxs-lookup"><span data-stu-id="9c2e8-213">No</span></span>|  
|<span data-ttu-id="9c2e8-214">Lazy(T)(Func(T), LazyThreadSafetyMode)</span><span class="sxs-lookup"><span data-stu-id="9c2e8-214">Lazy(T)(Func(T), LazyThreadSafetyMode)</span></span>|<span data-ttu-id="9c2e8-215">ユーザー指定</span><span class="sxs-lookup"><span data-stu-id="9c2e8-215">User-specified</span></span>|<span data-ttu-id="9c2e8-216">[はい]</span><span class="sxs-lookup"><span data-stu-id="9c2e8-216">Yes</span></span>|<span data-ttu-id="9c2e8-217">ユーザーが <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly> を指定する場合は、いいえ。指定しない場合は、はい。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-217">No if user specifies <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>; otherwise, yes.</span></span>|  
  
## <a name="implementing-a-lazy-initialized-property"></a><span data-ttu-id="9c2e8-218">遅延初期化プロパティを実装する</span><span class="sxs-lookup"><span data-stu-id="9c2e8-218">Implementing a Lazy-Initialized Property</span></span>  
 <span data-ttu-id="9c2e8-219">遅延初期化を利用してパブリック プロパティを実装するには、プロパティのバッキング フィールドを <xref:System.Lazy%601> として定義し、プロパティの `get` アクセサーから <xref:System.Lazy%601.Value%2A> プロパティを返します。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-219">To implement a public property by using lazy initialization, define the backing field of the property as a <xref:System.Lazy%601>, and return the <xref:System.Lazy%601.Value%2A> property from the `get` accessor of the property.</span></span>  
  
 [!code-csharp[Lazy#5](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#5)]
 [!code-vb[Lazy#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#5)]  
  
 <span data-ttu-id="9c2e8-220"><xref:System.Lazy%601.Value%2A> プロパティは読み取り専用です。そのため、それを公開するプロパティには `set` アクセサーがありません。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-220">The <xref:System.Lazy%601.Value%2A> property is read-only; therefore, the property that exposes it has no `set` accessor.</span></span> <span data-ttu-id="9c2e8-221">読み取り/書き込みプロパティに <xref:System.Lazy%601> オブジェクトのバッキングが必要な場合、`set` アクセサーは新しい <xref:System.Lazy%601> オブジェクトを作成し、それをバッキング ストアに割り当てる必要があります。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-221">If you require a read/write property backed by a <xref:System.Lazy%601> object, the `set` accessor must create a new <xref:System.Lazy%601> object and assign it to the backing store.</span></span> <span data-ttu-id="9c2e8-222">`set` アクセサーは、`set` アクセサーに渡された新しいプロパティ値を返すラムダ式を作成し、そのラムダ式を新しい <xref:System.Lazy%601> オブジェクトのコンストラクターに渡す必要があります。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-222">The `set` accessor must create a lambda expression that returns the new property value that was passed to the `set` accessor, and pass that lambda expression to the constructor for the new <xref:System.Lazy%601> object.</span></span> <span data-ttu-id="9c2e8-223"><xref:System.Lazy%601.Value%2A> プロパティの次のアクセスで新しい <xref:System.Lazy%601> が初期化されます。そのため、その <xref:System.Lazy%601.Value%2A> プロパティは、プロパティに割り当てられた新しい値を返します。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-223">The next access of the <xref:System.Lazy%601.Value%2A> property will cause initialization of the new <xref:System.Lazy%601>, and its <xref:System.Lazy%601.Value%2A> property will thereafter return the new value that was assigned to the property.</span></span> <span data-ttu-id="9c2e8-224">このような入り組んだしくみになるのは、<xref:System.Lazy%601> にビルドされるマルチスレッド保護を保存するためです。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-224">The reason for this convoluted arrangement is to preserve the multithreading protections built into <xref:System.Lazy%601>.</span></span> <span data-ttu-id="9c2e8-225">そうでなければ、プロパティ アクセサーは <xref:System.Lazy%601.Value%2A> プロパティにより返された最初の値をキャッシュし、その値だけを変更することになり、自分のスレッド セーフ コードを記述しなければならなくなります。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-225">Otherwise, the property accessors would have to cache the first value returned by the <xref:System.Lazy%601.Value%2A> property and only modify the cached value, and you would have to write your own thread-safe code to do that.</span></span> <span data-ttu-id="9c2e8-226"><xref:System.Lazy%601> オブジェクトがバッキングする読み取り/書き込みプロパティで追加の初期化が必要になるため、パフォーマンスは許容できないものになる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-226">Because of the additional initializations required by a read/write property backed by a <xref:System.Lazy%601> object, the performance might not be acceptable.</span></span> <span data-ttu-id="9c2e8-227">さらに、シナリオによっては、セッターとゲッターの競合状態を回避するために、追加の調整が必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-227">Furthermore, depending on the specific scenario, additional coordination might be required to avoid race conditions between setters and getters.</span></span>  
  
## <a name="thread-local-lazy-initialization"></a><span data-ttu-id="9c2e8-228">スレッドローカルの遅延初期化</span><span class="sxs-lookup"><span data-stu-id="9c2e8-228">Thread-Local Lazy Initialization</span></span>  
 <span data-ttu-id="9c2e8-229">一部のマルチスレッド シナリオでは、各スレッドに独自のプライベート データを与えると効果的になります。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-229">In some multithreaded scenarios, you might want to give each thread its own private data.</span></span> <span data-ttu-id="9c2e8-230">そのようなデータは*スレッドローカル データ*と呼ばれています。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-230">Such data is called *thread-local data*.</span></span> <span data-ttu-id="9c2e8-231">.NET Framework バージョン 3.5 以前では、`ThreadStatic` 属性を静的変数に適用し、スレッドローカルにすることができました。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-231">In the .NET Framework version 3.5 and earlier, you could apply the `ThreadStatic` attribute to a static variable to make it thread-local.</span></span> <span data-ttu-id="9c2e8-232">ただし、`ThreadStatic` 属性を使用すると、検出が困難なエラーが発生することがあります。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-232">However, using the `ThreadStatic` attribute can lead to subtle errors.</span></span> <span data-ttu-id="9c2e8-233">たとえば、次の例のように、基本的な初期化ステートメントであっても、それにアクセスする最初のスレッドでのみ、変数が初期化されます。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-233">For example, even basic initialization statements will cause the variable to be initialized only on the first thread that accesses it, as shown in the following example.</span></span>  
  
 [!code-csharp[Lazy#6](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#6)]
 [!code-vb[Lazy#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#6)]  
  
 <span data-ttu-id="9c2e8-234">その他すべてのスレッドでは、その既定値 (ゼロ) を利用して変数は初期化されます。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-234">On all other threads, the variable will be initialized by using its default value (zero).</span></span> <span data-ttu-id="9c2e8-235">.NET Framework バージョン 4 における代替として、<xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> 型を使用し、インスタンスベースで、指定した <xref:System.Action%601> デリゲートによりすべてのスレッドで初期化されるスレッドローカル変数を作成できます。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-235">As an alternative in the .NET Framework version 4, you can use the <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> type to create an instance-based, thread-local variable that is initialized on all threads by the <xref:System.Action%601> delegate that you provide.</span></span> <span data-ttu-id="9c2e8-236">次の例では、`counter` にアクセスするすべてのスレッドでその開始値が 1 になります。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-236">In the following example, all threads that access `counter` will see its starting value as 1.</span></span>  
  
 [!code-csharp[Lazy#7](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#7)]
 [!code-vb[Lazy#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#7)]  
  
 <span data-ttu-id="9c2e8-237"><xref:System.Threading.ThreadLocal%601> は、<xref:System.Lazy%601> とほとんど同じ方法でそのオブジェクトをラップしますが、本質的な違いとして次があります。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-237"><xref:System.Threading.ThreadLocal%601> wraps its object in much the same way as <xref:System.Lazy%601>, with these essential differences:</span></span>  
  
-   <span data-ttu-id="9c2e8-238">各スレッドは、他のスレッドからアクセスできない独自のプライベート データを利用してスレッドローカル変数を初期化します。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-238">Each thread initializes the thread-local variable by using its own private data that is not accessible from other threads.</span></span>  
  
-   <span data-ttu-id="9c2e8-239"><xref:System.Threading.ThreadLocal%601.Value%2A?displayProperty=nameWithType> プロパティは編集可能なプロパティです。何回でも変更できます。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-239">The <xref:System.Threading.ThreadLocal%601.Value%2A?displayProperty=nameWithType> property is read-write, and can be modified any number of times.</span></span> <span data-ttu-id="9c2e8-240">これは例外伝達に影響を与えることがあります。たとえば、ある `get` 操作で例外が発生したが、次の操作で値を初期化できたということがあります。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-240">This can affect exception propagation, for example, one `get` operation can raise an exception but the next one can successfully initialize the value.</span></span>  
  
-   <span data-ttu-id="9c2e8-241">初期化デリゲートが指定されない場合、<xref:System.Threading.ThreadLocal%601> は、型の初期値を利用し、そのラップされた型を初期化します。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-241">If no initialization delegate is provided, <xref:System.Threading.ThreadLocal%601> will initialize its wrapped type by using the default value of the type.</span></span> <span data-ttu-id="9c2e8-242">この点では、<xref:System.Threading.ThreadLocal%601> は <xref:System.ThreadStaticAttribute> 属性と一致しています。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-242">In this regard, <xref:System.Threading.ThreadLocal%601> is consistent with the <xref:System.ThreadStaticAttribute> attribute.</span></span>  
  
 <span data-ttu-id="9c2e8-243">次の例は、`ThreadLocal<int>` インスタンスにアクセスするすべてのスレッドがデータの独自のコピーを取得する様子を示しています。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-243">The following example demonstrates that every thread that accesses the `ThreadLocal<int>` instance gets its own unique copy of the data.</span></span>  
  
 [!code-csharp[Lazy#9](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#9)]
 [!code-vb[Lazy#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#9)]  
  
## <a name="thread-local-variables-in-parallelfor-and-foreach"></a><span data-ttu-id="9c2e8-244">Parallel.For と ForEach のスレッドローカル変数</span><span class="sxs-lookup"><span data-stu-id="9c2e8-244">Thread-Local Variables in Parallel.For and ForEach</span></span>  
 <span data-ttu-id="9c2e8-245"><xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> メソッドまたは <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> メソッドを利用してデータ ソースを並列で繰り返すとき、スレッドローカル データのサポートが組み込まれたオーバーロードを利用できます。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-245">When you use the <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method or <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method to iterate over data sources in parallel, you can use the overloads that have built-in support for thread-local data.</span></span> <span data-ttu-id="9c2e8-246">そのようなメソッドでは、ローカル デリゲートを利用してデータの作成、アクセス、クリーンアップを行うことで、スレッドローカルになります。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-246">In these methods, the thread-locality is achieved by using local delegates to create, access, and clean up the data.</span></span> <span data-ttu-id="9c2e8-247">詳細については、「[方法 :スレッド ローカル変数を使用する Parallel.For ループを記述する](../../../docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md)」および「[方法:パーティション ローカル変数を使用する Parallel.ForEach ループを記述する](../../../docs/standard/parallel-programming/how-to-write-a-parallel-foreach-loop-with-partition-local-variables.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-247">For more information, see [How to: Write a Parallel.For Loop with Thread-Local Variables](../../../docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md) and [How to: Write a Parallel.ForEach Loop with Partition-Local Variables](../../../docs/standard/parallel-programming/how-to-write-a-parallel-foreach-loop-with-partition-local-variables.md).</span></span>  
  
## <a name="using-lazy-initialization-for-low-overhead-scenarios"></a><span data-ttu-id="9c2e8-248">オーバーヘッドが低いシナリオで遅延初期化を使用する</span><span class="sxs-lookup"><span data-stu-id="9c2e8-248">Using Lazy Initialization for Low-Overhead Scenarios</span></span>  
 <span data-ttu-id="9c2e8-249">大量のオブジェクトを遅延初期化しなければならないシナリオでは、<xref:System.Lazy%601> で各オブジェクトをラッピングするとき、あまりにも多くのメモリまたは計算処理リソースが必要になるのか判断することがあります。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-249">In scenarios where you have to lazy-initialize a large number of objects, you might decide that wrapping each object in a <xref:System.Lazy%601> requires too much memory or too many computing resources.</span></span> <span data-ttu-id="9c2e8-250">あるいは、遅延初期化の公開方法について厳格な要件が与えられることがあります。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-250">Or, you might have stringent requirements about how lazy initialization is exposed.</span></span> <span data-ttu-id="9c2e8-251">そのような場合、<xref:System.Threading.LazyInitializer?displayProperty=nameWithType> クラスの `static` (Visual Basic の場合、`Shared`) メソッドを利用し、<xref:System.Lazy%601> のインスタンスでラッピングせずに、各オブジェクトを遅延初期化できます。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-251">In such cases, you can use the `static` (`Shared` in Visual Basic) methods of the <xref:System.Threading.LazyInitializer?displayProperty=nameWithType> class to lazy-initialize each object without wrapping it in an instance of <xref:System.Lazy%601>.</span></span>  
  
 <span data-ttu-id="9c2e8-252">次の例では、1 つの <xref:System.Lazy%601> オブジェクトで `Orders` オブジェクト全体をラッピングする代わりに、必要な場合にのみ、個々の `Order` オブジェクトを遅延初期化したと想定しています。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-252">In the following example, assume that, instead of wrapping an entire `Orders` object in one <xref:System.Lazy%601> object, you have lazy-initialized individual `Order` objects only if they are required.</span></span>  
  
 [!code-csharp[Lazy#10](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#10)]
 [!code-vb[Lazy#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#10)]  
  
 <span data-ttu-id="9c2e8-253">この例では、ループの繰り返しの旅に初期化プロシージャが呼び出されていることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-253">In this example, notice that the initialization procedure is invoked on every iteration of the loop.</span></span> <span data-ttu-id="9c2e8-254">マルチスレッド シナリオでは、初期化プロシージャを呼び出した最初のスレッドの値をすべてのスレッドで確認できます。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-254">In multi-threaded scenarios, the first thread to invoke the initialization procedure is the one whose value is seen by all threads.</span></span> <span data-ttu-id="9c2e8-255">後続のスレッドも初期化プロシージャを呼び出しますが、その結果は利用されません。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-255">Later threads also invoke the initialization procedure, but their results are not used.</span></span> <span data-ttu-id="9c2e8-256">この種類の潜在的競合状態が許容できない場合、ブール値引数と同期オブジェクトを取る <xref:System.Threading.LazyInitializer.EnsureInitialized%2A?displayProperty=nameWithType> のオーバーロードを使用します。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-256">If this kind of potential race condition is not acceptable, use the overload of <xref:System.Threading.LazyInitializer.EnsureInitialized%2A?displayProperty=nameWithType> that takes a Boolean argument and a synchronization object.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="9c2e8-257">関連項目</span><span class="sxs-lookup"><span data-stu-id="9c2e8-257">See also</span></span>

- [<span data-ttu-id="9c2e8-258">マネージ スレッド処理の基本</span><span class="sxs-lookup"><span data-stu-id="9c2e8-258">Managed Threading Basics</span></span>](../../../docs/standard/threading/managed-threading-basics.md)
- [<span data-ttu-id="9c2e8-259">スレッドおよびスレッド処理</span><span class="sxs-lookup"><span data-stu-id="9c2e8-259">Threads and Threading</span></span>](../../../docs/standard/threading/threads-and-threading.md)
- [<span data-ttu-id="9c2e8-260">タスク並列ライブラリ (TPL)</span><span class="sxs-lookup"><span data-stu-id="9c2e8-260">Task Parallel Library (TPL)</span></span>](../../../docs/standard/parallel-programming/task-parallel-library-tpl.md)
- [<span data-ttu-id="9c2e8-261">方法: オブジェクトの遅延初期化を実行します。</span><span class="sxs-lookup"><span data-stu-id="9c2e8-261">How to: Perform Lazy Initialization of Objects</span></span>](../../../docs/framework/performance/how-to-perform-lazy-initialization-of-objects.md)
