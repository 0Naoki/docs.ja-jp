---
title: レガシ モノリシック .NET Framework アプリケーションを Windows コンテナーに移行する
description: '.NET マイクロサービス: コンテナー化された .NET アプリケーションのアーキテクチャ | レガシ モノリシック .NET Framework アプリケーションを Windows コンテナーに移行する'
keywords: Docker, マイクロサービス, ASP.NET, コンテナー
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: c88027156b55829f77357c1fdb1aef01a802b88a
ms.sourcegitcommit: e7f04439d78909229506b56935a1105a4149ff3d
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/23/2017
---
# <a name="migrating-legacy-monolithic-net-framework-applications-to-windows-containers"></a><span data-ttu-id="abd3a-104">レガシ モノリシック .NET Framework アプリケーションを Windows コンテナーに移行する</span><span class="sxs-lookup"><span data-stu-id="abd3a-104">Migrating Legacy Monolithic .NET Framework Applications to Windows Containers</span></span>

<span data-ttu-id="abd3a-105">*Windows コンテナーは、開発環境とテスト環境を強化し、Web* *Forms などのレガシ .NET Framework テクノロジをベースにするアプリケーションを展開する方法として使用できます。この方法でレガシ アプリケーションのコンテナーを使用することを、"リフトアンドシフト" シナリオと呼びます。*</span><span class="sxs-lookup"><span data-stu-id="abd3a-105">*Windows Containers can be used as a way to improve development and test environments, and to deploy applications that are based on legacy .NET Framework technologies like Web* *Forms. Using containers for legacy applications in this way is referred to as a “lift and shift” scenario.*</span></span>

<span data-ttu-id="abd3a-106">このガイドの前のセクションでは、小規模のフォーカスされているサービスを実行するごとに、ビジネス アプリケーションがさまざまなコンテナーに配布される、マイクロサービス アーキテクチャを支持していました。</span><span class="sxs-lookup"><span data-stu-id="abd3a-106">Earlier sections of this guide have championed a microservices architecture where business applications are distributed among different containers, each running a small, focused service.</span></span> <span data-ttu-id="abd3a-107">このゴールには、多くの利点があります。</span><span class="sxs-lookup"><span data-stu-id="abd3a-107">That goal has many benefits.</span></span> <span data-ttu-id="abd3a-108">新しい開発では、この手法を強くお勧めします。</span><span class="sxs-lookup"><span data-stu-id="abd3a-108">In new development, that approach is strongly recommended.</span></span> <span data-ttu-id="abd3a-109">また、エンタープライズに必要なアプリケーションは、アーキテクチャと実装の見直しにかかるコストの正当性を保証できるだけの利益を得ることもできます。</span><span class="sxs-lookup"><span data-stu-id="abd3a-109">Enterprise-critical applications will also benefit enough to justify the cost of a rearchitecture and reimplementation.</span></span>

<span data-ttu-id="abd3a-110">ただし、すべてのアプリケーションが、そのコストの正当性を証明できるだけの利益を得るわけではありません。</span><span class="sxs-lookup"><span data-stu-id="abd3a-110">But not every application will benefit enough to justify the cost.</span></span> <span data-ttu-id="abd3a-111">これは、これらのアプリケーションがコンテナーのシナリオで使用できないということではありません。</span><span class="sxs-lookup"><span data-stu-id="abd3a-111">That does not mean that those applications cannot be used in container scenarios.</span></span>

<span data-ttu-id="abd3a-112">このセクションでは、図 7-1 に示すように、eShopOnContainers のアプリケーションの詳細を確認します。</span><span class="sxs-lookup"><span data-stu-id="abd3a-112">In this section, we will explore an application for eShopOnContainers, shown in Figure 7-1.</span></span> <span data-ttu-id="abd3a-113">このアプリケーションは、製品カタログを表示および編集するために、eShopOnContainers エンタープライズ チームのメンバーによって使用されます。</span><span class="sxs-lookup"><span data-stu-id="abd3a-113">This application would be used by members of the eShopOnContainers enterprise team to view and edit the product catalog.</span></span>

![](./media/image1.png)

<span data-ttu-id="abd3a-114">**図 7-1**。</span><span class="sxs-lookup"><span data-stu-id="abd3a-114">**Figure 7-1**.</span></span> <span data-ttu-id="abd3a-115">Windows コンテナー上の ASP.NET Web フォーム アプリケーション (レガシ テクノロジ)</span><span class="sxs-lookup"><span data-stu-id="abd3a-115">ASP.NET Web Forms application (legacy technology) on a Windows Container</span></span>

<span data-ttu-id="abd3a-116">これは、カタログ エントリを参照および変更するために使用する、Web フォーム アプリケーションです。</span><span class="sxs-lookup"><span data-stu-id="abd3a-116">This is a Web Forms application that is used to browse and modify the catalog entries.</span></span> <span data-ttu-id="abd3a-117">Web フォームの依存関係は、このアプリケーションが Web フォームではなく、ASP.NET Core MVC を使用して書き換えない限り、.NET Core 上で実行されないことを意味します。</span><span class="sxs-lookup"><span data-stu-id="abd3a-117">The Web Forms dependency means this application will not run on .NET Core unless it is rewritten without Web Forms and instead uses ASP.NET Core MVC.</span></span> <span data-ttu-id="abd3a-118">変更を行くことなく、コンテナーのアプリケーションのように、アプリケーションを実行できることがわかります。</span><span class="sxs-lookup"><span data-stu-id="abd3a-118">You will see how you can run applications like these in containers without changes.</span></span> <span data-ttu-id="abd3a-119">また、一部の機能が個別のマイクロサービスに移動されているハイブリッド モードで機能するように、最小限の変更を加える方法についても確認できますが、ほとんどの機能はモノリシック アプリケーション内に保持されます。</span><span class="sxs-lookup"><span data-stu-id="abd3a-119">You will also see how you can make minimal changes to work in a hybrid mode where some functionality has been moved into a separate microservice, but most functionality remains in the monolithic application.</span></span>

## <a name="benefits-of-containerizing-a-monolithic-application"></a><span data-ttu-id="abd3a-120">コンテナー化されたモノリシック アプリケーションの利点</span><span class="sxs-lookup"><span data-stu-id="abd3a-120">Benefits of containerizing a monolithic application</span></span>

<span data-ttu-id="abd3a-121">Catalog.WebForms アプリケーションは、eShopOnContainers GitHub リポジトリ (<https://github.com/dotnet/eShopOnContainers>) で入手できます。</span><span class="sxs-lookup"><span data-stu-id="abd3a-121">The Catalog.WebForms application is available in the eShopOnContainers GitHub repository (<https://github.com/dotnet/eShopOnContainers>).</span></span> <span data-ttu-id="abd3a-122">このアプリケーションは、可用性の高いデータ ストアにアクセスする、スタンドアロンの Web アプリケーションです。</span><span class="sxs-lookup"><span data-stu-id="abd3a-122">This application is a standalone web application accessing a high-availability data store.</span></span> <span data-ttu-id="abd3a-123">そうであっても、コンテナー内でアプリケーションを実行する利点があります。</span><span class="sxs-lookup"><span data-stu-id="abd3a-123">Even so, there are advantages to running the application in a container.</span></span> <span data-ttu-id="abd3a-124">アプリケーションのイメージを作成します。</span><span class="sxs-lookup"><span data-stu-id="abd3a-124">You create an image for the application.</span></span> <span data-ttu-id="abd3a-125">この時点から、すべての展開は同じ環境で実行されます。</span><span class="sxs-lookup"><span data-stu-id="abd3a-125">From that point forward, every deployment runs in the same environment.</span></span> <span data-ttu-id="abd3a-126">すべてのコンテナーは、同じ OS バージョンを使用し、同じバージョンの依存関係がインストールされており、同じフレームワークを使用し、同じプロセスを使用してビルドされます。</span><span class="sxs-lookup"><span data-stu-id="abd3a-126">Every container uses the same OS version, has the same version of dependencies installed, uses the same framework, and is built using the same process.</span></span> <span data-ttu-id="abd3a-127">図 7-2 では、Visual Studio 2017 に読み込まれたアプリケーションを確認できます。</span><span class="sxs-lookup"><span data-stu-id="abd3a-127">You can see the application loaded in Visual Studio 2017 in Figure 7-2.</span></span>

![](./media/image2.png)

<span data-ttu-id="abd3a-128">**図 7-2**。</span><span class="sxs-lookup"><span data-stu-id="abd3a-128">**Figure 7-2**.</span></span> <span data-ttu-id="abd3a-129">Visual Studio 2017 のカタログ管理の Web フォーム アプリケーション</span><span class="sxs-lookup"><span data-stu-id="abd3a-129">Catalog management Web Forms application in Visual Studio 2017</span></span>

<span data-ttu-id="abd3a-130">さらに、すべての開発者が、この一貫した環境でアプリケーションを実行できます。</span><span class="sxs-lookup"><span data-stu-id="abd3a-130">In addition, developers can all run the application in this consistent environment.</span></span> <span data-ttu-id="abd3a-131">特定のバージョンでのみ表れる問題は、ステージング環境や運用環境に提示されるのではなく、開発者にすぐに表示されます。</span><span class="sxs-lookup"><span data-stu-id="abd3a-131">Issues that only appear with certain versions will appear immediately for developers rather than surfacing in a staging or production environment.</span></span> <span data-ttu-id="abd3a-132">開発チーム間での開発環境の違いは、アプリケーションをコンテナーで実行すると、さほど問題ではありません。</span><span class="sxs-lookup"><span data-stu-id="abd3a-132">Differences between the development environments among the development team matter less once applications run in containers.</span></span>

<span data-ttu-id="abd3a-133">最後に、コンテナー化されたアプリケーションは、時間をかけてスケールアウトできます。</span><span class="sxs-lookup"><span data-stu-id="abd3a-133">Finally, containerized applications have a flatter scale-out curve.</span></span> <span data-ttu-id="abd3a-134">コンテナー化されたアプリを使って、VM で多くのコンテナーまたは物理マシンで多くのコンテナーを有効にする方法について学習しました。</span><span class="sxs-lookup"><span data-stu-id="abd3a-134">You have learned how containerized apps enable more containers in a VM or more containers in a physical machine.</span></span> <span data-ttu-id="abd3a-135">この操作を行うと、平均密度が高くなり、必要なリソースが少なくなります。</span><span class="sxs-lookup"><span data-stu-id="abd3a-135">This translates to higher density and fewer required resources.</span></span>

<span data-ttu-id="abd3a-136">これらすべての理由から、"リフトアンドシフト" 操作を使用して、Docker コンテナーでレガシ モノリシック アプリを実行することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="abd3a-136">For all these reasons, consider running legacy monolithic apps in a Docker container using a “lift-and-shift” operation.</span></span> <span data-ttu-id="abd3a-137">"リフトアンドシフト" という語句は、タスクのスコープについて示しています。物理マシンまたは仮想マシンからアプリケーション全体を*リフト*して、コンテナーに*シフト*します。</span><span class="sxs-lookup"><span data-stu-id="abd3a-137">The phrase “lift and shift” describes the scope of the task: you *lift* the entire application from a physical or virtual machine, and *shift* it into a container.</span></span> <span data-ttu-id="abd3a-138">理想的な状況では、コンテナーで実行するために、アプリケーション コードに変更を加える必要はありません。</span><span class="sxs-lookup"><span data-stu-id="abd3a-138">In ideal situations, you do not need to make any changes to the application code to run it in a container.</span></span>

## <a name="possible-migration-paths"></a><span data-ttu-id="abd3a-139">使用可能な移行パス</span><span class="sxs-lookup"><span data-stu-id="abd3a-139">Possible migration paths</span></span>

<span data-ttu-id="abd3a-140">モノリシック アプリケーションとして、Catalog.Webforms アプリケーションは、データ アクセス ライブラリなど、すべてのコードを含む 1 つの Web アプリケーションです。</span><span class="sxs-lookup"><span data-stu-id="abd3a-140">As a monolithic application, the Catalog.Webforms application is one web application containing all the code, including the data access libraries.</span></span> <span data-ttu-id="abd3a-141">そのデータベースは、個別の可用性の高いマシンで実行されています。</span><span class="sxs-lookup"><span data-stu-id="abd3a-141">The database runs on a separate high-availability machine.</span></span> <span data-ttu-id="abd3a-142">この構成は、モック カタログ サービスを使用して、サンプル コードでシミュレートされます。純粋なリフトアンドシフトするシナリオをシミュレートする仮のデータに対して、Catalog.WebForms アプリケーションを実行できます。</span><span class="sxs-lookup"><span data-stu-id="abd3a-142">That configuration is simulated in the sample code by using a mock catalog service: you can run the Catalog.WebForms application against that fake data to simulate a pure lift-and-shift scenario.</span></span> <span data-ttu-id="abd3a-143">これにより、コードに変更を加えることなく、コンテナーで実行するために、既存のアセットを移動する最も簡単な移行パスが示されます。</span><span class="sxs-lookup"><span data-stu-id="abd3a-143">This demonstrates the simplest migration path, where you move existing assets to run in a container without any code changes at all.</span></span> <span data-ttu-id="abd3a-144">このパスは、完全なアプリケーション、およびマイクロサービスに移動する機能と最小限の相互作用があるアプリケーションに適しています。</span><span class="sxs-lookup"><span data-stu-id="abd3a-144">This path is appropriate for applications that are complete and that have minimal interaction with functionality that you are moving to microservices.</span></span>

<span data-ttu-id="abd3a-145">ただし、eShopOnContainers Web サイトは、既にさまざまなシナリオのマイクロサービスを使用して、データ ストレージにアクセスしています。</span><span class="sxs-lookup"><span data-stu-id="abd3a-145">However, the eShopOnContainers website is already accessing the data storage using microservices for different scenarios.</span></span> <span data-ttu-id="abd3a-146">カタログ データ ストレージに直接アクセスするのではなく、カタログ マイクロサービスを活用するために、いくつかの小さな追加の変更がカタログ エディターに加えられる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="abd3a-146">Some small additional changes can be made to the catalog editor to leverage the catalog microservice instead of accessing the catalog data storage directly.</span></span>

<span data-ttu-id="abd3a-147">これらの変更は、独自のアプリケーションの Continuum をデモンストレーションします。</span><span class="sxs-lookup"><span data-stu-id="abd3a-147">These changes demonstrate the continuum for your own applications.</span></span> <span data-ttu-id="abd3a-148">既存のアプリケーションがいくつかの新しいマイクロサービスにアクセスできるように小さな変更を加えるため、新しいマイクロサービス ベースのアーキテクチャに完全に参加するためにアプリケーションを完全に書き換えるために、コンテナーに変更を加えることなく、既存のアプリケーションを移動することで、すべての操作を実行できます。</span><span class="sxs-lookup"><span data-stu-id="abd3a-148">You can do anything from moving an existing application without change into containers, to making small changes that enable existing applications to access some of the new microservices, to completely rewriting an application to fully participate in a new microservice-based architecture.</span></span> <span data-ttu-id="abd3a-149">この適切なパスは、移行のコストと移行からの利点の両方に依存します。</span><span class="sxs-lookup"><span data-stu-id="abd3a-149">The right path depends on both the cost of the migration and the benefits from any migration.</span></span>

## <a name="application-tour"></a><span data-ttu-id="abd3a-150">アプリケーション ツアー</span><span class="sxs-lookup"><span data-stu-id="abd3a-150">Application tour</span></span>

<span data-ttu-id="abd3a-151">Catalog.WebForms ソリューションを読み込み、スタンドアロン アプリケーションとしてアプリケーションを実行することができます。</span><span class="sxs-lookup"><span data-stu-id="abd3a-151">You can load the Catalog.WebForms solution and run the application as a standalone application.</span></span> <span data-ttu-id="abd3a-152">この構成では、永続ストレージ データベースの代わりに、アプリケーションはデータを返すために仮のサービスを使用します。</span><span class="sxs-lookup"><span data-stu-id="abd3a-152">In this configuration, instead of a persistent storage database, the application uses a fake service to return data.</span></span> <span data-ttu-id="abd3a-153">アプリケーションでは、制御の反転 (IOC) コンテナーとして Autofac (<https://autofac.org/>) を使用します。</span><span class="sxs-lookup"><span data-stu-id="abd3a-153">The application uses Autofac (<https://autofac.org/>) as an inversion of control (IOC) container.</span></span> <span data-ttu-id="abd3a-154">依存関係の挿入 (DI) を使用して、仮のデータやライブ カタログ データ サービスを使用するように、アプリケーションを構成できます。</span><span class="sxs-lookup"><span data-stu-id="abd3a-154">Using Dependency Injection (DI), you can configure the application to use the fake data or the live catalog data service.</span></span> <span data-ttu-id="abd3a-155">(DI の詳細については、この後ですぐに説明します)。スタートアップ コードは、web.config ファイルから useFake 設定を読み込んで、仮のデータ サービスまたはライブ カタログ サービスのいずれかを挿入するように、Autofac コンテナーを構成します。</span><span class="sxs-lookup"><span data-stu-id="abd3a-155">(We will explain more about DI shortly.) The startup code reads a useFake setting from the web.config files, and configures the Autofac container to inject either the fake data service or the live catalog service.</span></span> <span data-ttu-id="abd3a-156">web.config ファイルの useFake を false に設定してアプリケーションを実行した場合、カタログ データを示している Web フォーム アプリケーションが表示されます。</span><span class="sxs-lookup"><span data-stu-id="abd3a-156">If you run the application with useFake set to false in the web.config file, you see the Web Forms application displaying the catalog data.</span></span>

<span data-ttu-id="abd3a-157">このアプリケーションで使用される技術のほとんどを、Web フォームを使用しているすべてのユーザーがよく理解している必要があります。</span><span class="sxs-lookup"><span data-stu-id="abd3a-157">Most of the techniques used in this application should be very familiar to anyone who has used Web Forms.</span></span> <span data-ttu-id="abd3a-158">ただし、カタログ マイクロサービスでは、慣れていない可能性がある 2 つの技術を導入しています。それは、前述の依存関係の挿入 (DI) で、Web フォームで保存される非同期データを使って動作します。</span><span class="sxs-lookup"><span data-stu-id="abd3a-158">However, the catalog microservice introduces two techniques that might be unfamiliar: Dependency Injection (DI), which was mentioned earlier, and working with asynchronous data stores in Web Forms.</span></span>

<span data-ttu-id="abd3a-159">DI は、必要なすべてのリソースを割り当てるクラスを作成する、一般的なオブジェクト指向の戦略を逆転させたものです。</span><span class="sxs-lookup"><span data-stu-id="abd3a-159">DI inverts the typical object-oriented strategy of writing classes that allocate all needed resources.</span></span> <span data-ttu-id="abd3a-160">代わりに、クラスがサービス コンテナーに依存関係を要求します。</span><span class="sxs-lookup"><span data-stu-id="abd3a-160">Instead, classes request their dependencies from a service container.</span></span> <span data-ttu-id="abd3a-161">DI の利点は、テスト環境やその他の環境をサポートするために、外部サービスを仮 (モック) に置き換えることができることです。</span><span class="sxs-lookup"><span data-stu-id="abd3a-161">The advantage of DI is that you can replace external services with fakes (mocks) to support testing or other environments.</span></span>

<span data-ttu-id="abd3a-162">DI コンテナーでは、web.config appSettings 構成を使用して、仮のカタログ データを使用するか、実行中のサービスからのライブ データを使用するかをコントロールします。</span><span class="sxs-lookup"><span data-stu-id="abd3a-162">The DI container uses the web.config appSettings configuration to control whether to use the fake catalog data or the live data from the running service.</span></span> <span data-ttu-id="abd3a-163">アプリケーションは、コンテナーを構築する HttpModule オブジェクトを登録し、依存関係を挿入するために、事前に要求されたハンドラーを登録します。</span><span class="sxs-lookup"><span data-stu-id="abd3a-163">The application registers an HttpModule object that builds the container and registers a pre-request handler to inject dependencies.</span></span> <span data-ttu-id="abd3a-164">次の例のように、コードを Modules/AutoFacHttpModule.cs ファイルで確認することができます。</span><span class="sxs-lookup"><span data-stu-id="abd3a-164">You can see that code in the Modules/AutoFacHttpModule.cs file, which looks like the following example:</span></span>

```cs
private static IContainer CreateContainer()
{
  // Configure AutoFac:
  // Register Containers:

  var settings = WebConfigurationManager.AppSettings;
  var useFake = settings["usefake"];
  bool fake = useFake == "true";
  var builder = new ContainerBuilder();

  if (fake)
  {
    builder.RegisterType<CatalogMockService>()
    .As<ICatalogService>();
  }
  else
  {
    builder.RegisterType<CatalogService>()
    .As<ICatalogService>();
    builder.RegisterType<RequestProvider>()
    .As<IRequestProvider>();
  }

  var container = builder.Build();
  return container;
}

private void InjectDependencies()
{
  if (HttpContext.Current.CurrentHandler is Page page)
  {
    // Get the code-behind class that we may have written
    var pageType = page.GetType().BaseType;

    // Determine if there is a constructor to inject, and grab it
    var ctor = (from c in pageType.GetConstructors()
                where c.GetParameters().Length > 0
                select c).FirstOrDefault();

    if (ctor != null)
    {
      // Resolve the parameters for the constructor
      var args = (from parm in ctor.GetParameters()
                  select Container.Resolve(parm.ParameterType))
                  .ToArray();

      // Execute the constructor method with the arguments resolved
      ctor.Invoke(page, args);
    }

    // Use the Autofac method to inject any
    // properties that can be filled by Autofac
    Container.InjectProperties(page);
  }
}
```

<span data-ttu-id="abd3a-165">アプリケーションのページ (Default.aspx.cs と EditPage.aspx.cs) は、これらの依存関係を取得するコンストラクターを定義します。</span><span class="sxs-lookup"><span data-stu-id="abd3a-165">The application’s pages (Default.aspx.cs and EditPage.aspx.cs) define constructors that take these dependencies.</span></span> <span data-ttu-id="abd3a-166">既定のコンストラクターが引き続き存在し、アクセスできることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="abd3a-166">Note that the default constructor is still present and accessible.</span></span> <span data-ttu-id="abd3a-167">インフラストラクチャには、次のコードが必要です。</span><span class="sxs-lookup"><span data-stu-id="abd3a-167">The infrastructure needs the following code.</span></span>

```cs
protected _Default() { }

public _Default(ICatalogService catalog) => this.catalog = catalog;
```

<span data-ttu-id="abd3a-168">カタログ API はすべて、非同期メソッドです。</span><span class="sxs-lookup"><span data-stu-id="abd3a-168">The catalog APIs are all asynchronous methods.</span></span> <span data-ttu-id="abd3a-169">Web フォームでは、すべてのデータ コントロールに対してこれらをサポートするようになりました。</span><span class="sxs-lookup"><span data-stu-id="abd3a-169">Web Forms now supports these for all data controls.</span></span> <span data-ttu-id="abd3a-170">Catalog.WebForms アプリケーションでは、リストと編集ページにモデル バインドを使用します。これは、タスクを返す非同期操作を指定する、SelectMethod、UpdateMethod、InsertMethod、DeleteMethod プロパティを定義するページをコントロールします。</span><span class="sxs-lookup"><span data-stu-id="abd3a-170">The Catalog.WebForms application uses model binding for the list and edit pages; controls on the pages define SelectMethod, UpdateMethod, InsertMethod, and DeleteMethod properties that specify Task-returning asynchronous operations.</span></span> <span data-ttu-id="abd3a-171">Web フォーム コントロールは、メソッドが非同期のコントロールにバインドされるタイミングを理解します。</span><span class="sxs-lookup"><span data-stu-id="abd3a-171">Web Forms controls understand when the methods bound to a control are asynchronous.</span></span> <span data-ttu-id="abd3a-172">非同期の選択メソッドを使用するときに直面する唯一の制限は、ページングをサポートできないことです。</span><span class="sxs-lookup"><span data-stu-id="abd3a-172">The only restriction you encounter when using asynchronous select methods is that you cannot support paging.</span></span> <span data-ttu-id="abd3a-173">ページング署名には out パラメーターが必要で、非同期メソッドが out パラメーターを持つことはできません。</span><span class="sxs-lookup"><span data-stu-id="abd3a-173">The paging signature requires an out parameter, and asynchronous methods cannot have out parameters.</span></span> <span data-ttu-id="abd3a-174">この同じ技術が、カタログ サービスからのデータを必要とするその他のページで使用されます。</span><span class="sxs-lookup"><span data-stu-id="abd3a-174">This same technique is used on other pages that require data from the catalog service.</span></span>

<span data-ttu-id="abd3a-175">カタログ Web フォーム アプリケーションの既定の構成は、catalog.api サービスのモック実装を使用します。</span><span class="sxs-lookup"><span data-stu-id="abd3a-175">The default configuration for the catalog Web Forms application uses a mock implementation of the catalog.api service.</span></span> <span data-ttu-id="abd3a-176">このモックは、開発環境の catalog.api サービスの依存関係を削除して、一部のタスクを簡略化する、データがハードコーディングされたデータセットを使用します。</span><span class="sxs-lookup"><span data-stu-id="abd3a-176">This mock uses a hard-coded dataset for its data, which simplifies some tasks by removing the dependency on the catalog.api service in development environments.</span></span>

## <a name="lifting-and-shifting"></a><span data-ttu-id="abd3a-177">リフトアンドシフト</span><span class="sxs-lookup"><span data-stu-id="abd3a-177">Lifting and shifting</span></span>

<span data-ttu-id="abd3a-178">Visual Studio では、アプリケーションをコンテナー化するために最適なサポートを提供します。</span><span class="sxs-lookup"><span data-stu-id="abd3a-178">Visual Studio provides great support for containerizing an application.</span></span> <span data-ttu-id="abd3a-179">プロジェクト ノードを右クリックし、**[追加]**、**[Docker サポート]** の順に選択します。</span><span class="sxs-lookup"><span data-stu-id="abd3a-179">You right-click the project node and then select **Add** and **Docker Support**.</span></span> <span data-ttu-id="abd3a-180">Docker プロジェクト テンプレートは、新しいプロジェクトを **docker-compose** と呼ばれるソリューションに追加します。</span><span class="sxs-lookup"><span data-stu-id="abd3a-180">The Docker project template adds a new project to the solution called **docker-compose**.</span></span> <span data-ttu-id="abd3a-181">プロジェクトには、図 7-3 に示すように、必要なイメージを作成 (またはビルド) する Docker アセットが含まれ、必要なコンテナーの実行を開始します。</span><span class="sxs-lookup"><span data-stu-id="abd3a-181">The project contains the Docker assets that compose (or build) the images you need, and starts running the necessary containers, as shown in Figure 7-3.</span></span>

<span data-ttu-id="abd3a-182">最も簡単なリフトアンドシフトのシナリオでは、アプリケーションは、Web フォーム アプリケーションに使用する単一のサービスになります。</span><span class="sxs-lookup"><span data-stu-id="abd3a-182">In the simplest lift-and-shift scenarios, the application will be the single service that you use for the Web Forms application.</span></span> <span data-ttu-id="abd3a-183">また、テンプレートは、**docker-compose** プロジェクトをポイントするスタートアップ プロジェクトも変更します。</span><span class="sxs-lookup"><span data-stu-id="abd3a-183">The template also changes your startup project to point to the **docker-compose** project.</span></span> <span data-ttu-id="abd3a-184">Ctrl キーを押しながら F5 キーを押すか、F5 キーを押して、Docker イメージを作成し、Docker コンテナーを開始できます。</span><span class="sxs-lookup"><span data-stu-id="abd3a-184">Pressing Ctrl+F5 or F5 now creates the Docker image and launches the Docker container.</span></span>

![](./media/image3.png)

<span data-ttu-id="abd3a-185">**図 7-3**。</span><span class="sxs-lookup"><span data-stu-id="abd3a-185">**Figure 7-3**.</span></span> <span data-ttu-id="abd3a-186">Web フォーム ソリューションの **docker-compose** プロジェクト</span><span class="sxs-lookup"><span data-stu-id="abd3a-186">The **docker-compose** project in the Web Forms solution</span></span>

<span data-ttu-id="abd3a-187">ソリューションを実行する前に、Windows コンテナーを使用するように、Docker を構成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="abd3a-187">Before you run the solution, you must make sure that you configure Docker to use Windows Containers.</span></span> <span data-ttu-id="abd3a-188">この操作を行うには、図 7-4 に示すように、Windows の Docker タスク バー アイコンを右クリックして、**[Switch to Windows Containers]\(Windows コンテナーに切り替える\)** を選択します。</span><span class="sxs-lookup"><span data-stu-id="abd3a-188">To do that, you right-click the Docker taskbar icon in Windows and select **Switch to Windows Containers**, as shown in Figure 7-4.</span></span>

![](./media/image4.png)

<span data-ttu-id="abd3a-189">**図 7-4**。</span><span class="sxs-lookup"><span data-stu-id="abd3a-189">**Figure 7-4**.</span></span> <span data-ttu-id="abd3a-190">Windows で Docker タスク バーから Windows コンテナーに切り替える</span><span class="sxs-lookup"><span data-stu-id="abd3a-190">Switching to Windows Containers from the Docker taskbar icon in Windows</span></span>

<span data-ttu-id="abd3a-191">メニュー項目に **[Switch to Linux Containers]\(Linux コンテナーに切り替える\)** と表示される場合は、既に Windows コンテナーで Docker を実行しています。</span><span class="sxs-lookup"><span data-stu-id="abd3a-191">If the menu item says **Switch to Linux containers**, you are already running Docker with Windows Containers.</span></span>

<span data-ttu-id="abd3a-192">ソリューションを実行すると、Docker ホストが再起動されます。</span><span class="sxs-lookup"><span data-stu-id="abd3a-192">Running the solution restarts the Docker host.</span></span> <span data-ttu-id="abd3a-193">構築するときに、Web フォーム プロジェクトのアプリケーションと Docker イメージを作成します。</span><span class="sxs-lookup"><span data-stu-id="abd3a-193">When you build, you build the application and the Docker image for the Web Forms project.</span></span> <span data-ttu-id="abd3a-194">初めてこの操作を行う場合は、時間がかかります。</span><span class="sxs-lookup"><span data-stu-id="abd3a-194">The first time you do this, it takes considerable time.</span></span> <span data-ttu-id="abd3a-195">ビルド プロセスでは、Windows Server の基本イメージと ASP.NET の追加イメージをプルダウンするためです。</span><span class="sxs-lookup"><span data-stu-id="abd3a-195">This is because the build process pulls down the base Windows Server image and the additional image for ASP.NET.</span></span> <span data-ttu-id="abd3a-196">後のビルドおよび実行サイクルは、はるかに速くなります。</span><span class="sxs-lookup"><span data-stu-id="abd3a-196">Subsequent build and run cycles will be much faster.</span></span>

<span data-ttu-id="abd3a-197">Docker プロジェクト テンプレートによって追加されるファイルを詳しく見ていきましょう。</span><span class="sxs-lookup"><span data-stu-id="abd3a-197">Let’s take a deeper look at the files added by the Docker project template.</span></span> <span data-ttu-id="abd3a-198">いくつかのファイルが作成されています。</span><span class="sxs-lookup"><span data-stu-id="abd3a-198">It created several files for you.</span></span> <span data-ttu-id="abd3a-199">Visual Studio では、これらのファイルを使用して、Docker イメージを作成し、コンテナーを開始します。</span><span class="sxs-lookup"><span data-stu-id="abd3a-199">Visual Studio uses these files to create the Docker image and launch a container.</span></span> <span data-ttu-id="abd3a-200">CLI から同じファイルを使用して、手動で Docker コマンドを実行することができます。</span><span class="sxs-lookup"><span data-stu-id="abd3a-200">You can use the same files from the CLI to run Docker commands manually.</span></span>

<span data-ttu-id="abd3a-201">次の Dockerfile の例は、ASP.NET サイトを実行する Windows ASP.NET イメージに基づいて、Docker イメージをビルドするための基本的な設定を示しています。</span><span class="sxs-lookup"><span data-stu-id="abd3a-201">The following Dockerfile example shows the basic settings for building a Docker image based on the Windows ASP.NET image that runs an ASP.NET site.</span></span>

```
FROM microsoft/aspnet

ARG source

WORKDIR /inetpub/wwwroot

COPY ${source:-obj/Docker/publish} .
```

<span data-ttu-id="abd3a-202">この Dockerfile は、Linux コンテナーで ASP.NET Core アプリケーションを実行するために作成されたものとよく似ています。</span><span class="sxs-lookup"><span data-stu-id="abd3a-202">This Dockerfile will look very similar to those created for running an ASP.NET Core application in Linux containers.</span></span> <span data-ttu-id="abd3a-203">ただし、重要な違いがいくつかあります。</span><span class="sxs-lookup"><span data-stu-id="abd3a-203">However, there are a few important differences.</span></span> <span data-ttu-id="abd3a-204">最も重要な違いは、基本イメージが microsoft/aspnet であることです。これは、.NET Framework を含む、現在の Windows Server イメージです。</span><span class="sxs-lookup"><span data-stu-id="abd3a-204">The most important difference is that the base image is microsoft/aspnet, which is the current Windows Server image that includes the .NET Framework.</span></span> <span data-ttu-id="abd3a-205">他の違いは、ソース ディレクトリからコピーされたディレクトリが異なるということです。</span><span class="sxs-lookup"><span data-stu-id="abd3a-205">Other differences are that the directories copied from your source directory are different.</span></span>

<span data-ttu-id="abd3a-206">**docker-compose** プロジェクトのその他のファイルは、コンテナーをビルドおよび構成するために必要な Docker アセットです。</span><span class="sxs-lookup"><span data-stu-id="abd3a-206">The other files in the **docker-compose** project are the Docker assets needed to build and configure the containers.</span></span> <span data-ttu-id="abd3a-207">Visual Studio では、ファイルの使用方法を強調するために、1 つのノードにさまざまな docker-compose.yml ファイルを配置しています。</span><span class="sxs-lookup"><span data-stu-id="abd3a-207">Visual Studio puts the various docker-compose.yml files under one node to highlight how they are used.</span></span> <span data-ttu-id="abd3a-208">基本の docker-compose ファイルには、すべての構成に共通のディレクティブが含まれています。</span><span class="sxs-lookup"><span data-stu-id="abd3a-208">The base docker-compose file contains the directives that are common to all configurations.</span></span> <span data-ttu-id="abd3a-209">docker-compose.override.yml ファイルには、環境変数および開発者用の構成に関連するオーバーライドが含まれています。</span><span class="sxs-lookup"><span data-stu-id="abd3a-209">The docker-compose.override.yml file contains environment variables and related overrides for a developer configuration.</span></span> <span data-ttu-id="abd3a-210">.vs.debug と .vs.release を含むバリアントは、Visual Studio が実行中のコンテナーに対してアタッチし、管理できるようにする環境設定を指定します。</span><span class="sxs-lookup"><span data-stu-id="abd3a-210">The variants with .vs.debug and .vs.release provide environment settings that enable Visual Studio to attach to and manage the running container.</span></span>

<span data-ttu-id="abd3a-211">Visual Studio の統合は、ソリューションへの Docker サポートの追加の一部ですが、前のセクションで示したように、docker-compose up コマンドを使用して、コマンド ラインからビルドおよび実行することもできます。</span><span class="sxs-lookup"><span data-stu-id="abd3a-211">While Visual Studio integration is part of adding Docker support to your solution, you can also build and run from the command line, using the docker-compose up command, as you saw in previous sections.</span></span>

## <a name="getting-data-from-the-existing-catalog-net-core-microservice"></a><span data-ttu-id="abd3a-212">既存のカタログ .NET Core マイクロサービスからデータを取得する</span><span class="sxs-lookup"><span data-stu-id="abd3a-212">Getting data from the existing catalog .NET Core microservice</span></span>

<span data-ttu-id="abd3a-213">仮のデータを使用する代わりに、データを取得する eShopOnContainers カタログ マイクロサービスを使用するように、Web フォーム アプリケーションを構成できます。</span><span class="sxs-lookup"><span data-stu-id="abd3a-213">You can configure the Web Forms application to use the eShopOnContainers catalog microservice to get data instead of using fake data.</span></span> <span data-ttu-id="abd3a-214">この操作を行うには、web.config ファイルを編集して、useFake キーの値を false に設定します。</span><span class="sxs-lookup"><span data-stu-id="abd3a-214">To do this, you edit the web.config file and set the value of the useFake key to false.</span></span> <span data-ttu-id="abd3a-215">DI コンテナーでは、ハード コーディングされたデータを返すクラスの代わりに、ライブ カタログ マイクロサービスにアクセスするクラスを使用します。</span><span class="sxs-lookup"><span data-stu-id="abd3a-215">The DI container will use the class that accesses the live catalog microservice instead of the class that returns the hard-coded data.</span></span> <span data-ttu-id="abd3a-216">他のコードの変更は必要ありません。</span><span class="sxs-lookup"><span data-stu-id="abd3a-216">No other code changes are needed.</span></span>

<span data-ttu-id="abd3a-217">ライブ カタログ サービスにアクセスするということは、カタログ サービス イメージをビルドして、カタログ サービス コンテナーを開始するように、**docker-compose** プロジェクトを更新する必要があるということです。</span><span class="sxs-lookup"><span data-stu-id="abd3a-217">Accessing the live catalog service does mean you need to update the **docker-compose** project to build the catalog service image and launch the catalog service container.</span></span> <span data-ttu-id="abd3a-218">Docker CE for Windows は、Linux コンテナーと Windows コンテナーの両方をサポートしますが、同時に使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="abd3a-218">Docker CE for Windows supports both Linux containers and Windows Containers, but not at the same time.</span></span> <span data-ttu-id="abd3a-219">カタログ マイクロサービスを実行するには、Windows ベースのコンテナーの上にカタログ マイクロサービスを実行するイメージをビルドする必要があります。</span><span class="sxs-lookup"><span data-stu-id="abd3a-219">To run the catalog microservice, you need to build an image that runs the catalog microservice on top of a Windows-based container.</span></span> <span data-ttu-id="abd3a-220">この手法では、前のセクションで使用したものではなく、マイクロサービス プロジェクト用に別の Dockerfile が必要です。</span><span class="sxs-lookup"><span data-stu-id="abd3a-220">This approach requires a different Dockerfile for the microservices project than you have seen in earlier sections.</span></span> <span data-ttu-id="abd3a-221">Dockerfile.windows ファイルには、カタログ API コンテナー イメージをビルドするために、構成設定が含まれるため、(たとえば、Windows Nano Docker イメージを使用するために) Windows コンテナー上で実行されます。</span><span class="sxs-lookup"><span data-stu-id="abd3a-221">The Dockerfile.windows file contains the configuration settings to build the catalog API container image so that it runs on a Windows container—for example, to use a Windows Nano Docker image.</span></span>

<span data-ttu-id="abd3a-222">カタログ マイクロサービスは、SQL Server データベースに依存します。</span><span class="sxs-lookup"><span data-stu-id="abd3a-222">The catalog microservice relies on the SQL Server database.</span></span> <span data-ttu-id="abd3a-223">そのため、Windows ベースの SQL Server の Docker イメージも使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="abd3a-223">Therefore, you need to use a Windows-based SQL Server Docker image as well.</span></span>

<span data-ttu-id="abd3a-224">これらの変更後、docker-compose プロジェクトは、アプリケーションを開始するために、さらに多くのことを行います。</span><span class="sxs-lookup"><span data-stu-id="abd3a-224">After these changes, the docker-compose project does more to start the application.</span></span> <span data-ttu-id="abd3a-225">そして、プロジェクトは、Windows ベースの SQL Server イメージを使用して、SQL Server を開始します。</span><span class="sxs-lookup"><span data-stu-id="abd3a-225">The project now starts the SQL Server using the Windows based SQL Server image.</span></span> <span data-ttu-id="abd3a-226">これにより、Windows コンテナーでカタログ マイクロサービスが開始されます。</span><span class="sxs-lookup"><span data-stu-id="abd3a-226">It starts the catalog microservice in a Windows container.</span></span> <span data-ttu-id="abd3a-227">また、Windows コンテナーで Web フォーム カタログ エディター コンテナーも開始されます。</span><span class="sxs-lookup"><span data-stu-id="abd3a-227">And it starts the Web Forms catalog editor container, also in a Windows container.</span></span> <span data-ttu-id="abd3a-228">いずれかのイメージでビルドが必要な場合、そのイメージが最初に作成されます。</span><span class="sxs-lookup"><span data-stu-id="abd3a-228">If any of the images need building, the images are created first.</span></span>

## <a name="development-and-production-environments"></a><span data-ttu-id="abd3a-229">開発環境と運用環境</span><span class="sxs-lookup"><span data-stu-id="abd3a-229">Development and production environments</span></span>

<span data-ttu-id="abd3a-230">開発環境の構成と運用環境の構成には、いくつかの違いがあります。</span><span class="sxs-lookup"><span data-stu-id="abd3a-230">There are a couple of differences between the development configuration and a production configuration.</span></span> <span data-ttu-id="abd3a-231">開発環境では、同じ Docker ホストの一部として、Windows コンテナー内で Web フォーム アプリケーション、カタログ マイクロサービス、および SQL Server を実行します。</span><span class="sxs-lookup"><span data-stu-id="abd3a-231">In the development environment, you run the Web Forms application, the catalog microservice, and SQL Server in Windows Containers, as part of the same Docker host.</span></span> <span data-ttu-id="abd3a-232">前のセクションで、SQL Server イメージは、Linux ベースの Docker ホスト上の他の .NET Core ベースのサービスとして、同じ Docker ホストに展開されると説明しました。</span><span class="sxs-lookup"><span data-stu-id="abd3a-232">In earlier sections, we mentioned SQL Server images deployed in the same Docker host as the other .NET Core-based services on a Linux-based Docker host.</span></span> <span data-ttu-id="abd3a-233">同じ Docker ホスト (またはクラスター) で実行している複数のマイクロサービスの利点は、ネットワーク通信を減らし、コンテナー間の通信の待ち時間の短くできることです。</span><span class="sxs-lookup"><span data-stu-id="abd3a-233">The advantage of running the multiple microservices in the same Docker host (or cluster) is that there is less network communication and the communication between containers has lower latency.</span></span>

<span data-ttu-id="abd3a-234">開発環境では、同じ OS のすべてのコンテナーを実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="abd3a-234">In the development environment, you must run all the containers in the same OS.</span></span> <span data-ttu-id="abd3a-235">Docker CE for Windows では、Windows ベースのコンテナーと Linux ベースのコンテナーの同時実行はサポートしていません。</span><span class="sxs-lookup"><span data-stu-id="abd3a-235">Docker CE for Windows does not support running Windows- and Linux-based containers at the same time.</span></span> <span data-ttu-id="abd3a-236">運用環境で、単一の Docker ホスト (またはクラスター) の Windows コンテナーでカタログ マイクロサービスを実行するか、Web フォーム アプリケーションを別の Docker ホストの Linux コンテナーで実行しているカタログ マイクロサービスのインスタンスと通信させるかを決定することができます。</span><span class="sxs-lookup"><span data-stu-id="abd3a-236">In production, you can decide if you want to run the catalog microservice in a Windows container in a single Docker host (or cluster), or have the Web Forms application communicate with an instance of the catalog microservice running in a Linux container on a different Docker host.</span></span> <span data-ttu-id="abd3a-237">これは、ネットワーク待ち時間を最適化する方法によって異なります。</span><span class="sxs-lookup"><span data-stu-id="abd3a-237">It depends on how you want to optimize for network latency.</span></span> <span data-ttu-id="abd3a-238">ほとんどの場合、展開を簡単にして通信の待ち時間を短くするために、アプリケーションが同じ Docker ホスト (または Swarm) で実行されていることに依存するマイクロサービスを必要とします。</span><span class="sxs-lookup"><span data-stu-id="abd3a-238">In most cases, you want the microservices that your applications depend on running in the same Docker host (or swarm) for ease of deployment and lower communication latency.</span></span> <span data-ttu-id="abd3a-239">これらの構成で、コストがかかる通信は、マイクロサービス インスタンスと永続データ ストレージの可用性が高いサーバー間のみです。</span><span class="sxs-lookup"><span data-stu-id="abd3a-239">In those configurations, the only costly communications is between the microservice instances and the high-availability servers for the persistent data storage.</span></span>

>[!div class="step-by-step"]
<span data-ttu-id="abd3a-240">[前へ] (../net-core-single-containers-linux-windows-server-hosts/index.md) [次へ] (../multi-container-microservice-net-applications/index.md)</span><span class="sxs-lookup"><span data-stu-id="abd3a-240">[Previous] (../net-core-single-containers-linux-windows-server-hosts/index.md) [Next] (../multi-container-microservice-net-applications/index.md)</span></span>
