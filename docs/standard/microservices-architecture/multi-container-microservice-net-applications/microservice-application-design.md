---
title: "マイクロ サービス指向アプリケーションの設計"
description: "コンテナーの .NET アプリケーションの .NET Microservices アーキテクチャ |マイクロ サービス指向アプリケーションの設計"
keywords: "Docker, マイクロサービス, ASP.NET, コンテナー"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: 1e1dc919c7e35580576c86b4cf9872b4f8cea2c2
ms.sourcegitcommit: c2e216692ef7576a213ae16af2377cd98d1a67fa
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/22/2017
---
# <a name="designing-a-microservice-oriented-application"></a>マイクロ サービス指向アプリケーションの設計

このセクションでは、仮想的なサーバー側のエンタープライズ アプリケーションの開発について説明します。

## <a name="application-specifications"></a>アプリケーションの仕様

仮想アプリケーションは、ビジネス ロジックの実行、データベースにアクセスする、HTML、JSON または XML 応答を返す、要求を処理します。 アプリケーションでさまざまなシングル ページ アプリケーション (SPAs)、従来の web アプリ、モバイル web アプリ、およびネイティブ モバイル アプリを実行しているデスクトップ ブラウザーも含めて、クライアントがサポートするいると言います。 アプリケーションは、使用するサード パーティの API を公開も可能性があります。 必要がありますも可能になってその microservices または外部アプリケーションを非同期的に、統合のアプローチが部分的な障害の場合 microservices の回復性に役立つようにします。

アプリケーションは、これらの種類のコンポーネントで構成されます。

-   プレゼンテーション コンポーネントです。 これらは、UI を処理し、リモート サービスの使用を担当します。

-   ドメインまたはビジネス ロジック。 これは、アプリケーションのドメイン ロジックです。

-   データベース アクセス ロジック。 これは、データ アクセス コンポーネント (SQL または NoSQL) データベースへのアクセスを担当するので構成されます。

-   アプリケーションの統合のロジックです。 これには、メッセージ ブローカーに基づく主に、メッセージング チャネルが含まれます。

アプリケーションでは、特定のサブシステム他よりもスケーラビリティが必要になりますので、垂直サブシステムを自律的に、スケール アウトを許可しているときに高いスケーラビリティが必要です。

アプリケーションでは、(複数のパブリック クラウドと内部設置型) の複数のインフラストラクチャ環境で展開できる必要があり、クロスプラット フォーム、Windows (またはその逆) を Linux から簡単に移動できることが理想的です。

## <a name="development-team-context"></a>開発チーム コンテキスト

アプリケーションの開発プロセスについては、次を仮定します。

-   アプリケーションのさまざまなビジネス領域に焦点を当てた複数の開発チームがあります。

-   新しいチーム メンバーが必要があります生産性の高い、迅速になり、アプリケーションを簡単に理解して、変更する必要があります。

-   アプリケーションは、長期的な展開と常に変化するビジネス ルールがあります。

-   適切な長期的な保守容易性、他のサブシステムに最低限への影響を複数のサブシステムを更新しているときに、将来新しい変更を実装する場合は、機敏性を持つことを意味する必要があります。

-   プラクティス継続的インテグレーションと継続的なデプロイのアプリケーションにします。

-   アプリケーションが進化する新しいテクノロジ (フレームワーク、プログラミング言語など) を活用するためにします。 高コストの結果し、予測可能性と、アプリケーションの安定性に影響するとなるため、新しいテクノロジに移動するときに、アプリケーションの完全移行を行うにはしません。

## <a name="choosing-an-architecture"></a>アーキテクチャを選択します。

アプリケーション展開のアーキテクチャのべきでしょうか。 開発のコンテキストと共に、アプリケーションの仕様をお勧めする場所、マイクロ サービス、共同 microservices とコンテナーの形式で自律的なサブシステムに分解することによって、アプリケーションを設計する必要があります。コンテナーです。

この方法では、各サービス (コンテナー) は、一連の結束力と狭義に関連する関数を実装します。 たとえば、アプリケーション カタログ サービスは、サービス、バスケット サービス、ユーザー プロファイル サービスなどを注文などのサービスの可能性がありますで構成されます。

Microservices 通信を使用してプロトコル HTTP (REST) などがも非同期的に (つまり AMQP) 可能な限り、特に更新されると、伝達統合イベントとします。

Microservices が開発し、互いにコンテナーとして展開します。 これは、開発チームの開発およびその他のサブシステムの影響を与えずに特定のマイクロ サービスを展開することを意味します。

各マイクロ サービスには、独自のデータベースは、その他の microservices から完全に分離させるを許可することがあります。 必要に応じて、異なる microservices のデータベース間で整合性は実現 (論理イベント バス) を介してイベントをアプリケーション レベルの統合を使用するコマンドと Query Responsibility Segregation (CQRS) で処理済みとしてされます。 そのため、ビジネス上の制約が複数 microservices 間最終的整合性を採用し、関連するデータベース。

### <a name="eshoponcontainers-a-reference-application-for-net-core-and-microservices-deployed-using-containers"></a>eShopOnContainers: .NET Core およびコンテナーを使用して配置 microservices リファレンス アプリケーション

よく知られているビジネス ドメインを選択したアーキテクチャと考えたわからない場合がありますを hypothetic ビジネス ドメインではなくテクノロジに専念することができるように、つまり、簡略化された電子商取引 (電子メールなど) アプリケーションのカタログを表示します。製品、顧客から注文を受け取り、インベントリ、ことを確認およびその他のビジネス関数を実行します。 このコンテナー ベースのアプリケーションのソース コードについては、 [eShopOnContainers](http://aka.ms/MicroservicesArchitecture) GitHub リポジトリです。

アプリケーションは、いくつかストア UI フロント エンド (Web アプリケーションとネイティブ モバイル アプリ)、およびバックエンド microservices と必要なすべてのサーバー側の操作用のコンテナーを含む複数のサブシステムで構成されます。 図 8-1 は、参照アプリケーションのアーキテクチャを示しています。

![](./media/image1.png)

**図 8-1**です。 EShopOnContainers 直接マイクロ サービスでのクライアントに通信し、イベント バスを示す、アプリケーションを参照します。

**ホスティング環境**です。 図 8-1 では、1 つの Docker ホスト内に配置されたいくつかのコンテナーが表示されます。 ある場合、docker を使用した単一の Docker ホストに展開する場合、コマンドを作成します。 ただし、する場合は、別のホスト (ノード) で実行すること、orchestrator またはコンテナーのクラスター、各コンテナーを使用して、任意のノードでしたされて搭載されている任意の数のコンテナーをアーキテクチャ」で説明しました。

**通信アーキテクチャ**です。 EShopOnContainers アプリケーションは、(更新とトランザクションとクエリ) の機能のアクションの種類に応じて、通信の 2 つの種類を使用します。

-   マイクロ サービスでのクライアントへの直接通信します。 更新プログラムまたはクライアント アプリからのトランザクションのコマンドを受け入れる場合は、クエリ、およびこの使用されます。

-   イベント ベースの非同期通信します。 これは、イベント バス microservices の更新プログラムを伝達するまたは外部アプリケーションと統合するを介して行われます。 RabbitMQ、または Azure Service Bus、NServiceBus、MassTransit、Brighter などの上位レベルのサービス バスを使用するように他のメッセージング ブローカー インフラストラクチャ テクノロジは、イベント バスを実装できます。

アプリケーションは、一連のコンテナーの形式で microservices として配置されます。 クライアント アプリこれらのコンテナーと通信したりできるよう microservices 間で通信します。 前述のように、この初期のアーキテクチャは、クライアント アプリケーション要求を作成できます、microservices のそれぞれに直接ことを意味するマイクロ サービスでのクライアントへの直接的な通信アーキテクチャを使用しています。 各マイクロ サービス https://servicename.applicationname.companyname などのパブリック エンドポイントがあります。 必要な場合、各マイクロ サービスは、別の TCP ポートを使用できます。 Microservices のロード バランサーに URL にマッピングする、実稼働環境では、使用可能なマイクロ サービス インスタンス間で使用する要求を分散します。

**API のゲートウェイの vs での重要な注意事項です。EShopOnContainers で直接通信します。** このガイドのアーキテクチャ」で説明、マイクロ サービスでのクライアントへの直接的な通信アーキテクチャは、大規模で複雑なマイクロ サービス ベースのアプリケーションを作成するとき欠点を持つことができます。 など、eShopOnContainers で簡単な作業に重点を置くが、目的のアプリケーションは、Docker コンテナー ベースのアプリケーションを開始しませんでしたに影響する 1 つのモノリシック API ゲートウェイを作成するは、小規模なアプリケーションで十分にすることができますが、microservices の開発の自律性。

数十個の microservices での大規模マイクロ サービス ベースのアプリケーションを設計する場合は、強くお勧め API ゲートウェイ パターンを考慮するアーキテクチャのセクションで説明しました。
リモート クライアントの運用環境でアプリケーションおよび特別に行われたファサードについて考えると、このアーキテクチャ上の意思決定のリファクタリングを行う可能性があります。 クライアント アプリのフォーム ファクターによって複数のカスタム API ゲートウェイを持つには利点については、そのクライアント アプリケーションごとに別のデータ集計と、クライアント アプリを内部 microservices または Api を非表示にし、その 1 つの層で承認できます。 

ただし、および説明したように、microservices の開発の自律性を強制終了大きくてモノリシックの API のゲートウェイに対してに注意してください。

### <a name="data-sovereignty-per-microservice"></a>マイクロ サービスごとのデータに対して

サンプル アプリケーションで各マイクロ サービスでは、独自のデータベースまたはデータ ソース、および各データベースを所有しているまたはデータ ソースを別のコンテナーとして展開します。 この設計の決定は、開発者は、GitHub からコードを取得する、複製、および Visual Studio または Visual Studio のコードで開くを簡単にのみしました。 または、代わりに、容易を .NET Core CLI と Docker CLI を使用してカスタム Docker イメージをコンパイルし展開して、Docker の開発環境で実行します。 どちらにしては、により、開発者が作成し、外部データベースまたはその他のデータ ソース (クラウドまたは内部設置型) のインフラストラクチャへのハード依存関係をプロビジョニングすることがなく、数分で展開をソース データ用のコンテナーを使用します。

高可用性、スケーラビリティ、実際の運用環境でデータベースをコンテナーではなく、クラウドまたはオンプレミスでデータベース サーバーに基づく必要があります。

そのため、展開の microservices (およびでもこのアプリケーション内のデータベース) の単位は、Docker コンテナー、参照アプリケーション microservices 原則を採用するアプリケーションをマルチです。

### <a name="additional-resources"></a>その他の技術情報

-   **eShopOnContainers GitHub リポジトリです。参照のアプリケーションのコードをソース**
    *https://aka.ms/eShopOnContainers/*

## <a name="benefits-of-a-microservice-based-solution"></a>マイクロ サービス ベースのソリューションの利点

次のように基づくマイクロ サービス ソリューションでは、多くの利点があります。

**各マイクロ サービスが比較的少ない-簡単な管理および進化**です。 具体的には、次のように使用します。

-   開発者が理解し、適切な生産性とすぐに開始する簡単です。

-   コンテナーは、これにより、開発者は、生産性の向上に高速、開始します。

-   Visual Studio のように IDE は、開発者の生産性を向上する高速で小さいプロジェクトを読み込むことができます。

-   各マイクロ サービスのように設計、開発、して microservices の新しいバージョンを頻繁に展開が容易になっているために、機敏性を提供するその他の microservices とは無関係に展開できます。

**スケール アウト アプリケーションの個々 の領域を行うことが**です。 たとえば、カタログ サービスまたはバスケット サービスは、順序付けプロセスではなく、スケール アウトする必要があります。 Microservices インフラストラクチャはモノリシック アーキテクチャよりも、スケール アウトする際に使用するリソースに関してより効率的になります。

**複数チーム間で開発作業を分割できる**です。 各サービスは、1 つの開発チームが所有することができます。 各チームは、管理、開発、展開、およびチームの残りの部分とは無関係に、サービスの規模をことができます。

**問題がより分離された**です。 1 つのサービスに問題がある場合のみ、そのサービスが初期状態に影響を与える (正しくないデザインを使用する場合、microservices 間の直接の依存関係を持つ) を除くとその他のサービスが要求の処理を続行できます。 これに対し、モノリシック展開アーキテクチャで正常に機能しないコンポーネントを 1 つは、メモリ リークなどのリソースに関係する場合は特に、全体のシステムを起動できます。 さらにのマイクロ サービスで発生する問題が解決されたら、アプリケーションの残りの部分に影響を与えずに影響を受けるマイクロ サービスだけを展開できます。

**最新のテクノロジを使用する**です。 サービスを個別に開発を開始して、サイド バイ サイドで (ご協力に感謝コンテナーと .NET Core) を実行、ため古いスタックや、全体のフレームワークに固定されているのではなく、最新のテクノロジとフレームワークを使用して臨機応変を起動することができます。アプリケーション。

## <a name="downsides-of-a-microservice-based-solution"></a>マイクロ サービス ベースのソリューションの欠点

次のように基づくマイクロ サービス ソリューションでは、いくつかの欠点もあります。

**分散アプリケーション**です。 設計され、サービスの構築時に、開発者向けの複雑さを追加するアプリケーションを配布します。 たとえば、開発者は、HTTP または AMPQ、テストおよび例外処理の複雑さを追加するなどのプロトコルを使用して通信を interservice を実装する必要があります。 また、待機時間をシステムに追加します。

**デプロイメントの複雑さ**です。 数十 microservices 種類があり、高い拡張性を実現 (サービスごとの多くのインスタンスを作成して多数のホスト間でそれらのサービスを分散できるようにする必要があります) を必要するアプリケーションでは、IT の運用と管理の高度なデプロイメントの複雑さを意味します。 (と同様に、orchestrator とスケジューラ) マイクロ サービス指向のインフラストラクチャを使用していない場合、その複雑さは、ビジネス アプリケーション自体よりもかなり多くの開発作業を要求できます。

**アトミック トランザクション**です。 複数 microservices 通常の間でアトミックのトランザクションがあります。 ビジネス要件は、複数 microservices 間最終的整合性を採用する必要があります。

**グローバルなリソースのニーズの増加**(メモリ、ドライブ、およびすべてのサーバーまたはホストのネットワーク リソースを total)。 多くの場合、microservices 方法、使用すると、単体のアプリケーションを置き換えるときに新しいマイクロ サービス ベースのアプリケーションで必要なグローバル リソースの量が大きくなりますモノリシック元のアプリケーションのインフラストラクチャのニーズよりもします。 これより高いレベルの粒度と分散サービスより多くのグローバル リソースを必要とするためです。 ただし、指定すると、低コストの一般的な情報とスケール アウト モノリシックなアプリケーションを開発する際の長期的なコストと比較して、アプリケーションのだけ特定の領域を使用できるという利点は、リソース、リソースの使用量が増えるは通常のトレードオフの大きな、長期的なアプリケーションです。

**直接 client‑to‑microservice の通信に問題**です。 アプリケーションが数十個の microservices を含む、大規模なである場合がある課題と制限事項、アプリケーションに直接マイクロ サービスでのクライアントに通信が必要な場合です。 問題の 1 つは、クライアントのニーズと、microservices の各によって公開されている Api の間で不一致の可能性がします。 場合によっては、クライアント アプリケーションは、UI は、インターネット経由で効率的なでき、モバイル ネットワーク経由で実用的なが作成する多くの独立した要求を行う必要があります。 そのため、バックエンド システムにクライアント アプリケーションからの要求を最小限に抑える必要があります。

直接のクライアント-マイクロ-サービスの通信に別の問題は、Web で表示されているプロトコルが使用する可能性のある一部 microservices です。 1 つのサービスは、別のサービスが AMQP のメッセージングを使用する場合があります、バイナリ プロトコルを使用できます。 これらのプロトコルは firewall‑friendly であり最も内部的に使用されます。 通常、アプリケーションでは、ファイアウォール外との通信に HTTP や Websocket などのプロトコルを使用する必要があります。

まだこの直接 client‑to‑service アプローチでの別の欠点は、ことが困難になってその microservices のコントラクトをリファクターします。 時間の経過と共に開発者がサービスに、システムがパーティション分割方法を変更するとする可能性があります。 たとえば、2 つのサービスをマージ、または 2 つまたは複数のサービスにサービスを分割します。 ただしとクライアントは、サービスと直接通信して、、この種類のリファクタリングを実行する動作しなくなるクライアント アプリとの互換性。

前述のセクションでは、アーキテクチャ、設計および microservices に基づいて複雑なアプリケーションを構築するときよりシンプルな直接 client‑to‑microservice 通信方法ではなく複数の粒度の細かい API ゲートウェイの使用を検討する可能性があります。

**パーティション分割、microservices**です。 最後に、どちらの方法は、マイクロ サービス アーキテクチャを実行する場合に関係なく別の課題決める複数 microservices にエンド ツー エンド アプリケーションをパーティション分割する方法です。 このガイドのアーキテクチャ」で説明されてがあるいくつかの手法とアプローチを実行できます。 基本的には、アプリケーションは他の部分から切り離されていると、依存関係の数が少ないがある領域を特定する必要があります。 多くの場合、これは配置サービスをパーティション分割するユース ケースによってされます。 たとえば、e のワンストップ ショップ アプリケーションでは、注文プロセスに関連するすべてのビジネス ロジックを担当する順序付けのサービスをあります。 また、カタログ サービスとその他の機能を実装するバスケット サービスがあります。 理想的には、各サービスには、責任の少数のセットのみが必要です。 これは、単一責任原則 (SRP) クラスに適用されるクラスのみが変更する 1 つの理由を示すに似ています。 ここでは、microservices、に関するため、スコープが 1 つのクラスよりも大きくなります。 、すべての最も、マイクロ サービスを完全に独立した、独自のデータ ソースに対する責任を含む、エンド ツー エンドにある必要があります。

## <a name="external-versus-internal-architecture-and-design-patterns"></a>内部のアーキテクチャと設計パターンではなく外部

外部のアーキテクチャは、このガイドのアーキテクチャのセクションで説明した原則に従って、複数のサービスによって作成されてマイクロ サービスのアーキテクチャです。 ただし、およびマイクロ サービスの高度なアーキテクチャを選択するとは無関係に各マイクロ サービスの性質、によって共通ともことはお勧め別の内部アーキテクチャである各に基づいて、さまざまなパターンは、の異なるmicroservices です。 また、microservices は、さまざまなテクノロジおよびプログラミング言語を使用していることもできます。 図 8-2 は、この多様性を示しています。

![](./media/image2.png)

**図 8-2**です。 外部の内部アーキテクチャと設計との比較

インスタンスで、 *eShopOnContainers*サンプル、カタログ、バスケット、およびユーザーのプロファイル microservices は単純な (基本的に、CRUD サブシステム)。 そのため、その内部のアーキテクチャと設計では簡単です。 ただしより複雑なあり高度なドメインの複雑さを絶えず変化するビジネス ルールを表す順序マイクロ サービスなど、他の microservices があります。 上記のような場合は、場合行っているように、ドメインに基づくデザイン (DDD) アプローチで定義されているのと同様に、特定のマイクロ サービス内のより高度なパターンを実装する、 *eShopOnContainers*順序マイクロ サービス。 (これら DDD パターンいるセクションで後での実装について説明していきます、 *eShopOnContainers*マイクロ サービスを順序付けします)。

マイクロ サービスごとのさまざまなテクノロジの原因として、各マイクロ サービスの性質があります。 たとえば、だと考えられます F のように、関数型プログラミング言語を使用する方がよい\#、AI および機械学習で C のような複数のオブジェクト指向のプログラミング言語ではなく、ドメインを対象とする場合は、R などの言語をも\#。

一番下の行は、各マイクロ サービスはさまざまなデザイン パターンに基づく別の内部アーキテクチャであることができます。 すべて microservices を実装する高度なの DDD パターンを使用するいるとする過剰エンジニア リングにあるためです。 同様に、CRUD コンポーネントとして、絶えず変化するビジネス ロジックで複雑な microservices を実装しないようにまたは低品質のコード終了することができます。



## <a name="the-new-world-multiple-architectural-patterns-and-polyglot-microservices"></a>新しい世界: 複数のアーキテクチャのパターンおよび多言語 microservices

ソフトウェア設計者および開発者によって使用される多くのアーキテクチャのパターンがあります。 いくつかを次に示します (アーキテクチャのスタイル、およびアーキテクチャのパターンが混在)。

-   単純な CRUD、1 階層 1 層です。

-   [従来 N 層](https://msdn.microsoft.com/en-us/library/ee658109.aspx#Layers)です。

-   [ドメインに基づくデザイン N 層](https://blogs.msdn.microsoft.com/cesardelatorre/2011/07/03/published-first-alpha-version-of-domain-oriented-n-layered-architecture-v2-0/)です。

-   [アーキテクチャのクリーンアップ](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html)(で使用される[eShopOnWeb](http://aka.ms/WebAppArchitecture))

-   [コマンドおよび責任の分離をクエリ](https://martinfowler.com/bliki/CQRS.html)(CQRS)。

-   [イベント ドリブンのアーキテクチャ](https://en.wikipedia.org/wiki/Event-driven_architecture)(EDA)。

多くのテクノロジおよび ASP.NET Core Web Api、NancyFx、(.NET Core 2 で使用可能) ASP.NET Core SignalR、F などの言語と microservices を構築することもできます。\#、Node.js、Python、Java、C++、GoLang、および詳細。

重要な点は、特定のアーキテクチャ パターンのないスタイル、しても、または、特定のテクノロジですべての条件に適合です。 図 8-3 は、(ただしではなく、特定の順序) いくつかのアプローチとテクノロジを示しています。 異なる microservices でを使用できます。

![](./media/image3.png)

**図 8-3**です。 複数のアーキテクチャのパターンと多言語 microservices world

示すように図 8-3、アプリケーションから成る多く microservices (範囲指定されたコンテキストはデザインのドメインに基づく用語、または単に「サブシステム」自律 microservices として)、別の方法で各マイクロ サービスを実装する場合があります。 あるとは異なるアーキテクチャのパターンと、さまざまな言語と、アプリケーションの性質、ビジネス要件、および優先度に応じてデータベースを使用して各可能性があります。 場合によっては、microservices はのような可能性があります。 されていないに通常場合は、各サブシステムのコンテキストの境界と要件が通常異なるためです。

たとえば、単純な CRUD メンテナンス アプリケーションのされません賢明かもしれませんを設計および DDD パターンを実装します。 中核となるドメインまたは主要業務には、絶えず変化するビジネス ルールとビジネスの複雑さに対応するより高度なパターンを適用する必要があります。

大規模なアプリケーションの複数のサブシステムによって構成を処理する場合に特には、1 つのアーキテクチャのパターンに基づいた 1 つの最上位レベル アーキテクチャを適用しないでください。 たとえば、CQRS は全体のアプリケーションの最上位レベル アーキテクチャとしては適用しないが、一連のサービスの特定に役立つ場合があります。

シルバー箇条書きなしまたは指定した事例ごとに適切なアーキテクチャ パターンがあります。 「1 つのアーキテクチャ パターンそれらすべてを排除するためです」することはできません。 各マイクロ サービスの優先度に応じて、次のセクションで説明したようごとに、別のアプローチを選択してください。


>[!div class="step-by-step"]
[前](index.md) [次へ] (データのドリブン-crud-microservice.md)
