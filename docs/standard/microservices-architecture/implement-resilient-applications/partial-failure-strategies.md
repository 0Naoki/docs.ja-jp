---
title: "部分的な障害を処理するための戦略"
description: "コンテナーの .NET アプリケーションの .NET Microservices アーキテクチャ |部分的な障害を処理するための戦略"
keywords: "Docker, マイクロサービス, ASP.NET, コンテナー"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: ff3bed530b13a9b1822c7cccf5a4d47df6fc6239
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/18/2017
---
# <a name="strategies-for-handling-partial-failure"></a><span data-ttu-id="27b4f-104">部分的な障害を処理するための戦略</span><span class="sxs-lookup"><span data-stu-id="27b4f-104">Strategies for handling partial failure</span></span>

<span data-ttu-id="27b4f-105">部分的な障害を処理するための戦略には、次の項目が含まれます。</span><span class="sxs-lookup"><span data-stu-id="27b4f-105">Strategies for dealing with partial failures include the following.</span></span>

<span data-ttu-id="27b4f-106">**内部 microservices 間で非同期通信 (たとえば、メッセージ ベースの通信) を使用して**です。</span><span class="sxs-lookup"><span data-stu-id="27b4f-106">**Use asynchronous communication (for example, message-based communication) across internal microservices**.</span></span> <span data-ttu-id="27b4f-107">その正しくないデザインは不適切な停止の主な原因を最終的になるために、内部 microservices 間で同期の HTTP 呼び出しの長いチェーンを作成するには、いないことを強く勧めします。</span><span class="sxs-lookup"><span data-stu-id="27b4f-107">It is highly advisable not to create long chains of synchronous HTTP calls across the internal microservices because that incorrect design will eventually become the main cause of bad outages.</span></span> <span data-ttu-id="27b4f-108">反対に、クライアント アプリケーションと microservices や粒度の細かい API ゲートウェイの最初のレベル間フロント エンドの通信を除くをお勧め通信を使用するのみ非同期 (メッセージに基づく)、最初の要求の 1 回を超えて/内部 microservices 間での応答のサイクルです。</span><span class="sxs-lookup"><span data-stu-id="27b4f-108">On the contrary, except for the front-end communications between the client applications and the first level of microservices or fine-grained API Gateways, it is recommended to use only asynchronous (message-based) communication once past the initial request/response cycle, across the internal microservices.</span></span> <span data-ttu-id="27b4f-109">最終的整合性およびイベント ドリブンのアーキテクチャは、ripple 影響を最小限に抑えるに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="27b4f-109">Eventual consistency and event-driven architectures will help to minimize ripple effects.</span></span> <span data-ttu-id="27b4f-110">これらの方法はマイクロ サービスの自律性の高いレベルを適用して、ここに記載されている問題を防止するため。</span><span class="sxs-lookup"><span data-stu-id="27b4f-110">These approaches enforce a higher level of microservice autonomy and therefore prevent against the problem noted here.</span></span>

<span data-ttu-id="27b4f-111">**指数バックオフによる再試行を使用して**です。</span><span class="sxs-lookup"><span data-stu-id="27b4f-111">**Use retries with exponential backoff**.</span></span> <span data-ttu-id="27b4f-112">この手法の回避に役立ちます短いと、サービスが短時間に対してのみ使用可能な場合に呼び出しを実行することによって断続的なエラー再試行する回数だけ、します。</span><span class="sxs-lookup"><span data-stu-id="27b4f-112">This technique helps to avoid short and intermittent failures by performing call retries a certain number of times, in case the service was not available only for a short time.</span></span> <span data-ttu-id="27b4f-113">これは、断続的なネットワークの問題により、またはマイクロ サービス/コンテナーがクラスター内の異なるノードに移動したときに発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="27b4f-113">This might occur due to intermittent network issues or when a microservice/container is moved to a different node in a cluster.</span></span> <span data-ttu-id="27b4f-114">ただし、これらの再試行がブレーカーを正しく設計されていません場合、そのことができますを悪化させること波及効果、最終的にも発生する[サービス拒否 (DoS)](https://en.wikipedia.org/wiki/Denial-of-service_attack)です。</span><span class="sxs-lookup"><span data-stu-id="27b4f-114">However, if these retries are not designed properly with circuit breakers, it can aggravate the ripple effects, ultimately even causing a [Denial of Service (DoS)](https://en.wikipedia.org/wiki/Denial-of-service_attack).</span></span>

<span data-ttu-id="27b4f-115">**ネットワークのタイムアウトを回避する**です。</span><span class="sxs-lookup"><span data-stu-id="27b4f-115">**Work around network timeouts**.</span></span> <span data-ttu-id="27b4f-116">一般に、クライアントは、応答を待機しているときに常にタイムアウトを使用して無期限にブロックを設計する必要があります。</span><span class="sxs-lookup"><span data-stu-id="27b4f-116">In general, clients should be designed not to block indefinitely and to always use timeouts when waiting for a response.</span></span> <span data-ttu-id="27b4f-117">タイムアウトを使用しているリソースは決して関連付けられています無期限にことを確認します。</span><span class="sxs-lookup"><span data-stu-id="27b4f-117">Using timeouts ensures that resources are never tied up indefinitely.</span></span>

<span data-ttu-id="27b4f-118">**遮断器パターンを使用して**です。</span><span class="sxs-lookup"><span data-stu-id="27b4f-118">**Use the Circuit Breaker pattern**.</span></span> <span data-ttu-id="27b4f-119">この方法では、クライアント プロセスは、失敗した要求の数を追跡します。</span><span class="sxs-lookup"><span data-stu-id="27b4f-119">In this approach, the client process tracks the number of failed requests.</span></span> <span data-ttu-id="27b4f-120">場合はエラー率は、再試行はすぐに失敗できるように構成されている制限値は、「遮断器」トリップを超えています。</span><span class="sxs-lookup"><span data-stu-id="27b4f-120">If the error rate exceeds a configured limit, a “circuit breaker” trips so that further attempts fail immediately.</span></span> <span data-ttu-id="27b4f-121">(大量の要求が失敗する場合を提案する、サービスが使用できないと、要求を送信することは、無意味です。)タイムアウト期間後にクライアント必要がありますもう一度やり直してくださいし、新しい要求が成功すると、遮断器を閉じます。</span><span class="sxs-lookup"><span data-stu-id="27b4f-121">(If a large number of requests are failing, that suggests the service is unavailable and that sending requests is pointless.) After a timeout period, the client should try again and, if the new requests are successful, close the circuit breaker.</span></span>

<span data-ttu-id="27b4f-122">**フォールバックを提供**です。</span><span class="sxs-lookup"><span data-stu-id="27b4f-122">**Provide fallbacks**.</span></span> <span data-ttu-id="27b4f-123">この方法では、クライアント プロセスは、要求が失敗した場合に、キャッシュされたデータまたは既定値を返すなどに、フォールバック ロジックを実行します。</span><span class="sxs-lookup"><span data-stu-id="27b4f-123">In this approach, the client process performs fallback logic when a request fails, such as returning cached data or a default value.</span></span> <span data-ttu-id="27b4f-124">これはクエリでは、適切なアプローチであり、更新プログラムやコマンドにより複雑なは。</span><span class="sxs-lookup"><span data-stu-id="27b4f-124">This is an approach suitable for queries, and is more complex for updates or commands.</span></span>

<span data-ttu-id="27b4f-125">**キューに置かれた要求の数を制限**です。</span><span class="sxs-lookup"><span data-stu-id="27b4f-125">**Limit the number of queued requests**.</span></span> <span data-ttu-id="27b4f-126">クライアントは、クライアント マイクロ サービスを特定のサービスに送信できる未処理の要求の数に上限を課すもする必要があります。</span><span class="sxs-lookup"><span data-stu-id="27b4f-126">Clients should also impose an upper bound on the number of outstanding requests that a client microservice can send to a particular service.</span></span> <span data-ttu-id="27b4f-127">制限に達している場合は、おそらく他の要求を行うことも意味がなく、再試行回数が即座に失敗します。</span><span class="sxs-lookup"><span data-stu-id="27b4f-127">If the limit has been reached, it is probably pointless to make additional requests, and those attempts should fail immediately.</span></span> <span data-ttu-id="27b4f-128">実装では、ポリーの観点から[バルクヘッド分離](https://github.com/App-vNext/Polly/wiki/Bulkhead)ポリシーは、この要件を受け付けますを使用することができます。</span><span class="sxs-lookup"><span data-stu-id="27b4f-128">In terms of implementation, the Polly [Bulkhead Isolation](https://github.com/App-vNext/Polly/wiki/Bulkhead) policy can be used to fulfil this requirement.</span></span> <span data-ttu-id="27b4f-129">並列化スロットル本質的には、この方法は[SemaphoreSlim](https://docs.microsoft.com/dotnet/api/system.threading.semaphoreslim?view=netcore-1.1)として実装します。</span><span class="sxs-lookup"><span data-stu-id="27b4f-129">This approach is essentially a parallelization throttle with [SemaphoreSlim](https://docs.microsoft.com/dotnet/api/system.threading.semaphoreslim?view=netcore-1.1) as the implementation.</span></span> <span data-ttu-id="27b4f-130">バルクヘッド外"queue"をこともできます。</span><span class="sxs-lookup"><span data-stu-id="27b4f-130">It also permits a "queue" outside the bulkhead.</span></span> <span data-ttu-id="27b4f-131">(たとえば、容量には、すべてのものと見なされます) ため能動的に実行する前に余分な負荷かアドバイスことができます。</span><span class="sxs-lookup"><span data-stu-id="27b4f-131">You can proactively shed excess load even before execution (for example, because capacity is deemed full).</span></span> <span data-ttu-id="27b4f-132">これにより、特定の障害シナリオへの応答、遮断器である場合は、障害の遮断器が待機するためのより高速化します。</span><span class="sxs-lookup"><span data-stu-id="27b4f-132">This makes its response to certain failure scenarios faster than a circuit breaker would be, since the circuit breaker waits for the failures.</span></span> <span data-ttu-id="27b4f-133">ポリーで BulkheadPolicy オブジェクトがどの程度のバルクヘッドを公開およびキューは、オーバーフローについて提供イベントのでこともできますを水平方向の自動スケーリングを実行します。</span><span class="sxs-lookup"><span data-stu-id="27b4f-133">The BulkheadPolicy object in Polly exposes how full the bulkhead and queue are, and offers events on overflow so can also be used to drive automated horizontal scaling.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="27b4f-134">その他の技術情報</span><span class="sxs-lookup"><span data-stu-id="27b4f-134">Additional resources</span></span>

-   <span data-ttu-id="27b4f-135">**回復力のパターン**
    [*https://docs.microsoft.com/azure/architecture/patterns/category/resiliency*](https://docs.microsoft.com/azure/architecture/patterns/category/resiliency)</span><span class="sxs-lookup"><span data-stu-id="27b4f-135">**Resiliency patterns**
[*https://docs.microsoft.com/azure/architecture/patterns/category/resiliency*](https://docs.microsoft.com/azure/architecture/patterns/category/resiliency)</span></span>

-   <span data-ttu-id="27b4f-136">**回復力を追加して、パフォーマンスを最適化する**
    [*https://msdn.microsoft.com/en-us/library/jj591574.aspx*](https://msdn.microsoft.com/en-us/library/jj591574.aspx)</span><span class="sxs-lookup"><span data-stu-id="27b4f-136">**Adding Resilience and Optimizing Performance**
[*https://msdn.microsoft.com/en-us/library/jj591574.aspx*](https://msdn.microsoft.com/en-us/library/jj591574.aspx)</span></span>

-   <span data-ttu-id="27b4f-137">**バルクヘッドです。**</span><span class="sxs-lookup"><span data-stu-id="27b4f-137">**Bulkhead.**</span></span> <span data-ttu-id="27b4f-138">GitHub のリポジトリ。</span><span class="sxs-lookup"><span data-stu-id="27b4f-138">GitHub repo.</span></span> <span data-ttu-id="27b4f-139">ポリー ポリシーを使用して実装します \。</span><span class="sxs-lookup"><span data-stu-id="27b4f-139">Implementation with Polly policy.\\</span></span>
    [<span data-ttu-id="27b4f-140">*https://github.com/App-vNext/Polly/wiki/Bulkhead*</span><span class="sxs-lookup"><span data-stu-id="27b4f-140">*https://github.com/App-vNext/Polly/wiki/Bulkhead*</span></span>](https://github.com/App-vNext/Polly/wiki/Bulkhead)

-   <span data-ttu-id="27b4f-141">**Azure の回復力のあるアプリケーションの設計**
    [*https://docs.microsoft.com/azure/architecture/resiliency/*](https://docs.microsoft.com/azure/architecture/resiliency/)</span><span class="sxs-lookup"><span data-stu-id="27b4f-141">**Designing resilient applications for Azure**
[*https://docs.microsoft.com/azure/architecture/resiliency/*](https://docs.microsoft.com/azure/architecture/resiliency/)</span></span>

-   <span data-ttu-id="27b4f-142">**一時的なエラー処理**
    <https://docs.microsoft.com/azure/architecture/best-practices/transient-faults></span><span class="sxs-lookup"><span data-stu-id="27b4f-142">**Transient fault handling**
<https://docs.microsoft.com/azure/architecture/best-practices/transient-faults></span></span>


>[!div class="step-by-step"]
<span data-ttu-id="27b4f-143">[前](ハンドル-部分的-failure.md) [次へ] (実装の再試行-指数-backoff.md)</span><span class="sxs-lookup"><span data-stu-id="27b4f-143">[Previous] (handle-partial-failure.md) [Next] (implement-retries-exponential-backoff.md)</span></span>
