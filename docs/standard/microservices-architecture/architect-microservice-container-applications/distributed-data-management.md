---
title: "分散データ管理に関する課題とソリューション"
description: "コンテナーの .NET アプリケーションの .NET Microservices アーキテクチャ |分散データ管理に関する課題とソリューション"
keywords: "Docker, マイクロサービス, ASP.NET, コンテナー"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: f961475b40c74bf448cff1aeae04ae4866360e52
ms.sourcegitcommit: c2e216692ef7576a213ae16af2377cd98d1a67fa
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/22/2017
---
# <a name="challenges-and-solutions-for-distributed-data-management"></a>分散データ管理に関する課題とソリューション

## <a name="challenge-1-how-to-define-the-boundaries-of-each-microservice"></a>チャレンジ\#1: 各マイクロ サービスの境界を定義する方法

マイクロ サービスの境界を定義することは、すべてのユーザーが検出した最初のチャレンジでが考えられます。 各マイクロ サービスが、アプリケーションの一部であるが、各マイクロ サービスをすべての利点と、表示する課題自律的にする必要があります。 しかし、これらの境界を特定する方法でしょうか。

最初に、アプリケーションの論理ドメイン モデルと関連するデータに重点を置く必要があります。 データと同じアプリケーション内の異なるコンテキストの切り離されたアイランドを識別しようとする必要があります。 各コンテキストには、さまざまなビジネス言語 (さまざまなビジネス用語) 可能性があります。 コンテキストの定義し、は別に管理する必要があります。 用語とそのさまざまなコンテキストで使用するエンティティと同様に、音の可能性がありますが、特定のコンテキストで 1 つのビジネスの概念に対してを使用する別のコンテキストで別の目的を検出でき、別の名前にもあるでしょう。 たとえば、ユーザー コンテキストでは、順序、購入者としてのコンテキストでは、CRM、お客様のコンテキストでは、id またはメンバーシップ、ユーザーとして参照できますなど。

各コンテキストが各ビジネス マイクロ サービスとその関連の境界を特定する方法には、複数のアプリケーション コンテキストを別のドメイン間の境界を識別する方法は、ドメイン モデルとデータ。 常にしようとするそれら microservices 間の結合を最小化します。 このガイドは、セクションでこの id とドメインのモデル設計について詳細に説明が[各マイクロ サービスのドメイン モデルの境界を識別する](#identifying-domain-model-boundaries-for-each-microservice)以降。

## <a name="challenge-2-how-to-create-queries-that-retrieve-data-from-several-microservices"></a>チャレンジ\#2: いくつかの microservices からデータを取得するクエリを作成する方法

2 番目の課題は、リモート クライアント アプリケーションから、microservices に chatty な通信を回避しながら、いくつかの microservices からデータを取得するクエリを実装する方法を示します。 バスケット、カタログ、およびユーザーの id microservices によって所有されているユーザー情報を表示する必要があるモバイル アプリからの 1 つの画面の例があります。 別の例には、複数の microservices にある多数のテーブルに関連する複雑なレポートがあります。 最適なソリューションは、クエリの複雑さによって異なります。 いずれの場合は必要しますが、あります情報を集計する方法をシステムの通信の効率を向上する場合。 最も一般的なソリューションは次のです。

**API ゲートウェイ**です。 異なるデータベースを所有する複数の microservices から単純なデータの集計、推奨される方法は、API ゲートウェイと呼ばれる、集計マイクロ サービスです。 ただし、システムで、チョーク ポイントであることができます、マイクロ サービスの自律性の原則に違反することができますが、このパターンの実装について注意する必要があります。 この可能性を軽減するためにはそれぞれ 1 つに焦点を当てた垂直"、スライス"またはシステムのビジネス領域罰金粒度の複数の API ゲートウェイができます。 API ゲートウェイ パターンが使用方法のセクションで詳しく説明されている API ゲートウェイを後でします。

**クエリの読み取り/テーブルでの CQRS**です。 複数の microservices からデータを集計するための別のソリューションが、[ビューの具体化パターン](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)です。 この方法で生成する、事前に (実際のクエリでは、発生する前に正規化されていないデータを準備する、) 複数 microservices によって所有されているデータを含む読み取り専用テーブル。 テーブルには、クライアント アプリケーションのニーズに合った形式があります。

モバイル アプリの画面のようなものを検討してください。 1 つのデータベースがある場合は、可能性がありますをプルする同時に複数のテーブルに関連する複雑な結合を実行する SQL クエリを使用して、その画面のデータ。 複数のデータベースがあり、各データベースが異なるマイクロ サービスによって所有されているときにそれらのデータベースのクエリし、SQL 結合を作成できません。 複雑なクエリでは、困難になります。 CQRS アプローチを使用して、要件に対処することができます: クエリにのみ使用する別のデータベースで非正規化されたテーブルを作成します。 具体的には、アプリケーションの画面およびクエリのテーブルの列で必要なフィールド間の一対一のリレーションシップを使用して、複雑なクエリの必要なデータのテーブルを設計できます。 レポートのため、しまう可能性もあります。

このアプローチはだけでなく (クエリおよび microservices 間で結合する方法); 元の問題を解決します。クエリ テーブルに、アプリケーションに必要なデータが既にあるために、複雑な結合と比較した場合に非常にパフォーマンスも向上します。 もちろん、追加の開発作業をクエリ/読み取りテーブル コマンドと Query Responsibility Segregation (CQRS) を使用することを意味し、最終的整合性を採用する必要があります。 ただし、パフォーマンスと高スケーラビリティの要件[コラボレーションのシナリオ](http://udidahan.com/2011/10/02/why-you-should-be-using-cqrs-almost-everywhere/)(またはの観点に応じて、競合するシナリオ) は、複数のデータベースでの CQRS を適用する必要があります。

**中央のデータベース内の「コールド データ」**です。 複雑なレポートとリアルタイムのデータを必要としない場合のクエリでは、一般的な方法は、ホット データ"をエクスポートするのには (、microservices からトランザクション データ) レポート用のみに使用されている大規模なデータベースに「コールド データ」です。 中央のデータベース システムでは、Hadoop、Azure SQL Data Warehouse、または (サイズには、問題はされない) 場合は、レポートにのみ使用される単一 SQL データベースでもに基づくいずれかのように、データ ウェアハウスなどの大規模なデータに基づくシステムを指定できます。

クエリおよびリアルタイムのデータを必要としないレポートに対してのみこの一元化されたデータベースを使用することに注意してください。 元の更新プログラムと、実際のソースとしてのトランザクションは、microservices データにする必要です。 イベント ドリブンの通信 (次のセクションで説明) を使用して、またはその他のデータベース インフラストラクチャのインポート/エクスポート ツールを使用してデータを同期するようになります。 イベント ドリブンの通信を使用する場合、その統合プロセスは CQRS テーブルをクエリの前述のようにデータを伝達するのと同様になります。

ただし、アプリケーションの設計には、複数の microservices 複雑なクエリからの情報を常に集計が含まれている場合がありますの不適切なデザインの症状に —、マイクロ サービスを他の microservices からできるだけに分離する必要があります。 (コールド データの中央データベースが常に使用するレポートと分析は除く)。多くの場合、この問題が発生すると、microservices をマージするための可能性があります。 展開の自主性と厳密な依存性、凝集度、およびデータの集計で各マイクロ サービスの展開のバランスをとる必要があります。

## <a name="challenge-3-how-to-achieve-consistency-across-multiple-microservices"></a>チャレンジ\#3: 複数 microservices 全体で一貫性を実現する方法

前述のように、各マイクロ サービスが所有するデータはそのマイクロ サービスをプライベートおよびそのマイクロ サービス API を使用してのみアクセスできます。 そのため、表示されるチャレンジは、複数 microservices 全体で一貫性を維持しながら、エンド ツー エンドのビジネス プロセスを実装する方法を示します。

この問題を分析する例を見てみましょうから、 [eShopOnContainers 参照アプリケーション](http://aka.ms/eshoponcontainers)です。 カタログ マイクロ サービスは、株価のレベルを含むすべての製品に関する情報を保持します。 順序付けマイクロ サービスは、注文を管理し、新しい注文が利用可能なカタログの製品の在庫を超えていないことを確認する必要があります。 (または、シナリオには、在庫のある製品を処理するロジックが含まれます)。仮定モノリシックなバージョンのこのアプリケーションでは、順序サブシステムでしただけで使用 ACID トランザクションを使用可能な在庫を確認して、Orders テーブルに注文を作成および更新、Products テーブル内の利用可能なストックです。

ただし、microservices ベースのアプリケーションでは、注文および製品のテーブルは、それぞれ microservices によって所有されます。 マイクロ サービス含める必要がありますれたなしで、独自のトランザクションまたはクエリを別のマイクロ サービスを所有するデータベース図 4-9 に示すようにします。

![](./media/image9.PNG)

**図 4. ~ 9.**です。 マイクロ サービスは、別のマイクロ サービス内のテーブルに直接アクセスできません。

順序付けマイクロ サービスする必要がありますテーブルを更新できません製品を直接、Products テーブルは、カタログ マイクロ サービスによって所有されているためです。 カタログ マイクロ サービスを更新するには、その順序マイクロ サービスはだけ統合イベント (メッセージとイベント ベースの通信) などの非同期通信を使用してください。 これは、方法、 [eShopOnContainers](http://aka.ms/eshoponcontainers)参照アプリケーションは、この種類の更新プログラムを実行します。

説明したように、 [CAP 定理](https://en.wikipedia.org/wiki/CAP_theorem)、可用性または ACID の強力な一貫性を選択する必要があります。 マイクロ サービス ベースのほとんどのシナリオは、可用性と高スケーラビリティ強力な一貫性とは対照的に要求します。 ミッション クリティカルなアプリケーションを維持する必要があり、実行、および開発者できる回避強力な一貫性弱いまたは最終的整合性を操作するための手法を使用して、します。 これは、ほとんどのマイクロ サービス ベースのアーキテクチャで採用されているアプローチです。

さらに、ACID スタイルや 2 フェーズ コミット トランザクションではありません microservices 原則; に対してのみ(Azure Cosmos DB や MongoDB など) などのほとんどの NoSQL データベースは、2 フェーズ コミット トランザクションをサポートしていません。 ただし、データを維持するサービスとデータベース間の一貫性が不可欠です。 この課題が特定のデータが冗長である必要がある場合は、複数 microservices 間で変更を反映する方法についての質問に関連するも、製品の名前またはカタログ マイクロ サービスおよびバスケットで説明する必要がある場合など、マイクロ サービス。

この問題に適したソリューションでは、イベント ドリブンの通信およびパブリッシュとサブスクライブ システムを通じて表記 microservices 間最終的整合性を使用します。 これらのトピックのセクションで説明されて[イベント ドリブンの非同期通信](#async_event_driven_communication)このガイドで後述します。

## <a name="challenge-4-how-to-design-communication-across-microservice-boundaries"></a>チャレンジ\#4: マイクロ サービス境界を越えて通信を設計する方法

マイクロ サービス経由で通信する境界は、実際の課題です。 このコンテキストでは、通信を参照しない (HTTP および AMQP、メッセージング、およびために、残りの部分) を使用するプロトコルする必要があります。 代わりに、どのような通信のスタイルを使用する必要があり、どのように結合された、microservices べきでは対処します。 結合のレベルに応じて障害が発生したときにシステムにそのエラーの影響はさまざまです。

Microservices に基づくアプリケーション、非常に多くのアイテムを移動して多くのサーバーまたはホスト間での分散サービスのように、分散システムのコンポーネントは最終的に失敗します。 部分的な障害とより大きな停止が発生、考慮に入れて、リスク一般的な分散システムのこの型の間で、microservices との通信を設計する必要があるようにします。

一般的な方法は、HTTP (REST) を実装する-microservices、その簡潔さのためのベースします。 HTTP ベースのアプローチがまったく問題ありません。ここでの問題を使用する方法に関連するとします。 クライアント アプリケーションまたは API ゲートウェイから、microservices との対話に HTTP 要求と応答を使用する場合でもよいのです。 Microservices にわたって同期の HTTP 呼び出しの長いチェーンを作成する場合場合と同様、microservices モノリシックのアプリケーション内のオブジェクトの境界を越えて通信、アプリケーションが最終的に問題がします。

たとえば、クライアント アプリケーションが順序付けマイクロ サービスのように個々 のマイクロ サービスへの HTTP API 呼び出しを行うことを想像してください。 順序付けマイクロ サービスを呼び出して追加 microservices HTTP を使用して同じ要求/応答のサイクル、HTTP 呼び出しのチェーンを作成します。 思う妥当な初期状態です。 ただし、このパスを移動するときに考慮する重要な点があります。

-   ブロッキングと低パフォーマンス。 同期の特性により、HTTP、元の要求は応答を受信しなかった内部のすべての HTTP 呼び出しを完了するまでです。 これらの呼び出しの数が大幅に増加し、同時に、マイクロ サービスを呼び出す中級者向けの HTTP のいずれかがブロックされているかどうかを想像してください。 パフォーマンスが影響を与えるし、全体的なスケーラビリティは指数関数的に影響を受けるその他の HTTP 要求の増加としてことになります。

-   HTTP と microservices を結合します。 その他のビジネス microservices と、ビジネス microservices を組み合わせるいない必要があります。 理想的には、する必要があります「認識」しないその他の microservices の存在についてです。 場合は、アプリケーションでは、結合、例のように microservices 依存として、マイクロ サービスごとの自律性を実現するされないこともほぼ不可能です。

-   任意の 1 つのマイクロ サービスで失敗しました。 Microservices のチェーン全体を microservices のいずれかが失敗した (および最終的にそれらが失敗する) ときに、HTTP 呼び出しによってリンクされている microservices のチェーンを実装している場合は失敗します。 マイクロ サービス ベースのシステムは、引き続き部分的な障害中に、できるだけ効率よく機能を設計する必要があります。 指数バックオフまたは遮断器のメカニズムを持つ再試行を使用するクライアント ロジックを実装する場合でも複数の複雑な HTTP 呼び出しチェーンは、HTTP に基づいてエラー戦略を実装して、操作が複雑です。

実際には、説明に従って、HTTP 要求のチェーンを作成することでは、内部、microservices が通信している場合、でしたになるとプロセス内の通信メカニズムではなくプロセス間で HTTP に基づく 1 つ以外は、単体のアプリケーションがあります。

したがって、マイクロ サービスの自律性を適用し、回復性の向上がある、ためには最小限に要求/応答通信のチェーンの使用 microservices 全体です。 非同期メッセージおよびイベント ベースの通信を使用するか、元の HTTP 要求/応答のサイクルとは無関係に HTTP ポーリングを使用して、マイクロ サービス間の通信にのみ非同期操作を使用することをお勧めします。

非同期通信の使用が追加の詳細情報のセクションでは、このガイドの後半で説明されている[非同期マイクロ サービスの統合がマイクロ サービスの自律性を強制](#asynchronous-microservice-integration-enforce-microservices-autonomy)と[非同期メッセージ ベースの通信](#asynchronous-message-based-communication)です。

## <a name="additional-resources"></a>その他の技術情報

-   **キャップの定理**
    [*https://en.wikipedia.org/wiki/CAP\_定理*](https://en.wikipedia.org/wiki/CAP_theorem)

-   **最終的整合性**
    [*https://en.wikipedia.org/wiki/Eventual\_整合性*](https://en.wikipedia.org/wiki/Eventual_consistency)

-   **データ整合性の入門**
    [*https://msdn.microsoft.com/library/dn589800.aspx*](https://msdn.microsoft.com/library/dn589800.aspx)

-   **Martin Fowler。(コマンドおよびクエリの役割の分離) CQRS**
    [*http://martinfowler.com/bliki/CQRS.html*](http://martinfowler.com/bliki/CQRS.html)

-   **ビューを具現化**
    [*https://docs.microsoft.com/azure/architecture/patterns/materialized-view*](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)

-   **Charles 行です。ACID vs です。ベース: データベース トランザクションの処理の Shifting pH**
    [*http://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing/*](http://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing/)

-   **トランザクションを補正**
    [*https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction*](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction)

-   **Udi Dahan です。サービス指向のコンポジション**
    [*http://udidahan.com/2014/07/30/service-oriented-composition-with-video/*](http://udidahan.com/2014/07/30/service-oriented-composition-with-video/)


>[!div class="step-by-step"]
[前](論理-ではなく、物理-architecture.md) [次へ] (識別-マイクロ サービスのドメインのモデルの boundaries.md)
