---
title: "分散データ管理に関する課題とソリューション"
description: "コンテナーの .NET アプリケーションの .NET Microservices アーキテクチャ |分散データ管理に関する課題とソリューション"
keywords: "Docker, マイクロサービス, ASP.NET, コンテナー"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: f961475b40c74bf448cff1aeae04ae4866360e52
ms.sourcegitcommit: c2e216692ef7576a213ae16af2377cd98d1a67fa
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/22/2017
---
# <a name="challenges-and-solutions-for-distributed-data-management"></a><span data-ttu-id="0f117-104">分散データ管理に関する課題とソリューション</span><span class="sxs-lookup"><span data-stu-id="0f117-104">Challenges and solutions for distributed data management</span></span>

## <a name="challenge-1-how-to-define-the-boundaries-of-each-microservice"></a><span data-ttu-id="0f117-105">チャレンジ\#1: 各マイクロ サービスの境界を定義する方法</span><span class="sxs-lookup"><span data-stu-id="0f117-105">Challenge \#1: How to define the boundaries of each microservice</span></span>

<span data-ttu-id="0f117-106">マイクロ サービスの境界を定義することは、すべてのユーザーが検出した最初のチャレンジでが考えられます。</span><span class="sxs-lookup"><span data-stu-id="0f117-106">Defining microservice boundaries is probably the first challenge anyone encounters.</span></span> <span data-ttu-id="0f117-107">各マイクロ サービスが、アプリケーションの一部であるが、各マイクロ サービスをすべての利点と、表示する課題自律的にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f117-107">Each microservice has to be a piece of your application and each microservice should be autonomous with all the benefits and challenges that it conveys.</span></span> <span data-ttu-id="0f117-108">しかし、これらの境界を特定する方法でしょうか。</span><span class="sxs-lookup"><span data-stu-id="0f117-108">But how do you identify those boundaries?</span></span>

<span data-ttu-id="0f117-109">最初に、アプリケーションの論理ドメイン モデルと関連するデータに重点を置く必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f117-109">First, you need to focus on the application’s logical domain models and related data.</span></span> <span data-ttu-id="0f117-110">データと同じアプリケーション内の異なるコンテキストの切り離されたアイランドを識別しようとする必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f117-110">You must try to identify decoupled islands of data and different contexts within the same application.</span></span> <span data-ttu-id="0f117-111">各コンテキストには、さまざまなビジネス言語 (さまざまなビジネス用語) 可能性があります。</span><span class="sxs-lookup"><span data-stu-id="0f117-111">Each context could have a different business language (different business terms).</span></span> <span data-ttu-id="0f117-112">コンテキストの定義し、は別に管理する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f117-112">The contexts should be defined and managed independently.</span></span> <span data-ttu-id="0f117-113">用語とそのさまざまなコンテキストで使用するエンティティと同様に、音の可能性がありますが、特定のコンテキストで 1 つのビジネスの概念に対してを使用する別のコンテキストで別の目的を検出でき、別の名前にもあるでしょう。</span><span class="sxs-lookup"><span data-stu-id="0f117-113">The terms and entities used in those different contexts might sound similar, but you might discover that in a particular context, a business concept with one is used for a different purpose in another context, and might even have a different name.</span></span> <span data-ttu-id="0f117-114">たとえば、ユーザー コンテキストでは、順序、購入者としてのコンテキストでは、CRM、お客様のコンテキストでは、id またはメンバーシップ、ユーザーとして参照できますなど。</span><span class="sxs-lookup"><span data-stu-id="0f117-114">For instance, a user can be referred as a user in the identity or membership context, as a customer in a CRM context, as a buyer in an ordering context, and so forth.</span></span>

<span data-ttu-id="0f117-115">各コンテキストが各ビジネス マイクロ サービスとその関連の境界を特定する方法には、複数のアプリケーション コンテキストを別のドメイン間の境界を識別する方法は、ドメイン モデルとデータ。</span><span class="sxs-lookup"><span data-stu-id="0f117-115">The way you identify boundaries between multiple application contexts with a different domain for each context is exactly how you can identify the boundaries for each business microservice and its related domain model and data.</span></span> <span data-ttu-id="0f117-116">常にしようとするそれら microservices 間の結合を最小化します。</span><span class="sxs-lookup"><span data-stu-id="0f117-116">You always attempt to minimize the coupling between those microservices.</span></span> <span data-ttu-id="0f117-117">このガイドは、セクションでこの id とドメインのモデル設計について詳細に説明が[各マイクロ サービスのドメイン モデルの境界を識別する](#identifying-domain-model-boundaries-for-each-microservice)以降。</span><span class="sxs-lookup"><span data-stu-id="0f117-117">This guide goes into more detail about this identification and domain model design in the section [Identifying domain-model boundaries for each microservice](#identifying-domain-model-boundaries-for-each-microservice) later.</span></span>

## <a name="challenge-2-how-to-create-queries-that-retrieve-data-from-several-microservices"></a><span data-ttu-id="0f117-118">チャレンジ\#2: いくつかの microservices からデータを取得するクエリを作成する方法</span><span class="sxs-lookup"><span data-stu-id="0f117-118">Challenge \#2: How to create queries that retrieve data from several microservices</span></span>

<span data-ttu-id="0f117-119">2 番目の課題は、リモート クライアント アプリケーションから、microservices に chatty な通信を回避しながら、いくつかの microservices からデータを取得するクエリを実装する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="0f117-119">A second challenge is how to implement queries that retrieve data from several microservices, while avoiding chatty communication to the microservices from remote client apps.</span></span> <span data-ttu-id="0f117-120">バスケット、カタログ、およびユーザーの id microservices によって所有されているユーザー情報を表示する必要があるモバイル アプリからの 1 つの画面の例があります。</span><span class="sxs-lookup"><span data-stu-id="0f117-120">An example could be a single screen from a mobile app that needs to show user information that is owned by the basket, catalog, and user identity microservices.</span></span> <span data-ttu-id="0f117-121">別の例には、複数の microservices にある多数のテーブルに関連する複雑なレポートがあります。</span><span class="sxs-lookup"><span data-stu-id="0f117-121">Another example would be a complex report involving many tables located in multiple microservices.</span></span> <span data-ttu-id="0f117-122">最適なソリューションは、クエリの複雑さによって異なります。</span><span class="sxs-lookup"><span data-stu-id="0f117-122">The right solution depends on the complexity of the queries.</span></span> <span data-ttu-id="0f117-123">いずれの場合は必要しますが、あります情報を集計する方法をシステムの通信の効率を向上する場合。</span><span class="sxs-lookup"><span data-stu-id="0f117-123">But in any case, you will need a way to aggregate information if you want to improve the efficiency in the communications of your system.</span></span> <span data-ttu-id="0f117-124">最も一般的なソリューションは次のです。</span><span class="sxs-lookup"><span data-stu-id="0f117-124">The most popular solutions are the following.</span></span>

<span data-ttu-id="0f117-125">**API ゲートウェイ**です。</span><span class="sxs-lookup"><span data-stu-id="0f117-125">**API Gateway**.</span></span> <span data-ttu-id="0f117-126">異なるデータベースを所有する複数の microservices から単純なデータの集計、推奨される方法は、API ゲートウェイと呼ばれる、集計マイクロ サービスです。</span><span class="sxs-lookup"><span data-stu-id="0f117-126">For simple data aggregation from multiple microservices that own different databases, the recommended approach is an aggregation microservice referred to as an API Gateway.</span></span> <span data-ttu-id="0f117-127">ただし、システムで、チョーク ポイントであることができます、マイクロ サービスの自律性の原則に違反することができますが、このパターンの実装について注意する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f117-127">However, you need to be careful about implementing this pattern, because it can be a choke point in your system, and it can violate the principle of microservice autonomy.</span></span> <span data-ttu-id="0f117-128">この可能性を軽減するためにはそれぞれ 1 つに焦点を当てた垂直"、スライス"またはシステムのビジネス領域罰金粒度の複数の API ゲートウェイができます。</span><span class="sxs-lookup"><span data-stu-id="0f117-128">To mitigate this possibility, you can have multiple fined-grained API Gateways each one focusing on a vertical “slice” or business area of the system.</span></span> <span data-ttu-id="0f117-129">API ゲートウェイ パターンが使用方法のセクションで詳しく説明されている API ゲートウェイを後でします。</span><span class="sxs-lookup"><span data-stu-id="0f117-129">The API Gateway pattern is explained in more detail in the section in the Using an API Gateway later.</span></span>

<span data-ttu-id="0f117-130">**クエリの読み取り/テーブルでの CQRS**です。</span><span class="sxs-lookup"><span data-stu-id="0f117-130">**CQRS with query/reads tables**.</span></span> <span data-ttu-id="0f117-131">複数の microservices からデータを集計するための別のソリューションが、[ビューの具体化パターン](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)です。</span><span class="sxs-lookup"><span data-stu-id="0f117-131">Another solution for aggregating data from multiple microservices is the [Materialized View pattern](https://docs.microsoft.com/azure/architecture/patterns/materialized-view).</span></span> <span data-ttu-id="0f117-132">この方法で生成する、事前に (実際のクエリでは、発生する前に正規化されていないデータを準備する、) 複数 microservices によって所有されているデータを含む読み取り専用テーブル。</span><span class="sxs-lookup"><span data-stu-id="0f117-132">In this approach, you generate, in advance (prepare denormalized data before the actual queries happen), a read-only table with the data that is owned by multiple microservices.</span></span> <span data-ttu-id="0f117-133">テーブルには、クライアント アプリケーションのニーズに合った形式があります。</span><span class="sxs-lookup"><span data-stu-id="0f117-133">The table has a format suited to the client app’s needs.</span></span>

<span data-ttu-id="0f117-134">モバイル アプリの画面のようなものを検討してください。</span><span class="sxs-lookup"><span data-stu-id="0f117-134">Consider something like the screen for a mobile app.</span></span> <span data-ttu-id="0f117-135">1 つのデータベースがある場合は、可能性がありますをプルする同時に複数のテーブルに関連する複雑な結合を実行する SQL クエリを使用して、その画面のデータ。</span><span class="sxs-lookup"><span data-stu-id="0f117-135">If you have a single database, you might pull together the data for that screen using a SQL query that performs a complex join involving multiple tables.</span></span> <span data-ttu-id="0f117-136">複数のデータベースがあり、各データベースが異なるマイクロ サービスによって所有されているときにそれらのデータベースのクエリし、SQL 結合を作成できません。</span><span class="sxs-lookup"><span data-stu-id="0f117-136">However, when you have multiple databases, and each database is owned by a different microservice, you cannot query those databases and create a SQL join.</span></span> <span data-ttu-id="0f117-137">複雑なクエリでは、困難になります。</span><span class="sxs-lookup"><span data-stu-id="0f117-137">Your complex query becomes a challenge.</span></span> <span data-ttu-id="0f117-138">CQRS アプローチを使用して、要件に対処することができます: クエリにのみ使用する別のデータベースで非正規化されたテーブルを作成します。</span><span class="sxs-lookup"><span data-stu-id="0f117-138">You can address the requirement using a CQRS approach—you create a denormalized table in a different database that is used just for queries.</span></span> <span data-ttu-id="0f117-139">具体的には、アプリケーションの画面およびクエリのテーブルの列で必要なフィールド間の一対一のリレーションシップを使用して、複雑なクエリの必要なデータのテーブルを設計できます。</span><span class="sxs-lookup"><span data-stu-id="0f117-139">The table can be designed specifically for the data you need for the complex query, with a one-to-one relationship between fields needed by your application’s screen and the columns in the query table.</span></span> <span data-ttu-id="0f117-140">レポートのため、しまう可能性もあります。</span><span class="sxs-lookup"><span data-stu-id="0f117-140">It could also serve for reporting purposes.</span></span>

<span data-ttu-id="0f117-141">このアプローチはだけでなく (クエリおよび microservices 間で結合する方法); 元の問題を解決します。クエリ テーブルに、アプリケーションに必要なデータが既にあるために、複雑な結合と比較した場合に非常にパフォーマンスも向上します。</span><span class="sxs-lookup"><span data-stu-id="0f117-141">This approach not only solves the original problem (how to query and join across microservices); it also improves performance considerably when compared with a complex join, because you already have the data that the application needs in the query table.</span></span> <span data-ttu-id="0f117-142">もちろん、追加の開発作業をクエリ/読み取りテーブル コマンドと Query Responsibility Segregation (CQRS) を使用することを意味し、最終的整合性を採用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f117-142">Of course, using Command and Query Responsibility Segregation (CQRS) with query/reads tables means additional development work, and you will need to embrace eventual consistency.</span></span> <span data-ttu-id="0f117-143">ただし、パフォーマンスと高スケーラビリティの要件[コラボレーションのシナリオ](http://udidahan.com/2011/10/02/why-you-should-be-using-cqrs-almost-everywhere/)(またはの観点に応じて、競合するシナリオ) は、複数のデータベースでの CQRS を適用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f117-143">Nonetheless, requirements on performance and high scalability in [collaborative scenarios](http://udidahan.com/2011/10/02/why-you-should-be-using-cqrs-almost-everywhere/) (or competitive scenarios, depending on the point of view) is where you should apply CQRS with multiple databases.</span></span>

<span data-ttu-id="0f117-144">**中央のデータベース内の「コールド データ」**です。</span><span class="sxs-lookup"><span data-stu-id="0f117-144">**“Cold data” in central databases**.</span></span> <span data-ttu-id="0f117-145">複雑なレポートとリアルタイムのデータを必要としない場合のクエリでは、一般的な方法は、ホット データ"をエクスポートするのには (、microservices からトランザクション データ) レポート用のみに使用されている大規模なデータベースに「コールド データ」です。</span><span class="sxs-lookup"><span data-stu-id="0f117-145">For complex reports and queries that might not require real-time data, a common approach is to export your “hot data” (transactional data from the microservices) as “cold data” into large databases that are used only for reporting.</span></span> <span data-ttu-id="0f117-146">中央のデータベース システムでは、Hadoop、Azure SQL Data Warehouse、または (サイズには、問題はされない) 場合は、レポートにのみ使用される単一 SQL データベースでもに基づくいずれかのように、データ ウェアハウスなどの大規模なデータに基づくシステムを指定できます。</span><span class="sxs-lookup"><span data-stu-id="0f117-146">That central database system can be a Big Data-based system, like Hadoop, a data warehouse like one based on Azure SQL Data Warehouse, or even a single SQL database used just for reports (if size will not be an issue).</span></span>

<span data-ttu-id="0f117-147">クエリおよびリアルタイムのデータを必要としないレポートに対してのみこの一元化されたデータベースを使用することに注意してください。</span><span class="sxs-lookup"><span data-stu-id="0f117-147">Keep in mind that this centralized database would be used only for queries and reports that do not need real-time data.</span></span> <span data-ttu-id="0f117-148">元の更新プログラムと、実際のソースとしてのトランザクションは、microservices データにする必要です。</span><span class="sxs-lookup"><span data-stu-id="0f117-148">The original updates and transactions, as your source of truth, have to be in your microservices data.</span></span> <span data-ttu-id="0f117-149">イベント ドリブンの通信 (次のセクションで説明) を使用して、またはその他のデータベース インフラストラクチャのインポート/エクスポート ツールを使用してデータを同期するようになります。</span><span class="sxs-lookup"><span data-stu-id="0f117-149">The way you would synchronize data would be either by using event-driven communication (covered in the next sections) or by using other database infrastructure import/export tools.</span></span> <span data-ttu-id="0f117-150">イベント ドリブンの通信を使用する場合、その統合プロセスは CQRS テーブルをクエリの前述のようにデータを伝達するのと同様になります。</span><span class="sxs-lookup"><span data-stu-id="0f117-150">If you use event-driven communication, that integration process would be similar to the way you propagate data as described earlier for CQRS query tables.</span></span>

<span data-ttu-id="0f117-151">ただし、アプリケーションの設計には、複数の microservices 複雑なクエリからの情報を常に集計が含まれている場合がありますの不適切なデザインの症状に —、マイクロ サービスを他の microservices からできるだけに分離する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f117-151">However, if your application design involves constantly aggregating information from multiple microservices for complex queries, it might be a symptom of a bad design—a microservice should be as isolated as possible from other microservices.</span></span> <span data-ttu-id="0f117-152">(コールド データの中央データベースが常に使用するレポートと分析は除く)。多くの場合、この問題が発生すると、microservices をマージするための可能性があります。</span><span class="sxs-lookup"><span data-stu-id="0f117-152">(This excludes reports/analytics that always should use cold-data central databases.) Having this problem often might be a reason to merge microservices.</span></span> <span data-ttu-id="0f117-153">展開の自主性と厳密な依存性、凝集度、およびデータの集計で各マイクロ サービスの展開のバランスをとる必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f117-153">You need to balance the autonomy of evolution and deployment of each microservice with strong dependencies, cohesion, and data aggregation.</span></span>

## <a name="challenge-3-how-to-achieve-consistency-across-multiple-microservices"></a><span data-ttu-id="0f117-154">チャレンジ\#3: 複数 microservices 全体で一貫性を実現する方法</span><span class="sxs-lookup"><span data-stu-id="0f117-154">Challenge \#3: How to achieve consistency across multiple microservices</span></span>

<span data-ttu-id="0f117-155">前述のように、各マイクロ サービスが所有するデータはそのマイクロ サービスをプライベートおよびそのマイクロ サービス API を使用してのみアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="0f117-155">As stated previously, the data owned by each microservice is private to that microservice and can only be accessed using its microservice API.</span></span> <span data-ttu-id="0f117-156">そのため、表示されるチャレンジは、複数 microservices 全体で一貫性を維持しながら、エンド ツー エンドのビジネス プロセスを実装する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="0f117-156">Therefore, a challenge presented is how to implement end-to-end business processes while keeping consistency across multiple microservices.</span></span>

<span data-ttu-id="0f117-157">この問題を分析する例を見てみましょうから、 [eShopOnContainers 参照アプリケーション](http://aka.ms/eshoponcontainers)です。</span><span class="sxs-lookup"><span data-stu-id="0f117-157">To analyze this problem, let’s look at an example from the [eShopOnContainers reference application](http://aka.ms/eshoponcontainers).</span></span> <span data-ttu-id="0f117-158">カタログ マイクロ サービスは、株価のレベルを含むすべての製品に関する情報を保持します。</span><span class="sxs-lookup"><span data-stu-id="0f117-158">The Catalog microservice maintains information about all the products, including their stock level.</span></span> <span data-ttu-id="0f117-159">順序付けマイクロ サービスは、注文を管理し、新しい注文が利用可能なカタログの製品の在庫を超えていないことを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f117-159">The Ordering microservice manages orders and must verify that a new order does not exceed the available catalog product stock.</span></span> <span data-ttu-id="0f117-160">(または、シナリオには、在庫のある製品を処理するロジックが含まれます)。仮定モノリシックなバージョンのこのアプリケーションでは、順序サブシステムでしただけで使用 ACID トランザクションを使用可能な在庫を確認して、Orders テーブルに注文を作成および更新、Products テーブル内の利用可能なストックです。</span><span class="sxs-lookup"><span data-stu-id="0f117-160">(Or the scenario might involve logic that handles backordered products.) In a hypothetical monolithic version of this application, the ordering subsystem could simply use an ACID transaction to check the available stock, create the order in the Orders table, and update the available stock in the Products table.</span></span>

<span data-ttu-id="0f117-161">ただし、microservices ベースのアプリケーションでは、注文および製品のテーブルは、それぞれ microservices によって所有されます。</span><span class="sxs-lookup"><span data-stu-id="0f117-161">However, in a microservices- based application, the Order and Product tables are owned by their respective microservices.</span></span> <span data-ttu-id="0f117-162">マイクロ サービス含める必要がありますれたなしで、独自のトランザクションまたはクエリを別のマイクロ サービスを所有するデータベース図 4-9 に示すようにします。</span><span class="sxs-lookup"><span data-stu-id="0f117-162">No microservice should ever include databases owned by another microservice in its own transactions or queries, as shown in Figure 4-9.</span></span>

![](./media/image9.PNG)

<span data-ttu-id="0f117-163">**図 4. ~ 9.**です。</span><span class="sxs-lookup"><span data-stu-id="0f117-163">**Figure 4-9**.</span></span> <span data-ttu-id="0f117-164">マイクロ サービスは、別のマイクロ サービス内のテーブルに直接アクセスできません。</span><span class="sxs-lookup"><span data-stu-id="0f117-164">A microservice cannot directly access a table in another microservice</span></span>

<span data-ttu-id="0f117-165">順序付けマイクロ サービスする必要がありますテーブルを更新できません製品を直接、Products テーブルは、カタログ マイクロ サービスによって所有されているためです。</span><span class="sxs-lookup"><span data-stu-id="0f117-165">The Ordering microservice should not update the Products table directly, because the Products table is owned by the Catalog microservice.</span></span> <span data-ttu-id="0f117-166">カタログ マイクロ サービスを更新するには、その順序マイクロ サービスはだけ統合イベント (メッセージとイベント ベースの通信) などの非同期通信を使用してください。</span><span class="sxs-lookup"><span data-stu-id="0f117-166">To make an update to the Catalog microservice, the Ordering microservice should only ever use asynchronous communication such as integration events (message and event-based communication).</span></span> <span data-ttu-id="0f117-167">これは、方法、 [eShopOnContainers](http://aka.ms/eshoponcontainers)参照アプリケーションは、この種類の更新プログラムを実行します。</span><span class="sxs-lookup"><span data-stu-id="0f117-167">This is how the [eShopOnContainers](http://aka.ms/eshoponcontainers) reference application performs this type of update.</span></span>

<span data-ttu-id="0f117-168">説明したように、 [CAP 定理](https://en.wikipedia.org/wiki/CAP_theorem)、可用性または ACID の強力な一貫性を選択する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f117-168">As stated by the [CAP theorem](https://en.wikipedia.org/wiki/CAP_theorem), you need to choose between availability and ACID strong consistency.</span></span> <span data-ttu-id="0f117-169">マイクロ サービス ベースのほとんどのシナリオは、可用性と高スケーラビリティ強力な一貫性とは対照的に要求します。</span><span class="sxs-lookup"><span data-stu-id="0f117-169">Most microservice-based scenarios demand availability and high scalability as opposed to strong consistency.</span></span> <span data-ttu-id="0f117-170">ミッション クリティカルなアプリケーションを維持する必要があり、実行、および開発者できる回避強力な一貫性弱いまたは最終的整合性を操作するための手法を使用して、します。</span><span class="sxs-lookup"><span data-stu-id="0f117-170">Mission-critical applications must remain up and running, and developers can work around strong consistency by using techniques for working with weak or eventual consistency.</span></span> <span data-ttu-id="0f117-171">これは、ほとんどのマイクロ サービス ベースのアーキテクチャで採用されているアプローチです。</span><span class="sxs-lookup"><span data-stu-id="0f117-171">This is the approach taken by most microservice-based architectures.</span></span>

<span data-ttu-id="0f117-172">さらに、ACID スタイルや 2 フェーズ コミット トランザクションではありません microservices 原則; に対してのみ(Azure Cosmos DB や MongoDB など) などのほとんどの NoSQL データベースは、2 フェーズ コミット トランザクションをサポートしていません。</span><span class="sxs-lookup"><span data-stu-id="0f117-172">Moreover, ACID-style or two-phase commit transactions are not just against microservices principles; most NoSQL databases (like Azure Cosmos DB, MongoDB, etc.) do not support two-phase commit transactions.</span></span> <span data-ttu-id="0f117-173">ただし、データを維持するサービスとデータベース間の一貫性が不可欠です。</span><span class="sxs-lookup"><span data-stu-id="0f117-173">However, maintaining data consistency across services and databases is essential.</span></span> <span data-ttu-id="0f117-174">この課題が特定のデータが冗長である必要がある場合は、複数 microservices 間で変更を反映する方法についての質問に関連するも、製品の名前またはカタログ マイクロ サービスおよびバスケットで説明する必要がある場合など、マイクロ サービス。</span><span class="sxs-lookup"><span data-stu-id="0f117-174">This challenge is also related to the question of how to propagate changes across multiple microservices when certain data needs to be redundant—for example, when you need to have the product’s name or description in the Catalog microservice and the Basket microservice.</span></span>

<span data-ttu-id="0f117-175">この問題に適したソリューションでは、イベント ドリブンの通信およびパブリッシュとサブスクライブ システムを通じて表記 microservices 間最終的整合性を使用します。</span><span class="sxs-lookup"><span data-stu-id="0f117-175">A good solution for this problem is to use eventual consistency between microservices articulated through event-driven communication and a publish-and-subscribe system.</span></span> <span data-ttu-id="0f117-176">これらのトピックのセクションで説明されて[イベント ドリブンの非同期通信](#async_event_driven_communication)このガイドで後述します。</span><span class="sxs-lookup"><span data-stu-id="0f117-176">These topics are covered in the section [Asynchronous event-driven communication](#async_event_driven_communication) later in this guide.</span></span>

## <a name="challenge-4-how-to-design-communication-across-microservice-boundaries"></a><span data-ttu-id="0f117-177">チャレンジ\#4: マイクロ サービス境界を越えて通信を設計する方法</span><span class="sxs-lookup"><span data-stu-id="0f117-177">Challenge \#4: How to design communication across microservice boundaries</span></span>

<span data-ttu-id="0f117-178">マイクロ サービス経由で通信する境界は、実際の課題です。</span><span class="sxs-lookup"><span data-stu-id="0f117-178">Communicating across microservice boundaries is a real challenge.</span></span> <span data-ttu-id="0f117-179">このコンテキストでは、通信を参照しない (HTTP および AMQP、メッセージング、およびために、残りの部分) を使用するプロトコルする必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f117-179">In this context, communication does not refer to what protocol you should use (HTTP and REST, AMQP, messaging, and so on).</span></span> <span data-ttu-id="0f117-180">代わりに、どのような通信のスタイルを使用する必要があり、どのように結合された、microservices べきでは対処します。</span><span class="sxs-lookup"><span data-stu-id="0f117-180">Instead, it addresses what communication style you should use, and especially how coupled your microservices should be.</span></span> <span data-ttu-id="0f117-181">結合のレベルに応じて障害が発生したときにシステムにそのエラーの影響はさまざまです。</span><span class="sxs-lookup"><span data-stu-id="0f117-181">Depending on the level of coupling, when failure occurs, the impact of that failure on your system will vary significantly.</span></span>

<span data-ttu-id="0f117-182">Microservices に基づくアプリケーション、非常に多くのアイテムを移動して多くのサーバーまたはホスト間での分散サービスのように、分散システムのコンポーネントは最終的に失敗します。</span><span class="sxs-lookup"><span data-stu-id="0f117-182">In a distributed system like a microservices-based application, with so many artifacts moving around and with distributed services across many servers or hosts, components will eventually fail.</span></span> <span data-ttu-id="0f117-183">部分的な障害とより大きな停止が発生、考慮に入れて、リスク一般的な分散システムのこの型の間で、microservices との通信を設計する必要があるようにします。</span><span class="sxs-lookup"><span data-stu-id="0f117-183">Partial failure and even larger outages will occur, so you need to design your microservices and the communication across them taking into account the risks common in this type of distributed system.</span></span>

<span data-ttu-id="0f117-184">一般的な方法は、HTTP (REST) を実装する-microservices、その簡潔さのためのベースします。</span><span class="sxs-lookup"><span data-stu-id="0f117-184">A popular approach is to implement HTTP (REST)- based microservices, due to their simplicity.</span></span> <span data-ttu-id="0f117-185">HTTP ベースのアプローチがまったく問題ありません。ここでの問題を使用する方法に関連するとします。</span><span class="sxs-lookup"><span data-stu-id="0f117-185">An HTTP-based approach is perfectly acceptable; the issue here is related to how you use it.</span></span> <span data-ttu-id="0f117-186">クライアント アプリケーションまたは API ゲートウェイから、microservices との対話に HTTP 要求と応答を使用する場合でもよいのです。</span><span class="sxs-lookup"><span data-stu-id="0f117-186">If you use HTTP requests and responses just to interact with your microservices from client applications or from API Gateways, that is fine.</span></span> <span data-ttu-id="0f117-187">Microservices にわたって同期の HTTP 呼び出しの長いチェーンを作成する場合場合と同様、microservices モノリシックのアプリケーション内のオブジェクトの境界を越えて通信、アプリケーションが最終的に問題がします。</span><span class="sxs-lookup"><span data-stu-id="0f117-187">But if you create long chains of synchronous HTTP calls across microservices, communicating across their boundaries as if the microservices were objects in a monolithic application, your application will eventually run into problems.</span></span>

<span data-ttu-id="0f117-188">たとえば、クライアント アプリケーションが順序付けマイクロ サービスのように個々 のマイクロ サービスへの HTTP API 呼び出しを行うことを想像してください。</span><span class="sxs-lookup"><span data-stu-id="0f117-188">For instance, imagine that your client application makes an HTTP API call to an individual microservice like the Ordering microservice.</span></span> <span data-ttu-id="0f117-189">順序付けマイクロ サービスを呼び出して追加 microservices HTTP を使用して同じ要求/応答のサイクル、HTTP 呼び出しのチェーンを作成します。</span><span class="sxs-lookup"><span data-stu-id="0f117-189">If the Ordering microservice in turn calls additional microservices using HTTP within the same request/response cycle, you are creating a chain of HTTP calls.</span></span> <span data-ttu-id="0f117-190">思う妥当な初期状態です。</span><span class="sxs-lookup"><span data-stu-id="0f117-190">It might sound reasonable initially.</span></span> <span data-ttu-id="0f117-191">ただし、このパスを移動するときに考慮する重要な点があります。</span><span class="sxs-lookup"><span data-stu-id="0f117-191">However, there are important points to consider when going down this path:</span></span>

-   <span data-ttu-id="0f117-192">ブロッキングと低パフォーマンス。</span><span class="sxs-lookup"><span data-stu-id="0f117-192">Blocking and low performance.</span></span> <span data-ttu-id="0f117-193">同期の特性により、HTTP、元の要求は応答を受信しなかった内部のすべての HTTP 呼び出しを完了するまでです。</span><span class="sxs-lookup"><span data-stu-id="0f117-193">Due to the synchronous nature of HTTP, the original request will not get a response until all the internal HTTP calls are finished.</span></span> <span data-ttu-id="0f117-194">これらの呼び出しの数が大幅に増加し、同時に、マイクロ サービスを呼び出す中級者向けの HTTP のいずれかがブロックされているかどうかを想像してください。</span><span class="sxs-lookup"><span data-stu-id="0f117-194">Imagine if the number of these calls increases significantly and at the same time one of the intermediate HTTP calls to a microservice is blocked.</span></span> <span data-ttu-id="0f117-195">パフォーマンスが影響を与えるし、全体的なスケーラビリティは指数関数的に影響を受けるその他の HTTP 要求の増加としてことになります。</span><span class="sxs-lookup"><span data-stu-id="0f117-195">The result is that performance is impacted, and the overall scalability will be exponentially affected as additional HTTP requests increase.</span></span>

-   <span data-ttu-id="0f117-196">HTTP と microservices を結合します。</span><span class="sxs-lookup"><span data-stu-id="0f117-196">Coupling microservices with HTTP.</span></span> <span data-ttu-id="0f117-197">その他のビジネス microservices と、ビジネス microservices を組み合わせるいない必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f117-197">Business microservices should not be coupled with other business microservices.</span></span> <span data-ttu-id="0f117-198">理想的には、する必要があります「認識」しないその他の microservices の存在についてです。</span><span class="sxs-lookup"><span data-stu-id="0f117-198">Ideally, they should not “know” about the existence of other microservices.</span></span> <span data-ttu-id="0f117-199">場合は、アプリケーションでは、結合、例のように microservices 依存として、マイクロ サービスごとの自律性を実現するされないこともほぼ不可能です。</span><span class="sxs-lookup"><span data-stu-id="0f117-199">If your application relies on coupling microservices as in the example, achieving autonomy per microservice will be almost impossible.</span></span>

-   <span data-ttu-id="0f117-200">任意の 1 つのマイクロ サービスで失敗しました。</span><span class="sxs-lookup"><span data-stu-id="0f117-200">Failure in any one microservice.</span></span> <span data-ttu-id="0f117-201">Microservices のチェーン全体を microservices のいずれかが失敗した (および最終的にそれらが失敗する) ときに、HTTP 呼び出しによってリンクされている microservices のチェーンを実装している場合は失敗します。</span><span class="sxs-lookup"><span data-stu-id="0f117-201">If you implemented a chain of microservices linked by HTTP calls, when any of the microservices fails (and eventually they will fail) the whole chain of microservices will fail.</span></span> <span data-ttu-id="0f117-202">マイクロ サービス ベースのシステムは、引き続き部分的な障害中に、できるだけ効率よく機能を設計する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f117-202">A microservice-based system should be designed to continue to work as well as possible during partial failures.</span></span> <span data-ttu-id="0f117-203">指数バックオフまたは遮断器のメカニズムを持つ再試行を使用するクライアント ロジックを実装する場合でも複数の複雑な HTTP 呼び出しチェーンは、HTTP に基づいてエラー戦略を実装して、操作が複雑です。</span><span class="sxs-lookup"><span data-stu-id="0f117-203">Even if you implement client logic that uses retries with exponential backoff or circuit breaker mechanisms, the more complex the HTTP call chains are, the more complex it is implement a failure strategy based on HTTP.</span></span>

<span data-ttu-id="0f117-204">実際には、説明に従って、HTTP 要求のチェーンを作成することでは、内部、microservices が通信している場合、でしたになるとプロセス内の通信メカニズムではなくプロセス間で HTTP に基づく 1 つ以外は、単体のアプリケーションがあります。</span><span class="sxs-lookup"><span data-stu-id="0f117-204">In fact, if your internal microservices are communicating by creating chains of HTTP requests as described, it could be argued that you have a monolithic application, but one based on HTTP between processes instead of intraprocess communication mechanisms.</span></span>

<span data-ttu-id="0f117-205">したがって、マイクロ サービスの自律性を適用し、回復性の向上がある、ためには最小限に要求/応答通信のチェーンの使用 microservices 全体です。</span><span class="sxs-lookup"><span data-stu-id="0f117-205">Therefore, in order to enforce microservice autonomy and have better resiliency, you should minimize the use of chains of request/response communication across microservices.</span></span> <span data-ttu-id="0f117-206">非同期メッセージおよびイベント ベースの通信を使用するか、元の HTTP 要求/応答のサイクルとは無関係に HTTP ポーリングを使用して、マイクロ サービス間の通信にのみ非同期操作を使用することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="0f117-206">It is recommended that you use only asynchronous interaction for inter-microservice communication, either by using asynchronous message- and event-based communication, or by using HTTP polling independently of the original HTTP request/response cycle.</span></span>

<span data-ttu-id="0f117-207">非同期通信の使用が追加の詳細情報のセクションでは、このガイドの後半で説明されている[非同期マイクロ サービスの統合がマイクロ サービスの自律性を強制](#asynchronous-microservice-integration-enforce-microservices-autonomy)と[非同期メッセージ ベースの通信](#asynchronous-message-based-communication)です。</span><span class="sxs-lookup"><span data-stu-id="0f117-207">The use of asynchronous communication is explained with additional details later in this guide in the sections [Asynchronous microservice integration enforces microservice’s autonomy](#asynchronous-microservice-integration-enforce-microservices-autonomy) and [Asynchronous message-based communication](#asynchronous-message-based-communication).</span></span>

## <a name="additional-resources"></a><span data-ttu-id="0f117-208">その他の技術情報</span><span class="sxs-lookup"><span data-stu-id="0f117-208">Additional resources</span></span>

-   <span data-ttu-id="0f117-209">**キャップの定理**
    [*https://en.wikipedia.org/wiki/CAP\_定理*](https://en.wikipedia.org/wiki/CAP_theorem)</span><span class="sxs-lookup"><span data-stu-id="0f117-209">**CAP theorem**
[*https://en.wikipedia.org/wiki/CAP\_theorem*](https://en.wikipedia.org/wiki/CAP_theorem)</span></span>

-   <span data-ttu-id="0f117-210">**最終的整合性**
    [*https://en.wikipedia.org/wiki/Eventual\_整合性*](https://en.wikipedia.org/wiki/Eventual_consistency)</span><span class="sxs-lookup"><span data-stu-id="0f117-210">**Eventual consistency**
[*https://en.wikipedia.org/wiki/Eventual\_consistency*](https://en.wikipedia.org/wiki/Eventual_consistency)</span></span>

-   <span data-ttu-id="0f117-211">**データ整合性の入門**
    [*https://msdn.microsoft.com/library/dn589800.aspx*](https://msdn.microsoft.com/library/dn589800.aspx)</span><span class="sxs-lookup"><span data-stu-id="0f117-211">**Data Consistency Primer**
[*https://msdn.microsoft.com/library/dn589800.aspx*](https://msdn.microsoft.com/library/dn589800.aspx)</span></span>

-   <span data-ttu-id="0f117-212">**Martin Fowler。(コマンドおよびクエリの役割の分離) CQRS**
    [*http://martinfowler.com/bliki/CQRS.html*](http://martinfowler.com/bliki/CQRS.html)</span><span class="sxs-lookup"><span data-stu-id="0f117-212">**Martin Fowler. CQRS (Command and Query Responsibility Segregation)**
[*http://martinfowler.com/bliki/CQRS.html*](http://martinfowler.com/bliki/CQRS.html)</span></span>

-   <span data-ttu-id="0f117-213">**ビューを具現化**
    [*https://docs.microsoft.com/azure/architecture/patterns/materialized-view*](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)</span><span class="sxs-lookup"><span data-stu-id="0f117-213">**Materialized View**
[*https://docs.microsoft.com/azure/architecture/patterns/materialized-view*](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)</span></span>

-   <span data-ttu-id="0f117-214">**Charles 行です。ACID vs です。ベース: データベース トランザクションの処理の Shifting pH**
    [*http://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing/*](http://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing/)</span><span class="sxs-lookup"><span data-stu-id="0f117-214">**Charles Row. ACID vs. BASE: The Shifting pH of Database Transaction Processing**
[*http://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing/*](http://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing/)</span></span>

-   <span data-ttu-id="0f117-215">**トランザクションを補正**
    [*https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction*](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction)</span><span class="sxs-lookup"><span data-stu-id="0f117-215">**Compensating Transaction**
[*https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction*](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction)</span></span>

-   <span data-ttu-id="0f117-216">**Udi Dahan です。サービス指向のコンポジション**
    [*http://udidahan.com/2014/07/30/service-oriented-composition-with-video/*](http://udidahan.com/2014/07/30/service-oriented-composition-with-video/)</span><span class="sxs-lookup"><span data-stu-id="0f117-216">**Udi Dahan. Service Oriented Composition**
[*http://udidahan.com/2014/07/30/service-oriented-composition-with-video/*](http://udidahan.com/2014/07/30/service-oriented-composition-with-video/)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="0f117-217">[前](論理-ではなく、物理-architecture.md) [次へ] (識別-マイクロ サービスのドメインのモデルの boundaries.md)</span><span class="sxs-lookup"><span data-stu-id="0f117-217">[Previous] (logical-versus-physical-architecture.md) [Next] (identify-microservice-domain-model-boundaries.md)</span></span>
