---
title: クライアントからマイクロサービスへの直接通信に対する API ゲートウェイ パターン
description: コンテナー化された .NET アプリケーションの .NET マイクロサービス アーキテクチャ | クライアントからマイクロサービスへの直接通信に対する API ゲートウェイ パターン
keywords: Docker, マイクロサービス, ASP.NET, コンテナー, API ゲートウェイ
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 10/18/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: fa3f4bb97cf942ee7698b1efa1dcd09b3f2ca571
ms.sourcegitcommit: 2e8acae16ae802f2d6d04e3ce0a6dbf04e476513
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/18/2018
---
# <a name="direct-client-to-microservice-communication-versus-the-api-gateway-pattern"></a><span data-ttu-id="dc97a-104">クライアントからマイクロサービスへの直接通信に対する API ゲートウェイ パターン</span><span class="sxs-lookup"><span data-stu-id="dc97a-104">Direct client-to-microservice communication versus the API Gateway pattern</span></span>

<span data-ttu-id="dc97a-105">マイクロサービス アーキテクチャでは、各マイクロサービスは (通常) 細かいエンドポイントのセットを公開します。</span><span class="sxs-lookup"><span data-stu-id="dc97a-105">In a microservices architecture, each microservice exposes a set of (typically) fine‑grained endpoints.</span></span> <span data-ttu-id="dc97a-106">このセクションの説明のとおり、このことがクライアントからマイクロサービスへの通信に影響する場合があります。</span><span class="sxs-lookup"><span data-stu-id="dc97a-106">This fact can impact the client‑to‑microservice communication, as explained in this section.</span></span>

## <a name="direct-client-to-microservice-communication"></a><span data-ttu-id="dc97a-107">クライアントからマイクロサービスへの直接通信</span><span class="sxs-lookup"><span data-stu-id="dc97a-107">Direct client-to-microservice communication</span></span>

<span data-ttu-id="dc97a-108">クライアントからマイクロサービスへの直接通信アーキテクチャを使用する方法が考えられます。</span><span class="sxs-lookup"><span data-stu-id="dc97a-108">A possible approach is to use a direct client-to-microservice communication architecture.</span></span> <span data-ttu-id="dc97a-109">この方法では、図 4-12 に示すように、クライアント アプリは一部のマイクロサービスに直接要求することができます。</span><span class="sxs-lookup"><span data-stu-id="dc97a-109">In this approach, a client app can make requests directly to some of the microservices, as shown in Figure 4-12.</span></span>

![](./media/image12.png)

<span data-ttu-id="dc97a-110">**図 4-12**. </span><span class="sxs-lookup"><span data-stu-id="dc97a-110">**Figure 4-12**.</span></span> <span data-ttu-id="dc97a-111">クライアントからマイクロサービスへの直接通信アーキテクチャの使用</span><span class="sxs-lookup"><span data-stu-id="dc97a-111">Using a direct client-to-microservice communication architecture</span></span>

<span data-ttu-id="dc97a-112">この方法では、</span><span class="sxs-lookup"><span data-stu-id="dc97a-112">In this approach.</span></span> <span data-ttu-id="dc97a-113">各マイクロサービスにパブリック エンドポイントがあり、マイクロサービスごとに異なる TCP ポートがある場合があります。</span><span class="sxs-lookup"><span data-stu-id="dc97a-113">each microservice has a public endpoint, sometimes with a different TCP port for each microservice.</span></span> <span data-ttu-id="dc97a-114">特定のサービスの URL の例として、Azure での URL を以下に示します。</span><span class="sxs-lookup"><span data-stu-id="dc97a-114">An example of a URL for a particular service could be the following URL in Azure:</span></span>

<http://eshoponcontainers.westus.cloudapp.azure.com:88/>

<span data-ttu-id="dc97a-115">クラスターに基づく運用環境では、その URL がクラスターで使用されるロード バランサーにマップされ、その後、マイクロサービス全体に要求が分散されます。</span><span class="sxs-lookup"><span data-stu-id="dc97a-115">In a production environment based on a cluster, that URL would map to the load balancer used in the cluster, which in turn distributes the requests across the microservices.</span></span> <span data-ttu-id="dc97a-116">運用環境では、マイクロサービスとインターネット間で [Azure Application Gateway](https://docs.microsoft.com/azure/application-gateway/application-gateway-introduction) などのアプリケーション配信コントローラー (ADC) を使用できます。</span><span class="sxs-lookup"><span data-stu-id="dc97a-116">In production environments, you could have an Application Delivery Controller (ADC) like [Azure Application Gateway](https://docs.microsoft.com/azure/application-gateway/application-gateway-introduction) between your microservices and the Internet.</span></span> <span data-ttu-id="dc97a-117">これは、負荷分散を実行するだけでなく、SSL 終了を提供することにより、サービスをセキュリティで保護する透過層として機能します。</span><span class="sxs-lookup"><span data-stu-id="dc97a-117">This acts as a transparent tier that not only performs load balancing, but secures your services by offering SSL termination.</span></span> <span data-ttu-id="dc97a-118">CPU 負荷の高い SSL 終了と他のルーティング作業を Azure Application Gateway にオフロードすることで、ホストの負荷が改善されます。</span><span class="sxs-lookup"><span data-stu-id="dc97a-118">This improves the load of your hosts by offloading CPU-intensive SSL termination and other routing duties to the Azure Application Gateway.</span></span> <span data-ttu-id="dc97a-119">いずれの場合も、論理アプリケーション アーキテクチャの観点からロード バランサーと ADC は透過的となります。</span><span class="sxs-lookup"><span data-stu-id="dc97a-119">In any case, a load balancer and ADC are transparent from a logical application architecture point of view.</span></span>

<span data-ttu-id="dc97a-120">マイクロサービス ベースの小さなアプリケーションの場合、特にクライアント アプリが ASP.NET MVC アプリなどのサーバー側の Web アプリケーションである場合はクライアントからマイクロサービスへの直接通信アーキテクチャで十分です。</span><span class="sxs-lookup"><span data-stu-id="dc97a-120">A direct client-to-microservice communication architecture could be good enough for a small microservice-based application, especially if the client app is a server-side web application like an ASP.NET MVC app.</span></span> <span data-ttu-id="dc97a-121">ただし、マイクロサービス ベースの大きい複雑なアプリケーションをビルドする場合 (たとえば、多数の種類のマイクロサービスを処理する場合) と、特にクライアント アプリがリモート モバイル アプリまたは SPA Web アプリケーションである場合、この方法ではいくつかの問題に直面します。</span><span class="sxs-lookup"><span data-stu-id="dc97a-121">However, when you build large and complex microservice-based applications (for example, when handling dozens of microservice types), and especially when the client apps are remote mobile apps or SPA web applications, that approach faces a few issues.</span></span>

<span data-ttu-id="dc97a-122">マイクロサービスに基づいて大きなアプリケーションを開発する際には、以下の点を考慮してください。</span><span class="sxs-lookup"><span data-stu-id="dc97a-122">Consider the following questions when developing a large application based on microservices:</span></span>

-   <span data-ttu-id="dc97a-123">*クライアント アプリではバックエンドへの要求数をどのように最小化し、複数のマイクロサービスへの多数の通信をどのように減らすことができるか*</span><span class="sxs-lookup"><span data-stu-id="dc97a-123">*How can client apps minimize the number of requests to the backend and reduce chatty communication to multiple microservices?*</span></span>

<span data-ttu-id="dc97a-124">単一の UI 画面をビルドするために複数のマイクロサービスと対話すると、インターネット経由のラウンドトリップ数が増加します。</span><span class="sxs-lookup"><span data-stu-id="dc97a-124">Interacting with multiple microservices to build a single UI screen increases the number of roundtrips across the Internet.</span></span> <span data-ttu-id="dc97a-125">これにより、UI 側の待機時間と複雑さが増します。</span><span class="sxs-lookup"><span data-stu-id="dc97a-125">This increases latency and complexity on the UI side.</span></span> <span data-ttu-id="dc97a-126">応答をサーバー側で効率的に集約するのが理想的です。そうすれば、データの複数の部分が並列で返され、一部の UI では準備ができしだいデータを表示できるため、待機時間が短くなります。</span><span class="sxs-lookup"><span data-stu-id="dc97a-126">Ideally, responses should be efficiently aggregated in the server side—this reduces latency, since multiple pieces of data come back in parallel and some UI can show data as soon as it is ready.</span></span>

-   <span data-ttu-id="dc97a-127">*承認、データ変換、動的な要求のディスパッチなど、横断的な問題をどのように処理できるか*</span><span class="sxs-lookup"><span data-stu-id="dc97a-127">*How can you handle cross-cutting concerns such as authorization, data transformations, and dynamic request dispatching?*</span></span>

<span data-ttu-id="dc97a-128">すべてのマイクロサービスでのセキュリティと承認などのセキュリティと横断的な問題の実装には、開発作業がかなり必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="dc97a-128">Implementing security and cross-cutting concerns like security and authorization on every microservice can require significant development effort.</span></span> <span data-ttu-id="dc97a-129">外部からのサービスへの直接アクセスを制限する場合や、API ゲートウェイなどの一元化された場所で横断的な問題を実装する場合に、Docker ホストまたは内部クラスター内にサービスを配置する方法が考えられます。</span><span class="sxs-lookup"><span data-stu-id="dc97a-129">A possible approach is to have those services within the Docker host or internal cluster, in order to restrict direct access to them from the outside, and to implement those cross-cutting concerns in a centralized place, like an API Gateway.</span></span>

-   <span data-ttu-id="dc97a-130">*クライアント アプリは非インターネット対応プロトコルを使用するサービスとどのように通信できるのか*</span><span class="sxs-lookup"><span data-stu-id="dc97a-130">*How can client apps communicate with services that use non-Internet-friendly protocols?*</span></span>

<span data-ttu-id="dc97a-131">サーバー側で使用されるプロトコル (AMQP やバイナリ プロトコルなど) は、通常、クライアント アプリではサポートされません。</span><span class="sxs-lookup"><span data-stu-id="dc97a-131">Protocols used on the server side (like AMQP or binary protocols) are usually not supported in client apps.</span></span> <span data-ttu-id="dc97a-132">そのため、要求は HTTP/HTTPS などのプロトコル経由で実行し、その後、他のプロトコルに変換する必要があります。</span><span class="sxs-lookup"><span data-stu-id="dc97a-132">Therefore, requests must be performed through protocols like HTTP/HTTPS and translated to the other protocols afterwards.</span></span> <span data-ttu-id="dc97a-133">このような状況では*中間者* 方法が役立つ場合があります。</span><span class="sxs-lookup"><span data-stu-id="dc97a-133">A *man-in-the-middle* approach can help in this situation.</span></span>

-   <span data-ttu-id="dc97a-134">*モバイル アプリ専用のファサードはどのように形成できるのか*</span><span class="sxs-lookup"><span data-stu-id="dc97a-134">*How can you shape a façade especially made for mobile apps?*</span></span>

<span data-ttu-id="dc97a-135">複数のマイクロサービスの API は、さまざまなクライアント アプリケーションのニーズに合わせて適切に設計されていない場合があります。</span><span class="sxs-lookup"><span data-stu-id="dc97a-135">The API of multiple microservices might not be well designed for the needs of different client applications.</span></span> <span data-ttu-id="dc97a-136">たとえば、モバイル アプリのニーズは、Web アプリのニーズとは異なる場合があります。</span><span class="sxs-lookup"><span data-stu-id="dc97a-136">For instance, the needs of a mobile app might be different than the needs of a web app.</span></span> <span data-ttu-id="dc97a-137">モバイル アプリでは、データ応答をより効率的にできるようにさらに最適化する必要がある場合があります。</span><span class="sxs-lookup"><span data-stu-id="dc97a-137">For mobile apps, you might need to optimize even further so that data responses can be more efficient.</span></span> <span data-ttu-id="dc97a-138">この操作は、複数のマイクロサービスからデータを集約し、単一のデータ セットを返し、場合によってはモバイル アプリには必要のない応答内のデータを排除することで行うことがあります。</span><span class="sxs-lookup"><span data-stu-id="dc97a-138">You might do this by aggregating data from multiple microservices and returning a single set of data, and sometimes eliminating any data in the response that is not needed by the mobile app.</span></span> <span data-ttu-id="dc97a-139">また、当然ながら、そのデータを圧縮する場合があります。</span><span class="sxs-lookup"><span data-stu-id="dc97a-139">And, of course, you might compress that data.</span></span> <span data-ttu-id="dc97a-140">モバイル アプリとマイクロサービス間の API またはファサードはこのシナリオでも便利な場合があります。</span><span class="sxs-lookup"><span data-stu-id="dc97a-140">Again, a façade or API in between the mobile app and the microservices can be convenient for this scenario.</span></span>

## <a name="using-an-api-gateway"></a><span data-ttu-id="dc97a-141">API ゲートウェイの使用</span><span class="sxs-lookup"><span data-stu-id="dc97a-141">Using an API Gateway</span></span>

<span data-ttu-id="dc97a-142">複数のクライアント アプリを持つマイクロサービス ベースの大きく複雑なアプリケーションを設計してビルドする場合、[API ゲートウェイ](https://microservices.io/patterns/apigateway.html)の使用を検討することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="dc97a-142">When you design and build large or complex microservice-based applications with multiple client apps, a good approach to consider can be an [API Gateway](https://microservices.io/patterns/apigateway.html).</span></span> <span data-ttu-id="dc97a-143">これは、特定のマイクロサービス グループに対して単一のエントリ ポイントを提供するサービスです。</span><span class="sxs-lookup"><span data-stu-id="dc97a-143">This is a service that provides a single entry point for certain groups of microservices.</span></span> <span data-ttu-id="dc97a-144">オブジェクト指向設計の[ファサード パターン](https://en.wikipedia.org/wiki/Facade_pattern)に似ていますが、この場合、これは分散システムの一部となります。</span><span class="sxs-lookup"><span data-stu-id="dc97a-144">It is similar to the [Facade pattern](https://en.wikipedia.org/wiki/Facade_pattern) from object‑oriented design, but in this case, it is part of a distributed system.</span></span> <span data-ttu-id="dc97a-145">API ゲートウェイ パターンは、クライアント アプリのニーズを考えながらビルドするため、"backend for frontend" [(BFF)](https://samnewman.io/patterns/architectural/bff/) と呼ばれることもあります。</span><span class="sxs-lookup"><span data-stu-id="dc97a-145">The API Gateway pattern is also sometimes known as the “backend for frontend” [(BFF)](https://samnewman.io/patterns/architectural/bff/) because you build it while thinking about the needs of the client app.</span></span>

<span data-ttu-id="dc97a-146">図 4-13 には、マイクロサービス ベースのアーキテクチャにカスタム API ゲートウェイをどのように収めるかが示されています。</span><span class="sxs-lookup"><span data-stu-id="dc97a-146">Figure 4-13 shows how a custom API Gateway can fit into a microservice-based architecture.</span></span>
<span data-ttu-id="dc97a-147">この図では、複数の異なるクライアント アプリに接続されている単一のカスタム API ゲートウェイ サービスを使用していることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="dc97a-147">It is important to highlight that in that diagram, you would be using a single custom API Gateway service facing multiple and different client apps.</span></span> <span data-ttu-id="dc97a-148">クライアント アプリからの多くのさまざまな要件に基づいて API ゲートウェイ サービスが拡大し、進化するため、このことが重要なリスクになる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dc97a-148">That fact can be an important risk because your API Gateway service will be growing and evolving based on many different requirements from the client apps.</span></span> <span data-ttu-id="dc97a-149">最終的に、これらのさまざまなニーズにより肥大化し、実際はモノシリック アプリケーションまたはモノシリック サービスにとてもよく似たものになる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dc97a-149">Eventually, it will be bloated because of those different needs and effectively it could be pretty similar to a monolithic application or monolithic service.</span></span> <span data-ttu-id="dc97a-150">そのため、API ゲートウェイを複数のサービスまたは複数のより小さい API ゲートウェイに分割する (たとえば、フォーム ファクター タイプごとに 1 つずつ) ことを強くお勧めします。</span><span class="sxs-lookup"><span data-stu-id="dc97a-150">That is why it is very much recommended to split the API Gateway in multiple services or multiple smaller API Gateways, one per form-factor type, for instance.</span></span>

![](./media/image13.png)

<span data-ttu-id="dc97a-151">**図 4-13**. </span><span class="sxs-lookup"><span data-stu-id="dc97a-151">**Figure 4-13**.</span></span> <span data-ttu-id="dc97a-152">カスタム Web API サービスとして実装された API ゲートウェイの使用</span><span class="sxs-lookup"><span data-stu-id="dc97a-152">Using an API Gateway implemented as a custom Web API service</span></span>

<span data-ttu-id="dc97a-153">この例では、API ゲートウェイは、コンテナーとして実行されるカスタム Web API サービスとして実装されます。</span><span class="sxs-lookup"><span data-stu-id="dc97a-153">In this example, the API Gateway would be implemented as a custom Web API service running as a container.</span></span>

<span data-ttu-id="dc97a-154">前述のとおり、各クライアント アプリのニーズに合わせて異なるファサードを使用できるように、いくつかの API ゲートウェイを実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="dc97a-154">As mentioned, you should implement several API Gateways so that you can have a different façade for the needs of each client app.</span></span> <span data-ttu-id="dc97a-155">各 API ゲートウェイは、複数の内部マイクロサービスを呼び出す特定のアダプター コードを実装することで場合によってはクライアント フォーム ファクターにも基づいて、クライアント アプリごとに調整された異なる API を提供できます。</span><span class="sxs-lookup"><span data-stu-id="dc97a-155">Each API Gateway can provide a different API tailored for each client app, possibly even based on the client form factor by implementing specific adapter code which underneath calls multiple internal microservices.</span></span>

<span data-ttu-id="dc97a-156">カスタム API ゲートウェイは通常、データ アグリゲーターであるため、注意が必要です。</span><span class="sxs-lookup"><span data-stu-id="dc97a-156">Since a custom API Gateway is usually a data aggregator, you need to be careful with it.</span></span> <span data-ttu-id="dc97a-157">通常は、単一の API ゲートウェイでアプリケーションの内部マイクロサービスをすべて集約することはお勧めできません。</span><span class="sxs-lookup"><span data-stu-id="dc97a-157">Usually it isn't a good idea to have a single API Gateway aggregating all the internal microservices of your application.</span></span> <span data-ttu-id="dc97a-158">これを行うと、モノシリック アグリゲーターまたはオーケストレーターとして機能し、すべてのマイクロサービスを結合することでマイクロサービスの自律性を侵害することになります。</span><span class="sxs-lookup"><span data-stu-id="dc97a-158">If it does, it acts as a monolithic aggregator or orchestrator and violates microservice autonomy by coupling all the microservices.</span></span> <span data-ttu-id="dc97a-159">したがって、API ゲートウェイはビジネス境界に基づいて分離し、アプリケーション全体のアグリゲーターとして機能しないようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="dc97a-159">Therefore, the API Gateways should be segregated based on business boundaries and not act as an aggregator for the whole application.</span></span>

<span data-ttu-id="dc97a-160">細分化された API ゲートウェイはそれ自体がマイクロサービスである場合があり、ドメインまたはビジネス名と関連データを含む場合もあります。</span><span class="sxs-lookup"><span data-stu-id="dc97a-160">Sometimes a granular API Gateway can also be a microservice by itself, and even have a domain or business name and related data.</span></span> <span data-ttu-id="dc97a-161">ビジネスまたはドメインで API ゲートウェイの境界を示すことは、より優れた設計にするのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="dc97a-161">Having the API Gateway’s boundaries dictated by the business or domain will help you to get a better design.</span></span>

<span data-ttu-id="dc97a-162">API ゲートウェイ層を細分化することは、マイクロサービスに基づくより高度な複合 UI アプリケーションで特に役立つ場合があります。これは、細かい API ゲートウェイの概念が UI コンポジション サービスと似ているためです。</span><span class="sxs-lookup"><span data-stu-id="dc97a-162">Granularity in the API Gateway tier can be especially useful for more advanced composite UI applications based on microservices, because the concept of a fine-grained API Gateway is similar to a UI composition service.</span></span> <span data-ttu-id="dc97a-163">これについては、後述の「[マイクロサービスを基にしている複合 UI を作成する](#creating-composite-ui-based-on-microservices-including-visual-ui-shape-and-layout-generated-by-multiple-microservices)」で説明します。</span><span class="sxs-lookup"><span data-stu-id="dc97a-163">We discuss this later in the [Creating composite UI based on microservices](#creating-composite-ui-based-on-microservices-including-visual-ui-shape-and-layout-generated-by-multiple-microservices).</span></span>

<span data-ttu-id="dc97a-164">したがって、多くの中規模および大規模なアプリケーションの場合、通常はカスタム ビルドの API ゲートウェイを使用することをお勧めします。ただし、単一のモノシリック アグリゲーターや一意の中央カスタム API ゲートウェイとしてではありません。</span><span class="sxs-lookup"><span data-stu-id="dc97a-164">Therefore, for many medium- and large-size applications, using a custom-built API Gateway is usually a good approach, but not as a single monolithic aggregator or unique central custom API Gateway.</span></span>

<span data-ttu-id="dc97a-165">図 4-14 に示すように、[Azure API Management](https://azure.microsoft.com/services/api-management/) などの製品を使用する方法もあります。</span><span class="sxs-lookup"><span data-stu-id="dc97a-165">Another approach is to use a product like [Azure API Management](https://azure.microsoft.com/services/api-management/) as shown in Figure 4-14.</span></span> <span data-ttu-id="dc97a-166">この方法は、API ゲートウェイのニーズを解決するだけでなく、API からの洞察を収集するなどの機能を提供します。</span><span class="sxs-lookup"><span data-stu-id="dc97a-166">This approach not only solves your API Gateway needs, but provides features like gathering insights from your APIs.</span></span> <span data-ttu-id="dc97a-167">API 管理ソリューションを使用している場合、API ゲートウェイはその完全な API 管理ソリューション内の単なるコンポーネントです。</span><span class="sxs-lookup"><span data-stu-id="dc97a-167">If you are using an API management solution, an API Gateway is only a component within that full API management solution.</span></span>

![](./media/image14.png)

<span data-ttu-id="dc97a-168">**図 4-14**. </span><span class="sxs-lookup"><span data-stu-id="dc97a-168">**Figure 4-14**.</span></span> <span data-ttu-id="dc97a-169">API ゲートウェイでの Azure API Management の使用</span><span class="sxs-lookup"><span data-stu-id="dc97a-169">Using Azure API Management for your API Gateway</span></span>

<span data-ttu-id="dc97a-170">この場合、Azure API Management などの製品を使用する際に単一の API ゲートウェイを使用することはそれほど危険ではありません。この種の API ゲートウェイは "細かい" ためです。つまり、モノシリック コンポーネントに進化する可能性のあるカスタム C# コードを実装することはありません。</span><span class="sxs-lookup"><span data-stu-id="dc97a-170">In this case, when using a product like Azure API Management, the fact that you might have a single API Gateway is not so risky because these kinds of API Gateways are "thinner", meaning that you don't implement custom C# code that could evolve towards a monolithic component.</span></span> 

<span data-ttu-id="dc97a-171">この種の製品はむしろイングレス通信のリバース プロキシに近い動作をします。この場合、内部マイクロサービスから API をフィルター処理し、さらにこの単一層で公開された API に承認を適用することもできます。</span><span class="sxs-lookup"><span data-stu-id="dc97a-171">This type of product acts more like a reverse proxy for ingress communication, where you can also filter the APIs from the internal microservices plus apply authorization to the published APIs in this single tier.</span></span>

<span data-ttu-id="dc97a-172">API Management システムから得られる洞察は、API の使用方法と実行方法を理解するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="dc97a-172">The insights available from an API Management system help you get an understanding of how your APIs are being used and how they are performing.</span></span> <span data-ttu-id="dc97a-173">これは、ほぼリアルタイムに分析レポートを表示し、ビジネスに影響する可能性のある傾向を識別することで行います。</span><span class="sxs-lookup"><span data-stu-id="dc97a-173">They do this by letting you view near real-time analytics reports and identifying trends that might impact your business.</span></span> <span data-ttu-id="dc97a-174">さらに、オンラインとオフラインの分析のために要求と応答のアクティビティに関するログを使用できます。</span><span class="sxs-lookup"><span data-stu-id="dc97a-174">Plus, you can have logs about request and response activity for further online and offline analysis.</span></span>

<span data-ttu-id="dc97a-175">Azure API Management では、キー、トークン、および IP フィルタリングを使用して API をセキュリティで保護することができます。</span><span class="sxs-lookup"><span data-stu-id="dc97a-175">With Azure API Management, you can secure your APIs using a key, a token, and IP filtering.</span></span> <span data-ttu-id="dc97a-176">これらの機能では、柔軟な細かいクォータと転送率の制限を適用し、ポリシーを使用して API の形状と動作を変更し、応答キャッシュによりパフォーマンスを向上させることができます。</span><span class="sxs-lookup"><span data-stu-id="dc97a-176">These features let you enforce flexible and fine-grained quotas and rate limits, modify the shape and behavior of your APIs using policies, and improve performance with response caching.</span></span>

<span data-ttu-id="dc97a-177">このガイドと参照用のサンプル アプリケーション (eShopOnContainers) では、Azure API Management などの PaaS 製品を使用せずにプレーン コンテナーに重点を置くため、アーキテクチャをより単純なカスタムのコンテナー化されたアーキテクチャに制限します。</span><span class="sxs-lookup"><span data-stu-id="dc97a-177">In this guide and the reference sample application (eShopOnContainers), we are limiting the architecture to a simpler and custom-made containerized architecture in order to focus on plain containers without using PaaS products like Azure API Management.</span></span> <span data-ttu-id="dc97a-178">ただし、Microsoft Azure にデプロイされるマイクロサービス ベースの大きなアプリケーションの場合は、API ゲートウェイのベースとして Azure API Management を確認して採用することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="dc97a-178">But for large microservice-based applications that are deployed into Microsoft Azure, we encourage you to review and adopt Azure API Management as the base for your API Gateways.</span></span>

## <a name="drawbacks-of-the-api-gateway-pattern"></a><span data-ttu-id="dc97a-179">API ゲートウェイ パターンの欠点</span><span class="sxs-lookup"><span data-stu-id="dc97a-179">Drawbacks of the API Gateway pattern</span></span>

-   <span data-ttu-id="dc97a-180">最も重要な欠点は、API ゲートウェイを実装する際に、その層を内部マイクロサービスと結合することです。</span><span class="sxs-lookup"><span data-stu-id="dc97a-180">The most important drawback is that when you implement an API Gateway, you are coupling that tier with the internal microservices.</span></span> <span data-ttu-id="dc97a-181">このような結合は、アプリケーションの重大な問題を発生させる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dc97a-181">Coupling like this might introduce serious difficulties for your application.</span></span> <span data-ttu-id="dc97a-182">Clemens Vaster (Azure Service Bus チームのアーキテクト) は、GOTO 2016 の "[Messaging and Microservices](https://www.youtube.com/watch?v=rXi5CLjIQ9k)" (メッセージングとマイクロサービス) セッションでこの潜在的な問題を "新しい ESB" と呼んでいます。</span><span class="sxs-lookup"><span data-stu-id="dc97a-182">Clemens Vaster, architect at the Azure Service Bus team, refers to this potential difficulty as “the new ESB” in his "[Messaging and Microservices](https://www.youtube.com/watch?v=rXi5CLjIQ9k)" session at GOTO 2016.</span></span>

-   <span data-ttu-id="dc97a-183">マイクロサービス API ゲートウェイを使用すると、単一障害点が増える可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dc97a-183">Using a microservices API Gateway creates an additional possible single point of failure.</span></span>

-   <span data-ttu-id="dc97a-184">API ゲートウェイでは、追加のネットワーク呼び出しにより応答時間が増加する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dc97a-184">An API Gateway can introduce increased response time due to the additional network call.</span></span> <span data-ttu-id="dc97a-185">ただし、この追加呼び出しは通常、内部マイクロサービスを直接呼び出す、やり取りが多すぎるクライアント インターフェイスの場合より影響は少なくなります。</span><span class="sxs-lookup"><span data-stu-id="dc97a-185">However, this extra call usually has less impact than having a client interface that is too chatty directly calling the internal microservices.</span></span>

-   <span data-ttu-id="dc97a-186">正しくスケールアウトされていない場合、API ゲートウェイがボトルネックになる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dc97a-186">If not scaled out properly, the API Gateway can become a bottleneck.</span></span>

-   <span data-ttu-id="dc97a-187">API ゲートウェイでは、カスタム ロジックとデータ集計が含まれる場合、追加の開発費と将来のメンテナンスが必要になります。</span><span class="sxs-lookup"><span data-stu-id="dc97a-187">An API Gateway requires additional development cost and future maintenance if it includes custom logic and data aggregation.</span></span> <span data-ttu-id="dc97a-188">開発者は、各マイクロ サービスのエンドポイントを公開するために、API ゲートウェイを更新する必要があります。</span><span class="sxs-lookup"><span data-stu-id="dc97a-188">Developers must update the API Gateway in order to expose each microservice’s endpoints.</span></span> <span data-ttu-id="dc97a-189">さらに、内部マイクロサービスでの実装変更により、API ゲートウェイ レベルでのコード変更が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dc97a-189">Moreover, implementation changes in the internal microservices might cause code changes at the API Gateway level.</span></span> <span data-ttu-id="dc97a-190">ただし、API ゲートウェイがセキュリティの適用、ログ記録、バージョン管理を行うだけの場合、この追加の開発費は適用されない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dc97a-190">However, if the API Gateway is just applying security, logging, and versioning (as when using Azure API Management), this additional development cost might not apply.</span></span>

-   <span data-ttu-id="dc97a-191">API ゲートウェイが単一チームによって開発される場合、開発のボトルネックが存在する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dc97a-191">If the API Gateway is developed by a single team, there can be a development bottleneck.</span></span> <span data-ttu-id="dc97a-192">これが、さまざまなクライアントのニーズに対応する細かい API ゲートウェイをいくつか使用することをお勧めする理由です。</span><span class="sxs-lookup"><span data-stu-id="dc97a-192">This is another reason why a better approach is to have several fined-grained API Gateways that respond to different client needs.</span></span> <span data-ttu-id="dc97a-193">内部マイクロサービスに取り組むさまざまなチームによって所有されている複数の領域またはレイヤーに API ゲートウェイを内部的に分離することもできます。</span><span class="sxs-lookup"><span data-stu-id="dc97a-193">You could also segregate the API Gateway internally into multiple areas or layers that are owned by the different teams working on the internal microservices.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="dc97a-194">その他の技術情報</span><span class="sxs-lookup"><span data-stu-id="dc97a-194">Additional resources</span></span>

-   <span data-ttu-id="dc97a-195">**Charles Richardson。パターン: API ゲートウェイ/フロントエンドのバックエンド**
    [*https://microservices.io/patterns/apigateway.html*](https://microservices.io/patterns/apigateway.html)</span><span class="sxs-lookup"><span data-stu-id="dc97a-195">**Charles Richardson. Pattern: API Gateway / Backend for Front-End**
[*https://microservices.io/patterns/apigateway.html*](https://microservices.io/patterns/apigateway.html)</span></span>

-   <span data-ttu-id="dc97a-196">**Azure API Management**
    [*https://azure.microsoft.com/services/api-management/*](https://azure.microsoft.com/services/api-management/)</span><span class="sxs-lookup"><span data-stu-id="dc97a-196">**Azure API Management**
[*https://azure.microsoft.com/services/api-management/*](https://azure.microsoft.com/services/api-management/)</span></span>

-   <span data-ttu-id="dc97a-197">**Udi Dahan。サービス指向のコンポジション**\\</span><span class="sxs-lookup"><span data-stu-id="dc97a-197">**Udi Dahan. Service Oriented Composition**\\</span></span>
    [*http://udidahan.com/2014/07/30/service-oriented-composition-with-video/*](http://udidahan.com/2014/07/30/service-oriented-composition-with-video/)

-   <span data-ttu-id="dc97a-198">**Clemens Vasters。GOTO 2016 でのメッセージングとマイクロサービス** (ビデオ) [*https://www.youtube.com/watch?v=rXi5CLjIQ9k*](https://www.youtube.com/watch?v=rXi5CLjIQ9k)</span><span class="sxs-lookup"><span data-stu-id="dc97a-198">**Clemens Vasters. Messaging and Microservices at GOTO 2016** (video) [*https://www.youtube.com/watch?v=rXi5CLjIQ9k*](https://www.youtube.com/watch?v=rXi5CLjIQ9k)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="dc97a-199">[前へ] (identify-microservice-domain-model-boundaries.md) [次へ] (communication-in-microservice-architecture.md)</span><span class="sxs-lookup"><span data-stu-id="dc97a-199">[Previous] (identify-microservice-domain-model-boundaries.md) [Next] (communication-in-microservice-architecture.md)</span></span>
