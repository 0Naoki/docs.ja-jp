---
title: "マイクロ サービス アーキテクチャでの通信"
description: "コンテナーの .NET アプリケーションの .NET Microservices アーキテクチャ |マイクロ サービス アーキテクチャのアーキテクチャでの通信"
keywords: "Docker, マイクロサービス, ASP.NET, コンテナー"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 10/18/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: 8d38095a151b7568619b17340d768eff684d3271
ms.sourcegitcommit: c2e216692ef7576a213ae16af2377cd98d1a67fa
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/22/2017
---
# <a name="communication-in-a-microservice-architecture"></a>マイクロ サービス アーキテクチャでの通信

1 つのプロセスで実行されているモノリシックなアプリケーションでは、コンポーネントは、言語レベルのメソッドや関数呼び出しを使用して相互を呼び出します。 これら厳密に結合できるコードを持つオブジェクトを作成する場合 (たとえば、 `new ClassName()`)、または具体的なオブジェクトのインスタンスではなく、抽象化を参照することで、依存関係の挿入を使用している場合に、分離された方法で呼び出すことができます。 どちらの方法でも、オブジェクトは、同じプロセス内で実行しています。 通信メカニズムを変更するのには、モノリシック microservices ベースのアプリケーションをアプリケーションから変更する場合は、最大の課題があります。 いない効率的な通信では実行されませんを分散環境とサービスへの RPC 呼び出しにインプロセスでメソッド呼び出しからの直接変換、chatty な原因になります。 分散システムを正しく設計の課題は、十分な既知のと呼ばれる canon があっても、[の分散コンピューティング環境と 10 のウソ](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing)いる開発者は、多くの場合から移動するときに、前提条件を一覧表示分散設計にモノリシックです。

1 つソリューションではなく、いくつか。 1 つのソリューションでは、できるだけ多くのビジネス microservices を分離する必要があります。 内部 microservices 間の非同期通信を使用し、一般的に、細かい通信とオブジェクト間のプロセス間通信に粒度の細かい通信を交換します。 これは、呼び出しをグループ化して、クライアントに複数の内部呼び出しの結果を集計するデータを返すことによって行うことができます。

Microservices ベースのアプリケーションは、複数のプロセスまたは複数のサーバーやホスト間であっても通常、サービスで実行されている分散システムです。 各サービス インスタンスは、通常、プロセスです。 そのため、サービスは、HTTP、AMQP、各サービスの性質によって、TCP のようなバイナリ プロトコルなどのプロセス間通信プロトコルを使用して対話する必要があります。

マイクロ サービス コミュニティの考え方の昇格"[スマート エンドポイントとダム パイプ](http://simplicable.com/new/smart-endpoints-and-dumb-pipes)"。 この標語 microservices、間に可能であり、単一のマイクロ サービス内でできるだけまとまりのあるように切り離すことがある設計を推奨します。 前述のように、各マイクロ サービスは、独自のデータと、独自のドメイン ロジックを所有します。 エンド ツー エンド アプリケーションを作成する microservices は単に通常 ws-などの複雑なプロトコルではなく、他の通信を使用して構成するが、\*の代わりに柔軟なイベント ドリブンの通信の集中管理とビジネスのプロセス-orchestrators です。

2 つの一般的に使用されるプロトコルは HTTP 要求/応答 Api (ほとんどすべてのクエリを実行する) 場合は、リソースを使用し、複数 microservices 全体で更新軽量な非同期メッセージング通信するときにします。 これらは、次のセクションで詳しく説明します。

## <a name="communication-types"></a>通信の種類

クライアントとサービスは、さまざまな種類の通信を対象となる、さまざまなシナリオおよび目標の 1 つずつを介して通信できます。 最初に、これらの種類の通信は、2 つの軸に分類できます。

プロトコルが同期または非同期の場合は、最初の軸が定義します。

-   同期のプロトコルです。 HTTP は、同期プロトコルです。 クライアントは、要求を送信し、サービスからの応答を待機します。 クライアント コードの実行の同期の可能性がある独立した (スレッドはブロック) または非同期 (スレッドがブロックされていないと、応答がコールバックを最終的に到達)。 ここでの重要なポイントされているプロトコル (HTTP または HTTPS) が同期サーバーの HTTP 応答を受信すると、クライアント コードはそのタスクを続行のみできます。

-   非同期のプロトコルです。 AMQP (多くのオペレーティング システムとクラウド環境でサポートされているプロトコル) などの他のプロトコルでは、非同期メッセージを使用します。 クライアント コードまたはメッセージの送信者は、通常の応答は待機しません。 RabbitMQ キューまたはその他のメッセージ ブローカーにメッセージを送信するときにだけとしてメッセージを送信します。

受信者を 1 つまたは複数の受信者の通信がある場合は、2 つ目の軸が定義します。

-   単一の受信者です。 各要求は、1 つの受信側またはサービスによって処理する必要があります。 この通信の例は、[コマンド パターン](https://en.wikipedia.org/wiki/Command_pattern)です。

-   複数の受信者です。 複数の受信者に 0 では、各要求を処理できます。 この種類の通信を非同期にする必要があります。 例としては、[パブリッシュ/サブスクライブ](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern)のようなパターンで使用されるメカニズム[イベント ドリブン アーキテクチャ](http://microservices.io/patterns/data/event-driven-architecture.html)です。 イベント; を介して複数 microservices 間でデータの更新を反映するときに、イベント バス インターフェイスまたはメッセージ ブローカーに基づきますservice bus またはなどのような成果物を通じては実装通常[Azure Service Bus](https://azure.microsoft.com/services/service-bus/)を使用して[トピックおよびサブスクリプション](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions)です。

マイクロ サービス ベースのアプリケーションは、これらのスタイルの通信の組み合わせを使用して多くの場合、します。 最も一般的な型は、通常の Web API HTTP サービスを呼び出すときに、HTTP、HTTPS などの同期プロトコルとの通信を 1 つと受信者です。 また、一般的 Microservices は microservices 間の非同期通信のメッセージング プロトコルを使用します。

これらの軸は通信メカニズムにわかりやすくする必要があるが、microservices を構築するときに重要な問題ではありませんのでを知っておくと便利です。 クライアント スレッドの実行、非同期の性質であっても、選択したプロトコルの非同期の性質は、microservices を統合する場合の重要な点です。 どのような*は*重要されて、次のセクションで説明するよう、microservices の独立性を維持しながら、microservices を非同期的に統合することです。

## <a name="asynchronous-microservice-integration-enforces-microservices-autonomy"></a>マイクロ サービスの自律性を強制する非同期マイクロ サービスの統合

前述のように、microservices ベースのアプリケーションを構築するときに重要な点は、microservices を統合する方法です。 理想的には、内部 microservices 間の通信を最小化しようとする必要があります。 以下の間の通信 microservices、パフォーマンスは向上します。 もちろん、多くの場合は、microservices を何らかの理由で統合します。 そのために必要なとき、microservices 間の通信を非同期にすることはここで重要なルールです。 特定のプロトコル (たとえば、非同期メッセージングと同期 HTTP) を使用する必要があることは限りません。 ある microservices 間の通信データを非同期的に伝達するだけで行う必要がありますが、初期サービスの HTTP 要求/応答操作の一部として他の内部 microservices に依存しないよう、ということです。

可能であれば、同期通信 (要求/応答) のクエリであっても、複数の microservices 間に依存しません。 各マイクロ サービスの目的は、エンド ツー エンドのアプリケーションの一部である他のサービスが停止しているか異常な場合でもされる自律的なクライアント コンシューマーから利用できるようにするためです。 クライアント アプリケーションへの応答を提供できるようにに含まれないときにいくつか、回復力のあるアーキテクチャがあると判断した場合 (データのクエリを HTTP 要求を実行する) などの他の microservices を 1 つのマイクロ サービスからの呼び出しを行う必要がありますでmicroservices が失敗します。

さらに、microservices、最初の部分の図 4-15 に示すようと HTTP の要求/応答のサイクルが、チェーンを要求長いを作成するときと同じように間で HTTP の依存関係にあるだけでなくでき、microservices いない自律がも、パフォーマンスは、そのチェーン内のサービスのいずれかが実行されていないと、すぐに影響を受けます。 

クエリ要求などの microservices 間の同期の依存関係を追加するほど、クライアント アプリより悪い全体の応答時間を取得します。

![](./media/image15.png)

**図 4-15**です。 アンチ パターンと microservices 間の通信

マイクロ サービスは、別のマイクロ サービスの追加のアクションを発生させる必要があります場合、可能であればを実行しないでそのアクション同期的に、元のマイクロ サービス要求と応答の操作の一部として。 代わりに、非同期的に行う (非同期メッセージングまたは統合イベントは、キューを使用して、です。)。 ただし、できるだけ、元の同期の要求と応答の操作の一部として同期的に動作を引き起こすことはありません。

最後に、これは、問題のほとんどが microservices を構築するときに発生する)、初期のマイクロ サービスは、その他の microservices 元が所有するデータを必要とする場合がそのデータの同期要求を行うに依存しません。 代わりに、レプリケートまたは最終的整合性を (通常を使用して統合イベントの場合は、次のセクションで説明したもの) を使用して、初期サービスのデータベースにデータを (必要がある属性のみ) を反映します。

セクションで述べた[各マイクロ サービスのドメイン モデルの境界を識別する](#identifying-domain-model-boundaries-for-each-microservice)、いくつかの microservices 全体でいくつかのデータを複製する不適切なデザインではありません-逆に、ときにその変換できるデータ特定の言語または条件の追加のドメインまたは境界を付けられたコンテキスト。 インスタンスで、 [eShopOnContainers](http://aka.ms/MicroservicesArchitecture)という名前であるユーザーのデータの大部分を担当するユーザーをという名前のエンティティと identity.api マイクロ サービスがあるアプリケーション。 ただし、順序付けマイクロ サービス内でのユーザーに関するデータを格納する必要がある場合として保管する購入者をという名前の別のエンティティです。 Buyer エンティティは、元のユーザー エンティティと同じ id を共有が、順序付けドメインおよび全体のユーザー プロファイルではなくで必要ないくつかの属性のみである可能性があります。

通信して最終的整合性を確保するため、microservices 間でデータを非同期的に伝達する任意のプロトコルを使用する場合があります。 前述のように、イベント バスまたはブローカーでしたでもを使用してしたり HTTP 代わりに、その他のサービスをポーリングすることによってメッセージを使用して統合イベントを使用できます。 必要はありません。 重要な規則、microservices 間の同期の依存関係は作成を開始します。

次のセクションでは、マイクロ サービス ベースのアプリケーションでの使用を検討する複数の通信スタイルについて説明します。

## <a name="communication-styles"></a>通信方式

多くのプロトコルとを使用する通信の種類によって、通信に使用できる選択肢があります。 同期要求/応答ベースの通信メカニズムを使用している場合、Docker ホストまたはマイクロ サービス クラスターの外部サービスを公開している場合に特に HTTP および REST アプローチなどのプロトコルは、最も一般的なです。 内部で (クラスター内で、Docker ホストまたは microservices) サービスの間で通信している場合をすることも (Service Fabric リモート処理や TCP およびバイナリ形式を使用して WCF) などのバイナリ形式の通信メカニズムを使用します。 また、AMQP など、メッセージ ベースの非同期通信メカニズムを使用することができます。

JSON または XML などの複数のメッセージ形式またはバイナリ形式の効率的でもあります。 選択された、バイナリ形式でない場合、標準的なは、可能性がありますその形式を使用して、サービスをパブリックに公開することをお勧めします。 Microservices 間の内部通信用の標準以外の形式を使用できます。 クラスター内で、Docker ホストまたはマイクロ サービス (Docker orchestrators または Azure Service Fabric)、または独自のクライアント アプリケーションと通信する、microservices microservices 間で通信するときに、これを行う可能性があります。

### <a name="requestresponse-communication-with-http-and-rest"></a>HTTP と残りの部分が要求/応答通信 

クライアントは、要求/応答通信を使用する場合、要求をサービス プロセスでは、サービスに要求を送信し、応答を返信します。 要求/応答通信は、クライアント アプリからリアルタイム UI (実際のユーザー インターフェイス) のデータのクエリに特に適しています。 したがって、マイクロ サービス アーキテクチャでする可能性がありますメカニズムを使用するこの通信ほとんどのクエリでは、図 4-16 が示すようにします。

![](./media/image16.png)

**図 4-16**です。 HTTP 要求/応答通信 (同期または非同期) を使用します。

クライアントは、要求/応答通信を使用する場合は、応答到達する短い時間で通常、1 秒未満または数秒多くてと仮定します。 応答が遅延する必要がありますに基づく非同期通信を実装する[メッセージング パターン](https://docs.microsoft.com/azure/architecture/patterns/category/messaging)と[メッセージング テクノロジ](https://en.wikipedia.org/wiki/Message-oriented_middleware)、これは、次のセクションで説明する別のアプローチです。

要求/応答通信の場合は、人気のあるアーキテクチャ スタイルが[REST](https://en.wikipedia.org/wiki/Representational_state_transfer)です。 このアプローチと緊密に結び付けられます、基づいて、 [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol)プロトコル、POST、GET などの HTTP 動詞を採用し、配置します。 残りの部分は、サービスを作成するときに最もよく使用されるアーキテクチャの通信方法です。 ASP.NET Core Web API サービスを開発するときに、REST サービスを実装することができます。

追加の値がある、インターフェイス定義言語として HTTP REST サービスを使用する場合。 インスタンスを使用する場合[Swagger メタデータ](http://swagger.io/)サービス API を記述するを直接検出し、サービスを使用するクライアントのスタブを生成するツールを使用することができます。

### <a name="additional-resources"></a>その他の技術情報

-   **Martin Fowler。Richardson 成熟度モデルです。** 残りの部分のモデルの説明です。
    [*http://martinfowler.com/articles/richardsonMaturityModel.html*](http://martinfowler.com/articles/richardsonMaturityModel.html)

-   **Swagger です。** 公式サイトです。
    [*http://swagger.io/*](http://swagger.io/)

### <a name="push-and-real-time-communication-based-on-http"></a>プッシュおよび HTTP に基づいてリアルタイム コミュニケーション

上位レベルのフレームワークとリアルタイムと一対多の通信がなど、(通常、残りの部分よりもさまざまな目的は) 可能性[ASP.NET SignalR](https://www.asp.net/signalr)などのプロトコルと[Websocket](https://en.wikipedia.org/wiki/WebSocket)です。

図 4-17 では、リアルタイムの HTTP 通信は、サーバー コード、サーバーを新しいデータを要求するクライアントを待機するのではなく、データが利用可能になるように接続しているクライアントにコンテンツをプッシュしたことを意味します。

![](./media/image17.png)

**図 4-17**です。 一対一のリアルタイム非同期メッセージ通信

通信がリアルタイムであるため、クライアント アプリがほぼ瞬時に変更内容を表示します。 これは通常、多くの Websocket 接続 (クライアントごとに 1 つ) を使用して Websocket などのプロトコルによって処理されます。 典型的な例は、サービスが同時に多くのクライアントの web アプリにスポーツ ゲームのスコアの変更が通信する場合です。


>[!div class="step-by-step"]
[前](direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md) [次へ] (非同期のメッセージに基づく-communication.md)
