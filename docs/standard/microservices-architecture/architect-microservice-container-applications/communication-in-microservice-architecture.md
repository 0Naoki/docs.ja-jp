---
title: "マイクロ サービス アーキテクチャでの通信"
description: "コンテナーの .NET アプリケーションの .NET Microservices アーキテクチャ |マイクロ サービス アーキテクチャのアーキテクチャでの通信"
keywords: "Docker, マイクロサービス, ASP.NET, コンテナー"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 10/18/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: 8d38095a151b7568619b17340d768eff684d3271
ms.sourcegitcommit: c2e216692ef7576a213ae16af2377cd98d1a67fa
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/22/2017
---
# <a name="communication-in-a-microservice-architecture"></a><span data-ttu-id="36ef8-104">マイクロ サービス アーキテクチャでの通信</span><span class="sxs-lookup"><span data-stu-id="36ef8-104">Communication in a microservice architecture</span></span>

<span data-ttu-id="36ef8-105">1 つのプロセスで実行されているモノリシックなアプリケーションでは、コンポーネントは、言語レベルのメソッドや関数呼び出しを使用して相互を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="36ef8-105">In a monolithic application running on a single process, components invoke one another using language-level method or function calls.</span></span> <span data-ttu-id="36ef8-106">これら厳密に結合できるコードを持つオブジェクトを作成する場合 (たとえば、 `new ClassName()`)、または具体的なオブジェクトのインスタンスではなく、抽象化を参照することで、依存関係の挿入を使用している場合に、分離された方法で呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="36ef8-106">These can be strongly coupled if you are creating objects with code (for example, `new ClassName()`), or can be invoked in a decoupled way if you are using Dependency Injection by referencing abstractions rather than concrete object instances.</span></span> <span data-ttu-id="36ef8-107">どちらの方法でも、オブジェクトは、同じプロセス内で実行しています。</span><span class="sxs-lookup"><span data-stu-id="36ef8-107">Either way, the objects are running within the same process.</span></span> <span data-ttu-id="36ef8-108">通信メカニズムを変更するのには、モノリシック microservices ベースのアプリケーションをアプリケーションから変更する場合は、最大の課題があります。</span><span class="sxs-lookup"><span data-stu-id="36ef8-108">The biggest challenge when changing from a monolithic application to a microservices-based application lies in changing the communication mechanism.</span></span> <span data-ttu-id="36ef8-109">いない効率的な通信では実行されませんを分散環境とサービスへの RPC 呼び出しにインプロセスでメソッド呼び出しからの直接変換、chatty な原因になります。</span><span class="sxs-lookup"><span data-stu-id="36ef8-109">A direct conversion from in-process method calls into RPC calls to services will cause a chatty and not efficient communication that will not perform well in distributed environments.</span></span> <span data-ttu-id="36ef8-110">分散システムを正しく設計の課題は、十分な既知のと呼ばれる canon があっても、[の分散コンピューティング環境と 10 のウソ](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing)いる開発者は、多くの場合から移動するときに、前提条件を一覧表示分散設計にモノリシックです。</span><span class="sxs-lookup"><span data-stu-id="36ef8-110">The challenges of designing distributed system properly are well enough known that there is even a canon known as the [The fallacies of distributed computing](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing) that lists assumptions that developers often make when moving from monolithic to distributed designs.</span></span>

<span data-ttu-id="36ef8-111">1 つソリューションではなく、いくつか。</span><span class="sxs-lookup"><span data-stu-id="36ef8-111">There is not one solution, but several.</span></span> <span data-ttu-id="36ef8-112">1 つのソリューションでは、できるだけ多くのビジネス microservices を分離する必要があります。</span><span class="sxs-lookup"><span data-stu-id="36ef8-112">One solution involves isolating the business microservices as much as possible.</span></span> <span data-ttu-id="36ef8-113">内部 microservices 間の非同期通信を使用し、一般的に、細かい通信とオブジェクト間のプロセス間通信に粒度の細かい通信を交換します。</span><span class="sxs-lookup"><span data-stu-id="36ef8-113">You then use asynchronous communication between the internal microservices and replace fine-grained communication that is typical in intra-process communication between objects with coarser-grained communication.</span></span> <span data-ttu-id="36ef8-114">これは、呼び出しをグループ化して、クライアントに複数の内部呼び出しの結果を集計するデータを返すことによって行うことができます。</span><span class="sxs-lookup"><span data-stu-id="36ef8-114">You can do this by grouping calls, and by returning data that aggregates the results of multiple internal calls, to the client.</span></span>

<span data-ttu-id="36ef8-115">Microservices ベースのアプリケーションは、複数のプロセスまたは複数のサーバーやホスト間であっても通常、サービスで実行されている分散システムです。</span><span class="sxs-lookup"><span data-stu-id="36ef8-115">A microservices-based application is a distributed system running on multiple processes or services, usually even across multiple servers or hosts.</span></span> <span data-ttu-id="36ef8-116">各サービス インスタンスは、通常、プロセスです。</span><span class="sxs-lookup"><span data-stu-id="36ef8-116">Each service instance is typically a process.</span></span> <span data-ttu-id="36ef8-117">そのため、サービスは、HTTP、AMQP、各サービスの性質によって、TCP のようなバイナリ プロトコルなどのプロセス間通信プロトコルを使用して対話する必要があります。</span><span class="sxs-lookup"><span data-stu-id="36ef8-117">Therefore, services must interact using an inter-process communication protocol such as HTTP, AMQP, or a binary protocol like TCP, depending on the nature of each service.</span></span>

<span data-ttu-id="36ef8-118">マイクロ サービス コミュニティの考え方の昇格"[スマート エンドポイントとダム パイプ](http://simplicable.com/new/smart-endpoints-and-dumb-pipes)"。</span><span class="sxs-lookup"><span data-stu-id="36ef8-118">The microservice community promotes the philosophy of “[smart endpoints and dumb pipes](http://simplicable.com/new/smart-endpoints-and-dumb-pipes).”</span></span> <span data-ttu-id="36ef8-119">この標語 microservices、間に可能であり、単一のマイクロ サービス内でできるだけまとまりのあるように切り離すことがある設計を推奨します。</span><span class="sxs-lookup"><span data-stu-id="36ef8-119">This slogan encourages a design that is as decoupled as possible between microservices, and as cohesive as possible within a single microservice.</span></span> <span data-ttu-id="36ef8-120">前述のように、各マイクロ サービスは、独自のデータと、独自のドメイン ロジックを所有します。</span><span class="sxs-lookup"><span data-stu-id="36ef8-120">As explained earlier, each microservice owns its own data and its own domain logic.</span></span> <span data-ttu-id="36ef8-121">エンド ツー エンド アプリケーションを作成する microservices は単に通常 ws-などの複雑なプロトコルではなく、他の通信を使用して構成するが、\*の代わりに柔軟なイベント ドリブンの通信の集中管理とビジネスのプロセス-orchestrators です。</span><span class="sxs-lookup"><span data-stu-id="36ef8-121">But the microservices composing an end-to-end application are usually simply choreographed by using REST communications rather than complex protocols such as WS-\* and flexible event-driven communications instead of centralized business-process-orchestrators.</span></span>

<span data-ttu-id="36ef8-122">2 つの一般的に使用されるプロトコルは HTTP 要求/応答 Api (ほとんどすべてのクエリを実行する) 場合は、リソースを使用し、複数 microservices 全体で更新軽量な非同期メッセージング通信するときにします。</span><span class="sxs-lookup"><span data-stu-id="36ef8-122">The two commonly used protocols are HTTP request/response with resource APIs (when querying most of all), and lightweight asynchronous messaging when communicating updates across multiple microservices.</span></span> <span data-ttu-id="36ef8-123">これらは、次のセクションで詳しく説明します。</span><span class="sxs-lookup"><span data-stu-id="36ef8-123">These are explained in more detail in the following sections.</span></span>

## <a name="communication-types"></a><span data-ttu-id="36ef8-124">通信の種類</span><span class="sxs-lookup"><span data-stu-id="36ef8-124">Communication types</span></span>

<span data-ttu-id="36ef8-125">クライアントとサービスは、さまざまな種類の通信を対象となる、さまざまなシナリオおよび目標の 1 つずつを介して通信できます。</span><span class="sxs-lookup"><span data-stu-id="36ef8-125">Client and services can communicate through many different types of communication, each one targeting a different scenario and goals.</span></span> <span data-ttu-id="36ef8-126">最初に、これらの種類の通信は、2 つの軸に分類できます。</span><span class="sxs-lookup"><span data-stu-id="36ef8-126">Initially, those types of communications can be classified in two axes.</span></span>

<span data-ttu-id="36ef8-127">プロトコルが同期または非同期の場合は、最初の軸が定義します。</span><span class="sxs-lookup"><span data-stu-id="36ef8-127">The first axis is defining if the protocol is synchronous or asynchronous:</span></span>

-   <span data-ttu-id="36ef8-128">同期のプロトコルです。</span><span class="sxs-lookup"><span data-stu-id="36ef8-128">Synchronous protocol.</span></span> <span data-ttu-id="36ef8-129">HTTP は、同期プロトコルです。</span><span class="sxs-lookup"><span data-stu-id="36ef8-129">HTTP is a synchronous protocol.</span></span> <span data-ttu-id="36ef8-130">クライアントは、要求を送信し、サービスからの応答を待機します。</span><span class="sxs-lookup"><span data-stu-id="36ef8-130">The client sends a request and waits for a response from the service.</span></span> <span data-ttu-id="36ef8-131">クライアント コードの実行の同期の可能性がある独立した (スレッドはブロック) または非同期 (スレッドがブロックされていないと、応答がコールバックを最終的に到達)。</span><span class="sxs-lookup"><span data-stu-id="36ef8-131">That is independent of the client code execution that could be synchronous (thread is blocked) or asynchronous (thread is not blocked, and the response will reach a callback eventually).</span></span> <span data-ttu-id="36ef8-132">ここでの重要なポイントされているプロトコル (HTTP または HTTPS) が同期サーバーの HTTP 応答を受信すると、クライアント コードはそのタスクを続行のみできます。</span><span class="sxs-lookup"><span data-stu-id="36ef8-132">The important point here is that the protocol (HTTP/HTTPS) is synchronous and the client code can only continue its task when it receives the HTTP server response.</span></span>

-   <span data-ttu-id="36ef8-133">非同期のプロトコルです。</span><span class="sxs-lookup"><span data-stu-id="36ef8-133">Asynchronous protocol.</span></span> <span data-ttu-id="36ef8-134">AMQP (多くのオペレーティング システムとクラウド環境でサポートされているプロトコル) などの他のプロトコルでは、非同期メッセージを使用します。</span><span class="sxs-lookup"><span data-stu-id="36ef8-134">Other protocols like AMQP (a protocol supported by many operating systems and cloud environments) use asynchronous messages.</span></span> <span data-ttu-id="36ef8-135">クライアント コードまたはメッセージの送信者は、通常の応答は待機しません。</span><span class="sxs-lookup"><span data-stu-id="36ef8-135">The client code or message sender usually does not wait for a response.</span></span> <span data-ttu-id="36ef8-136">RabbitMQ キューまたはその他のメッセージ ブローカーにメッセージを送信するときにだけとしてメッセージを送信します。</span><span class="sxs-lookup"><span data-stu-id="36ef8-136">It just sends the message as when sending a message to a RabbitMQ queue or any other message broker.</span></span>

<span data-ttu-id="36ef8-137">受信者を 1 つまたは複数の受信者の通信がある場合は、2 つ目の軸が定義します。</span><span class="sxs-lookup"><span data-stu-id="36ef8-137">The second axis is defining if the communication has a single receiver or multiple receivers:</span></span>

-   <span data-ttu-id="36ef8-138">単一の受信者です。</span><span class="sxs-lookup"><span data-stu-id="36ef8-138">Single receiver.</span></span> <span data-ttu-id="36ef8-139">各要求は、1 つの受信側またはサービスによって処理する必要があります。</span><span class="sxs-lookup"><span data-stu-id="36ef8-139">Each request must be processed by exactly one receiver or service.</span></span> <span data-ttu-id="36ef8-140">この通信の例は、[コマンド パターン](https://en.wikipedia.org/wiki/Command_pattern)です。</span><span class="sxs-lookup"><span data-stu-id="36ef8-140">An example of this communication is the [Command pattern](https://en.wikipedia.org/wiki/Command_pattern).</span></span>

-   <span data-ttu-id="36ef8-141">複数の受信者です。</span><span class="sxs-lookup"><span data-stu-id="36ef8-141">Multiple receivers.</span></span> <span data-ttu-id="36ef8-142">複数の受信者に 0 では、各要求を処理できます。</span><span class="sxs-lookup"><span data-stu-id="36ef8-142">Each request can be processed by zero to multiple receivers.</span></span> <span data-ttu-id="36ef8-143">この種類の通信を非同期にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="36ef8-143">This type of communication must be asynchronous.</span></span> <span data-ttu-id="36ef8-144">例としては、[パブリッシュ/サブスクライブ](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern)のようなパターンで使用されるメカニズム[イベント ドリブン アーキテクチャ](http://microservices.io/patterns/data/event-driven-architecture.html)です。</span><span class="sxs-lookup"><span data-stu-id="36ef8-144">An example is the [publish/subscribe](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern) mechanism used in patterns like [Event-driven architecture](http://microservices.io/patterns/data/event-driven-architecture.html).</span></span> <span data-ttu-id="36ef8-145">イベント; を介して複数 microservices 間でデータの更新を反映するときに、イベント バス インターフェイスまたはメッセージ ブローカーに基づきますservice bus またはなどのような成果物を通じては実装通常[Azure Service Bus](https://azure.microsoft.com/services/service-bus/)を使用して[トピックおよびサブスクリプション](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions)です。</span><span class="sxs-lookup"><span data-stu-id="36ef8-145">This is based on an event-bus interface or message broker when propagating data updates between multiple microservices through events; it is usually implemented through a service bus or similar artifact like [Azure Service Bus](https://azure.microsoft.com/services/service-bus/) by using [topics and subscriptions](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span></span>

<span data-ttu-id="36ef8-146">マイクロ サービス ベースのアプリケーションは、これらのスタイルの通信の組み合わせを使用して多くの場合、します。</span><span class="sxs-lookup"><span data-stu-id="36ef8-146">A microservice-based application will often use a combination of these communication styles.</span></span> <span data-ttu-id="36ef8-147">最も一般的な型は、通常の Web API HTTP サービスを呼び出すときに、HTTP、HTTPS などの同期プロトコルとの通信を 1 つと受信者です。</span><span class="sxs-lookup"><span data-stu-id="36ef8-147">The most common type is single-receiver communication with a synchronous protocol like HTTP/HTTPS when invoking a regular Web API HTTP service.</span></span> <span data-ttu-id="36ef8-148">また、一般的 Microservices は microservices 間の非同期通信のメッセージング プロトコルを使用します。</span><span class="sxs-lookup"><span data-stu-id="36ef8-148">Microservices also typically use messaging protocols for asynchronous communication between microservices.</span></span>

<span data-ttu-id="36ef8-149">これらの軸は通信メカニズムにわかりやすくする必要があるが、microservices を構築するときに重要な問題ではありませんのでを知っておくと便利です。</span><span class="sxs-lookup"><span data-stu-id="36ef8-149">These axes are good to know so you have clarity on the possible communication mechanisms, but they are not the important concerns when building microservices.</span></span> <span data-ttu-id="36ef8-150">クライアント スレッドの実行、非同期の性質であっても、選択したプロトコルの非同期の性質は、microservices を統合する場合の重要な点です。</span><span class="sxs-lookup"><span data-stu-id="36ef8-150">The asynchronous nature of client thread execution not even the asynchronous nature of the selected protocol are the important points when integrating microservices.</span></span> <span data-ttu-id="36ef8-151">どのような*は*重要されて、次のセクションで説明するよう、microservices の独立性を維持しながら、microservices を非同期的に統合することです。</span><span class="sxs-lookup"><span data-stu-id="36ef8-151">What *is* important is being able to integrate your microservices asynchronously while maintaining the independence of microservices, as explained in the following section.</span></span>

## <a name="asynchronous-microservice-integration-enforces-microservices-autonomy"></a><span data-ttu-id="36ef8-152">マイクロ サービスの自律性を強制する非同期マイクロ サービスの統合</span><span class="sxs-lookup"><span data-stu-id="36ef8-152">Asynchronous microservice integration enforces microservice’s autonomy</span></span>

<span data-ttu-id="36ef8-153">前述のように、microservices ベースのアプリケーションを構築するときに重要な点は、microservices を統合する方法です。</span><span class="sxs-lookup"><span data-stu-id="36ef8-153">As mentioned, the important point when building a microservices-based application is the way you integrate your microservices.</span></span> <span data-ttu-id="36ef8-154">理想的には、内部 microservices 間の通信を最小化しようとする必要があります。</span><span class="sxs-lookup"><span data-stu-id="36ef8-154">Ideally, you should try to minimize the communication between the internal microservices.</span></span> <span data-ttu-id="36ef8-155">以下の間の通信 microservices、パフォーマンスは向上します。</span><span class="sxs-lookup"><span data-stu-id="36ef8-155">The less communications between microservices, the better.</span></span> <span data-ttu-id="36ef8-156">もちろん、多くの場合は、microservices を何らかの理由で統合します。</span><span class="sxs-lookup"><span data-stu-id="36ef8-156">But of course, in many cases you will have to somehow integrate the microservices.</span></span> <span data-ttu-id="36ef8-157">そのために必要なとき、microservices 間の通信を非同期にすることはここで重要なルールです。</span><span class="sxs-lookup"><span data-stu-id="36ef8-157">When you need to do that, the critical rule here is that the communication between the microservices should be asynchronous.</span></span> <span data-ttu-id="36ef8-158">特定のプロトコル (たとえば、非同期メッセージングと同期 HTTP) を使用する必要があることは限りません。</span><span class="sxs-lookup"><span data-stu-id="36ef8-158">That does not mean that you have to use a specific protocol (for example, asynchronous messaging versus synchronous HTTP).</span></span> <span data-ttu-id="36ef8-159">ある microservices 間の通信データを非同期的に伝達するだけで行う必要がありますが、初期サービスの HTTP 要求/応答操作の一部として他の内部 microservices に依存しないよう、ということです。</span><span class="sxs-lookup"><span data-stu-id="36ef8-159">It just means that the communication between microservices should be done only by propagating data asynchronously, but try not to depend on other internal microservices as part of the initial service’s HTTP request/response operation.</span></span>

<span data-ttu-id="36ef8-160">可能であれば、同期通信 (要求/応答) のクエリであっても、複数の microservices 間に依存しません。</span><span class="sxs-lookup"><span data-stu-id="36ef8-160">If possible, never depend on synchronous communication (request/response) between multiple microservices, not even for queries.</span></span> <span data-ttu-id="36ef8-161">各マイクロ サービスの目的は、エンド ツー エンドのアプリケーションの一部である他のサービスが停止しているか異常な場合でもされる自律的なクライアント コンシューマーから利用できるようにするためです。</span><span class="sxs-lookup"><span data-stu-id="36ef8-161">The goal of each microservice is to be autonomous and available to the client consumer, even if the other services that are part of the end-to-end application are down or unhealthy.</span></span> <span data-ttu-id="36ef8-162">クライアント アプリケーションへの応答を提供できるようにに含まれないときにいくつか、回復力のあるアーキテクチャがあると判断した場合 (データのクエリを HTTP 要求を実行する) などの他の microservices を 1 つのマイクロ サービスからの呼び出しを行う必要がありますでmicroservices が失敗します。</span><span class="sxs-lookup"><span data-stu-id="36ef8-162">If you think you need to make a call from one microservice to other microservices (like performing an HTTP request for a data query) in order to be able to provide a response to a client application, you have an architecture that will not be resilient when some microservices fail.</span></span>

<span data-ttu-id="36ef8-163">さらに、microservices、最初の部分の図 4-15 に示すようと HTTP の要求/応答のサイクルが、チェーンを要求長いを作成するときと同じように間で HTTP の依存関係にあるだけでなくでき、microservices いない自律がも、パフォーマンスは、そのチェーン内のサービスのいずれかが実行されていないと、すぐに影響を受けます。</span><span class="sxs-lookup"><span data-stu-id="36ef8-163">Moreover, having HTTP dependencies between microservices, like when creating long request/response cycles with HTTP request chains, as shown in the first part of the Figure 4-15, not only makes your microservices not autonomous but also their performance is impacted as soon as one of the services in that chain is not performing well.</span></span> 

<span data-ttu-id="36ef8-164">クエリ要求などの microservices 間の同期の依存関係を追加するほど、クライアント アプリより悪い全体の応答時間を取得します。</span><span class="sxs-lookup"><span data-stu-id="36ef8-164">The more you add synchronous dependencies between microservices, such as query requests, the worse the overall response time gets for the client apps.</span></span>

![](./media/image15.png)

<span data-ttu-id="36ef8-165">**図 4-15**です。</span><span class="sxs-lookup"><span data-stu-id="36ef8-165">**Figure 4-15**.</span></span> <span data-ttu-id="36ef8-166">アンチ パターンと microservices 間の通信</span><span class="sxs-lookup"><span data-stu-id="36ef8-166">Anti-patterns and patterns in communication between microservices</span></span>

<span data-ttu-id="36ef8-167">マイクロ サービスは、別のマイクロ サービスの追加のアクションを発生させる必要があります場合、可能であればを実行しないでそのアクション同期的に、元のマイクロ サービス要求と応答の操作の一部として。</span><span class="sxs-lookup"><span data-stu-id="36ef8-167">If your microservice needs to raise an additional action in another microservice, if possible, do not perform that action synchronously and as part of the original microservice request and reply operation.</span></span> <span data-ttu-id="36ef8-168">代わりに、非同期的に行う (非同期メッセージングまたは統合イベントは、キューを使用して、です。)。</span><span class="sxs-lookup"><span data-stu-id="36ef8-168">Instead, do it asynchronously (using asynchronous messaging or integration events, queues, etc.).</span></span> <span data-ttu-id="36ef8-169">ただし、できるだけ、元の同期の要求と応答の操作の一部として同期的に動作を引き起こすことはありません。</span><span class="sxs-lookup"><span data-stu-id="36ef8-169">But, as much as possible, do not invoke the action synchronously as part of the original synchronous request and reply operation.</span></span>

<span data-ttu-id="36ef8-170">最後に、これは、問題のほとんどが microservices を構築するときに発生する)、初期のマイクロ サービスは、その他の microservices 元が所有するデータを必要とする場合がそのデータの同期要求を行うに依存しません。</span><span class="sxs-lookup"><span data-stu-id="36ef8-170">And finally (and this is where most of the issues arise when building microservices), if your initial microservice needs data that is originally owned by other microservices, do not rely on making synchronous requests for that data.</span></span> <span data-ttu-id="36ef8-171">代わりに、レプリケートまたは最終的整合性を (通常を使用して統合イベントの場合は、次のセクションで説明したもの) を使用して、初期サービスのデータベースにデータを (必要がある属性のみ) を反映します。</span><span class="sxs-lookup"><span data-stu-id="36ef8-171">Instead, replicate or propagate that data (only the attributes you need) into the initial service’s database by using eventual consistency (typically by using integration events, as explained in upcoming sections).</span></span>

<span data-ttu-id="36ef8-172">セクションで述べた[各マイクロ サービスのドメイン モデルの境界を識別する](#identifying-domain-model-boundaries-for-each-microservice)、いくつかの microservices 全体でいくつかのデータを複製する不適切なデザインではありません-逆に、ときにその変換できるデータ特定の言語または条件の追加のドメインまたは境界を付けられたコンテキスト。</span><span class="sxs-lookup"><span data-stu-id="36ef8-172">As noted earlier in the section [Identifying domain-model boundaries for each microservice](#identifying-domain-model-boundaries-for-each-microservice), duplicating some data across several microservices is not an incorrect design—on the contrary, when doing that you can translate the data into the specific language or terms of that additional domain or Bounded Context.</span></span> <span data-ttu-id="36ef8-173">インスタンスで、 [eShopOnContainers](http://aka.ms/MicroservicesArchitecture)という名前であるユーザーのデータの大部分を担当するユーザーをという名前のエンティティと identity.api マイクロ サービスがあるアプリケーション。</span><span class="sxs-lookup"><span data-stu-id="36ef8-173">For instance, in the [eShopOnContainers](http://aka.ms/MicroservicesArchitecture) application you have a microservice named identity.api that is in charge of most of the user’s data with an entity named User.</span></span> <span data-ttu-id="36ef8-174">ただし、順序付けマイクロ サービス内でのユーザーに関するデータを格納する必要がある場合として保管する購入者をという名前の別のエンティティです。</span><span class="sxs-lookup"><span data-stu-id="36ef8-174">However, when you need to store data about the user within the Ordering microservice, you store it as a different entity named Buyer.</span></span> <span data-ttu-id="36ef8-175">Buyer エンティティは、元のユーザー エンティティと同じ id を共有が、順序付けドメインおよび全体のユーザー プロファイルではなくで必要ないくつかの属性のみである可能性があります。</span><span class="sxs-lookup"><span data-stu-id="36ef8-175">The Buyer entity shares the same identity with the original User entity, but it might have only the few attributes needed by the Ordering domain, and not the whole user profile.</span></span>

<span data-ttu-id="36ef8-176">通信して最終的整合性を確保するため、microservices 間でデータを非同期的に伝達する任意のプロトコルを使用する場合があります。</span><span class="sxs-lookup"><span data-stu-id="36ef8-176">You might use any protocol to communicate and propagate data asynchronously across microservices in order to have eventual consistency.</span></span> <span data-ttu-id="36ef8-177">前述のように、イベント バスまたはブローカーでしたでもを使用してしたり HTTP 代わりに、その他のサービスをポーリングすることによってメッセージを使用して統合イベントを使用できます。</span><span class="sxs-lookup"><span data-stu-id="36ef8-177">As mentioned, you could use integration events using an event bus or message broker or you could even use HTTP by polling the other services instead.</span></span> <span data-ttu-id="36ef8-178">必要はありません。</span><span class="sxs-lookup"><span data-stu-id="36ef8-178">It does not matter.</span></span> <span data-ttu-id="36ef8-179">重要な規則、microservices 間の同期の依存関係は作成を開始します。</span><span class="sxs-lookup"><span data-stu-id="36ef8-179">The important rule is to not create synchronous dependencies between your microservices.</span></span>

<span data-ttu-id="36ef8-180">次のセクションでは、マイクロ サービス ベースのアプリケーションでの使用を検討する複数の通信スタイルについて説明します。</span><span class="sxs-lookup"><span data-stu-id="36ef8-180">The following sections explain the multiple communication styles you can consider using in a microservice-based application.</span></span>

## <a name="communication-styles"></a><span data-ttu-id="36ef8-181">通信方式</span><span class="sxs-lookup"><span data-stu-id="36ef8-181">Communication styles</span></span>

<span data-ttu-id="36ef8-182">多くのプロトコルとを使用する通信の種類によって、通信に使用できる選択肢があります。</span><span class="sxs-lookup"><span data-stu-id="36ef8-182">There are many protocols and choices you can use for communication, depending on the communication type you want to use.</span></span> <span data-ttu-id="36ef8-183">同期要求/応答ベースの通信メカニズムを使用している場合、Docker ホストまたはマイクロ サービス クラスターの外部サービスを公開している場合に特に HTTP および REST アプローチなどのプロトコルは、最も一般的なです。</span><span class="sxs-lookup"><span data-stu-id="36ef8-183">If you are using a synchronous request/response-based communication mechanism, protocols such as HTTP and REST approaches are the most common, especially if you are publishing your services outside the Docker host or microservice cluster.</span></span> <span data-ttu-id="36ef8-184">内部で (クラスター内で、Docker ホストまたは microservices) サービスの間で通信している場合をすることも (Service Fabric リモート処理や TCP およびバイナリ形式を使用して WCF) などのバイナリ形式の通信メカニズムを使用します。</span><span class="sxs-lookup"><span data-stu-id="36ef8-184">If you are communicating between services internally (within your Docker host or microservices cluster) you might also want to use binary format communication mechanisms (like Service Fabric remoting or WCF using TCP and binary format).</span></span> <span data-ttu-id="36ef8-185">また、AMQP など、メッセージ ベースの非同期通信メカニズムを使用することができます。</span><span class="sxs-lookup"><span data-stu-id="36ef8-185">Alternatively, you can use asynchronous, message-based communication mechanisms such as AMQP.</span></span>

<span data-ttu-id="36ef8-186">JSON または XML などの複数のメッセージ形式またはバイナリ形式の効率的でもあります。</span><span class="sxs-lookup"><span data-stu-id="36ef8-186">There are also multiple message formats like JSON or XML, or even binary formats, which can be more efficient.</span></span> <span data-ttu-id="36ef8-187">選択された、バイナリ形式でない場合、標準的なは、可能性がありますその形式を使用して、サービスをパブリックに公開することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="36ef8-187">If your chosen binary format is not a standard, it is probably not a good idea to publicly publish your services using that format.</span></span> <span data-ttu-id="36ef8-188">Microservices 間の内部通信用の標準以外の形式を使用できます。</span><span class="sxs-lookup"><span data-stu-id="36ef8-188">You could use a non-standard format for internal communication between your microservices.</span></span> <span data-ttu-id="36ef8-189">クラスター内で、Docker ホストまたはマイクロ サービス (Docker orchestrators または Azure Service Fabric)、または独自のクライアント アプリケーションと通信する、microservices microservices 間で通信するときに、これを行う可能性があります。</span><span class="sxs-lookup"><span data-stu-id="36ef8-189">You might do this when communicating between microservices within your Docker host or microservice cluster (Docker orchestrators or Azure Service Fabric), or for proprietary client applications that talk to the microservices.</span></span>

### <a name="requestresponse-communication-with-http-and-rest"></a><span data-ttu-id="36ef8-190">HTTP と残りの部分が要求/応答通信</span><span class="sxs-lookup"><span data-stu-id="36ef8-190">Request/response communication with HTTP and REST</span></span> 

<span data-ttu-id="36ef8-191">クライアントは、要求/応答通信を使用する場合、要求をサービス プロセスでは、サービスに要求を送信し、応答を返信します。</span><span class="sxs-lookup"><span data-stu-id="36ef8-191">When a client uses request/response communication, it sends a request to a service, then the service processes the request and sends back a response.</span></span> <span data-ttu-id="36ef8-192">要求/応答通信は、クライアント アプリからリアルタイム UI (実際のユーザー インターフェイス) のデータのクエリに特に適しています。</span><span class="sxs-lookup"><span data-stu-id="36ef8-192">Request/response communication is especially well suited for querying data for a real-time UI (a live user interface) from client apps.</span></span> <span data-ttu-id="36ef8-193">したがって、マイクロ サービス アーキテクチャでする可能性がありますメカニズムを使用するこの通信ほとんどのクエリでは、図 4-16 が示すようにします。</span><span class="sxs-lookup"><span data-stu-id="36ef8-193">Therefore, in a microservice architecture you will probably use this communication mechanism for most queries, as shown in Figure 4-16.</span></span>

![](./media/image16.png)

<span data-ttu-id="36ef8-194">**図 4-16**です。</span><span class="sxs-lookup"><span data-stu-id="36ef8-194">**Figure 4-16**.</span></span> <span data-ttu-id="36ef8-195">HTTP 要求/応答通信 (同期または非同期) を使用します。</span><span class="sxs-lookup"><span data-stu-id="36ef8-195">Using HTTP request/response communication (synchronous or asynchronous)</span></span>

<span data-ttu-id="36ef8-196">クライアントは、要求/応答通信を使用する場合は、応答到達する短い時間で通常、1 秒未満または数秒多くてと仮定します。</span><span class="sxs-lookup"><span data-stu-id="36ef8-196">When a client uses request/response communication, it assumes that the response will arrive in a short time, typically less than a second, or a few seconds at most.</span></span> <span data-ttu-id="36ef8-197">応答が遅延する必要がありますに基づく非同期通信を実装する[メッセージング パターン](https://docs.microsoft.com/azure/architecture/patterns/category/messaging)と[メッセージング テクノロジ](https://en.wikipedia.org/wiki/Message-oriented_middleware)、これは、次のセクションで説明する別のアプローチです。</span><span class="sxs-lookup"><span data-stu-id="36ef8-197">For delayed responses, you need to implement asynchronous communication based on [messaging patterns](https://docs.microsoft.com/azure/architecture/patterns/category/messaging) and [messaging technologies](https://en.wikipedia.org/wiki/Message-oriented_middleware), which is a different approach that we explain in the next section.</span></span>

<span data-ttu-id="36ef8-198">要求/応答通信の場合は、人気のあるアーキテクチャ スタイルが[REST](https://en.wikipedia.org/wiki/Representational_state_transfer)です。</span><span class="sxs-lookup"><span data-stu-id="36ef8-198">A popular architectural style for request/response communication is [REST](https://en.wikipedia.org/wiki/Representational_state_transfer).</span></span> <span data-ttu-id="36ef8-199">このアプローチと緊密に結び付けられます、基づいて、 [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol)プロトコル、POST、GET などの HTTP 動詞を採用し、配置します。</span><span class="sxs-lookup"><span data-stu-id="36ef8-199">This approach is based on, and tightly coupled to, the [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) protocol, embracing HTTP verbs like GET, POST, and PUT.</span></span> <span data-ttu-id="36ef8-200">残りの部分は、サービスを作成するときに最もよく使用されるアーキテクチャの通信方法です。</span><span class="sxs-lookup"><span data-stu-id="36ef8-200">REST is the most commonly used architectural communication approach when creating services.</span></span> <span data-ttu-id="36ef8-201">ASP.NET Core Web API サービスを開発するときに、REST サービスを実装することができます。</span><span class="sxs-lookup"><span data-stu-id="36ef8-201">You can implement REST services when you develop ASP.NET Core Web API services.</span></span>

<span data-ttu-id="36ef8-202">追加の値がある、インターフェイス定義言語として HTTP REST サービスを使用する場合。</span><span class="sxs-lookup"><span data-stu-id="36ef8-202">There is additional value when using HTTP REST services as your interface definition language.</span></span> <span data-ttu-id="36ef8-203">インスタンスを使用する場合[Swagger メタデータ](http://swagger.io/)サービス API を記述するを直接検出し、サービスを使用するクライアントのスタブを生成するツールを使用することができます。</span><span class="sxs-lookup"><span data-stu-id="36ef8-203">For instance, if you use [Swagger metadata](http://swagger.io/) to describe your service API, you can use tools that generate client stubs that can directly discover and consume your services.</span></span>

### <a name="additional-resources"></a><span data-ttu-id="36ef8-204">その他の技術情報</span><span class="sxs-lookup"><span data-stu-id="36ef8-204">Additional resources</span></span>

-   <span data-ttu-id="36ef8-205">**Martin Fowler。Richardson 成熟度モデルです。**</span><span class="sxs-lookup"><span data-stu-id="36ef8-205">**Martin Fowler. Richardson Maturity Model.**</span></span> <span data-ttu-id="36ef8-206">残りの部分のモデルの説明です。</span><span class="sxs-lookup"><span data-stu-id="36ef8-206">A description of the REST model.</span></span>
    [<span data-ttu-id="36ef8-207">*http://martinfowler.com/articles/richardsonMaturityModel.html*</span><span class="sxs-lookup"><span data-stu-id="36ef8-207">*http://martinfowler.com/articles/richardsonMaturityModel.html*</span></span>](http://martinfowler.com/articles/richardsonMaturityModel.html)

-   <span data-ttu-id="36ef8-208">**Swagger です。**</span><span class="sxs-lookup"><span data-stu-id="36ef8-208">**Swagger.**</span></span> <span data-ttu-id="36ef8-209">公式サイトです。</span><span class="sxs-lookup"><span data-stu-id="36ef8-209">The official site.</span></span>
    [<span data-ttu-id="36ef8-210">*http://swagger.io/*</span><span class="sxs-lookup"><span data-stu-id="36ef8-210">*http://swagger.io/*</span></span>](http://swagger.io/)

### <a name="push-and-real-time-communication-based-on-http"></a><span data-ttu-id="36ef8-211">プッシュおよび HTTP に基づいてリアルタイム コミュニケーション</span><span class="sxs-lookup"><span data-stu-id="36ef8-211">Push and real-time communication based on HTTP</span></span>

<span data-ttu-id="36ef8-212">上位レベルのフレームワークとリアルタイムと一対多の通信がなど、(通常、残りの部分よりもさまざまな目的は) 可能性[ASP.NET SignalR](https://www.asp.net/signalr)などのプロトコルと[Websocket](https://en.wikipedia.org/wiki/WebSocket)です。</span><span class="sxs-lookup"><span data-stu-id="36ef8-212">Another possibility (usually for different purposes than REST) is a real-time and one-to-many communication with higher-level frameworks such as [ASP.NET SignalR](https://www.asp.net/signalr) and protocols such as [WebSockets](https://en.wikipedia.org/wiki/WebSocket).</span></span>

<span data-ttu-id="36ef8-213">図 4-17 では、リアルタイムの HTTP 通信は、サーバー コード、サーバーを新しいデータを要求するクライアントを待機するのではなく、データが利用可能になるように接続しているクライアントにコンテンツをプッシュしたことを意味します。</span><span class="sxs-lookup"><span data-stu-id="36ef8-213">As Figure 4-17 shows, real-time HTTP communication means that you can have server code pushing content to connected clients as the data becomes available, rather than having the server wait for a client to request new data.</span></span>

![](./media/image17.png)

<span data-ttu-id="36ef8-214">**図 4-17**です。</span><span class="sxs-lookup"><span data-stu-id="36ef8-214">**Figure 4-17**.</span></span> <span data-ttu-id="36ef8-215">一対一のリアルタイム非同期メッセージ通信</span><span class="sxs-lookup"><span data-stu-id="36ef8-215">One-to-one real-time asynchronous message communication</span></span>

<span data-ttu-id="36ef8-216">通信がリアルタイムであるため、クライアント アプリがほぼ瞬時に変更内容を表示します。</span><span class="sxs-lookup"><span data-stu-id="36ef8-216">Since communication is in real time, client apps show the changes almost instantly.</span></span> <span data-ttu-id="36ef8-217">これは通常、多くの Websocket 接続 (クライアントごとに 1 つ) を使用して Websocket などのプロトコルによって処理されます。</span><span class="sxs-lookup"><span data-stu-id="36ef8-217">This is usually handled by a protocol such as WebSockets, using many WebSockets connections (one per client).</span></span> <span data-ttu-id="36ef8-218">典型的な例は、サービスが同時に多くのクライアントの web アプリにスポーツ ゲームのスコアの変更が通信する場合です。</span><span class="sxs-lookup"><span data-stu-id="36ef8-218">A typical example is when a service communicates a change in the score of a sports game to many client web apps simultaneously.</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="36ef8-219">[前](direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md) [次へ] (非同期のメッセージに基づく-communication.md)</span><span class="sxs-lookup"><span data-stu-id="36ef8-219">[Previous] (direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md) [Next] (asynchronous-message-based-communication.md)</span></span>
