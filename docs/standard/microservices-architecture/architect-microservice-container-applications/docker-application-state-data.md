---
title: Docker アプリケーションの状態とデータ
description: コンテナー化された .NET アプリケーションの .NET マイクロサービス アーキテクチャ | Docker アプリケーションの状態とデータ
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 10/18/2017
ms.openlocfilehash: c5cfe617335d8150d069149ac87f79206b1b5eca
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/04/2018
ms.locfileid: "33578656"
---
# <a name="state-and-data-in-docker-applications"></a>Docker アプリケーションの状態とデータ

ほとんどの場合、コンテナーはプロセスのインスタンスと考えることができます。 プロセスは永続的な状態を維持しません。 コンテナーからローカル ストレージに書き込まれる可能性がありますが、インスタンスが無期限に存在すると想定することは、メモリ内の単一の場所が持続的であると想定するようなものです。 コンテナー イメージは、プロセスと同様に、複数のインスタンスがあると想定するか、最終的には強制終了されると想定する必要があります。コンテナー オーケストレーターを使用して管理されている場合は、あるノードまたは VM から別のノードまたは VM に移動する可能性があると想定する必要があります。

Docker には、*オーバーレイ ファイル システム*という機能があります。 この機能に、コンテナーのルート ファイル システムに更新された情報を保存するコピー オン ライト タスクが実装されています。 この情報とは別に、コンテナーの基になっている元のイメージがあります。 コンテナーがシステムから削除された場合、それらの変更は失われます。 そのため、ローカル ストレージ内にコンテナーの状態を保存することはできますが、それを中心にシステムを設計することは、既定ではステートレスなコンテナー設計の前提と矛盾します。

Docker アプリケーションで永続的なデータを管理するには、次のソリューションを使用します。

-   ホストにマウントする[データ ボリューム](https://docs.docker.com/engine/tutorials/dockervolumes/)。

-   外部コンテナーを使用してコンテナー全体に共有ストレージを提供する[データ ボリューム コンテナー](https://docs.docker.com/engine/tutorials/dockervolumes/#creating-and-mounting-a-data-volume-container)。

-   ボリュームをリモート サービスにマウントし、長期的な永続性を提供する[ボリューム プラグイン](https://docs.docker.com/engine/tutorials/dockervolumes/)。

-   [Azure Storage](https://docs.microsoft.com/azure/storage/)。地理的に分散可能なストレージを提供し、コンテナーに適した長期的で持続性の高いソリューションを提供します。

-   [Azure SQL Database](https://azure.microsoft.com/services/sql-database/) のようなリモート リレーショナル データベース、[Azure Cosmos DB](https://docs.microsoft.com/azure/cosmos-db/introduction) のような NoSQL データベース、[Redis](https://redis.io/) のようなキャッシュ サービス。

次にこれらの選択肢の詳細について説明します。

**データ ボリューム**は、ホスト OS からコンテナー内のディレクトリにマップされたディレクトリです。 コンテナー内のコードがディレクトリへのアクセス権を持っている場合、それは実際にはホスト OS 上のディレクトリに対するアクセス権です。 このディレクトリは、コンテナー自体の有効期間とは関連付けられていません。このディレクトリには、ホスト OS 上で直接実行されるコード、または同じホスト ディレクトリを自身にマップする別のコンテナーからアクセスできます。 したがって、データ ボリュームは、コンテナーの有効期間とは独立してデータを保持するように設計されます。 Docker ホストからコンテナーまたはイメージを削除した場合、データ ボリュームに保持されているデータは削除されません。 ボリューム内のデータには、ホスト OS からもアクセスできます。

**データ ボリューム コンテナー**は、通常のデータ ボリュームが進化したものです。 データ ボリューム コンテナーは、内部に 1 つ以上のデータ ボリュームがある単純なコンテナーです。 データ ボリューム コンテナーを使用すると、中央のマウント ポイントからコンテナーへアクセスできます。 このデータ アクセス方法は、元のデータの場所が抽象化されるので便利です。 それ以外の動作は、通常のデータ ボリュームの動作と似ています。そのため、アプリケーションのコンテナーのライフサイクルとは独立して、データはこの専用のコンテナーに保持されます。

図 4-5 に示すように、通常の Docker ボリュームは、コンテナー自体の外部 (ただし、ホスト サーバーまたは VM の物理的境界内) に格納できます。 ただし、Docker コンテナーは、あるホスト サーバーまたは VM から別のホスト サーバーまたは VM のボリュームにアクセスすることはできません。 つまり、このようなボリュームでは、異なる Docker ホスト上で実行されるコンテナー間で共有されるデータを管理することはできません

![](./media/image5.png)

**図 4-5** コンテナーベースのアプリケーションのデータ ボリュームと外部データ ソース

さらに、オーケストレーターが Docker コンテナーを管理する場合、クラスターによって実行される最適化に応じて、ホスト間でコンテナーが "移動" する可能性があります。 そのため、ビジネス データにデータ ボリュームを使用することはお勧めしません。 ただし、ビジネス データの一貫性に影響を与えないトレース ファイルやテンポラル ファイルなどを処理する場合には適しているメカニズムです。

[Flocker](https://clusterhq.com/flocker/) のような**ボリューム プラグイン**は、クラスター内のすべてのホストにデータ アクセスを提供します。 すべてのボリューム プラグインが同様に作成されているわけではありませんが、通常、ボリューム プラグインは、不変のコンテナーから外部化された永続的で信頼性の高いストレージを提供します。

Azure SQL Database、Azure Cosmos DB のような**リモート データ ソースとキャッシュ**、または Redis のようなリモート キャッシュは、コンテナーなしで開発する場合と同じ方法でコンテナー化アプリケーションで使用できます。 これは、ビジネス アプリケーション データを格納する実績のある方法です。

**Azure Storage。** ビジネス データは、通常、Azure Storage のような外部リソースやデータベースに配置する必要があります。 具体的には、Azure Storage はクラウドで次のサービスを提供します。

-   BLOB ストレージには、非構造化オブジェクト データが格納されます。 BLOB は、ドキュメントやメディア ファイル (画像、オーディオ、ビデオ ファイル) など、任意の種類のテキストまたはバイナリ データの可能性があります。 BLOB ストレージは、オブジェクト ストレージとも呼ばれます。

-   ファイル ストレージは、標準の SMB プロトコルを使用するレガシ アプリケーション用の共有ストレージを提供します。 Azure 仮想マシンとクラウド サービスは、マウントされた共有を介してアプリケーション コンポーネント全体でファイル データを共有できます。 オンプレミス アプリケーションは、ファイル サービス REST API を介して共有内のファイル データにアクセスできます。

-   テーブル ストレージには、構造化データセットが格納されます。 テーブル ストレージは NoSQL のキー属性データ ストアであり、迅速な開発と大量のデータへの高速アクセスが可能です。

**リレーショナル データベースと NoSQL データベース。** 外部データベースには、SQL Server、PostgreSQL、Oracle のようなリレーショナル データベースや、Azure Cosmos DB、MongoDB のような NoSQL データベースなど、多くの選択肢があります。これらのデータベースについては、まったく異なる話題なので、このガイドでは説明しません。


>[!div class="step-by-step"]
[Previous] (containerize-monolithic-applications.md) [Next] (service-oriented-architecture.md)
