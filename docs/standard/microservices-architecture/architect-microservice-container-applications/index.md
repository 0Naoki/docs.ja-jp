---
title: "コンテナーとマイクロサービス ベースのアプリケーションの設計"
description: ".NET マイクロサービス: コンテナー化された .NET アプリケーションのアーキテクチャ | コンテナーとマイクロサービス ベースのアプリケーションの設計"
keywords: "Docker, マイクロサービス, ASP.NET, コンテナー"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: 246605b301f6bcea4cced2cb7d1c494e9f66aa4a
ms.sourcegitcommit: c2e216692ef7576a213ae16af2377cd98d1a67fa
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/22/2017
---
# <a name="architecting-container--and-microservice-based-applications"></a><span data-ttu-id="04f6a-104">コンテナーとマイクロサービス ベースのアプリケーションの設計</span><span class="sxs-lookup"><span data-stu-id="04f6a-104">Architecting Container- and Microservice-Based Applications</span></span>

<span data-ttu-id="04f6a-105">*マイクロサービスは大きな利点がありますが、大きな新しい課題を発生させます。マイクロ サービス アーキテクチャ パターンは、マイクロサービス ベースのアプリケーションを作成するときの基本的な柱です。*</span><span class="sxs-lookup"><span data-stu-id="04f6a-105">*Microservices offer great benefits but also raise huge new challenges. Microservice architecture patterns are fundamental pillars when creating a microservice-based application.*</span></span>

<span data-ttu-id="04f6a-106">このガイドの前半では、コンテナーと Docker の基本的な概念を学習しました。</span><span class="sxs-lookup"><span data-stu-id="04f6a-106">Earlier in this guide, you learned basic concepts about containers and Docker.</span></span> <span data-ttu-id="04f6a-107">これはコンテナーの使用を開始するために必要な最小限の情報です。</span><span class="sxs-lookup"><span data-stu-id="04f6a-107">That was the minimum information you need in order to get started with containers.</span></span> <span data-ttu-id="04f6a-108">コンテナーがマイクロサービスの実現要素であり、マイクロサービスに最適な場合であっても、マイクロサービス アーキテクチャに必須ではなく、このアーキテクチャ セクションの多くのアーキテクチャの概念はコンテナーなしでも適用できます。</span><span class="sxs-lookup"><span data-stu-id="04f6a-108">Although, even when containers are enablers and a great fit for microservices, they are not mandatory for a microservice architecture and many architectural concepts in this architecture section could be applied without containers, too.</span></span> <span data-ttu-id="04f6a-109">ただし、このガイドでは、既に導入されたコンテナーの重要性のための、両方の共通部分に焦点を当てます。</span><span class="sxs-lookup"><span data-stu-id="04f6a-109">However, this guidance focuses on the intersection of both due to the already introduced importance of containers.</span></span>

<span data-ttu-id="04f6a-110">エンタープライズ アプリケーションでは、複雑になることがあり、多くの場合 1 つのサービス ベースのアプリケーションではなく、複数のサービスで構成されます。</span><span class="sxs-lookup"><span data-stu-id="04f6a-110">Enterprise applications can be complex and are often composed of multiple services instead of a single service-based application.</span></span> <span data-ttu-id="04f6a-111">このような場合、マイクロサービス、特定のドメイン駆動型設計 (DDD) パターン、コンテナー オーケストレーションの概念など、追加のアーキテクチャの手法を理解する必要があります。</span><span class="sxs-lookup"><span data-stu-id="04f6a-111">For those cases, you need to understand additional architectural approaches, such as the microservices and certain Domain-Driven Design (DDD) patterns plus container orchestration concepts.</span></span> <span data-ttu-id="04f6a-112">この章では、コンテナー上のマイクロサービスだけでなく、コンテナー化されたアプリケーションについても説明することに注意してください。</span><span class="sxs-lookup"><span data-stu-id="04f6a-112">Note that this chapter describes not just microservices on containers, but any containerized application, as well.</span></span>

## <a name="container-design-principles"></a><span data-ttu-id="04f6a-113">コンテナー設計の原則</span><span class="sxs-lookup"><span data-stu-id="04f6a-113">Container design principles</span></span>

<span data-ttu-id="04f6a-114">コンテナー モデルでは、コンテナー イメージのインスタンスは 1 つのプロセスを表します。</span><span class="sxs-lookup"><span data-stu-id="04f6a-114">In the container model, a container image instance represents a single process.</span></span> <span data-ttu-id="04f6a-115">コンテナー イメージのプロセス境界として定義すると、プロセスの拡張やバッチ処理に使用できるプリミティブを作成できます。</span><span class="sxs-lookup"><span data-stu-id="04f6a-115">By defining a container image as a process boundary, you can create primitives that can be used to scale the process or to batch it.</span></span>

<span data-ttu-id="04f6a-116">コンテナー イメージをデザインするときには、[ENTRYPOINT](https://docs.docker.com/engine/reference/builder/) 定義が Dockerfile に表示されます。</span><span class="sxs-lookup"><span data-stu-id="04f6a-116">When you design a container image, you will see an [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/) definition in the Dockerfile.</span></span> <span data-ttu-id="04f6a-117">これで定義するプロセスの有効期間が、コンテナーの有効期間を制御します。</span><span class="sxs-lookup"><span data-stu-id="04f6a-117">This defines the process whose lifetime controls the lifetime of the container.</span></span> <span data-ttu-id="04f6a-118">プロセスが完了すると、コンテナーのライフサイクルが終了します。</span><span class="sxs-lookup"><span data-stu-id="04f6a-118">When the process completes, the container lifecycle ends.</span></span> <span data-ttu-id="04f6a-119">コンテナーは、Web サーバーなどの実行時間の長いプロセスを表す場合がありますが、以前は Azure の [WebJobs](https://docs.microsoft.com/azure/app-service-web/websites-webjobs-resources) として実装される場合があったバッチ ジョブなどの有効期間が短いプロセスも表すことができます。</span><span class="sxs-lookup"><span data-stu-id="04f6a-119">Containers might represent long-running processes like web servers, but can also represent short-lived processes like batch jobs, which formerly might have been implemented as Azure [WebJobs](https://docs.microsoft.com/azure/app-service-web/websites-webjobs-resources).</span></span>

<span data-ttu-id="04f6a-120">プロセスが失敗した場合、コンテナーが終了し、Orchestrator が引き継ぎます。</span><span class="sxs-lookup"><span data-stu-id="04f6a-120">If the process fails, the container ends, and the orchestrator takes over.</span></span> <span data-ttu-id="04f6a-121">Orchestrator が 5 つのインスタンスの実行を維持するように構成され、1 つが失敗した場合、Orchestrator は、失敗したプロセスを置換する別のコンテナー インスタンスを作成します。</span><span class="sxs-lookup"><span data-stu-id="04f6a-121">If the orchestrator was configured to keep five instances running and one fails, the orchestrator will create another container instance to replace the failed process.</span></span> <span data-ttu-id="04f6a-122">バッチ ジョブで、プロセスはパラメーターを指定して開始されます。</span><span class="sxs-lookup"><span data-stu-id="04f6a-122">In a batch job, the process is started with parameters.</span></span> <span data-ttu-id="04f6a-123">プロセスが完了すると、作業が完了します。</span><span class="sxs-lookup"><span data-stu-id="04f6a-123">When the process completes, the work is complete.</span></span> <span data-ttu-id="04f6a-124">このガイダンスでは、後でオーケストレーターについてドリル ダウンします。</span><span class="sxs-lookup"><span data-stu-id="04f6a-124">This guidance drills-down on orchestrators, later on.</span></span>

<span data-ttu-id="04f6a-125">1 つのコンテナーで複数のプロセスが実行されているシナリオが見られる場合があります。</span><span class="sxs-lookup"><span data-stu-id="04f6a-125">You might find a scenario where you want multiple processes running in a single container.</span></span> <span data-ttu-id="04f6a-126">このシナリオでは、コンテナーごとに 1 つのエントリ ポイントのみが存在できるため、必要な数のプログラムを起動するスクリプトをコンテナー内で実行できます。</span><span class="sxs-lookup"><span data-stu-id="04f6a-126">For that scenario, since there can be only one entry point per container, you could run a script within the container that launches as many programs as needed.</span></span> <span data-ttu-id="04f6a-127">たとえば、[スーパーバイザー](http://supervisord.org/)または同様のツールを使用して、1 つのコンテナー内で複数のプロセスの起動を処理できます。</span><span class="sxs-lookup"><span data-stu-id="04f6a-127">For example, you can use [Supervisor](http://supervisord.org/) or a similar tool to take care of launching multiple processes inside a single container.</span></span> <span data-ttu-id="04f6a-128">ただし、コンテナーごとに複数のプロセスを保持するアーキテクチャが見られる場合でも、その方法はあまり一般的ではありません。</span><span class="sxs-lookup"><span data-stu-id="04f6a-128">However, even though you can find architectures that hold multiple processes per container, that approach it is not very common.</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="04f6a-129">[Previous] (../net-core-net-framework-containers/official-net-docker-images.md) [Next] (containerize-monolithic-applications.md)</span><span class="sxs-lookup"><span data-stu-id="04f6a-129">[Previous] (../net-core-net-framework-containers/official-net-docker-images.md) [Next] (containerize-monolithic-applications.md)</span></span>
