---
title: "Containerizing モノリシック アプリケーション"
description: "コンテナーの .NET アプリケーションの .NET Microservices アーキテクチャ |Containerizing モノリシック アプリケーション"
keywords: "Docker, マイクロサービス, ASP.NET, コンテナー"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: 11e2c24403b9b61584e424696c844e00e5d34b03
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/21/2017
---
# <a name="containerizing-monolithic-applications"></a><span data-ttu-id="ee669-104">Containerizing モノリシック アプリケーション</span><span class="sxs-lookup"><span data-stu-id="ee669-104">Containerizing monolithic applications</span></span>

<span data-ttu-id="ee669-105">Monolithically 展開された、1 つの web アプリケーションまたはサービスをビルドし、コンテナーとして展開する場合があります。</span><span class="sxs-lookup"><span data-stu-id="ee669-105">You might want to build a single, monolithically deployed web application or service and deploy it as a container.</span></span> <span data-ttu-id="ee669-106">アプリケーション自体は内部的にモノリシックできない可能性がありますが、いくつかのライブラリ、コンポーネント、または (アプリケーション レイヤーでドメイン層、データ アクセス層など) でもレイヤーを構造化します。</span><span class="sxs-lookup"><span data-stu-id="ee669-106">The application itself might not be internally monolithic, but structured as several libraries, components, or even layers (application layer, domain layer, data-access layer, etc.).</span></span> <span data-ttu-id="ee669-107">外部で、ただし、これは 1 つのコンテナー-1 つのプロセス、1 つの web アプリケーション、または 1 つのサービスです。</span><span class="sxs-lookup"><span data-stu-id="ee669-107">Externally, however, it is a single container—a single process, a single web application, or a single service.</span></span>

<span data-ttu-id="ee669-108">このモデルを管理するには、アプリケーションを表すための 1 つのコンテナーを展開します。</span><span class="sxs-lookup"><span data-stu-id="ee669-108">To manage this model, you deploy a single container to represent the application.</span></span> <span data-ttu-id="ee669-109">スケール アップ、だけをロード バランサーを前面にでより多くのコピーを追加します。</span><span class="sxs-lookup"><span data-stu-id="ee669-109">To scale up, you just add more copies with a load balancer in front.</span></span> <span data-ttu-id="ee669-110">簡単な 1 つのコンテナーまたは VM で単一の展開の管理に由来します。</span><span class="sxs-lookup"><span data-stu-id="ee669-110">The simplicity comes from managing a single deployment in a single container or VM.</span></span>

![](./media/image1.png)

<span data-ttu-id="ee669-111">**図 4-1**です。</span><span class="sxs-lookup"><span data-stu-id="ee669-111">**Figure 4-1**.</span></span> <span data-ttu-id="ee669-112">モノリシック コンテナー化アプリケーションのアーキテクチャの例</span><span class="sxs-lookup"><span data-stu-id="ee669-112">Example of the architecture of a containerized monolithic application</span></span>

<span data-ttu-id="ee669-113">図 4-1 に示すように各コンテナーに複数のコンポーネント、ライブラリ、または内部のレイヤーを含めることができます。</span><span class="sxs-lookup"><span data-stu-id="ee669-113">You can include multiple components, libraries, or internal layers in each container, as illustrated in Figure 4-1.</span></span> <span data-ttu-id="ee669-114">ただし、このモノリシックなパターンがあります競合「コンテナーは、1 つし、1 つのプロセスでは、」可能性があるコンテナーの原則を使用する一部のケース [ok] です。</span><span class="sxs-lookup"><span data-stu-id="ee669-114">However, this monolithic pattern might conflict with the container principle “a container does one thing, and does it in one process”, but might be ok for some cases.</span></span>

<span data-ttu-id="ee669-115">このアプローチの欠点は、拡張を必要とするアプリケーションが増加する場合に顕著になります。</span><span class="sxs-lookup"><span data-stu-id="ee669-115">The downside of this approach becomes evident if the application grows, requiring it to scale.</span></span> <span data-ttu-id="ee669-116">アプリケーション全体が拡張可能である場合は本当に問題</span><span class="sxs-lookup"><span data-stu-id="ee669-116">If the entire application can scale, it is not really a problem.</span></span> <span data-ttu-id="ee669-117">ただし、ほとんどの場合、アプリケーションのいくつかの部分はスケーリングを必要とする他のコンポーネントがときに使用される小さいチョーク ポイント。</span><span class="sxs-lookup"><span data-stu-id="ee669-117">However, in most cases, just a few parts of the application are the choke points that requiring scaling, while other components are used less.</span></span>

<span data-ttu-id="ee669-118">たとえば、一般的な e コマース アプリケーションで可能性がありますのでが必要、製品情報サブシステムを拡張する購入するよりも多くのユーザーが製品を参照します。</span><span class="sxs-lookup"><span data-stu-id="ee669-118">For example, in a typical e-commerce application, you likely need to scale the product information subsystem, because many more customers browse products than purchase them.</span></span> <span data-ttu-id="ee669-119">支払パイプラインを使用するより多くの顧客は、バスケットを使用します。</span><span class="sxs-lookup"><span data-stu-id="ee669-119">More customers use their basket than use the payment pipeline.</span></span> <span data-ttu-id="ee669-120">少ない顧客は、コメントを追加または、購入履歴を表示します。</span><span class="sxs-lookup"><span data-stu-id="ee669-120">Fewer customers add comments or view their purchase history.</span></span> <span data-ttu-id="ee669-121">コンテンツやマーケティング キャンペーンを管理する必要がある従業員のほんの一部のみがある可能性があります。</span><span class="sxs-lookup"><span data-stu-id="ee669-121">And you might have only a handful of employees, that need to manage the content and marketing campaigns.</span></span> <span data-ttu-id="ee669-122">モノリシックな設計を拡張する場合、これらのさまざまなタスクのすべてのコードが複数回の展開され、同じグレードに拡大/縮小します。</span><span class="sxs-lookup"><span data-stu-id="ee669-122">If you scale the monolithic design, all the code for these different tasks is deployed multiple times and scaled at the same grade.</span></span>

<span data-ttu-id="ee669-123">アプリケーションの拡張をいくつかの方法: 水平方向の重複、アプリケーション、およびパーティション分割のようなビジネスの概念やデータのさまざまな領域を分割します。</span><span class="sxs-lookup"><span data-stu-id="ee669-123">There are multiple ways to scale an application—horizontal duplication, splitting different areas of the application, and partitioning similar business concepts or data.</span></span> <span data-ttu-id="ee669-124">ただし、すべてのコンポーネントのスケーリングの問題、に加えて 1 つのコンポーネントへの変更を必要と、アプリケーション全体とすべてのインスタンスの再配置の完了の完全な再テストします。</span><span class="sxs-lookup"><span data-stu-id="ee669-124">But, in addition to the problem of scaling all components, changes to a single component require complete retesting of the entire application, and a complete redeployment of all the instances.</span></span>

<span data-ttu-id="ee669-125">ただし、モノリシックなアプローチが一般的では、アプリケーションの開発は microservices アプローチを最初により簡単です。</span><span class="sxs-lookup"><span data-stu-id="ee669-125">However, the monolithic approach is common, because the development of the application is initially easier than for microservices approaches.</span></span> <span data-ttu-id="ee669-126">したがって、多くの組織は、このアーキテクチャのアプローチを使用して開発します。</span><span class="sxs-lookup"><span data-stu-id="ee669-126">Thus, many organizations develop using this architectural approach.</span></span> <span data-ttu-id="ee669-127">一部の組織は、十分な結果良いいたが、間に制限他ヒットします。</span><span class="sxs-lookup"><span data-stu-id="ee669-127">While some organizations have had good enough results, others are hitting limits.</span></span> <span data-ttu-id="ee669-128">多くの組織には、ツールとインフラストラクチャ困難になることもサービスを構築する指向アーキテクチャ (SOA) 年前に、および成功必要性が確認できなかったために、このモデルを使用して、アプリケーションが設計されています: アプリケーションが拡張されるまでです。</span><span class="sxs-lookup"><span data-stu-id="ee669-128">Many organizations designed their applications using this model because tools and infrastructure made it too difficult to build service oriented architectures (SOA) years ago, and they did not see the need—until the application grew.</span></span>

<span data-ttu-id="ee669-129">インフラストラクチャの観点からは、各サーバーは、同じホスト内で多くのアプリケーションを実行し、図 4-2 に示すように、リソース使用量の効率性の許容の比率があります。</span><span class="sxs-lookup"><span data-stu-id="ee669-129">From an infrastructure perspective, each server can run many applications within the same host and have an acceptable ratio of efficiency in resources usage, as shown in Figure 4-2.</span></span>

![](./media/image2.png)

<span data-ttu-id="ee669-130">**図 4-2**です。</span><span class="sxs-lookup"><span data-stu-id="ee669-130">**Figure 4-2**.</span></span> <span data-ttu-id="ee669-131">モノリシックなアプローチ各アプリのコンテナーとして実行されているホストの複数のアプリを実行している。</span><span class="sxs-lookup"><span data-stu-id="ee669-131">Monolithic approach: Host running multiple apps, each app running as a container</span></span>

<span data-ttu-id="ee669-132">Microsoft Azure での単一のアプリケーションは、インスタンスごとに専用の仮想マシンを使用して展開できます。</span><span class="sxs-lookup"><span data-stu-id="ee669-132">Monolithic applications in Microsoft Azure can be deployed using dedicated VMs for each instance.</span></span> <span data-ttu-id="ee669-133">さらを使用して[Azure VM スケール セット](https://docs.microsoft.com/azure/virtual-machine-scale-sets/)Vm を簡単に拡張することができます。</span><span class="sxs-lookup"><span data-stu-id="ee669-133">Additionally, using [Azure VM Scale Sets](https://docs.microsoft.com/azure/virtual-machine-scale-sets/), you can easily scale the VMs.</span></span> <span data-ttu-id="ee669-134">[Azure App Service](https://azure.microsoft.com/services/app-service/)もモノリシックなアプリケーションを実行し、Vm を管理することがなく、インスタンスを簡単にスケールできます。</span><span class="sxs-lookup"><span data-stu-id="ee669-134">[Azure App Service](https://azure.microsoft.com/services/app-service/) can also run monolithic applications and easily scale instances without requiring you to manage the VMs.</span></span> <span data-ttu-id="ee669-135">2016 年以降、Azure アプリ サービスは、特定の展開を簡略化することも、Docker のコンテナーの単一のインスタンスを実行できます。</span><span class="sxs-lookup"><span data-stu-id="ee669-135">Since 2016, Azure App Services can run single instances of Docker containers as well, simplifying deployment.</span></span>

<span data-ttu-id="ee669-136">QA 環境または限定された運用環境では、複数の Docker ホストの Vm を展開し、図 4-3 に示すように、Azure の負荷分散装置を使用してそれらのバランスをとることがことができます。</span><span class="sxs-lookup"><span data-stu-id="ee669-136">As a QA environment or a limited production environment, you can deploy multiple Docker host VMs and balance them using the Azure balancer, as shown in Figure 4-3.</span></span> <span data-ttu-id="ee669-137">これにより、粒度が粗いアプローチを使用したスケールを管理するため、アプリケーション全体が 1 つのコンテナー内に存在できます。</span><span class="sxs-lookup"><span data-stu-id="ee669-137">This lets you manage scaling with a coarse-grain approach, because the whole application lives within a single container.</span></span>

![](./media/image3.png)

<span data-ttu-id="ee669-138">**図 4-3**です。</span><span class="sxs-lookup"><span data-stu-id="ee669-138">**Figure 4-3**.</span></span> <span data-ttu-id="ee669-139">複数のホストを 1 つのコンテナー アプリケーションのスケール アップの例</span><span class="sxs-lookup"><span data-stu-id="ee669-139">Example of multiple hosts scaling up a single container application</span></span>

<span data-ttu-id="ee669-140">さまざまなホストへの展開は、従来の展開方法で管理できます。</span><span class="sxs-lookup"><span data-stu-id="ee669-140">Deployment to the various hosts can be managed with traditional deployment techniques.</span></span> <span data-ttu-id="ee669-141">などのコマンドで docker ホストを管理できる`docker run`または`docker-compose`手動、または継続的な配信 (CD) パイプラインなどのオートメーションによってを実行します。</span><span class="sxs-lookup"><span data-stu-id="ee669-141">Docker hosts can be managed with commands like `docker run` or `docker-compose` performed manually, or through automation such as continuous delivery (CD) pipelines.</span></span>

## <a name="deploying-a-monolithic-application-as-a-container"></a><span data-ttu-id="ee669-142">コンテナーとしてモノリシックなアプリケーションを配置します。</span><span class="sxs-lookup"><span data-stu-id="ee669-142">Deploying a monolithic application as a container</span></span>

<span data-ttu-id="ee669-143">モノリシックなアプリケーション展開を管理するコンテナーを使用する利点があります。</span><span class="sxs-lookup"><span data-stu-id="ee669-143">There are benefits to using containers to manage monolithic application deployments.</span></span> <span data-ttu-id="ee669-144">コンテナーのインスタンスをスケール、はるかに高速化およびその他の Vm をデプロイするよりも簡単です。</span><span class="sxs-lookup"><span data-stu-id="ee669-144">Scaling container instances is far faster and easier than deploying additional VMs.</span></span> <span data-ttu-id="ee669-145">VM スケール セットを使用する場合でも、起動に時間がかかり Vm です。</span><span class="sxs-lookup"><span data-stu-id="ee669-145">Even if you use VM Scale Sets, VMs take time to start.</span></span> <span data-ttu-id="ee669-146">コンテナーではなく、従来のアプリケーション インスタンスとして展開されると、アプリケーションの構成は、VM の一部として管理はこれは理想的ではありません。</span><span class="sxs-lookup"><span data-stu-id="ee669-146">When deployed as traditional application instances instead of containers, the configuration of the application is managed as part of the VM, which is not ideal.</span></span>

<span data-ttu-id="ee669-147">Docker images がはるかに高速更新の展開とネットワーク効率的です。</span><span class="sxs-lookup"><span data-stu-id="ee669-147">Deploying updates as Docker images is far faster and network efficient.</span></span> <span data-ttu-id="ee669-148">Docker イメージ通常起動 (秒単位) の展開の速度が向上します。</span><span class="sxs-lookup"><span data-stu-id="ee669-148">Docker images typically start in seconds, which speeds rollouts.</span></span> <span data-ttu-id="ee669-149">発行元と同じくらい簡単設定解除を行う Docker イメージのインスタンスは、`docker stop`コマンドを使用し、通常、1 秒未満で完了します。</span><span class="sxs-lookup"><span data-stu-id="ee669-149">Tearing down a Docker image instance is as easy as issuing a `docker stop` command, and typically completes in less than a second.</span></span>

<span data-ttu-id="ee669-150">コンテナーがデザインが変更可能なことはありません、破損している Vm について心配する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ee669-150">Because containers are immutable by design, you never need to worry about corrupted VMs.</span></span> <span data-ttu-id="ee669-151">これに対し、VM の更新スクリプトは、いくつかの特定の構成またはファイルがディスク上の残りのアカウントを忘れた可能性があります。</span><span class="sxs-lookup"><span data-stu-id="ee669-151">In contrast, update scripts for a VM might forget to account for some specific configuration or file left on disk.</span></span>

<span data-ttu-id="ee669-152">モノリシック アプリケーションにとって有益な Docker、メリットにのみお接触します。</span><span class="sxs-lookup"><span data-stu-id="ee669-152">While monolithic applications can benefit from Docker, we are touching only on the benefits.</span></span> <span data-ttu-id="ee669-153">他のコンテナーを管理する利点は、コンテナー orchestrators は、さまざまなインスタンスと各コンテナー インスタンスのライフ サイクル管理と展開から取得されます。</span><span class="sxs-lookup"><span data-stu-id="ee669-153">Additional benefits of managing containers come from deploying with container orchestrators, which manage the various instances and lifecycle of each container instance.</span></span> <span data-ttu-id="ee669-154">Microservices の領域へのエントリ ポイントは、スケール、開発、および個別に展開できるサブシステムにモノリシックなアプリケーションを分割します。</span><span class="sxs-lookup"><span data-stu-id="ee669-154">Breaking up the monolithic application into subsystems that can be scaled, developed, and deployed individually is your entry point into the realm of microservices.</span></span>

## <a name="publishing-a-single-container-based-application-to-azure-app-service"></a><span data-ttu-id="ee669-155">Azure App Service に単一のコンテナーをベースのアプリケーションの発行</span><span class="sxs-lookup"><span data-stu-id="ee669-155">Publishing a single-container-based application to Azure App Service</span></span>

<span data-ttu-id="ee669-156">Azure にデプロイされたコンテナーの検証を取得するかどうか、またはアプリケーションが単一コンテナー アプリケーションだけである場合は、Azure App Service は、単一コンテナー ベースでのスケーラブルなサービスを提供する優れた方法を提供します。</span><span class="sxs-lookup"><span data-stu-id="ee669-156">Whether you want to get validation of a container deployed to Azure or when an application is simply a single-container application, Azure App Service provides a great way to provide scalable single-container-based services.</span></span> <span data-ttu-id="ee669-157">Azure App Service を使用することは簡単です。</span><span class="sxs-lookup"><span data-stu-id="ee669-157">Using Azure App Service is simple.</span></span> <span data-ttu-id="ee669-158">コードを取得し、Visual Studio でビルドし、Azure に直接展開が簡単に Git を使用した優れた統合を提供します。</span><span class="sxs-lookup"><span data-stu-id="ee669-158">It provides great integration with Git to make it easy to take your code, build it in Visual Studio, and deploy it directly to Azure.</span></span>

![](./media/image4.png)

<span data-ttu-id="ee669-159">**図 4-4**です。</span><span class="sxs-lookup"><span data-stu-id="ee669-159">**Figure 4-4**.</span></span> <span data-ttu-id="ee669-160">Visual Studio から Azure App Service に単一コンテナー アプリケーションの発行</span><span class="sxs-lookup"><span data-stu-id="ee669-160">Publishing a single-container application to Azure App Service from Visual Studio</span></span>

<span data-ttu-id="ee669-161">Docker, せず他の機能、フレームワーク、または Azure App Service でサポートされていない依存関係が必要な場合必要がありました Azure チームは、App Service でそれらの依存関係を更新するまで待機します。</span><span class="sxs-lookup"><span data-stu-id="ee669-161">Without Docker, if you needed other capabilities, frameworks, or dependencies that are not supported in Azure App Service, you had to wait until the Azure team updated those dependencies in App Service.</span></span> <span data-ttu-id="ee669-162">または、他のサービスを Azure Service Fabric、Azure クラウド サービス、またはであっても、その Vm をさらに制御があり、アプリケーションの必要なコンポーネントまたはフレームワークをインストールする可能性がありますに切り替える必要がありました。</span><span class="sxs-lookup"><span data-stu-id="ee669-162">Or you had to switch to other services like Azure Service Fabric, Azure Cloud Services, or even VMs, where you had further control and you could install a required component or framework for your application.</span></span>

<span data-ttu-id="ee669-163">Visual Studio 2017 でコンテナー サポートでは、図 4-4 に示すように、アプリケーション環境に自由に含める機能を提供します。</span><span class="sxs-lookup"><span data-stu-id="ee669-163">Container support in Visual Studio 2017 gives you the ability to include whatever you want in your application environment, as shown in Figure 4-4.</span></span> <span data-ttu-id="ee669-164">設定されているために、コンテナーで、アプリケーションに依存関係を追加する場合、Dockerfile または Docker イメージの依存関係を含めることができます。</span><span class="sxs-lookup"><span data-stu-id="ee669-164">Since you are running it in a container, if you add a dependency to your application, you can include the dependency in your Dockerfile or Docker image.</span></span>

<span data-ttu-id="ee669-165">表示されている図 4-4、としては、発行フローは、コンテナー レジストリを使用してイメージをプッシュします。</span><span class="sxs-lookup"><span data-stu-id="ee669-165">As also shown in Figure 4-4, the publish flow pushes an image through a container registry.</span></span> <span data-ttu-id="ee669-166">これは、Azure コンテナー レジストリ (レジストリは、Azure でデプロイを閉じるし、Azure Active Directory グループとアカウントによって保護された) または Docker Hub または内部設置型レジストリなどの他の Docker レジストリに指定できます。</span><span class="sxs-lookup"><span data-stu-id="ee669-166">This can be the Azure Container Registry (a registry close to your deployments in Azure and secured by Azure Active Directory groups and accounts), or any other Docker registry, like Docker Hub or an on-premises registry.</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="ee669-167">[前](index.md) [次へ] (docker-アプリケーションの状態-data.md)</span><span class="sxs-lookup"><span data-stu-id="ee669-167">[Previous] (index.md) [Next] (docker-application-state-data.md)</span></span>
