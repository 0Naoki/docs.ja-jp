---
title: "メッセージ ベースの非同期通信"
description: "コンテナーの .NET アプリケーションの .NET Microservices アーキテクチャ |メッセージ ベースの非同期通信"
keywords: "Docker, マイクロサービス, ASP.NET, コンテナー"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: df39771295d12e122edbe27e91cd899e3318e301
ms.sourcegitcommit: c2e216692ef7576a213ae16af2377cd98d1a67fa
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/22/2017
---
# <a name="asynchronous-message-based-communication"></a><span data-ttu-id="a06c6-104">メッセージ ベースの非同期通信</span><span class="sxs-lookup"><span data-stu-id="a06c6-104">Asynchronous message-based communication</span></span>

<span data-ttu-id="a06c6-105">非同期メッセージングとイベント ドリブンの通信は、複数の microservices とその関連ドメイン モデル間での変更を反映するときに重要です。</span><span class="sxs-lookup"><span data-stu-id="a06c6-105">Asynchronous messaging and event-driven communication are critical when propagating changes across multiple microservices and their related domain models.</span></span> <span data-ttu-id="a06c6-106">前述のとおり、ディスカッション microservices と範囲指定されたコンテキスト (BCs)、モデル (ユーザー、顧客、製品、アカウントなど) を異なる microservices または BCs 立場に応じてさまざまなを意味します。</span><span class="sxs-lookup"><span data-stu-id="a06c6-106">As mentioned earlier in the discussion microservices and Bounded Contexts (BCs), models (User, Customer, Product, Account, etc.) can mean different things to different microservices or BCs.</span></span> <span data-ttu-id="a06c6-107">を変更した場合は、別のモデル間での変更を調整するために何らかの方法が必要なことを意味します。</span><span class="sxs-lookup"><span data-stu-id="a06c6-107">That means that when changes occur, you need some way to reconcile changes across the different models.</span></span> <span data-ttu-id="a06c6-108">ソリューションは、最終的整合性と非同期メッセージングに基づき、イベント ドリブン通信です。</span><span class="sxs-lookup"><span data-stu-id="a06c6-108">A solution is eventual consistency and event-driven communication based on asynchronous messaging.</span></span>

<span data-ttu-id="a06c6-109">メッセージングを使用して、プロセスは非同期的にメッセージを交換して通信します。</span><span class="sxs-lookup"><span data-stu-id="a06c6-109">When using messaging, processes communicate by exchanging messages asynchronously.</span></span> <span data-ttu-id="a06c6-110">クライアントが、コマンドまたは要求をサービス メッセージを送信しています。</span><span class="sxs-lookup"><span data-stu-id="a06c6-110">A client makes a command or a request to a service by sending it a message.</span></span> <span data-ttu-id="a06c6-111">サービスは、返信する必要があります、クライアントにさまざまなメッセージを送信します。</span><span class="sxs-lookup"><span data-stu-id="a06c6-111">If the service needs to reply, it sends a different message back to the client.</span></span> <span data-ttu-id="a06c6-112">メッセージ ベースの通信のため、クライアントで、応答が受信されず、すぐと、ある可能性がありますいない応答まったくを使用します。</span><span class="sxs-lookup"><span data-stu-id="a06c6-112">Since it is a message-based communication, the client assumes that the reply will not be received immediately, and that there might be no response at all.</span></span>

<span data-ttu-id="a06c6-113">メッセージは、ヘッダー (id やセキュリティ情報などのメタデータ) と本文で構成されます。</span><span class="sxs-lookup"><span data-stu-id="a06c6-113">A message is composed by a header (metadata such as identification or security information) and a body.</span></span> <span data-ttu-id="a06c6-114">通常、メッセージは AMQP のような非同期プロトコルを通じて送信されます。</span><span class="sxs-lookup"><span data-stu-id="a06c6-114">Messages are usually sent through asynchronous protocols like AMQP.</span></span>

<span data-ttu-id="a06c6-115">優先インフラストラクチャ microservices コミュニティでの通信のこの型は、軽量のメッセージ ブローカー、大規模なブローカーと orchestrators SOA で使用されているとは異なります。</span><span class="sxs-lookup"><span data-stu-id="a06c6-115">The preferred infrastructure for this type of communication in the microservices community is a lightweight message broker, which is different than the large brokers and orchestrators used in SOA.</span></span> <span data-ttu-id="a06c6-116">軽量のメッセージ ブローカーのインフラストラクチャです通常"、"RabbitMQ や Azure Service Bus のようなクラウドでのスケーラブルな service bus などの単純な実装とのメッセージ ブローカーとしてのみ機能します。</span><span class="sxs-lookup"><span data-stu-id="a06c6-116">In a lightweight message broker, the infrastructure is typically “dumb,” acting only as a message broker, with simple implementations such as RabbitMQ or a scalable service bus in the cloud like Azure Service Bus.</span></span> <span data-ttu-id="a06c6-117">このシナリオで「スマート」考え方のほとんどは従来どおり生成され、メッセージを処理するエンドポイントで、つまり、microservices で。</span><span class="sxs-lookup"><span data-stu-id="a06c6-117">In this scenario, most of the “smart” thinking still lives in the endpoints that are producing and consuming messages—that is, in the microservices.</span></span>

<span data-ttu-id="a06c6-118">別の規則に従うと、可能な限りしようとする必要がありますが、内部のサービス間で唯一の非同期メッセージングを使用して、フロント エンド サービス (API ゲートウェイと、最初のレベルには、クライアント アプリケーションからのみ (HTTP など) の同期通信を使用するにはmicroservices)。</span><span class="sxs-lookup"><span data-stu-id="a06c6-118">Another rule you should try to follow, as much as possible, is to use only asynchronous messaging between the internal services, and to use synchronous communication (such as HTTP) only from the client apps to the front-end services (API Gateways plus the first level of microservices).</span></span>

<span data-ttu-id="a06c6-119">非同期メッセージング通信の 2 種類があります。 単一の受信者メッセージ ベースの通信、および複数の受信者メッセージ ベースの通信します。</span><span class="sxs-lookup"><span data-stu-id="a06c6-119">There are two kinds of asynchronous messaging communication: single receiver message-based communication, and multiple receivers message-based communication.</span></span> <span data-ttu-id="a06c6-120">次のセクションでは、に関する詳細情報を提供します。</span><span class="sxs-lookup"><span data-stu-id="a06c6-120">In the following sections we provide details about them.</span></span>

## <a name="single-receiver-message-based-communication"></a><span data-ttu-id="a06c6-121">単一の受信側メッセージ ベースの通信</span><span class="sxs-lookup"><span data-stu-id="a06c6-121">Single-receiver message-based communication</span></span> 

<span data-ttu-id="a06c6-122">メッセージ ベースの非同期通信を 1 つの受信側では、ただ 1 つのコンシューマー、チャネルから読み取られたことと、メッセージは一度だけ処理するのにメッセージを配信するポイント ツー ポイント通信を意味します。</span><span class="sxs-lookup"><span data-stu-id="a06c6-122">Message-based asynchronous communication with a single receiver means there is point-to-point communication that delivers a message to exactly one of the consumers that is reading from the channel, and that the message is processed just once.</span></span> <span data-ttu-id="a06c6-123">ただし、特別な状況があります。</span><span class="sxs-lookup"><span data-stu-id="a06c6-123">However, there are special situations.</span></span> <span data-ttu-id="a06c6-124">インスタンスをエラーから自動的に回復しようとするクラウド システムで、同じメッセージを送信でした複数回です。</span><span class="sxs-lookup"><span data-stu-id="a06c6-124">For instance, in a cloud system that tries to automatically recover from failures, the same message could be sent multiple times.</span></span> <span data-ttu-id="a06c6-125">により、ネットワークまたはその他のエラーでは、クライアントがメッセージの送信を再試行できるされており、サーバーがべき等になる特定のメッセージを 1 回だけ処理するために、操作を実装する必要です。</span><span class="sxs-lookup"><span data-stu-id="a06c6-125">Due to network or other failures, the client has to be able to retry sending messages, and the server has to implement an operation to be idempotent in order to process a particular message just once.</span></span>

<span data-ttu-id="a06c6-126">単一受信者メッセージ ベースの通信は、1 つのマイクロ サービス間で非同期コマンドを送信するように図 4-18 をこの方法を示していますに特に適しています。</span><span class="sxs-lookup"><span data-stu-id="a06c6-126">Single-receiver message-based communication is especially well suited for sending asynchronous commands from one microservice to another as shown in Figure 4-18 that illustrates this approach.</span></span>

<span data-ttu-id="a06c6-127">(コマンドまたはイベントのいずれか)、メッセージ ベースの通信の送信を開始すると、同期の HTTP 通信とメッセージ ベースの通信の混在を避ける必要があります。</span><span class="sxs-lookup"><span data-stu-id="a06c6-127">Once you start sending message-based communication (either with commands or events), you should avoid mixing message-based communication with synchronous HTTP communication.</span></span>

![](./media/image18.PNG)

<span data-ttu-id="a06c6-128">**図 4 ~ 18**です。</span><span class="sxs-lookup"><span data-stu-id="a06c6-128">**Figure 4-18**.</span></span> <span data-ttu-id="a06c6-129">非同期メッセージを受信する単一のマイクロ サービス</span><span class="sxs-lookup"><span data-stu-id="a06c6-129">A single microservice receiving an asynchronous message</span></span>

<span data-ttu-id="a06c6-130">コマンドは、クライアント アプリケーションから取得、ときに実装できる HTTP 同期コマンドとしてに注意してください。</span><span class="sxs-lookup"><span data-stu-id="a06c6-130">Note that when the commands come from client applications, they can be implemented as HTTP synchronous commands.</span></span> <span data-ttu-id="a06c6-131">高い拡張性が必要な場合や、メッセージ ベースのビジネス プロセスでは既に、メッセージ ベースのコマンドを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="a06c6-131">You should use message-based commands when you need higher scalability or when you are already in a message-based business process.</span></span>

## <a name="multiple-receivers-message-based-communication"></a><span data-ttu-id="a06c6-132">受信側の複数のメッセージ ベースの通信</span><span class="sxs-lookup"><span data-stu-id="a06c6-132">Multiple-receivers message-based communication</span></span> 

<span data-ttu-id="a06c6-133">、、より柔軟なアプローチとして、送信者からの通信を使用できるは、追加サブスクライバー microservices または外部アプリケーションにできるように、パブリッシュ/サブスクライブのメカニズムを使用することがもできます。</span><span class="sxs-lookup"><span data-stu-id="a06c6-133">As a more flexible approach, you might also want to use a publish/subscribe mechanism so that your communication from the sender will be available to additional subscriber microservices or to external applications.</span></span> <span data-ttu-id="a06c6-134">したがってに利用するに従って、[原則を開く/閉じる](https://en.wikipedia.org/wiki/Open/closed_principle)送信側のサービスでします。</span><span class="sxs-lookup"><span data-stu-id="a06c6-134">Thus, it helps you to follow the [open/closed principle](https://en.wikipedia.org/wiki/Open/closed_principle) in the sending service.</span></span> <span data-ttu-id="a06c6-135">ようにして、将来的に送信側サービスを変更する必要がないその他のサブスクライバーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="a06c6-135">That way, additional subscribers can be added in the future without the need to modify the sender service.</span></span>

<span data-ttu-id="a06c6-136">パブリッシュ/サブスクライブの通信を使用する場合は、任意のサブスクライバーにイベントを公開するイベント バス インターフェイスを使用する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="a06c6-136">When you use a publish/subscribe communication, you might be using an event bus interface to publish events to any subscriber.</span></span>

## <a name="asynchronous-event-driven-communication"></a><span data-ttu-id="a06c6-137">イベント ドリブンの非同期通信</span><span class="sxs-lookup"><span data-stu-id="a06c6-137">Asynchronous event-driven communication</span></span>

<span data-ttu-id="a06c6-138">イベント ドリブンの非同期通信を使用する場合、マイクロ サービスは、そのドメイン内で何かが発生し、別マイクロ サービスは、製品カタログ マイクロ サービスの価格変更と同様に、対応する必要があるときに、統合イベントを公開します。</span><span class="sxs-lookup"><span data-stu-id="a06c6-138">When using asynchronous event-driven communication, a microservice publishes an integration event when something happens within its domain and another microservice needs to be aware of it, like a price change in a product catalog microservice.</span></span> <span data-ttu-id="a06c6-139">追加 microservices は、それらを非同期的に受信できるように、イベントをサブスクライブします。</span><span class="sxs-lookup"><span data-stu-id="a06c6-139">Additional microservices subscribe to the events so they can receive them asynchronously.</span></span> <span data-ttu-id="a06c6-140">発生したときに、受信側は、独自のドメイン エンティティが公開する複数の統合イベントが発生することができますを更新可能性があります。</span><span class="sxs-lookup"><span data-stu-id="a06c6-140">When that happens, the receivers might update their own domain entities, which can cause more integration events to be published.</span></span> <span data-ttu-id="a06c6-141">このパブリッシュ/サブスクライブ システムは通常、イベント バスの実装を使用して実行されます。</span><span class="sxs-lookup"><span data-stu-id="a06c6-141">This publish/subscribe system is usually performed by using an implementation of an event bus.</span></span> <span data-ttu-id="a06c6-142">イベント バスは、抽象またはインターフェイスをサブスクライブまたはイベントをアンサブスク ライブして、イベントを発行するために必要な api として設計できます。</span><span class="sxs-lookup"><span data-stu-id="a06c6-142">The event bus can be designed as an abstraction or interface, with the API that is needed to subscribe or unsubscribe to events and to publish events.</span></span> <span data-ttu-id="a06c6-143">イベント バスできますも 1 つまたは複数の実装は、メッセージング キューまたはサービス バスの非同期通信と、パブリッシュ/サブスクライブ モデルをサポートするように、プロセス間およびメッセージング ブローカーに基づきます。</span><span class="sxs-lookup"><span data-stu-id="a06c6-143">The event bus can also have one or more implementations based on any inter-process and messaging broker, like a messaging queue or service bus that supports asynchronous communication and a publish/subscribe model.</span></span>

<span data-ttu-id="a06c6-144">システムでは、統合イベントによって最終的整合性を使用する場合は、この方法をエンドユーザーに完全に消えて行われることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="a06c6-144">If a system uses eventual consistency driven by integration events, it is recommended that this approach be made completely clear to the end user.</span></span> <span data-ttu-id="a06c6-145">システムは、SignalR クライアントからのポーリング システムなどの統合イベントを模倣するアプローチを使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="a06c6-145">The system should not use an approach that mimics integration events, like SignalR or polling systems from the client.</span></span> <span data-ttu-id="a06c6-146">エンドユーザーとビジネス所有者を明示的にシステムの最終的整合性を採用し、これは、明示的な限り多くの場合、ビジネスがないことには、この方法は、何か問題ことに注意してあります。</span><span class="sxs-lookup"><span data-stu-id="a06c6-146">The end user and the business owner have to explicitly embrace eventual consistency in the system and realize that in many cases the business does not have any problem with this approach, as long as it is explicit.</span></span>

<span data-ttu-id="a06c6-147">前に説明したとおり、[に関する課題とソリューションの分散データ管理](#challenges-and-solutions-for-distributed-data-management) セクションで、複数の microservices にまたがるビジネス タスクを実装する統合イベントを使用することができます。</span><span class="sxs-lookup"><span data-stu-id="a06c6-147">As noted earlier in the [Challenges and solutions for distributed data management](#challenges-and-solutions-for-distributed-data-management) section, you can use integration events to implement business tasks that span multiple microservices.</span></span> <span data-ttu-id="a06c6-148">したがって、サービス間で最終的整合性をがあります。</span><span class="sxs-lookup"><span data-stu-id="a06c6-148">Thus you will have eventual consistency between those services.</span></span> <span data-ttu-id="a06c6-149">最終的に一貫性のあるトランザクションは分散アクションのコレクションで構成をされます。</span><span class="sxs-lookup"><span data-stu-id="a06c6-149">An eventually consistent transaction is made up of a collection of distributed actions.</span></span> <span data-ttu-id="a06c6-150">各アクションには、関連マイクロ サービスは、ドメイン エンティティを更新し、同じエンド ツー エンドのビジネス タスク内で次のアクションを発生させているもう 1 つの統合イベントを発行します。</span><span class="sxs-lookup"><span data-stu-id="a06c6-150">At each action, the related microservice updates a domain entity and publishes another integration event that raises the next action within the same end-to-end business task.</span></span>

<span data-ttu-id="a06c6-151">重要な点は、可能性がある、同じイベントにサブスクライブされる複数の microservices と通信します。</span><span class="sxs-lookup"><span data-stu-id="a06c6-151">An important point is that you might want to communicate to multiple microservices that are subscribed to the same event.</span></span> <span data-ttu-id="a06c6-152">パブリッシュ/サブスクライブを行うこともできますメッセージングに基づくイベント ドリブンの通信では、図 4-19 に示すようにします。</span><span class="sxs-lookup"><span data-stu-id="a06c6-152">To do so, you can use publish/subscribe messaging based on event-driven communication, as shown in Figure 4-19.</span></span> <span data-ttu-id="a06c6-153">このパブリッシュ/サブスクライブ メカニズムがマイクロ サービス アーキテクチャに排他的ではないです。</span><span class="sxs-lookup"><span data-stu-id="a06c6-153">This publish/subscribe mechanism is not exclusive to the microservice architecture.</span></span> <span data-ttu-id="a06c6-154">同様の方法である[コンテキストの境界を付けられた](http://martinfowler.com/bliki/BoundedContext.html)で DDD が通信する必要があります、または、書き込み可能なデータベースからの読み取りのデータベースへの更新を伝達する方法を[コマンドと Query Responsibility Segregation (CQRS)](http://martinfowler.com/bliki/CQRS.html)アーキテクチャ パターン。</span><span class="sxs-lookup"><span data-stu-id="a06c6-154">It is similar to the way [Bounded Contexts](http://martinfowler.com/bliki/BoundedContext.html) in DDD should communicate, or to the way you propagate updates from the write database to the read database in the [Command and Query Responsibility Segregation (CQRS)](http://martinfowler.com/bliki/CQRS.html) architecture pattern.</span></span> <span data-ttu-id="a06c6-155">目標は、分散システム全体で複数のデータ ソース間で最終的整合性にです。</span><span class="sxs-lookup"><span data-stu-id="a06c6-155">The goal is to have eventual consistency between multiple data sources across your distributed system.</span></span>

![](./media/image19.png)

<span data-ttu-id="a06c6-156">**図 4-19**です。</span><span class="sxs-lookup"><span data-stu-id="a06c6-156">**Figure 4-19**.</span></span> <span data-ttu-id="a06c6-157">非同期イベント駆動型メッセージ通信</span><span class="sxs-lookup"><span data-stu-id="a06c6-157">Asynchronous event-driven message communication</span></span>

<span data-ttu-id="a06c6-158">実装では、イベント ドリブン、メッセージ ベースの通信に使用するプロトコルを決定します。</span><span class="sxs-lookup"><span data-stu-id="a06c6-158">Your implementation will determine what protocol to use for event-driven, message-based communications.</span></span> <span data-ttu-id="a06c6-159">[AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol)キューに置かれた通信の信頼性を実現するのに役立てることができます。</span><span class="sxs-lookup"><span data-stu-id="a06c6-159">[AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol) can help achieve reliable queued communication.</span></span>

<span data-ttu-id="a06c6-160">イベント バスを使用する場合と同様に、メッセージ ブローカーから API を使用してコードでクラスに関連する実装に基づいた (イベント バス インターフェイス) のような抽象化レベルを使用する可能性があります[RabbitMQ](https://www.rabbitmq.com/)やのようにservicebus[Azure Service Bus のトピックを参照](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions)です。</span><span class="sxs-lookup"><span data-stu-id="a06c6-160">When you use an event bus, you might want to use an abstraction level (like an event bus interface) based on a related implementation in classes with code using the API from a message broker like [RabbitMQ](https://www.rabbitmq.com/) or a service bus like [Azure Service Bus with Topics](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span></span> <span data-ttu-id="a06c6-161">また、明確に示す、イベント バスやシステムのパブリッシュ/サブスクライブに NServiceBus、MassTransit、Brighter などの上位レベルのサービス バスを使用することができます。</span><span class="sxs-lookup"><span data-stu-id="a06c6-161">Alternatively, you might want to use a higher-level service bus like NServiceBus, MassTransit, or Brighter to articulate your event bus and publish/subscribe system.</span></span>

## <a name="a-note-about-messaging-technologies-for-production-systems"></a><span data-ttu-id="a06c6-162">メッセージング テクノロジを運用システムに関する注意事項</span><span class="sxs-lookup"><span data-stu-id="a06c6-162">A note about messaging technologies for production systems</span></span>

<span data-ttu-id="a06c6-163">抽象イベント バスを実装するために利用できるメッセージング テクノロジは、さまざまなレベルでです。</span><span class="sxs-lookup"><span data-stu-id="a06c6-163">The messaging technologies available for implementing your abstract event bus are at different levels.</span></span> <span data-ttu-id="a06c6-164">たとえば、RabbitMQ (メッセージング ブローカー トランスポート) と Azure Service Bus などの製品の前に座って、またはより低いレベルの他の製品と同様に、NServiceBus、MassTransit、Brighter、RabbitMQ と Azure Service Bus の上に動作することができます。</span><span class="sxs-lookup"><span data-stu-id="a06c6-164">For instance, products like RabbitMQ (a messaging broker transport) and Azure Service Bus sit at a lower level than other products like, NServiceBus, MassTransit, or Brighter, which can work on top of RabbitMQ and Azure Service Bus.</span></span> <span data-ttu-id="a06c6-165">選択は、アプリケーション レベルと既定のスケーラビリティがアプリケーションに必要な数の豊富な機能によって異なります。</span><span class="sxs-lookup"><span data-stu-id="a06c6-165">Your choice depends on how many rich features at the application level and out-of-the-box scalability you need for your application.</span></span> <span data-ttu-id="a06c6-166">開発環境に合わせて、概念実証のイベント バスだけを実装するため eShopOnContainers サンプルでは、作業が完了する Docker コンテナーで実行されている RabbitMQ 上に簡単な実装ではあります十分です。</span><span class="sxs-lookup"><span data-stu-id="a06c6-166">For implementing just a proof-of-concept event bus for your development environment, as we have done in the eShopOnContainers sample, a simple implementation on top of RabbitMQ running on a Docker container might be enough.</span></span>

<span data-ttu-id="a06c6-167">ただし、ミッション クリティカル運用システム ハイパー スケーラビリティが必要では、Azure Service Bus を評価する必要があります。</span><span class="sxs-lookup"><span data-stu-id="a06c6-167">However, for mission-critical and production systems that need hyper-scalability, you might want to evaluate Azure Service Bus.</span></span> <span data-ttu-id="a06c6-168">高度な抽象化と分散アプリケーションの開発を容易にする機能は、NServiceBus、MassTransit、Brighter など他の商用およびオープン ソースのサービス バスを評価することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="a06c6-168">For high-level abstractions and features that make the development of distributed applications easier, we recommend that you evaluate other commercial and open-source service buses, such as NServiceBus, MassTransit, and Brighter.</span></span> <span data-ttu-id="a06c6-169">もちろん、RabbitMQ と Docker のような下位レベルのテクノロジの上に独自のサービス バス機能をビルドすることができます。</span><span class="sxs-lookup"><span data-stu-id="a06c6-169">Of course, you can build your own service-bus features on top of lower-level technologies like RabbitMQ and Docker.</span></span> <span data-ttu-id="a06c6-170">その組み込み作業可能性がありますコスト、カスタムのエンタープライズ アプリケーションには多すぎます。</span><span class="sxs-lookup"><span data-stu-id="a06c6-170">But that plumbing work might cost too much for a custom enterprise application.</span></span>

## <a name="resiliently-publishing-to-the-event-bus"></a><span data-ttu-id="a06c6-171">イベント バスに発行弾性的</span><span class="sxs-lookup"><span data-stu-id="a06c6-171">Resiliently publishing to the event bus</span></span>

<span data-ttu-id="a06c6-172">複数 microservices 間で、イベント ドリブンのアーキテクチャを実装する際の課題はアトミックに弾性的に基づいて何らかの理由で、イベント バスに、関連する統合イベントの発行中に元のマイクロ サービスの状態を更新する方法トランザクション。</span><span class="sxs-lookup"><span data-stu-id="a06c6-172">A challenge when implementing an event-driven architecture across multiple microservices is how to atomically update state in the original microservice while resiliently publishing its related integration event into the event bus, somehow based on transactions.</span></span> <span data-ttu-id="a06c6-173">次に示します、これを実現する方法はいくつか追加の方法があります。</span><span class="sxs-lookup"><span data-stu-id="a06c6-173">The following are a few ways to accomplish this, although there could be additional approaches as well.</span></span>

-   <span data-ttu-id="a06c6-174">MSMQ などのトランザクション (DTC ベース) のキューを使用します。</span><span class="sxs-lookup"><span data-stu-id="a06c6-174">Using a transactional (DTC-based) queue like MSMQ.</span></span> <span data-ttu-id="a06c6-175">(ただし、これは、従来のアプローチ) です。</span><span class="sxs-lookup"><span data-stu-id="a06c6-175">(However, this is a legacy approach.)</span></span>

-   <span data-ttu-id="a06c6-176">使用して[トランザクション ログ マイニング](http://www.scoop.it/t/sql-server-transaction-log-mining)です。</span><span class="sxs-lookup"><span data-stu-id="a06c6-176">Using [transaction log mining](http://www.scoop.it/t/sql-server-transaction-log-mining).</span></span>

-   <span data-ttu-id="a06c6-177">使用して完全[イベント調達](https://msdn.microsoft.com/en-us/library/dn589792.aspx)パターン。</span><span class="sxs-lookup"><span data-stu-id="a06c6-177">Using full [Event Sourcing](https://msdn.microsoft.com/en-us/library/dn589792.aspx) pattern.</span></span>

-   <span data-ttu-id="a06c6-178">使用して、[送信トレイ パターン](http://gistlabs.com/2014/05/the-outbox/): イベントを作成し、発行されるイベント作成者コンポーネントの基本となる、メッセージ キューとトランザクションのデータベース テーブルです。</span><span class="sxs-lookup"><span data-stu-id="a06c6-178">Using the [Outbox pattern](http://gistlabs.com/2014/05/the-outbox/): a transactional database table as a message queue that will be the base for an event-creator component that would create the event and publish it.</span></span>

<span data-ttu-id="a06c6-179">メッセージべき等性とメッセージの重複除去は、非同期通信を使用する際に考慮するその他のトピックです。</span><span class="sxs-lookup"><span data-stu-id="a06c6-179">Additional topics to consider when using asynchronous communication are message idempotence and message deduplication.</span></span> <span data-ttu-id="a06c6-180">これらのトピックのセクションで説明されて[microservices (統合イベント) の間でイベント ベースの通信を実装する](#implementing_event_based_comms_microserv)このガイドで後述します。</span><span class="sxs-lookup"><span data-stu-id="a06c6-180">These topics are covered in the section [Implementing event-based communication between microservices (integration events)](#implementing_event_based_comms_microserv) later in this guide.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="a06c6-181">その他の技術情報</span><span class="sxs-lookup"><span data-stu-id="a06c6-181">Additional resources</span></span>

-   <span data-ttu-id="a06c6-182">**イベント ドリブン メッセージング**
    [*http://soapatterns.org/design\_パターン/イベント\_ドリブン\_メッセージング*](http://soapatterns.org/design_patterns/event_driven_messaging)</span><span class="sxs-lookup"><span data-stu-id="a06c6-182">**Event Driven Messaging**
[*http://soapatterns.org/design\_patterns/event\_driven\_messaging*](http://soapatterns.org/design_patterns/event_driven_messaging)</span></span>

-   <span data-ttu-id="a06c6-183">**チャネルのパブリッシュ/サブスクライブ**
    [*http://www.enterpriseintegrationpatterns.com/patterns/messaging/PublishSubscribeChannel.html*](http://www.enterpriseintegrationpatterns.com/patterns/messaging/PublishSubscribeChannel.html)</span><span class="sxs-lookup"><span data-stu-id="a06c6-183">**Publish/Subscribe Channel**
[*http://www.enterpriseintegrationpatterns.com/patterns/messaging/PublishSubscribeChannel.html*](http://www.enterpriseintegrationpatterns.com/patterns/messaging/PublishSubscribeChannel.html)</span></span>

-   <span data-ttu-id="a06c6-184">**Udi Dahan です。CQRS が明確にされました**
    [*http://udidahan.com/2009/12/09/clarified-cqrs/*](http://udidahan.com/2009/12/09/clarified-cqrs/)</span><span class="sxs-lookup"><span data-stu-id="a06c6-184">**Udi Dahan. Clarified CQRS**
[*http://udidahan.com/2009/12/09/clarified-cqrs/*](http://udidahan.com/2009/12/09/clarified-cqrs/)</span></span>

-   <span data-ttu-id="a06c6-185">**コマンドおよび責任 Segregation (CQRS) をクエリ**
    [*https://docs.microsoft.com/azure/architecture/patterns/cqrs*](https://docs.microsoft.com/azure/architecture/patterns/cqrs)</span><span class="sxs-lookup"><span data-stu-id="a06c6-185">**Command and Query Responsibility Segregation (CQRS)**
[*https://docs.microsoft.com/azure/architecture/patterns/cqrs*](https://docs.microsoft.com/azure/architecture/patterns/cqrs)</span></span>

-   <span data-ttu-id="a06c6-186">**コンテキスト間の通信範囲指定された**
    [*https://msdn.microsoft.com/library/jj591572.aspx*](https://msdn.microsoft.com/library/jj591572.aspx)</span><span class="sxs-lookup"><span data-stu-id="a06c6-186">**Communicating Between Bounded Contexts**
[*https://msdn.microsoft.com/library/jj591572.aspx*](https://msdn.microsoft.com/library/jj591572.aspx)</span></span>

-   <span data-ttu-id="a06c6-187">**最終的整合性**
    [*https://en.wikipedia.org/wiki/Eventual\_整合性*](https://en.wikipedia.org/wiki/Eventual_consistency)</span><span class="sxs-lookup"><span data-stu-id="a06c6-187">**Eventual consistency**
[*https://en.wikipedia.org/wiki/Eventual\_consistency*](https://en.wikipedia.org/wiki/Eventual_consistency)</span></span>

-   <span data-ttu-id="a06c6-188">**Jimmy Bogard。に対する回復力のリファクタリング: 結合の評価**
    [*https://jimmybogard.com/refactoring-towards-resilience-evaluating-coupling/*](https://jimmybogard.com/refactoring-towards-resilience-evaluating-coupling/)</span><span class="sxs-lookup"><span data-stu-id="a06c6-188">**Jimmy Bogard. Refactoring Towards Resilience: Evaluating Coupling**
[*https://jimmybogard.com/refactoring-towards-resilience-evaluating-coupling/*](https://jimmybogard.com/refactoring-towards-resilience-evaluating-coupling/)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="a06c6-189">[前](通信-で-マイクロ サービス-architecture.md) [次へ] (管理-マイクロ サービス-apis.md)</span><span class="sxs-lookup"><span data-stu-id="a06c6-189">[Previous] (communication-in-microservice-architecture.md) [Next] (maintain-microservice-apis.md)</span></span>
