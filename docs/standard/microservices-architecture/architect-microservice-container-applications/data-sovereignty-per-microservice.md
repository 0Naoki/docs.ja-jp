---
title: "マイクロ サービスごとのデータに対して"
description: "コンテナーの .NET アプリケーションの .NET Microservices アーキテクチャ |マイクロ サービスごとのデータに対して"
keywords: "Docker, マイクロサービス, ASP.NET, コンテナー"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: c51daae04215cfa6f5b5b8d2158a8ed1a8949652
ms.sourcegitcommit: c2e216692ef7576a213ae16af2377cd98d1a67fa
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/22/2017
---
# <a name="data-sovereignty-per-microservice"></a><span data-ttu-id="dd626-104">マイクロ サービスごとのデータに対して</span><span class="sxs-lookup"><span data-stu-id="dd626-104">Data sovereignty per microservice</span></span>

<span data-ttu-id="dd626-105">Microservices アーキテクチャの重要な規則は、そのドメインのデータとロジック各マイクロ サービスを所有していることです。</span><span class="sxs-lookup"><span data-stu-id="dd626-105">An important rule for microservices architecture is that each microservice must own its domain data and logic.</span></span> <span data-ttu-id="dd626-106">完全なアプリケーションでは、そのロジックとデータを所有していると同様ように各マイクロ サービスを所有している、ロジックとデータがマイクロ サービスごとの独立した展開で、自律的なライフ サイクルの下。</span><span class="sxs-lookup"><span data-stu-id="dd626-106">Just as a full application owns its logic and data, so must each microservice own its logic and data under an autonomous lifecycle, with independent deployment per microservice.</span></span>

<span data-ttu-id="dd626-107">これは、ドメインの概念モデルはサブシステムまたは microservices 間で異なることを意味します。</span><span class="sxs-lookup"><span data-stu-id="dd626-107">This means that the conceptual model of the domain will differ between subsystems or microservices.</span></span> <span data-ttu-id="dd626-108">カスタマー リレーションシップ マネジメント (CRM) アプリケーション、トランザクションが、一意の顧客エンティティの属性と、データの各呼び出しサブシステム、および顧客サポート サブシステムを購入し、そのそれぞれが別に、エンタープライズ アプリケーションを検討してください。範囲指定されたコンテキスト (BC)。</span><span class="sxs-lookup"><span data-stu-id="dd626-108">Consider enterprise applications, where customer relationship management (CRM) applications, transactional purchase subsystems, and customer support subsystems each call on unique customer entity attributes and data, and where each employs a different Bounded Context (BC).</span></span>

<span data-ttu-id="dd626-109">この原則は似ている部分[ドメイン ドリブン デザイン (DDD)](https://en.wikipedia.org/wiki/Domain-driven_design)ここで、各[コンテキストの境界を付けられた](https://martinfowler.com/bliki/BoundedContext.html)自律的なサブシステムまたはサービスは、そのドメイン モデル (データとロジックの動作) を所有する必要がありますか。</span><span class="sxs-lookup"><span data-stu-id="dd626-109">This principle is similar in [Domain-driven design (DDD)](https://en.wikipedia.org/wiki/Domain-driven_design), where each [Bounded Context](https://martinfowler.com/bliki/BoundedContext.html) or autonomous subsystem or service must own its domain model (data plus logic and behavior).</span></span> <span data-ttu-id="dd626-110">1 つのビジネス マイクロ サービス (1 つまたは複数のサービス) に関連している各 DDD 範囲指定されたコンテキスト。</span><span class="sxs-lookup"><span data-stu-id="dd626-110">Each DDD Bounded Context correlates to one business microservice (one or several services).</span></span> <span data-ttu-id="dd626-111">(お展開に関する次のセクションで、コンテキストの境界を付けられたパターンには、このポイントでします。)</span><span class="sxs-lookup"><span data-stu-id="dd626-111">(We expand on this point about the Bounded Context pattern in the next section.)</span></span>

<span data-ttu-id="dd626-112">その一方で、多くのアプリケーションで使用する従来の (モノリシック データ) アプローチは、単一の集中化されたデータベースまたは少数のデータベースの設定です。</span><span class="sxs-lookup"><span data-stu-id="dd626-112">On the other hand, the traditional (monolithic data) approach used in many applications is to have a single centralized database or just a few databases.</span></span> <span data-ttu-id="dd626-113">これは、図 4-7 に示すようにアプリケーション全体とそのすべての内部サブシステムに使用される正規化された SQL データベースでは多くの場合。</span><span class="sxs-lookup"><span data-stu-id="dd626-113">This is often a normalized SQL database that is used for the whole application and all its internal subsystems, as shown in Figure 4-7.</span></span>

![](./media/image7.png)

<span data-ttu-id="dd626-114">**図 4-7**です。</span><span class="sxs-lookup"><span data-stu-id="dd626-114">**Figure 4-7**.</span></span> <span data-ttu-id="dd626-115">データに対して比較: microservices とモノリシック データベース</span><span class="sxs-lookup"><span data-stu-id="dd626-115">Data sovereignty comparison: monolithic database versus microservices</span></span>

<span data-ttu-id="dd626-116">最初に、集中化されたデータベースのアプローチは、単純な検索し、全ての一貫性のある複数のサブシステム内のエンティティの再利用を有効にするように見えます。</span><span class="sxs-lookup"><span data-stu-id="dd626-116">The centralized database approach initially looks simpler and seems to enable reuse of entities in different subsystems to make everything consistent.</span></span> <span data-ttu-id="dd626-117">実際には多くのさまざまなサブシステムを使用して、属性と不要な列を含むほとんどの場合、大きなテーブルを持つ終了します。</span><span class="sxs-lookup"><span data-stu-id="dd626-117">But the reality is you end up with huge tables that serve many different subsystems, and that include attributes and columns that are not needed in most cases.</span></span> <span data-ttu-id="dd626-118">短い証跡のハイキング、一日中自動車旅行を取り出し、geography を学習、同じ物理的なマップを使用するようになります。</span><span class="sxs-lookup"><span data-stu-id="dd626-118">it is like trying to use the same physical map for hiking a short trail, taking a day-long car trip, and learning geography.</span></span>

<span data-ttu-id="dd626-119">通常、単一のリレーショナル データベースでモノリシックなアプリケーションが 2 つの重要な利点があります: [ACID トランザクション](https://en.wikipedia.org/wiki/ACID)と SQL 言語が、すべてのテーブルと、アプリケーションに関連するデータにわたって両方の機能です。</span><span class="sxs-lookup"><span data-stu-id="dd626-119">A monolithic application with typically a single relational database has two important benefits: [ACID transactions](https://en.wikipedia.org/wiki/ACID) and the SQL language, both working across all the tables and data related to your application.</span></span> <span data-ttu-id="dd626-120">このアプローチは、簡単に複数のテーブルからデータを結合するクエリを記述する方法を提供します。</span><span class="sxs-lookup"><span data-stu-id="dd626-120">This approach provides a way to easily write a query that combines data from multiple tables.</span></span>

<span data-ttu-id="dd626-121">ただし、データ アクセス制限が microservices アーキテクチャに移動するとはるかに複雑です。</span><span class="sxs-lookup"><span data-stu-id="dd626-121">However, data access becomes much more complex when you move to a microservices architecture.</span></span> <span data-ttu-id="dd626-122">でも ACID トランザクションはマイクロ サービスまたは範囲指定されたコンテキスト内で使用する必要がありますしたり、各マイクロ サービスが所有するデータがそのマイクロ サービスをプライベートとそのマイクロ サービス API を介してのみアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="dd626-122">But even when ACID transactions can or should be used within a microservice or Bounded Context, the data owned by each microservice is private to that microservice and can only be accessed via its microservice API.</span></span> <span data-ttu-id="dd626-123">データをカプセル化により、こと、microservices 疎結合された互いに改善できます。</span><span class="sxs-lookup"><span data-stu-id="dd626-123">Encapsulating the data ensures that the microservices are loosely coupled and can evolve independently of one another.</span></span> <span data-ttu-id="dd626-124">複数のサービスは、同じデータにアクセスした、スキーマの更新はすべてのサービスに調整された更新プログラムを必要があります。</span><span class="sxs-lookup"><span data-stu-id="dd626-124">If multiple services were accessing the same data, schema updates would require coordinated updates to all the services.</span></span> <span data-ttu-id="dd626-125">マイクロ サービス ライフ サイクルの自律性これを使用できなくなります。</span><span class="sxs-lookup"><span data-stu-id="dd626-125">This would break the microservice lifecycle autonomy.</span></span> <span data-ttu-id="dd626-126">分散データ構造を意味 microservices 全体で 1 つの ACID トランザクションは作成できません。</span><span class="sxs-lookup"><span data-stu-id="dd626-126">But distributed data structures mean that you cannot make a single ACID transaction across microservices.</span></span> <span data-ttu-id="dd626-127">さらにつまり、ビジネス プロセスが複数 microservices にまたがっている場合は、最終的整合性を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="dd626-127">This in turn means you must use eventual consistency when a business process spans multiple microservices.</span></span> <span data-ttu-id="dd626-128">これは、はるかに単純な SQL 結合よりも実装困難同様に、その他の多くのリレーショナル データベース機能は使用可能な複数 microservices 間で</span><span class="sxs-lookup"><span data-stu-id="dd626-128">This is much harder to implement than simple SQL joins; similarly, many other relational database features are not available across multiple microservices.</span></span>

<span data-ttu-id="dd626-129">さらに進んで、異なる microservices 多くの場合、使用して異なる*種類*データベース。</span><span class="sxs-lookup"><span data-stu-id="dd626-129">Going even further, different microservices often use different *kinds* of databases.</span></span> <span data-ttu-id="dd626-130">最新のアプリケーション ストアとプロセスのさまざまな種類のデータ、およびリレーショナル データベースは常に最適な選択肢です。</span><span class="sxs-lookup"><span data-stu-id="dd626-130">Modern applications store and process diverse kinds of data, and a relational database is not always the best choice.</span></span> <span data-ttu-id="dd626-131">一部のユース ケース、Azure DocumentDB MongoDB などの NoSQL データベースを持つ方が便利なデータ モデル パフォーマンスと SQL Server のように SQL データベースや Azure SQL データベースよりもスケーラビリティの向上を提供します。</span><span class="sxs-lookup"><span data-stu-id="dd626-131">For some use cases, a NoSQL database such as Azure DocumentDB or MongoDB might have a more convenient data model and offer better performance and scalability than a SQL database like SQL Server or Azure SQL Database.</span></span> <span data-ttu-id="dd626-132">それ以外の場合に、リレーショナル データベースは最善の方法ではまだです。</span><span class="sxs-lookup"><span data-stu-id="dd626-132">In other cases, a relational database is still the best approach.</span></span> <span data-ttu-id="dd626-133">Microservices ベースのアプリケーションが多くの場合とも呼ば SQL、NoSQL のデータベースの組み合わせを使用ため、[多言語の永続化](http://martinfowler.com/bliki/PolyglotPersistence.html)アプローチです。</span><span class="sxs-lookup"><span data-stu-id="dd626-133">Therefore, microservices-based applications often use a mixture of SQL and NoSQL databases, which is sometimes called the [polyglot persistence](http://martinfowler.com/bliki/PolyglotPersistence.html) approach.</span></span>

<span data-ttu-id="dd626-134">データ記憶域のパーティション分割された、polyglot 永続的なアーキテクチャには、多くの利点があります。</span><span class="sxs-lookup"><span data-stu-id="dd626-134">A partitioned, polyglot-persistent architecture for data storage has many benefits.</span></span> <span data-ttu-id="dd626-135">疎結合サービスおよびより優れたパフォーマンス、スケーラビリティ、コスト、および管理容易性が含まれます。</span><span class="sxs-lookup"><span data-stu-id="dd626-135">These include loosely coupled services and better performance, scalability, costs, and manageability.</span></span> <span data-ttu-id="dd626-136">ただしが生じる場合がいくつかの分散データ管理の課題の説明はして"[ドメイン モデルの境界を識別する](#identifying-domain-model-boundaries-for-each-microservice)"この章で後述します。</span><span class="sxs-lookup"><span data-stu-id="dd626-136">However, it can introduce some distributed data management challenges, as we will explain in “[Identifying domain-model boundaries](#identifying-domain-model-boundaries-for-each-microservice)” later in this chapter.</span></span>

## <a name="the-relationship-between-microservices-and-the-bounded-context-pattern"></a><span data-ttu-id="dd626-137">Microservices とコンテキストの境界を付けられたパターンの間のリレーションシップ</span><span class="sxs-lookup"><span data-stu-id="dd626-137">The relationship between microservices and the Bounded Context pattern</span></span>

<span data-ttu-id="dd626-138">派生したマイクロ サービスの概念、[範囲指定されたコンテキスト (BC) パターン](http://martinfowler.com/bliki/BoundedContext.html)で[ドメイン ドリブン デザイン (DDD)](https://en.wikipedia.org/wiki/Domain-driven_design)です。</span><span class="sxs-lookup"><span data-stu-id="dd626-138">The concept of microservice derives from the [Bounded Context (BC) pattern](http://martinfowler.com/bliki/BoundedContext.html) in [domain-driven design (DDD)](https://en.wikipedia.org/wiki/Domain-driven_design).</span></span> <span data-ttu-id="dd626-139">DDD は、複数 BCs に分割して、その境界を明示されているが、大規模なモデルを処理します。</span><span class="sxs-lookup"><span data-stu-id="dd626-139">DDD deals with large models by dividing them into multiple BCs and being explicit about their boundaries.</span></span> <span data-ttu-id="dd626-140">各ビジネス継続性は、独自のモデルとデータベースが必要同様に、各マイクロ サービスは、その関連データを所有しています。</span><span class="sxs-lookup"><span data-stu-id="dd626-140">Each BC must have its own model and database; likewise, each microservice owns its related data.</span></span> <span data-ttu-id="dd626-141">さらに、各 BC 通常では、独自[ユビキタス言語](http://martinfowler.com/bliki/UbiquitousLanguage.html)ソフトウェア開発者とドメインの専門家間の通信を支援します。</span><span class="sxs-lookup"><span data-stu-id="dd626-141">In addition, each BC usually has its own [ubiquitous language](http://martinfowler.com/bliki/UbiquitousLanguage.html) to help communication between software developers and domain experts.</span></span>

<span data-ttu-id="dd626-142">ユビキタス言語でこれらの用語 (主にドメイン エンティティ) は、異なる範囲指定されたコンテキストで別の名前を持つことができます、異なる場合でもドメイン エンティティが同じ id (つまり、一意の ID、エンティティをストレージから読み取りに使用される) を共有します。</span><span class="sxs-lookup"><span data-stu-id="dd626-142">Those terms (mainly domain entities) in the ubiquitous language can have different names in different Bounded Contexts, even when different domain entities share the same identity (that is, the unique ID that is used to read the entity from storage).</span></span> <span data-ttu-id="dd626-143">たとえば、ユーザー プロファイルの境界を付けられたコンテキストでユーザーのドメイン エンティティ可能性があります id を共有 Buyer ドメイン内のエンティティ、順序付けの境界を付けられたコンテキスト。</span><span class="sxs-lookup"><span data-stu-id="dd626-143">For instance, in a user-profile Bounded Context, the User domain entity might share identity with the Buyer domain entity in the ordering Bounded Context.</span></span>

<span data-ttu-id="dd626-144">マイクロ サービスそのため、範囲指定されたコンテキストのようには分散型サービスであることも指定します。</span><span class="sxs-lookup"><span data-stu-id="dd626-144">A microservice is therefore like a Bounded Context, but it also specifies that it is a distributed service.</span></span> <span data-ttu-id="dd626-145">範囲指定されたコンテキストごとに個別のプロセスとしてビルドおよび述べたとおり、HTTP、HTTPS、Websocket のように分散するプロトコルを使用する必要がありますまたは[AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol)です。</span><span class="sxs-lookup"><span data-stu-id="dd626-145">It is built as a separate process for each Bounded Context, and it must use the distributed protocols noted earlier, like HTTP/HTTPS, WebSockets, or [AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol).</span></span> <span data-ttu-id="dd626-146">コンテキストの境界を付けられたパターンただしは指定されていませんかどうか、範囲指定されたコンテキストは、分散サービス (ジェネリック サブシステム) など、論理的な境界だけであるかどうか、展開モノリシック アプリケーション内で。</span><span class="sxs-lookup"><span data-stu-id="dd626-146">The Bounded Context pattern, however, does not specify whether the Bounded Context is a distributed service or if it is simply a logical boundary (such as a generic subsystem) within a monolithic-deployment application.</span></span>

<span data-ttu-id="dd626-147">強調表示する各範囲指定されたコンテキストのサービスを定義することをお勧めを開始するには重要です。</span><span class="sxs-lookup"><span data-stu-id="dd626-147">It is important to highlight that defining a service for each Bounded Context is a good place to start.</span></span> <span data-ttu-id="dd626-148">制約、設計にする必要はありません。</span><span class="sxs-lookup"><span data-stu-id="dd626-148">But you do not have to constrain your design to it.</span></span> <span data-ttu-id="dd626-149">範囲指定されたコンテキストを設計する必要がありますやビジネス マイクロ サービスをいくつかの物理サービスで構成される場合があります。</span><span class="sxs-lookup"><span data-stu-id="dd626-149">Sometimes you must design a Bounded Context or business microservice composed of several physical services.</span></span> <span data-ttu-id="dd626-150">最終的には、両方のパターンが、— 範囲指定されたコンテキストとマイクロ サービス-密接に関連します。</span><span class="sxs-lookup"><span data-stu-id="dd626-150">But ultimately, both patterns—Bounded Context and microservice—are closely related.</span></span>

<span data-ttu-id="dd626-151">分散 microservices の形式での実際の境界を取得することによって microservices から DDD の利点があります。</span><span class="sxs-lookup"><span data-stu-id="dd626-151">DDD benefits from microservices by getting real boundaries in the form of distributed microservices.</span></span> <span data-ttu-id="dd626-152">Microservices 間でモデルを共有していないなどのアイデアを何もする境界を付けられたコンテキストでします。</span><span class="sxs-lookup"><span data-stu-id="dd626-152">But ideas like not sharing the model between microservices are what you also want in a Bounded Context.</span></span>

### <a name="additional-resources"></a><span data-ttu-id="dd626-153">その他の技術情報</span><span class="sxs-lookup"><span data-stu-id="dd626-153">Additional resources</span></span>

-   <span data-ttu-id="dd626-154">**Chris Richardson です。パターン: サービスごとのデータベースの**
    [*http://microservices.io/patterns/data/database-per-service.html*](http://microservices.io/patterns/data/database-per-service.html)</span><span class="sxs-lookup"><span data-stu-id="dd626-154">**Chris Richardson. Pattern: Database per service**
[*http://microservices.io/patterns/data/database-per-service.html*](http://microservices.io/patterns/data/database-per-service.html)</span></span>

-   <span data-ttu-id="dd626-155">**Martin Fowler。BoundedContext**
    [*http://martinfowler.com/bliki/BoundedContext.html*](http://martinfowler.com/bliki/BoundedContext.html)</span><span class="sxs-lookup"><span data-stu-id="dd626-155">**Martin Fowler. BoundedContext**
[*http://martinfowler.com/bliki/BoundedContext.html*](http://martinfowler.com/bliki/BoundedContext.html)</span></span>

-   <span data-ttu-id="dd626-156">**Martin Fowler。PolyglotPersistence**
    [*http://martinfowler.com/bliki/PolyglotPersistence.html*](http://martinfowler.com/bliki/PolyglotPersistence.html)</span><span class="sxs-lookup"><span data-stu-id="dd626-156">**Martin Fowler. PolyglotPersistence**
[*http://martinfowler.com/bliki/PolyglotPersistence.html*](http://martinfowler.com/bliki/PolyglotPersistence.html)</span></span>

-   <span data-ttu-id="dd626-157">**Alberto Brandolini です。Driven Design コンテキスト マッピングを戦略的なドメイン**
    [*https://www.infoq.com/articles/ddd-contextmapping*](https://www.infoq.com/articles/ddd-contextmapping)</span><span class="sxs-lookup"><span data-stu-id="dd626-157">**Alberto Brandolini. Strategic Domain Driven Design with Context Mapping**
[*https://www.infoq.com/articles/ddd-contextmapping*](https://www.infoq.com/articles/ddd-contextmapping)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="dd626-158">[前](microservices architecture.md) [次へ] (論理のではなく、物理-architecture.md)</span><span class="sxs-lookup"><span data-stu-id="dd626-158">[Previous] (microservices-architecture.md) [Next] (logical-versus-physical-architecture.md)</span></span>
