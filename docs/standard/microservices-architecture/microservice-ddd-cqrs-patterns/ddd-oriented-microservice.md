---
title: "DDD 指向マイクロ サービスの設計"
description: "コンテナーの .NET アプリケーションの .NET Microservices アーキテクチャ |DDD 指向マイクロ サービスの設計"
keywords: "Docker, マイクロサービス, ASP.NET, コンテナー"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: df45441089fd59d5e0e52b4bcec409adcc11fb71
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/18/2017
---
# <a name="designing-a-ddd-oriented-microservice"></a>DDD 指向マイクロ サービスの設計

ドメイン ベースのデザイン (DDD) グループとして、ユース ケースに関連するビジネスの現状に基づくモデリングを重視します。 コンテキストでは、アプリケーションの構築、DDD はドメインと問題について説明します。 範囲指定されたコンテキストと独立した問題の領域がについて説明します (各範囲指定されたコンテキストが、マイクロ サービスに関連付けられている) 場合に、これらの問題について説明する一般的な言語を強調します。 多くの技術の概念とパターンの豊富なモデルとドメイン エンティティと同様に、また候補として表示 (ありません[anemic ドメイン モデル](https://martinfowler.com/bliki/AnemicDomainModel.html))、内部の実装をサポートするルールの値のオブジェクト、集計と集計ルート (またはルート エンティティ)。 このセクションでは、設計とそれらの内部パターンの実装について説明します。

場合があります、steep 習得 DDD アプローチを実装するための障害とこれら DDD 技術的なルールとパターンを認識します。 重要な部分はいないパターン自体が、ビジネス上の問題に揃えられますので、コードの整理と、同じビジネス条項 (ユビキタス言語) を使用してです。 さらに、DDD アプローチは、重要なビジネス ルールで複雑な microservices を実装している場合にのみ適用する必要があります。 CRUD service などの単純な責任は、簡単な方法で管理できます。

境界を描画する場所は、主な作業を設計および、マイクロ サービスを定義するときです。 DDD パターンでは、ドメインの複雑さを理解できます。 各範囲指定されたコンテキストのドメイン モデルの場合は、識別し、エンティティ、値のオブジェクト、およびドメインをモデル化した集計を定義します。 ビルドして、コンテキストを定義する境界内に含まれるドメイン モデルを調整します。 化、マイクロ サービスの形式で明示的に指定します。 これらの境界内のコンポーネント、microservices をされている状況によっては、ビジネス継続性にもされたりビジネス microservices をいくつかの物理サービスで構成できます。 DDD 境界について、microservices も削除します。

## <a name="keep-the-microservice-context-boundaries-relatively-small"></a>マイクロ サービスのコンテキストの境界を比較的小さく保つ

競合する 2 つの目標のバランス範囲指定されたコンテキスト間の境界を配置する場所を決定します。 最初に、最初に作成する最小の考えられる microservices メイン ドライバー; ならないことが凝集度を必要のある周辺の境界を作成する必要があります。 次に、microservices 間 chatty な通信を回避します。 これらの目標には、互いが内容と相反することができます。 急速に新しい範囲指定されたコンテキストを分離する追加の試行ごとに通信境界が表示されるまでをできる限り多くの小さな microservices へのシステムを分解してそれらを調整する必要があります。 凝集度は、1 つの境界のあるコンテキスト内のキーです。

に似ていますが、[不適切な親密性コード匂い](https://sourcemaking.com/refactoring/smells/inappropriate-intimacy)クラスを実装する場合。 互いに多くの共同作業を 2 つの microservices する場合は、同じマイクロ サービスになるでしょう。

これを確認する別の方法では、自律性です。 場合は、マイクロ サービスは、直接要求を処理する、別のサービスに依存する必要があります、本当に自律的なことはできません。

## <a name="layers-in-ddd-microservices"></a>DDD microservices 内のレイヤー

ほとんどのエンタープライズ アプリケーションの重要なビジネスと技術的な複雑さは、複数のレイヤーによって定義されます。 レイヤーは、論理の成果物、サービスの展開に関連していません。 それらは、開発者がコードの複雑さを管理するのに役立つ存在します。 (、ドメイン モデル層とプレゼンテーション層など) のようなさまざまな層がこれでそれらの型の間での変換が必須で、異なる型である可能性があります。

たとえば、エンティティは、データベースから読み込まれた可能性があります。 その情報、またはその他のエンティティから追加のデータを含む情報の集計の一部は、UI REST Web API を介してクライアントに送信できます。 ここでのポイントされているドメイン エンティティのドメイン モデル層内に含まれることに属さないと同様に、プレゼンテーション層を他の領域に反映できません必要があります。

さらに、常に有効なエンティティが存在する必要があります (を参照してください、[ドメイン モデル レイヤーでの検証を設計](#designing-validations-in-the-domain-model-layer)セクション) 集計ルート (ルート エンティティ) によって制御されます。 そのため、エンティティにバインドしないクライアントのビューにため、UI レベルで一部のデータがまだを検証できません。 これは、ViewModel のです。 ViewModel は、プレゼンテーション層のニーズの専用のデータ モデルです。 ドメイン エンティティが、ViewModel に直接属していません。 代わりに、ViewModels とドメイン エンティティの間、その逆に変換する必要があります。

そのグループのエンティティ (集計) が 1 つのエントリによって実行されますへの対応の複雑さがすべての不変部分とルールに関連しているかどうかを確認する集計のルート (に進むこのさらに詳しく後述) によって制御されるドメイン モデルが重要であります。ポイントまたはゲート、集計のルートです。

図 9-5 は、階層化設計が eShopOnContainers アプリケーションに実装される方法を示しています。

![](./media/image6.png)

**図 9-5**です。 DDD eShopOnContainers で順序付けマイクロ サービス レイヤー

各レイヤーが他の特定のレイヤーとだけ通信できるようにシステムをデザインするには。 ライブラリ間でどのような依存関係が設定を明確に識別できるため、レイヤーが別のクラス ライブラリとして実装されている場合を適用しやすくする必要があります。 たとえば、ドメイン モデル層受け取ることはできません、依存関係他のレイヤーに (ドメイン モデル クラスは Plain Old CLR Object、する必要がありますまたは[POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object)クラス)。 図 9-6 のように、 **Ordering.Domain** .NET Core ライブラリでのみ、その他のカスタム ライブラリ (データ ライブラリ、永続化ライブラリなど) ではなく、レイヤー ライブラリが依存関係。

![](./media/image7.PNG)

**図 9-6**です。 ライブラリは、レイヤー間の依存関係の制御を強化を許可するように実装レイヤー

### <a name="the-domain-model-layer"></a>ドメイン モデル レイヤー

Eric Evans 優れた book[ドメイン駆動設計](http://domainlanguage.com/ddd/)ドメイン モデル層とアプリケーション層について、次の質問。

**ドメイン モデル層**: ビジネス、ビジネス ルールとビジネスの状況に関する情報の概念を表すを担当します。 ビジネスの状況を反映する状態が制御され、ここでは、使用される場合でも、格納することの技術的な詳細は、インフラストラクチャに委任されます。 このレイヤーは、ビジネス ソフトウェアの中核です。

ドメイン モデル レイヤーでは、ビジネスが表されます。 マイクロ サービス ドメイン モデル レイヤーを .NET で実装するときに、そのレイヤーはに加えて動作 (メソッドのロジックを持つ) のデータをキャプチャするドメイン エンティティを含むクラス ライブラリとしてコード化されました。

次の[持続性の無視が適用](http://deviq.com/persistence-ignorance/)と[インフラストラクチャの無視が適用](https://ayende.com/blog/3137/infrastructure-ignorance)このレイヤーの基本原則はデータ持続性の詳細を完全に無視する必要があります。 インフラストラクチャ レイヤーでは、永続化タスクを実行する必要があります。 そのため、このレイヤーはかかりません直接的な依存関係という重要な規則は、ドメイン モデルのエンティティ クラスには、インフラストラクチャに[POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object)s。

ドメイン エンティティでは、Entity Framework や NHibernate などのデータ アクセスのインフラストラクチャ フレームワークに直接的な依存関係 (など、基本クラスから派生する) 必要はありません。 理想的には、ドメイン エンティティがから派生されません、またはインフラストラクチャの任意のフレームワークで定義されている任意の型を実装する必要があります。

Entity Framework Core などの最近のほとんどの ORM フレームワークでは、ドメイン モデル クラスは、インフラストラクチャに関連していないように、このアプローチができるようにします。 ただし、POCO エンティティを持つは常に特定の NoSQL データベースとアクターと Azure Service Fabric で信頼性の高いコレクションなどのフレームワークを使用する場合。

ドメイン モデルの持続性の無視が適用原則に従う必要がある場合でもは、永続化に関する注意事項を無視する必要があります。 物理的なデータ モデルとエンティティ オブジェクト モデルにマップする方法を理解することが重要はまだです。 それ以外の場合不可能なデザインを作成することができます。

またはありません、リレーショナル データベース用に設計されたモデルおよび NoSQL またはドキュメント指向のデータベースに直接移動できます。 一部のエンティティ モデルでモデルが適合するが通常ことはありません。 エンティティ モデルに従う必要あります、記憶域テクノロジと ORM テクノロジの両方に基づく制約がまだです。

### <a name="the-application-layer"></a>アプリケーション層

移動、アプリケーション レイヤーおをもう一度が示されている Eric Evans book[ドメイン駆動設計](http://domainlanguage.com/ddd/):

**アプリケーション層:**ソフトウェアすべきし、問題を操作する表現力が豊かドメイン オブジェクト、ジョブを定義します。 このレイヤーは、担当タスクとは、ビジネスにとって意味のある、または他のシステムのアプリケーション層との対話に必要です。 このレイヤーは、シンは保持されます。 ビジネス ルールまたは、ナレッジを含まないが、のみ座標タスクとデリゲートで作業を次の層内のドメイン オブジェクトのコラボレーション ダウンします。 ビジネスの状況を反映した状態はありませんが、ユーザーまたはプログラムの作業の進行状況を反映する状態を持つことができます。

マイクロ サービスのアプリケーション層を .NET では、ASP.NET Core Web API プロジェクトとしてよくコーディングされます。 プロジェクトは、マイクロ サービスの相互作用、リモート ネットワーク アクセス、および UI またはクライアント アプリから使用される外部の Web Api を実装します。 マイクロ サービス、およびであっても、イベント ドリブン間の通信 microservices (統合イベント) によって有効なコマンドからアプローチを CQRS を使用して、クエリが含まれます。 アプリケーション層を表す ASP.NET Core Web API には、ビジネス ルールまたはドメインのナレッジ (特にドメイン ルールは、トランザクションまたは更新) です。これらは、ドメイン モデル クラス ライブラリが所有する必要があります。 アプリケーション レイヤー必要がありますのみ座標タスクしする必要がありますいないを保持または任意のドメインの状態 (ドメイン モデル) を定義します。 これは、それらのドメイン エンティティ内のデータを更新する必要が最終的に自体 (集計ルートとドメイン エンティティ)、ドメイン モデル クラスに、ビジネス ルールの実行を代行します。

基本的には、アプリケーション ロジックは、指定したフロント エンドに依存するすべてのユース ケースを実装します。 たとえば、Web API サービスに関連する実装。

目標は、ドメイン モデル層、そのインバリアント、データ モデル、および関連するビジネス ルールのドメイン ロジック、プレゼンテーション層とアプリケーション層から完全に独立している必要があります。 ほとんどすべてのドメイン モデル レイヤー必要があります直接に依存しないのインフラストラクチャ フレームワークです。

### <a name="the-infrastructure-layer"></a>インフラストラクチャ レイヤー

インフラストラクチャ レイヤーは、(メモリ内) のドメイン エンティティに最初に保持されているデータをデータベースまたは別の永続的なストアに永続化する方法です。 例は、Entity Framework Core コードを使用して DBContext をリレーショナル データベース内のデータを永続化に使用されるリポジトリ パターン クラスを実装するがします。

前に説明したに従って[持続性の無視が適用](http://deviq.com/persistence-ignorance/)と[インフラストラクチャの無視が適用](https://ayende.com/blog/3137/infrastructure-ignorance)原則、インフラストラクチャ レイヤー必要があります「ソケットピン」ドメイン モデル レイヤー。 いないフレームワークについてハード依存関係を作成して (EF またはその他の任意のフレームワーク) のデータを永続化を使用するインフラストラクチャをドメイン モデル エンティティ クラスに依存しませんを維持する必要があります。 ドメイン モデル レイヤー クラス ライブラリでは、ドメイン コードのみをだけが必要[POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object)エンティティは、ソフトウェアの中心となるを実装するクラスし、インフラストラクチャ テクノロジから完全に分離します。

したがって、レイヤーまたはクラス ライブラリとプロジェクト必要があります最終的に依存ドメイン モデル レイヤー (ライブラリ)、逆はできない、図 9-7 に示すようにします。

![](./media/image8.png)

**図 9-7**です。 DDD 内のレイヤー間の依存関係

このレイヤーのデザインは、各マイクロ サービスを独立している必要があります。 最も複雑な microservices を実装するには前述のように、簡単な方法で、次のデータ ドリブン DDD パターンを簡単に実装する間に microservices (1 つのレイヤーで単純な CRUD)。

#### <a name="additional-resources"></a>その他の技術情報

-   **DevIQ です。持続性の無視が適用原則**
    [*http://deviq.com/persistence-ignorance/*](http://deviq.com/persistence-ignorance/)

-   **Oren Eini です。インフラストラクチャの無視が適用**
    [*https://ayende.com/blog/3137/infrastructure-ignorance*](https://ayende.com/blog/3137/infrastructure-ignorance)

-   **天使ロペスです。階層設計のドメインに基づくアーキテクチャ**
    [*https://ajlopez.wordpress.com/2008/09/12/layered-architecture-in-domain-driven-design/*](https://ajlopez.wordpress.com/2008/09/12/layered-architecture-in-domain-driven-design/)


>[!div class="step-by-step"]
[前](cqrs-マイクロ サービス-reads.md) [次へ] (マイクロ サービス ドメイン model.md)
