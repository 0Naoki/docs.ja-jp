---
title: "DDD 指向マイクロ サービスの設計"
description: "コンテナーの .NET アプリケーションの .NET Microservices アーキテクチャ |DDD 指向マイクロ サービスの設計"
keywords: "Docker, マイクロサービス, ASP.NET, コンテナー"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: df45441089fd59d5e0e52b4bcec409adcc11fb71
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/18/2017
---
# <a name="designing-a-ddd-oriented-microservice"></a><span data-ttu-id="d18e3-104">DDD 指向マイクロ サービスの設計</span><span class="sxs-lookup"><span data-stu-id="d18e3-104">Designing a DDD-oriented microservice</span></span>

<span data-ttu-id="d18e3-105">ドメイン ベースのデザイン (DDD) グループとして、ユース ケースに関連するビジネスの現状に基づくモデリングを重視します。</span><span class="sxs-lookup"><span data-stu-id="d18e3-105">Domain-driven design (DDD) advocates modeling based on the reality of business as relevant to your use cases.</span></span> <span data-ttu-id="d18e3-106">コンテキストでは、アプリケーションの構築、DDD はドメインと問題について説明します。</span><span class="sxs-lookup"><span data-stu-id="d18e3-106">In the context of building applications, DDD talks about problems as domains.</span></span> <span data-ttu-id="d18e3-107">範囲指定されたコンテキストと独立した問題の領域がについて説明します (各範囲指定されたコンテキストが、マイクロ サービスに関連付けられている) 場合に、これらの問題について説明する一般的な言語を強調します。</span><span class="sxs-lookup"><span data-stu-id="d18e3-107">It describes independent problem areas as Bounded Contexts (each Bounded Context correlates to a microservice), and emphasizes a common language to talk about these problems.</span></span> <span data-ttu-id="d18e3-108">多くの技術の概念とパターンの豊富なモデルとドメイン エンティティと同様に、また候補として表示 (ありません[anemic ドメイン モデル](https://martinfowler.com/bliki/AnemicDomainModel.html))、内部の実装をサポートするルールの値のオブジェクト、集計と集計ルート (またはルート エンティティ)。</span><span class="sxs-lookup"><span data-stu-id="d18e3-108">It also suggests many technical concepts and patterns, like domain entities with rich models (no [anemic-domain model](https://martinfowler.com/bliki/AnemicDomainModel.html)), value objects, aggregates and aggregate root (or root entity) rules to support the internal implementation.</span></span> <span data-ttu-id="d18e3-109">このセクションでは、設計とそれらの内部パターンの実装について説明します。</span><span class="sxs-lookup"><span data-stu-id="d18e3-109">This section introduces the design and implementation of those internal patterns.</span></span>

<span data-ttu-id="d18e3-110">場合があります、steep 習得 DDD アプローチを実装するための障害とこれら DDD 技術的なルールとパターンを認識します。</span><span class="sxs-lookup"><span data-stu-id="d18e3-110">Sometimes these DDD technical rules and patterns are perceived as obstacles that have a steep learning curve for implementing DDD approaches.</span></span> <span data-ttu-id="d18e3-111">重要な部分はいないパターン自体が、ビジネス上の問題に揃えられますので、コードの整理と、同じビジネス条項 (ユビキタス言語) を使用してです。</span><span class="sxs-lookup"><span data-stu-id="d18e3-111">But the important part is not the patterns themselves, but organizing the code so it is aligned to the business problems, and using the same business terms (ubiquitous language).</span></span> <span data-ttu-id="d18e3-112">さらに、DDD アプローチは、重要なビジネス ルールで複雑な microservices を実装している場合にのみ適用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d18e3-112">In addition, DDD approaches should be applied only if you are implementing complex microservices with significant business rules.</span></span> <span data-ttu-id="d18e3-113">CRUD service などの単純な責任は、簡単な方法で管理できます。</span><span class="sxs-lookup"><span data-stu-id="d18e3-113">Simpler responsibilities, like a CRUD service, can be managed with simpler approaches.</span></span>

<span data-ttu-id="d18e3-114">境界を描画する場所は、主な作業を設計および、マイクロ サービスを定義するときです。</span><span class="sxs-lookup"><span data-stu-id="d18e3-114">Where to draw the boundaries is the key task when designing and defining a microservice.</span></span> <span data-ttu-id="d18e3-115">DDD パターンでは、ドメインの複雑さを理解できます。</span><span class="sxs-lookup"><span data-stu-id="d18e3-115">DDD patterns help you understand the complexity in the domain.</span></span> <span data-ttu-id="d18e3-116">各範囲指定されたコンテキストのドメイン モデルの場合は、識別し、エンティティ、値のオブジェクト、およびドメインをモデル化した集計を定義します。</span><span class="sxs-lookup"><span data-stu-id="d18e3-116">For the domain model for each Bounded Context, you identify and define the entities, value objects, and aggregates that model your domain.</span></span> <span data-ttu-id="d18e3-117">ビルドして、コンテキストを定義する境界内に含まれるドメイン モデルを調整します。</span><span class="sxs-lookup"><span data-stu-id="d18e3-117">You build and refine a domain model that is contained within a boundary that defines your context.</span></span> <span data-ttu-id="d18e3-118">化、マイクロ サービスの形式で明示的に指定します。</span><span class="sxs-lookup"><span data-stu-id="d18e3-118">And that is very explicit in the form of a microservice.</span></span> <span data-ttu-id="d18e3-119">これらの境界内のコンポーネント、microservices をされている状況によっては、ビジネス継続性にもされたりビジネス microservices をいくつかの物理サービスで構成できます。</span><span class="sxs-lookup"><span data-stu-id="d18e3-119">The components within those boundaries end up being your microservices, although in some cases a BC or business microservices can be composed of several physical services.</span></span> <span data-ttu-id="d18e3-120">DDD 境界について、microservices も削除します。</span><span class="sxs-lookup"><span data-stu-id="d18e3-120">DDD is about boundaries and so are microservices.</span></span>

## <a name="keep-the-microservice-context-boundaries-relatively-small"></a><span data-ttu-id="d18e3-121">マイクロ サービスのコンテキストの境界を比較的小さく保つ</span><span class="sxs-lookup"><span data-stu-id="d18e3-121">Keep the microservice context boundaries relatively small</span></span>

<span data-ttu-id="d18e3-122">競合する 2 つの目標のバランス範囲指定されたコンテキスト間の境界を配置する場所を決定します。</span><span class="sxs-lookup"><span data-stu-id="d18e3-122">Determining where to place boundaries between Bounded Contexts balances two competing goals.</span></span> <span data-ttu-id="d18e3-123">最初に、最初に作成する最小の考えられる microservices メイン ドライバー; ならないことが凝集度を必要のある周辺の境界を作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d18e3-123">First, you want to initially create the smallest possible microservices, although that should not be the main driver; you should create a boundary around things that need cohesion.</span></span> <span data-ttu-id="d18e3-124">次に、microservices 間 chatty な通信を回避します。</span><span class="sxs-lookup"><span data-stu-id="d18e3-124">Second, you want to avoid chatty communications between microservices.</span></span> <span data-ttu-id="d18e3-125">これらの目標には、互いが内容と相反することができます。</span><span class="sxs-lookup"><span data-stu-id="d18e3-125">These goals can contradict one another.</span></span> <span data-ttu-id="d18e3-126">急速に新しい範囲指定されたコンテキストを分離する追加の試行ごとに通信境界が表示されるまでをできる限り多くの小さな microservices へのシステムを分解してそれらを調整する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d18e3-126">You should balance them by decomposing the system into as many small microservices as you can until you see communication boundaries growing quickly with each additional attempt to separate a new Bounded Context.</span></span> <span data-ttu-id="d18e3-127">凝集度は、1 つの境界のあるコンテキスト内のキーです。</span><span class="sxs-lookup"><span data-stu-id="d18e3-127">Cohesion is key within a single bounded context.</span></span>

<span data-ttu-id="d18e3-128">に似ていますが、[不適切な親密性コード匂い](https://sourcemaking.com/refactoring/smells/inappropriate-intimacy)クラスを実装する場合。</span><span class="sxs-lookup"><span data-stu-id="d18e3-128">It is similar to the [Inappropriate Intimacy code smell](https://sourcemaking.com/refactoring/smells/inappropriate-intimacy) when implementing classes.</span></span> <span data-ttu-id="d18e3-129">互いに多くの共同作業を 2 つの microservices する場合は、同じマイクロ サービスになるでしょう。</span><span class="sxs-lookup"><span data-stu-id="d18e3-129">If two microservices need to collaborate a lot with each other, they should probably be the same microservice.</span></span>

<span data-ttu-id="d18e3-130">これを確認する別の方法では、自律性です。</span><span class="sxs-lookup"><span data-stu-id="d18e3-130">Another way to look at this is autonomy.</span></span> <span data-ttu-id="d18e3-131">場合は、マイクロ サービスは、直接要求を処理する、別のサービスに依存する必要があります、本当に自律的なことはできません。</span><span class="sxs-lookup"><span data-stu-id="d18e3-131">If a microservice must rely on another service to directly service a request, it is not truly autonomous.</span></span>

## <a name="layers-in-ddd-microservices"></a><span data-ttu-id="d18e3-132">DDD microservices 内のレイヤー</span><span class="sxs-lookup"><span data-stu-id="d18e3-132">Layers in DDD microservices</span></span>

<span data-ttu-id="d18e3-133">ほとんどのエンタープライズ アプリケーションの重要なビジネスと技術的な複雑さは、複数のレイヤーによって定義されます。</span><span class="sxs-lookup"><span data-stu-id="d18e3-133">Most enterprise applications with significant business and technical complexity are defined by multiple layers.</span></span> <span data-ttu-id="d18e3-134">レイヤーは、論理の成果物、サービスの展開に関連していません。</span><span class="sxs-lookup"><span data-stu-id="d18e3-134">The layers are a logical artifact, and are not related to the deployment of the service.</span></span> <span data-ttu-id="d18e3-135">それらは、開発者がコードの複雑さを管理するのに役立つ存在します。</span><span class="sxs-lookup"><span data-stu-id="d18e3-135">They exist to help developers manage the complexity in the code.</span></span> <span data-ttu-id="d18e3-136">(、ドメイン モデル層とプレゼンテーション層など) のようなさまざまな層がこれでそれらの型の間での変換が必須で、異なる型である可能性があります。</span><span class="sxs-lookup"><span data-stu-id="d18e3-136">Different layers (like the domain model layer versus the presentation layer, etc.) might have different types, which mandates translations between those types.</span></span>

<span data-ttu-id="d18e3-137">たとえば、エンティティは、データベースから読み込まれた可能性があります。</span><span class="sxs-lookup"><span data-stu-id="d18e3-137">For example, an entity could be loaded from the database.</span></span> <span data-ttu-id="d18e3-138">その情報、またはその他のエンティティから追加のデータを含む情報の集計の一部は、UI REST Web API を介してクライアントに送信できます。</span><span class="sxs-lookup"><span data-stu-id="d18e3-138">Then part of that information, or an aggregation of information including additional data from other entities, can be sent to the client UI through a REST Web API.</span></span> <span data-ttu-id="d18e3-139">ここでのポイントされているドメイン エンティティのドメイン モデル層内に含まれることに属さないと同様に、プレゼンテーション層を他の領域に反映できません必要があります。</span><span class="sxs-lookup"><span data-stu-id="d18e3-139">The point here is that the domain entity is contained within the domain model layer and should not be propagated to other areas that it does not belong to, like to the presentation layer.</span></span>

<span data-ttu-id="d18e3-140">さらに、常に有効なエンティティが存在する必要があります (を参照してください、[ドメイン モデル レイヤーでの検証を設計](#designing-validations-in-the-domain-model-layer)セクション) 集計ルート (ルート エンティティ) によって制御されます。</span><span class="sxs-lookup"><span data-stu-id="d18e3-140">Additionally, you need to have always-valid entities (see the [Designing validations in the domain model layer](#designing-validations-in-the-domain-model-layer) section) controlled by aggregate roots (root entities).</span></span> <span data-ttu-id="d18e3-141">そのため、エンティティにバインドしないクライアントのビューにため、UI レベルで一部のデータがまだを検証できません。</span><span class="sxs-lookup"><span data-stu-id="d18e3-141">Therefore, entities should not be bound to client views, because at the UI level some data might still not be validated.</span></span> <span data-ttu-id="d18e3-142">これは、ViewModel のです。</span><span class="sxs-lookup"><span data-stu-id="d18e3-142">This is what the ViewModel is for.</span></span> <span data-ttu-id="d18e3-143">ViewModel は、プレゼンテーション層のニーズの専用のデータ モデルです。</span><span class="sxs-lookup"><span data-stu-id="d18e3-143">The ViewModel is a data model exclusively for presentation layer needs.</span></span> <span data-ttu-id="d18e3-144">ドメイン エンティティが、ViewModel に直接属していません。</span><span class="sxs-lookup"><span data-stu-id="d18e3-144">The domain entities do not belong directly to the ViewModel.</span></span> <span data-ttu-id="d18e3-145">代わりに、ViewModels とドメイン エンティティの間、その逆に変換する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d18e3-145">Instead, you need to translate between ViewModels and domain entities and vice versa.</span></span>

<span data-ttu-id="d18e3-146">そのグループのエンティティ (集計) が 1 つのエントリによって実行されますへの対応の複雑さがすべての不変部分とルールに関連しているかどうかを確認する集計のルート (に進むこのさらに詳しく後述) によって制御されるドメイン モデルが重要であります。ポイントまたはゲート、集計のルートです。</span><span class="sxs-lookup"><span data-stu-id="d18e3-146">When tackling complexity, it is important to have a domain model controlled by aggregate roots (we go into this in more detail later) that make sure that all the invariants and rules related to that group of entities (aggregate) are performed through a single entry point or gate, the aggregate root.</span></span>

<span data-ttu-id="d18e3-147">図 9-5 は、階層化設計が eShopOnContainers アプリケーションに実装される方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="d18e3-147">Figure 9-5 shows how a layered design is implemented in the eShopOnContainers application.</span></span>

![](./media/image6.png)

<span data-ttu-id="d18e3-148">**図 9-5**です。</span><span class="sxs-lookup"><span data-stu-id="d18e3-148">**Figure 9-5**.</span></span> <span data-ttu-id="d18e3-149">DDD eShopOnContainers で順序付けマイクロ サービス レイヤー</span><span class="sxs-lookup"><span data-stu-id="d18e3-149">DDD layers in the ordering microservice in eShopOnContainers</span></span>

<span data-ttu-id="d18e3-150">各レイヤーが他の特定のレイヤーとだけ通信できるようにシステムをデザインするには。</span><span class="sxs-lookup"><span data-stu-id="d18e3-150">You want to design the system so that each layer communicates only with certain other layers.</span></span> <span data-ttu-id="d18e3-151">ライブラリ間でどのような依存関係が設定を明確に識別できるため、レイヤーが別のクラス ライブラリとして実装されている場合を適用しやすくする必要があります。</span><span class="sxs-lookup"><span data-stu-id="d18e3-151">That may be easier to enforce if layers are implemented as different class libraries, because you can clearly identify what dependencies are set between libraries.</span></span> <span data-ttu-id="d18e3-152">たとえば、ドメイン モデル層受け取ることはできません、依存関係他のレイヤーに (ドメイン モデル クラスは Plain Old CLR Object、する必要がありますまたは[POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object)クラス)。</span><span class="sxs-lookup"><span data-stu-id="d18e3-152">For instance, the domain model layer should not take a dependency on any other layer (the domain model classes should be Plain Old CLR Objects, or [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object), classes).</span></span> <span data-ttu-id="d18e3-153">図 9-6 のように、 **Ordering.Domain** .NET Core ライブラリでのみ、その他のカスタム ライブラリ (データ ライブラリ、永続化ライブラリなど) ではなく、レイヤー ライブラリが依存関係。</span><span class="sxs-lookup"><span data-stu-id="d18e3-153">As shown in Figure 9-6, the **Ordering.Domain** layer library has dependencies only on the .NET Core libraries but not on any other custom library (data library, persistence library, etc.).</span></span>

![](./media/image7.PNG)

<span data-ttu-id="d18e3-154">**図 9-6**です。</span><span class="sxs-lookup"><span data-stu-id="d18e3-154">**Figure 9-6**.</span></span> <span data-ttu-id="d18e3-155">ライブラリは、レイヤー間の依存関係の制御を強化を許可するように実装レイヤー</span><span class="sxs-lookup"><span data-stu-id="d18e3-155">Layers implemented as libraries allow better control of dependencies between layers</span></span>

### <a name="the-domain-model-layer"></a><span data-ttu-id="d18e3-156">ドメイン モデル レイヤー</span><span class="sxs-lookup"><span data-stu-id="d18e3-156">The domain model layer</span></span>

<span data-ttu-id="d18e3-157">Eric Evans 優れた book[ドメイン駆動設計](http://domainlanguage.com/ddd/)ドメイン モデル層とアプリケーション層について、次の質問。</span><span class="sxs-lookup"><span data-stu-id="d18e3-157">Eric Evans's excellent book [Domain Driven Design](http://domainlanguage.com/ddd/) says the following about the domain model layer and the application layer.</span></span>

<span data-ttu-id="d18e3-158">**ドメイン モデル層**: ビジネス、ビジネス ルールとビジネスの状況に関する情報の概念を表すを担当します。</span><span class="sxs-lookup"><span data-stu-id="d18e3-158">**Domain Model Layer**: Responsible for representing concepts of the business, information about the business situation, and business rules.</span></span> <span data-ttu-id="d18e3-159">ビジネスの状況を反映する状態が制御され、ここでは、使用される場合でも、格納することの技術的な詳細は、インフラストラクチャに委任されます。</span><span class="sxs-lookup"><span data-stu-id="d18e3-159">State that reflects the business situation is controlled and used here, even though the technical details of storing it are delegated to the infrastructure.</span></span> <span data-ttu-id="d18e3-160">このレイヤーは、ビジネス ソフトウェアの中核です。</span><span class="sxs-lookup"><span data-stu-id="d18e3-160">This layer is the heart of business software.</span></span>

<span data-ttu-id="d18e3-161">ドメイン モデル レイヤーでは、ビジネスが表されます。</span><span class="sxs-lookup"><span data-stu-id="d18e3-161">The domain model layer is where the business is expressed.</span></span> <span data-ttu-id="d18e3-162">マイクロ サービス ドメイン モデル レイヤーを .NET で実装するときに、そのレイヤーはに加えて動作 (メソッドのロジックを持つ) のデータをキャプチャするドメイン エンティティを含むクラス ライブラリとしてコード化されました。</span><span class="sxs-lookup"><span data-stu-id="d18e3-162">When you implement a microservice domain model layer in .NET, that layer is coded as a class library with the domain entities that capture data plus behavior (methods with logic).</span></span>

<span data-ttu-id="d18e3-163">次の[持続性の無視が適用](http://deviq.com/persistence-ignorance/)と[インフラストラクチャの無視が適用](https://ayende.com/blog/3137/infrastructure-ignorance)このレイヤーの基本原則はデータ持続性の詳細を完全に無視する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d18e3-163">Following the [Persistence Ignorance](http://deviq.com/persistence-ignorance/) and the [Infrastructure Ignorance](https://ayende.com/blog/3137/infrastructure-ignorance) principles, this layer must completely ignore data persistence details.</span></span> <span data-ttu-id="d18e3-164">インフラストラクチャ レイヤーでは、永続化タスクを実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d18e3-164">These persistence tasks should be performed by the infrastructure layer.</span></span> <span data-ttu-id="d18e3-165">そのため、このレイヤーはかかりません直接的な依存関係という重要な規則は、ドメイン モデルのエンティティ クラスには、インフラストラクチャに[POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object)s。</span><span class="sxs-lookup"><span data-stu-id="d18e3-165">Therefore, this layer should not take direct dependencies on the infrastructure, which means that an important rule is that your domain model entity classes should be [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object)s.</span></span>

<span data-ttu-id="d18e3-166">ドメイン エンティティでは、Entity Framework や NHibernate などのデータ アクセスのインフラストラクチャ フレームワークに直接的な依存関係 (など、基本クラスから派生する) 必要はありません。</span><span class="sxs-lookup"><span data-stu-id="d18e3-166">Domain entities should not have any direct dependency (like deriving from a base class) on any data access infrastructure framework like Entity Framework or NHibernate.</span></span> <span data-ttu-id="d18e3-167">理想的には、ドメイン エンティティがから派生されません、またはインフラストラクチャの任意のフレームワークで定義されている任意の型を実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d18e3-167">Ideally, your domain entities should not derive from or implement any type defined in any infrastructure framework.</span></span>

<span data-ttu-id="d18e3-168">Entity Framework Core などの最近のほとんどの ORM フレームワークでは、ドメイン モデル クラスは、インフラストラクチャに関連していないように、このアプローチができるようにします。</span><span class="sxs-lookup"><span data-stu-id="d18e3-168">Most modern ORM frameworks like Entity Framework Core allow this approach, so that your domain model classes are not coupled to the infrastructure.</span></span> <span data-ttu-id="d18e3-169">ただし、POCO エンティティを持つは常に特定の NoSQL データベースとアクターと Azure Service Fabric で信頼性の高いコレクションなどのフレームワークを使用する場合。</span><span class="sxs-lookup"><span data-stu-id="d18e3-169">However, having POCO entities is not always possible when using certain NoSQL databases and frameworks, like Actors and Reliable Collections in Azure Service Fabric.</span></span>

<span data-ttu-id="d18e3-170">ドメイン モデルの持続性の無視が適用原則に従う必要がある場合でもは、永続化に関する注意事項を無視する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d18e3-170">Even when it is important to follow the Persistence Ignorance principle for you Domain model, you should not ignore persistence concerns.</span></span> <span data-ttu-id="d18e3-171">物理的なデータ モデルとエンティティ オブジェクト モデルにマップする方法を理解することが重要はまだです。</span><span class="sxs-lookup"><span data-stu-id="d18e3-171">It is still very important to understand the physical data model and how it maps to your entity object model.</span></span> <span data-ttu-id="d18e3-172">それ以外の場合不可能なデザインを作成することができます。</span><span class="sxs-lookup"><span data-stu-id="d18e3-172">Otherwise you can create impossible designs.</span></span>

<span data-ttu-id="d18e3-173">またはありません、リレーショナル データベース用に設計されたモデルおよび NoSQL またはドキュメント指向のデータベースに直接移動できます。</span><span class="sxs-lookup"><span data-stu-id="d18e3-173">Also, this does not mean you can take a model designed for a relational database and directly move it to a NoSQL or document-oriented database.</span></span> <span data-ttu-id="d18e3-174">一部のエンティティ モデルでモデルが適合するが通常ことはありません。</span><span class="sxs-lookup"><span data-stu-id="d18e3-174">In some entity models, the model might fit, but usually it does not.</span></span> <span data-ttu-id="d18e3-175">エンティティ モデルに従う必要あります、記憶域テクノロジと ORM テクノロジの両方に基づく制約がまだです。</span><span class="sxs-lookup"><span data-stu-id="d18e3-175">There are still constraints that your entity model must adhere to, based both on the storage technology and ORM technology.</span></span>

### <a name="the-application-layer"></a><span data-ttu-id="d18e3-176">アプリケーション層</span><span class="sxs-lookup"><span data-stu-id="d18e3-176">The application layer</span></span>

<span data-ttu-id="d18e3-177">移動、アプリケーション レイヤーおをもう一度が示されている Eric Evans book[ドメイン駆動設計](http://domainlanguage.com/ddd/):</span><span class="sxs-lookup"><span data-stu-id="d18e3-177">Moving on to the application layer, we can again cite Eric Evans's book [Domain Driven Design](http://domainlanguage.com/ddd/):</span></span>

<span data-ttu-id="d18e3-178">**アプリケーション層:**ソフトウェアすべきし、問題を操作する表現力が豊かドメイン オブジェクト、ジョブを定義します。</span><span class="sxs-lookup"><span data-stu-id="d18e3-178">**Application Layer:** Defines the jobs the software is supposed to do and directs the expressive domain objects to work out problems.</span></span> <span data-ttu-id="d18e3-179">このレイヤーは、担当タスクとは、ビジネスにとって意味のある、または他のシステムのアプリケーション層との対話に必要です。</span><span class="sxs-lookup"><span data-stu-id="d18e3-179">The tasks this layer is responsible for are meaningful to the business or necessary for interaction with the application layers of other systems.</span></span> <span data-ttu-id="d18e3-180">このレイヤーは、シンは保持されます。</span><span class="sxs-lookup"><span data-stu-id="d18e3-180">This layer is kept thin.</span></span> <span data-ttu-id="d18e3-181">ビジネス ルールまたは、ナレッジを含まないが、のみ座標タスクとデリゲートで作業を次の層内のドメイン オブジェクトのコラボレーション ダウンします。</span><span class="sxs-lookup"><span data-stu-id="d18e3-181">It does not contain business rules or knowledge, but only coordinates tasks and delegates work to collaborations of domain objects in the next layer down.</span></span> <span data-ttu-id="d18e3-182">ビジネスの状況を反映した状態はありませんが、ユーザーまたはプログラムの作業の進行状況を反映する状態を持つことができます。</span><span class="sxs-lookup"><span data-stu-id="d18e3-182">It does not have state reflecting the business situation, but it can have state that reflects the progress of a task for the user or the program.</span></span>

<span data-ttu-id="d18e3-183">マイクロ サービスのアプリケーション層を .NET では、ASP.NET Core Web API プロジェクトとしてよくコーディングされます。</span><span class="sxs-lookup"><span data-stu-id="d18e3-183">A microservice’s application layer in .NET is commonly coded as an ASP.NET Core Web API project.</span></span> <span data-ttu-id="d18e3-184">プロジェクトは、マイクロ サービスの相互作用、リモート ネットワーク アクセス、および UI またはクライアント アプリから使用される外部の Web Api を実装します。</span><span class="sxs-lookup"><span data-stu-id="d18e3-184">The project implements the microservice’s interaction, remote network access, and the external Web APIs used from the UI or client apps.</span></span> <span data-ttu-id="d18e3-185">マイクロ サービス、およびであっても、イベント ドリブン間の通信 microservices (統合イベント) によって有効なコマンドからアプローチを CQRS を使用して、クエリが含まれます。</span><span class="sxs-lookup"><span data-stu-id="d18e3-185">It includes queries if using a CQRS approach, commands accepted by the microservice, and even the event-driven communication between microservices (integration events).</span></span> <span data-ttu-id="d18e3-186">アプリケーション層を表す ASP.NET Core Web API には、ビジネス ルールまたはドメインのナレッジ (特にドメイン ルールは、トランザクションまたは更新) です。これらは、ドメイン モデル クラス ライブラリが所有する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d18e3-186">The ASP.NET Core Web API that represents the application layer must not contain business rules or domain knowledge (especially domain rules for transactions or updates); these should be owned by the domain model class library.</span></span> <span data-ttu-id="d18e3-187">アプリケーション レイヤー必要がありますのみ座標タスクしする必要がありますいないを保持または任意のドメインの状態 (ドメイン モデル) を定義します。</span><span class="sxs-lookup"><span data-stu-id="d18e3-187">The application layer must only coordinate tasks and must not hold or define any domain state (domain model).</span></span> <span data-ttu-id="d18e3-188">これは、それらのドメイン エンティティ内のデータを更新する必要が最終的に自体 (集計ルートとドメイン エンティティ)、ドメイン モデル クラスに、ビジネス ルールの実行を代行します。</span><span class="sxs-lookup"><span data-stu-id="d18e3-188">It delegates the execution of business rules to the domain model classes themselves (aggregate roots and domain entities), which will ultimately update the data within those domain entities.</span></span>

<span data-ttu-id="d18e3-189">基本的には、アプリケーション ロジックは、指定したフロント エンドに依存するすべてのユース ケースを実装します。</span><span class="sxs-lookup"><span data-stu-id="d18e3-189">Basically, the application logic is where you implement all use cases that depend on a given front end.</span></span> <span data-ttu-id="d18e3-190">たとえば、Web API サービスに関連する実装。</span><span class="sxs-lookup"><span data-stu-id="d18e3-190">For example, the implementation related to a Web API service.</span></span>

<span data-ttu-id="d18e3-191">目標は、ドメイン モデル層、そのインバリアント、データ モデル、および関連するビジネス ルールのドメイン ロジック、プレゼンテーション層とアプリケーション層から完全に独立している必要があります。</span><span class="sxs-lookup"><span data-stu-id="d18e3-191">The goal is that the domain logic in the domain model layer, its invariants, the data model, and related business rules must be completely independent from the presentation and application layers.</span></span> <span data-ttu-id="d18e3-192">ほとんどすべてのドメイン モデル レイヤー必要があります直接に依存しないのインフラストラクチャ フレームワークです。</span><span class="sxs-lookup"><span data-stu-id="d18e3-192">Most of all, the domain model layer must not directly depend on any infrastructure framework.</span></span>

### <a name="the-infrastructure-layer"></a><span data-ttu-id="d18e3-193">インフラストラクチャ レイヤー</span><span class="sxs-lookup"><span data-stu-id="d18e3-193">The infrastructure layer</span></span>

<span data-ttu-id="d18e3-194">インフラストラクチャ レイヤーは、(メモリ内) のドメイン エンティティに最初に保持されているデータをデータベースまたは別の永続的なストアに永続化する方法です。</span><span class="sxs-lookup"><span data-stu-id="d18e3-194">The infrastructure layer is how the data that is initially held in domain entities (in memory) is persisted in databases or another persistent store.</span></span> <span data-ttu-id="d18e3-195">例は、Entity Framework Core コードを使用して DBContext をリレーショナル データベース内のデータを永続化に使用されるリポジトリ パターン クラスを実装するがします。</span><span class="sxs-lookup"><span data-stu-id="d18e3-195">An example is using Entity Framework Core code to implement the Repository pattern classes that use a DBContext to persist data in a relational database.</span></span>

<span data-ttu-id="d18e3-196">前に説明したに従って[持続性の無視が適用](http://deviq.com/persistence-ignorance/)と[インフラストラクチャの無視が適用](https://ayende.com/blog/3137/infrastructure-ignorance)原則、インフラストラクチャ レイヤー必要があります「ソケットピン」ドメイン モデル レイヤー。</span><span class="sxs-lookup"><span data-stu-id="d18e3-196">In accordance with the previously mentioned [Persistence Ignorance](http://deviq.com/persistence-ignorance/) and [Infrastructure Ignorance](https://ayende.com/blog/3137/infrastructure-ignorance) principles, the infrastructure layer must not “contaminate” the domain model layer.</span></span> <span data-ttu-id="d18e3-197">いないフレームワークについてハード依存関係を作成して (EF またはその他の任意のフレームワーク) のデータを永続化を使用するインフラストラクチャをドメイン モデル エンティティ クラスに依存しませんを維持する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d18e3-197">You must keep the domain model entity classes agnostic from the infrastructure that you use to persist data (EF or any other framework) by not taking hard dependencies on frameworks.</span></span> <span data-ttu-id="d18e3-198">ドメイン モデル レイヤー クラス ライブラリでは、ドメイン コードのみをだけが必要[POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object)エンティティは、ソフトウェアの中心となるを実装するクラスし、インフラストラクチャ テクノロジから完全に分離します。</span><span class="sxs-lookup"><span data-stu-id="d18e3-198">Your domain model layer class library should have only your domain code, just [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object) entity classes implementing the heart of your software and completely decoupled from infrastructure technologies.</span></span>

<span data-ttu-id="d18e3-199">したがって、レイヤーまたはクラス ライブラリとプロジェクト必要があります最終的に依存ドメイン モデル レイヤー (ライブラリ)、逆はできない、図 9-7 に示すようにします。</span><span class="sxs-lookup"><span data-stu-id="d18e3-199">Thus, your layers or class libraries and projects should ultimately depend on your domain model layer (library), not vice versa, as shown in Figure 9-7.</span></span>

![](./media/image8.png)

<span data-ttu-id="d18e3-200">**図 9-7**です。</span><span class="sxs-lookup"><span data-stu-id="d18e3-200">**Figure 9-7**.</span></span> <span data-ttu-id="d18e3-201">DDD 内のレイヤー間の依存関係</span><span class="sxs-lookup"><span data-stu-id="d18e3-201">Dependencies between layers in DDD</span></span>

<span data-ttu-id="d18e3-202">このレイヤーのデザインは、各マイクロ サービスを独立している必要があります。</span><span class="sxs-lookup"><span data-stu-id="d18e3-202">This layer design should be independent for each microservice.</span></span> <span data-ttu-id="d18e3-203">最も複雑な microservices を実装するには前述のように、簡単な方法で、次のデータ ドリブン DDD パターンを簡単に実装する間に microservices (1 つのレイヤーで単純な CRUD)。</span><span class="sxs-lookup"><span data-stu-id="d18e3-203">As noted earlier, you can implement the most complex microservices following DDD patterns, while implementing simpler data-driven microservices (simple CRUD in a single layer) in a simpler way.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="d18e3-204">その他の技術情報</span><span class="sxs-lookup"><span data-stu-id="d18e3-204">Additional resources</span></span>

-   <span data-ttu-id="d18e3-205">**DevIQ です。持続性の無視が適用原則**
    [*http://deviq.com/persistence-ignorance/*](http://deviq.com/persistence-ignorance/)</span><span class="sxs-lookup"><span data-stu-id="d18e3-205">**DevIQ. Persistence Ignorance principle**
[*http://deviq.com/persistence-ignorance/*](http://deviq.com/persistence-ignorance/)</span></span>

-   <span data-ttu-id="d18e3-206">**Oren Eini です。インフラストラクチャの無視が適用**
    [*https://ayende.com/blog/3137/infrastructure-ignorance*](https://ayende.com/blog/3137/infrastructure-ignorance)</span><span class="sxs-lookup"><span data-stu-id="d18e3-206">**Oren Eini. Infrastructure Ignorance**
[*https://ayende.com/blog/3137/infrastructure-ignorance*](https://ayende.com/blog/3137/infrastructure-ignorance)</span></span>

-   <span data-ttu-id="d18e3-207">**天使ロペスです。階層設計のドメインに基づくアーキテクチャ**
    [*https://ajlopez.wordpress.com/2008/09/12/layered-architecture-in-domain-driven-design/*](https://ajlopez.wordpress.com/2008/09/12/layered-architecture-in-domain-driven-design/)</span><span class="sxs-lookup"><span data-stu-id="d18e3-207">**Angel Lopez. Layered Architecture In Domain-Driven Design**
[*https://ajlopez.wordpress.com/2008/09/12/layered-architecture-in-domain-driven-design/*](https://ajlopez.wordpress.com/2008/09/12/layered-architecture-in-domain-driven-design/)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="d18e3-208">[前](cqrs-マイクロ サービス-reads.md) [次へ] (マイクロ サービス ドメイン model.md)</span><span class="sxs-lookup"><span data-stu-id="d18e3-208">[Previous] (cqrs-microservice-reads.md) [Next] (microservice-domain-model.md)</span></span>
