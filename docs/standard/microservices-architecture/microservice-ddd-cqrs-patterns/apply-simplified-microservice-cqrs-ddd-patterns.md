---
title: "マイクロ サービスの簡略化された CQRS と DDD パターンを適用します。"
description: "コンテナーの .NET アプリケーションの .NET Microservices アーキテクチャ |マイクロ サービスの簡略化された CQRS と DDD パターンを適用します。"
keywords: "Docker, マイクロサービス, ASP.NET, コンテナー"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: 99fd7ce32039742e23f8e01aa4c33cddd7a9f698
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/18/2017
---
# <a name="applying-simplified-cqrs-and-ddd-patterns-in-a-microservice"></a><span data-ttu-id="9e8ed-104">マイクロ サービスの簡略化された CQRS と DDD パターンを適用します。</span><span class="sxs-lookup"><span data-stu-id="9e8ed-104">Applying simplified CQRS and DDD patterns in a microservice</span></span>

<span data-ttu-id="9e8ed-105">CQRS は、アーキテクチャ パターンを区切るデータ読み取りおよび書き込みのモデルです。</span><span class="sxs-lookup"><span data-stu-id="9e8ed-105">CQRS is an architectural pattern that separates the models for reading and writing data.</span></span> <span data-ttu-id="9e8ed-106">関連する用語[コマンド クエリの分離 (CQS)](https://martinfowler.com/bliki/CommandQuerySeparation.html)著書で最初に定義して Bertrand Meyer された*オブジェクト指向のソフトウェアの構築*です。</span><span class="sxs-lookup"><span data-stu-id="9e8ed-106">The related term [Command Query Separation (CQS)](https://martinfowler.com/bliki/CommandQuerySeparation.html) was originally defined by Bertrand Meyer in his book *Object Oriented Software Construction*.</span></span> <span data-ttu-id="9e8ed-107">基本的な考え方は、大幅に区切られた 2 つのカテゴリにシステムの操作を分割することができます。</span><span class="sxs-lookup"><span data-stu-id="9e8ed-107">The basic idea is that you can divide a system’s operations into two sharply separated categories:</span></span>

-   <span data-ttu-id="9e8ed-108">クエリを実行します。</span><span class="sxs-lookup"><span data-stu-id="9e8ed-108">Queries.</span></span> <span data-ttu-id="9e8ed-109">これらの結果を返すし、システムの状態は変更されず、、副作用の自由です。</span><span class="sxs-lookup"><span data-stu-id="9e8ed-109">These return a result and do not change the state of the system, and they are free of side effects.</span></span>

-   <span data-ttu-id="9e8ed-110">コマンド。</span><span class="sxs-lookup"><span data-stu-id="9e8ed-110">Commands.</span></span> <span data-ttu-id="9e8ed-111">これらは、システムの状態を変更します。</span><span class="sxs-lookup"><span data-stu-id="9e8ed-111">These change the state of a system.</span></span>

<span data-ttu-id="9e8ed-112">CQS は単純な概念-は、同じオブジェクト内のメソッドに関する説明はクエリまたはコマンド。</span><span class="sxs-lookup"><span data-stu-id="9e8ed-112">CQS is a simple concept—it is about methods within the same object being either queries or commands.</span></span> <span data-ttu-id="9e8ed-113">各メソッドは、状態を返すか、または、状態、両方は使用しない場合でも変化します。</span><span class="sxs-lookup"><span data-stu-id="9e8ed-113">Each method either returns state or mutates state, but not both.</span></span> <span data-ttu-id="9e8ed-114">1 つのリポジトリ パターンのオブジェクトでもは、CQS に従っていることができます。</span><span class="sxs-lookup"><span data-stu-id="9e8ed-114">Even a single repository pattern object can comply with CQS.</span></span> <span data-ttu-id="9e8ed-115">CQS 対象となる基本原則 CQRS です。</span><span class="sxs-lookup"><span data-stu-id="9e8ed-115">CQS can be considered a foundational principle for CQRS.</span></span>

<span data-ttu-id="9e8ed-116">[コマンドと Query Responsibility Segregation (CQRS)](https://martinfowler.com/bliki/CQRS.html) Greg young 氏が導入され強く Udi Dahan やその他のユーザーによって昇格されました。</span><span class="sxs-lookup"><span data-stu-id="9e8ed-116">[Command and Query Responsibility Segregation (CQRS)](https://martinfowler.com/bliki/CQRS.html) was introduced by Greg Young and strongly promoted by Udi Dahan and others.</span></span> <span data-ttu-id="9e8ed-117">ただしより詳細な CQS 原則に基づいています。</span><span class="sxs-lookup"><span data-stu-id="9e8ed-117">It is based on the CQS principle, although it is more detailed.</span></span> <span data-ttu-id="9e8ed-118">コマンドとイベント上と必要に応じて非同期メッセージに基づくパターンと見なされることができます。</span><span class="sxs-lookup"><span data-stu-id="9e8ed-118">It can be considered a pattern based on commands and events plus optionally on asynchronous messages.</span></span> <span data-ttu-id="9e8ed-119">多くの場合は、CQRS は書き込み (更新プログラム) よりも読み取り (クエリ) の別の物理データベースを持つようより高度なシナリオに関連します。</span><span class="sxs-lookup"><span data-stu-id="9e8ed-119">In many cases, CQRS is related to more advanced scenarios, like having a different physical database for reads (queries) than for writes (updates).</span></span> <span data-ttu-id="9e8ed-120">さらに、複数展開 CQRS システムで実装できます[イベント インソーシング (ES)](http://codebetter.com/gregyoung/2010/02/20/why-use-event-sourcing/)更新プログラム データベースのためだけイベントに格納、現在の状態データを保管する代わりに、ドメイン モデル。</span><span class="sxs-lookup"><span data-stu-id="9e8ed-120">Moreover, a more evolved CQRS system might implement [Event-Sourcing (ES)](http://codebetter.com/gregyoung/2010/02/20/why-use-event-sourcing/) for your updates database, so you would only store events in the domain model instead of storing the current-state data.</span></span> <span data-ttu-id="9e8ed-121">ただし、これはありません。 このガイドで使用する方法です。コマンドからのクエリを分離するだけで構成される、最も簡単な CQRS アプローチを使用します。</span><span class="sxs-lookup"><span data-stu-id="9e8ed-121">However, this is not the approach used in this guide; we are using the simplest CQRS approach, which consists of just separating the queries from the commands.</span></span>

<span data-ttu-id="9e8ed-122">CQRS の分離の側面は、別のレイヤーでのコマンドおよび 1 つのレイヤーでクエリ操作をグループ化によって実現されます。</span><span class="sxs-lookup"><span data-stu-id="9e8ed-122">The separation aspect of CQRS is achieved by grouping query operations in one layer and commands in another layer.</span></span> <span data-ttu-id="9e8ed-123">各レイヤーは、独自のデータ モデル (モデルでは、別のデータベースでは必ずしもということに注意してください) を持ち、パターンとテクノロジの独自の組み合わせを使用してビルドします。</span><span class="sxs-lookup"><span data-stu-id="9e8ed-123">Each layer has its own data model (note that we say model, not necessarily a different database) and is built using its own combination of patterns and technologies.</span></span> <span data-ttu-id="9e8ed-124">さらに、2 つのレイヤーは、同じ層またはマイクロ サービスを (マイクロ サービスの順序) 例と同様にこのガイドで使用される内にあることができます。</span><span class="sxs-lookup"><span data-stu-id="9e8ed-124">More importantly, the two layers can be within the same tier or microservice, as in the example (ordering microservice) used for this guide.</span></span> <span data-ttu-id="9e8ed-125">または、最適化およびをスケール アウトとは別に相互の影響を与えずにできるように異なる microservices またはプロセスを実装できます。</span><span class="sxs-lookup"><span data-stu-id="9e8ed-125">Or they could be implemented on different microservices or processes so they can be optimized and scaled out separately without affecting one another.</span></span>

<span data-ttu-id="9e8ed-126">CQRS は、他のコンテキストで 1 つである読み取り/書き込み操作の 2 つのオブジェクトを使うことを意味します。</span><span class="sxs-lookup"><span data-stu-id="9e8ed-126">CQRS means having two objects for a read/write operation where in other contexts there is one.</span></span> <span data-ttu-id="9e8ed-127">高度な CQRS 文献で学習できますが、非正規化された読み取りデータベースが存在する理由があります。</span><span class="sxs-lookup"><span data-stu-id="9e8ed-127">There are reasons to have a denormalized reads database, which you can learn about in more advanced CQRS literature.</span></span> <span data-ttu-id="9e8ed-128">使用しないその方法をここでは、ことが目的で集計のような DDD パターンから制約を使用したクエリを制限することではなくクエリをより柔軟です。</span><span class="sxs-lookup"><span data-stu-id="9e8ed-128">But we are not using that approach here, where the goal is to have more flexibility in the queries instead of limiting the queries with constraints from DDD patterns like aggregates.</span></span>

<span data-ttu-id="9e8ed-129">この種のサービスの例は、eShopOnContainers の参照をアプリケーションから順序マイクロ サービスです。</span><span class="sxs-lookup"><span data-stu-id="9e8ed-129">An example of this kind of service is the ordering microservice from the eShopOnContainers reference application.</span></span> <span data-ttu-id="9e8ed-130">このサービスでは、簡略化した CQRS 方法に基づいてマイクロ サービスを実装します。</span><span class="sxs-lookup"><span data-stu-id="9e8ed-130">This service implements a microservice based on a simplified CQRS approach.</span></span> <span data-ttu-id="9e8ed-131">使用、1 つのデータ ソースまたはデータベースが、2 つの論理モデルと DDD パターン トランザクションのドメインでは、図 9-2 に示すようにします。</span><span class="sxs-lookup"><span data-stu-id="9e8ed-131">It uses a single data source or database, but two logical models plus DDD patterns for the transactional domain, as shown in Figure 9-2.</span></span>

![](./media/image2.png)

<span data-ttu-id="9e8ed-132">**図 9-2**です。</span><span class="sxs-lookup"><span data-stu-id="9e8ed-132">**Figure 9-2**.</span></span> <span data-ttu-id="9e8ed-133">マイクロ サービスの簡略化された CQRS および DDD ベース</span><span class="sxs-lookup"><span data-stu-id="9e8ed-133">Simplified CQRS- and DDD-based microservice</span></span>

<span data-ttu-id="9e8ed-134">アプリケーション レイヤーでは、Web API 自体を指定できます。</span><span class="sxs-lookup"><span data-stu-id="9e8ed-134">The application layer can be the Web API itself.</span></span> <span data-ttu-id="9e8ed-135">重要な設計の側面をここでは、マイクロ サービスに分割することが、クエリと ViewModels (データ モデルが特にクライアント アプリケーションの作成)、コマンド、ドメイン モデル、および CQRS パターンに従うトランザクションです。</span><span class="sxs-lookup"><span data-stu-id="9e8ed-135">The important design aspect here is that the microservice has split the queries and ViewModels (data models especially created for the client applications) from the commands, domain model, and transactions following the CQRS pattern.</span></span> <span data-ttu-id="9e8ed-136">この方法は、制限事項と制約の以降のセクションで説明したもののみのトランザクションと更新したり、意味のある DDD パターンからのものから独立して、クエリを保持します。</span><span class="sxs-lookup"><span data-stu-id="9e8ed-136">This approach keeps the queries independent from restrictions and constraints coming from DDD patterns that only make sense for transactions and updates, as explained in later sections.</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="9e8ed-137">[前](index.md) [次へ] (eshoponcontainers-cqrs-ddd-microservice.md)</span><span class="sxs-lookup"><span data-stu-id="9e8ed-137">[Previous] (index.md) [Next] (eshoponcontainers-cqrs-ddd-microservice.md)</span></span>
