---
title: "インフラストラクチャの永続性レイヤーをデザイン"
description: "コンテナーの .NET アプリケーションの .NET Microservices アーキテクチャ |インフラストラクチャの永続性レイヤーをデザイン"
keywords: "Docker, マイクロサービス, ASP.NET, コンテナー"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: ce0f1d608eed909a7707f3c580afc5253f3eef06
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/18/2017
---
# <a name="designing-the-infrastructure-persistence-layer"></a><span data-ttu-id="c0efd-104">インフラストラクチャの永続性レイヤーをデザイン</span><span class="sxs-lookup"><span data-stu-id="c0efd-104">Designing the infrastructure persistence layer</span></span>

<span data-ttu-id="c0efd-105">データの永続化コンポーネントは、マイクロ サービス (つまり、マイクロ サービスのデータベース) の境界内でホストされているデータへのアクセスを提供します。</span><span class="sxs-lookup"><span data-stu-id="c0efd-105">Data persistence components provide access to the data hosted within the boundaries of a microservice (that is, a microservice’s database).</span></span> <span data-ttu-id="c0efd-106">リポジトリなどのコンポーネントの実際の実装が含まれていると[作業単位](http://martinfowler.com/eaaCatalog/unitOfWork.html)カスタム EF DBContexts などのクラスです。</span><span class="sxs-lookup"><span data-stu-id="c0efd-106">They contain the actual implementation of components such as repositories and [Unit of Work](http://martinfowler.com/eaaCatalog/unitOfWork.html) classes, like custom EF DBContexts.</span></span>

## <a name="the-repository-pattern"></a><span data-ttu-id="c0efd-107">リポジトリ パターン</span><span class="sxs-lookup"><span data-stu-id="c0efd-107">The Repository pattern</span></span>

<span data-ttu-id="c0efd-108">リポジトリは、クラスまたはデータ ソースへのアクセスに必要なロジックをカプセル化するコンポーネントです。</span><span class="sxs-lookup"><span data-stu-id="c0efd-108">Repositories are classes or components that encapsulate the logic required to access data sources.</span></span> <span data-ttu-id="c0efd-109">これらには、一般的なデータ アクセス機能を保守性の向上を提供して、インフラストラクチャまたはドメイン モデル レイヤーからデータベースにアクセスするためのテクノロジを切り離すことが一元管理します。</span><span class="sxs-lookup"><span data-stu-id="c0efd-109">They centralize common data access functionality, providing better maintainability and decoupling the infrastructure or technology used to access databases from the domain model layer.</span></span> <span data-ttu-id="c0efd-110">Entity Framework と同様に、ORM を使用する場合は LINQ と厳密な型指定のおかげで実装する必要がありますのあるコードが簡素化されます。</span><span class="sxs-lookup"><span data-stu-id="c0efd-110">If you use an ORM like Entity Framework, the code that must be implemented is simplified, thanks to LINQ and strong typing.</span></span> <span data-ttu-id="c0efd-111">これによりデータではなく、データの永続化ロジックに集中することの組み込みにアクセスします。</span><span class="sxs-lookup"><span data-stu-id="c0efd-111">This lets you focus on the data persistence logic rather than on data access plumbing.</span></span>

<span data-ttu-id="c0efd-112">リポジトリ パターンは、データ ソースを操作の詳しい解説方法です。</span><span class="sxs-lookup"><span data-stu-id="c0efd-112">The Repository pattern is a well-documented way of working with a data source.</span></span> <span data-ttu-id="c0efd-113">ブックで[エンタープライズ アプリケーションのアーキテクチャのパターン](https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420/)、次のように Martin ファウラーにリポジトリがについて説明します。</span><span class="sxs-lookup"><span data-stu-id="c0efd-113">In the book [Patterns of Enterprise Application Architecture](https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420/), Martin Fowler describes a repository as follows:</span></span>

<span data-ttu-id="c0efd-114">リポジトリは、メモリ内のドメイン オブジェクトのセットに似た方法で動作する、ドメイン モデル レイヤーとデータのマッピングの間の媒介のタスクを実行します。</span><span class="sxs-lookup"><span data-stu-id="c0efd-114">A repository performs the tasks of an intermediary between the domain model layers and data mapping, acting in a similar way to a set of domain objects in memory.</span></span> <span data-ttu-id="c0efd-115">クライアント オブジェクトは、宣言によってクエリの作成し、回答のリポジトリに送信します。</span><span class="sxs-lookup"><span data-stu-id="c0efd-115">Client objects declaratively build queries and send them to the repositories for answers.</span></span> <span data-ttu-id="c0efd-116">概念的には、リポジトリは、永続性レイヤーに近い方法を提供するのには、実行できる操作、データベースに格納されているオブジェクトのセットをカプセル化します。</span><span class="sxs-lookup"><span data-stu-id="c0efd-116">Conceptually, a repository encapsulates a set of objects stored in the database and operations that can be performed on them, providing a way that is closer to the persistence layer.</span></span> <span data-ttu-id="c0efd-117">リポジトリはまた、明確にし、一方向で、作業ドメインとデータの割り当ての間の依存関係を分離またはマッピングの目的をサポートします。</span><span class="sxs-lookup"><span data-stu-id="c0efd-117">Repositories, also, support the purpose of separating, clearly and in one direction, the dependency between the work domain and the data allocation or mapping.</span></span>

### <a name="define-one-repository-per-aggregate"></a><span data-ttu-id="c0efd-118">集計ごとに 1 つのリポジトリを定義します。</span><span class="sxs-lookup"><span data-stu-id="c0efd-118">Define one repository per aggregate</span></span>

<span data-ttu-id="c0efd-119">各集計または集計ルートには、1 つのリポジトリ クラスを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c0efd-119">For each aggregate or aggregate root, you should create one repository class.</span></span> <span data-ttu-id="c0efd-120">ドメイン ベースのデザイン パターンに基づくマイクロ サービス、チャネルの唯一のデータベースの更新に使用する必要がありますはリポジトリをする必要があります。</span><span class="sxs-lookup"><span data-stu-id="c0efd-120">In a microservice based on domain-driven design patterns, the only channel you should use to update the database should be the repositories.</span></span> <span data-ttu-id="c0efd-121">これは、集計の不変性とトランザクションの一貫性を制御する集計ルートと一対一のリレーションシップがあるためです。</span><span class="sxs-lookup"><span data-stu-id="c0efd-121">This is because they have a one-to-one relationship with the aggregate root, which controls the aggregate’s invariants and transactional consistency.</span></span> <span data-ttu-id="c0efd-122">他のデータベースを照会することがチャンネル (CQRS アプローチに従って行うことができます) と、クエリでは、データベースの状態が変更されないためです。</span><span class="sxs-lookup"><span data-stu-id="c0efd-122">It is okay to query the database through other channels (as you can do following a CQRS approach), because queries do not change the state of the database.</span></span> <span data-ttu-id="c0efd-123">ただし、トランザクション領域 — 更新プログラム-リポジトリと集計のルートで常に制御する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c0efd-123">However, the transactional area—the updates—must always be controlled by the repositories and the aggregate roots.</span></span>

<span data-ttu-id="c0efd-124">基本的には、リポジトリには、ドメイン エンティティの形式でデータベースから取得されるメモリ内のデータを設定することができます。</span><span class="sxs-lookup"><span data-stu-id="c0efd-124">Basically, a repository allows you to populate data in memory that comes from the database in the form of the domain entities.</span></span> <span data-ttu-id="c0efd-125">後のエンティティは、メモリ内では、それらを変更して、トランザクションを使用してデータベースにし、永続化ことができます。</span><span class="sxs-lookup"><span data-stu-id="c0efd-125">Once the entities are in memory, they can be changed and then persisted back to the database through transactions.</span></span>

<span data-ttu-id="c0efd-126">前述の CQS/CQRS アーキテクチャ パターンを使用している場合、Dapper を使用して単純な SQL ステートメントによって実行されるドメイン モデルで不足側クエリによって最初のクエリが実行されます。</span><span class="sxs-lookup"><span data-stu-id="c0efd-126">As noted earlier, if you are using the CQS/CQRS architectural pattern, the initial queries will be performed by side queries out of the domain model, performed by simple SQL statements using Dapper.</span></span> <span data-ttu-id="c0efd-127">この方法は、はるかに必要なクエリを実行して任意のテーブルを結合するので、リポジトリよりも柔軟性、および集計からこれらのクエリがルールによって制限されません。</span><span class="sxs-lookup"><span data-stu-id="c0efd-127">This approach is much more flexible than repositories because you can query and join any tables you need, and these queries are not restricted by rules from the aggregates.</span></span> <span data-ttu-id="c0efd-128">そのデータは、プレゼンテーション層またはクライアント アプリに移動します。</span><span class="sxs-lookup"><span data-stu-id="c0efd-128">That data will go to the presentation layer or client app.</span></span>

<span data-ttu-id="c0efd-129">変更を行い、データを更新するが、アプリケーション層 (Web API サービスなど) にクライアント アプリまたはプレゼンテーション層から得られます。</span><span class="sxs-lookup"><span data-stu-id="c0efd-129">If the user makes changes, the data to be updated will come from the client app or presentation layer to the application layer (such as a Web API service).</span></span> <span data-ttu-id="c0efd-130">コマンド ハンドラーで (データ) を使用したコマンドを受信するとリポジトリを使用してデータベースから更新するデータを取得します。</span><span class="sxs-lookup"><span data-stu-id="c0efd-130">When you receive a command (with data) in a command handler, you use repositories to get the data you want to update from the database.</span></span> <span data-ttu-id="c0efd-131">メモリ内で、コマンドを使用して渡された情報を更新して、しを追加または更新トランザクションを使用して、データベース内のデータ (ドメイン エンティティ)。</span><span class="sxs-lookup"><span data-stu-id="c0efd-131">You update it in memory with the information passed with the commands, and you then add or update the data (domain entities) in the database through a transaction.</span></span>

<span data-ttu-id="c0efd-132">必要がありますを強調するもう一度を図 9-17 ように、各集計ルートに 1 つだけのリポジトリを定義する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c0efd-132">We must emphasize again that only one repository should be defined for each aggregate root, as shown in Figure 9-17.</span></span> <span data-ttu-id="c0efd-133">集計内のすべてのオブジェクト間のトランザクションの一貫性を維持するために、集計のルートの目標を達成するには、データベース内の各テーブルのリポジトリは作成しないでです。</span><span class="sxs-lookup"><span data-stu-id="c0efd-133">To achieve the goal of the aggregate root to maintain transactional consistency between all the objects within the aggregate, you should never create a repository for each table in the database.</span></span>

![](./media/image18.png)

<span data-ttu-id="c0efd-134">**図 9-17**です。</span><span class="sxs-lookup"><span data-stu-id="c0efd-134">**Figure 9-17**.</span></span> <span data-ttu-id="c0efd-135">リポジトリ、集計、およびデータベースのテーブル間のリレーションシップ</span><span class="sxs-lookup"><span data-stu-id="c0efd-135">The relationship between repositories, aggregates, and database tables</span></span>

### <a name="enforcing-one-aggregate-root-per-repository"></a><span data-ttu-id="c0efd-136">リポジトリごとに 1 つの集計ルートを適用します。</span><span class="sxs-lookup"><span data-stu-id="c0efd-136">Enforcing one aggregate root per repository</span></span>

<span data-ttu-id="c0efd-137">集計ルートのみがリポジトリ ルールがによって適用されるように、リポジトリ設計を実装する価値があります。</span><span class="sxs-lookup"><span data-stu-id="c0efd-137">It can be valuable to implement your repository design in such a way that it enforces the rule that only aggregate roots should have repositories.</span></span> <span data-ttu-id="c0efd-138">連携して利用できるようにする IAggregateRoot マーカー インターフェイスには、エンティティの型を制約するジェネリック、またはベースのリポジトリの種類を作成することができます。</span><span class="sxs-lookup"><span data-stu-id="c0efd-138">You can create a generic or base repository type that constrains the type of entities it works with to ensure they have the IAggregateRoot marker interface.</span></span>

<span data-ttu-id="c0efd-139">このため、インフラストラクチャ レイヤーで実装されている各リポジトリ クラスを実装する独自の契約またはインターフェイスを次のコードに示すように。</span><span class="sxs-lookup"><span data-stu-id="c0efd-139">Thus, each repository class implemented at the infrastructure layer implements its own contract or interface, as shown in the following code:</span></span>

```csharp
namespace Microsoft.eShopOnContainers.Services.Ordering.Infrastructure.Repositories
{
    public class OrderRepository : IOrderRepository
    {
```

<span data-ttu-id="c0efd-140">特定のリポジトリの各インターフェイスには、ジェネリック IRepository インターフェイスを実装します。</span><span class="sxs-lookup"><span data-stu-id="c0efd-140">Each specific repository interface implements the generic IRepository interface:</span></span>

```csharp
public interface IOrderRepository : IRepository<Order>
{
    Order Add(Order order);
    // ...
}
```

<span data-ttu-id="c0efd-141">ただし、コードが、規則を適用する優れた方法として、特定の集計を対象とするリポジトリを使用している明示的なので、汎用的なリポジトリの種類を実装すること、1 つの集計に各リポジトリを関連付ける必要があります。</span><span class="sxs-lookup"><span data-stu-id="c0efd-141">However, a better way to have the code enforce the convention that each repository should be related to a single aggregate would be to implement a generic repository type so it is explicit that you are using a repository to target a specific aggregate.</span></span> <span data-ttu-id="c0efd-142">簡単に行えます IRepository 基本インターフェイスで、次のコードのように、そのジェネリックを実装することで。</span><span class="sxs-lookup"><span data-stu-id="c0efd-142">That can be easily done by implementing that generic in the IRepository base interface, as in the following code:</span></span>

```csharp
  public interface IRepository<T> where T : IAggregateRoot
```

### <a name="the-repository-pattern-makes-it-easier-to-test-your-application-logic"></a><span data-ttu-id="c0efd-143">リポジトリ パターンしやすく、アプリケーション ロジックをテストするには</span><span class="sxs-lookup"><span data-stu-id="c0efd-143">The Repository pattern makes it easier to test your application logic</span></span>

<span data-ttu-id="c0efd-144">リポジトリ パターンでは、単体テストでアプリケーションを簡単にテストすることができます。</span><span class="sxs-lookup"><span data-stu-id="c0efd-144">The Repository pattern allows you to easily test your application with unit tests.</span></span> <span data-ttu-id="c0efd-145">単体テストのみをテスト コード、インフラストラクチャではなく、リポジトリの抽象化によりその目的を達成しやすくために注意してください。</span><span class="sxs-lookup"><span data-stu-id="c0efd-145">Remember that unit tests only test your code, not infrastructure, so the repository abstractions make it easier to achieve that goal.</span></span>

<span data-ttu-id="c0efd-146">定義して配置リポジトリ インターフェイス ドメイン モデル レイヤーにおいて、アプリケーション レイヤー (マイクロたとえばに、Web API サービス) が、インフラストラクチャ レイヤーに直接依存しないようにがあることお勧め述べたように、前のセクションで、実際のリポジトリ クラスを実装します。</span><span class="sxs-lookup"><span data-stu-id="c0efd-146">As noted in an earlier section, it is recommended that you define and place the repository interfaces in the domain model layer so the application layer (for instance, your Web API microservice) does not depend directly on the infrastructure layer where you have implemented the actual repository classes.</span></span> <span data-ttu-id="c0efd-147">これを行うと、依存関係の挿入を使用して、Web api コント ローラーで、データベースからデータではなく偽のデータを返すモック リポジトリを実装できます。</span><span class="sxs-lookup"><span data-stu-id="c0efd-147">By doing this and using Dependency Injection in the controllers of your Web API, you can implement mock repositories that return fake data instead of data from the database.</span></span> <span data-ttu-id="c0efd-148">分離アプローチでは、作成することができ、実行の単位をテストすることは、データベースへの接続を必要とせず、アプリケーションのロジックだけをテストできます。</span><span class="sxs-lookup"><span data-stu-id="c0efd-148">That decoupled approach allows you to create and run unit tests that can test just the logic of your application without requiring connectivity to the database.</span></span>

<span data-ttu-id="c0efd-149">データベースへの接続が失敗する可能性し、さらに、データベースに対して数百台のテストを実行しているが、不適切な 2 つの理由。</span><span class="sxs-lookup"><span data-stu-id="c0efd-149">Connections to databases can fail and, more importantly, running hundreds of tests against a database is bad for two reasons.</span></span> <span data-ttu-id="c0efd-150">最初に、テスト数が多いため、多くの時間がかかることができます。</span><span class="sxs-lookup"><span data-stu-id="c0efd-150">First, it can take a lot of time because of the large number of tests.</span></span> <span data-ttu-id="c0efd-151">次に、データベースのレコードは、変更し、一貫性のある可能性がありますいないできるように、テストの結果に影響します。</span><span class="sxs-lookup"><span data-stu-id="c0efd-151">Second, the database records might change and impact the results of your tests, so that they might not be consistent.</span></span> <span data-ttu-id="c0efd-152">テスト データベースに対してはなく、単体テストとの統合をテストします。</span><span class="sxs-lookup"><span data-stu-id="c0efd-152">Testing against the database is not a unit tests but an integration test.</span></span> <span data-ttu-id="c0efd-153">高速で実行されている多くの単体テストが必要ですが、データベースに対して以下の統合をテストします。</span><span class="sxs-lookup"><span data-stu-id="c0efd-153">You should have many unit tests running fast, but fewer integration tests against the databases.</span></span>

<span data-ttu-id="c0efd-154">単体テストの関心の分離の観点から、ロジックは、メモリ内のドメイン エンティティで動作します。</span><span class="sxs-lookup"><span data-stu-id="c0efd-154">In terms of separation of concerns for unit tests, your logic operates on domain entities in memory.</span></span> <span data-ttu-id="c0efd-155">リポジトリのクラスが配信されるものと見なします。</span><span class="sxs-lookup"><span data-stu-id="c0efd-155">It assumes the repository class has delivered those.</span></span> <span data-ttu-id="c0efd-156">ロジックは、ドメイン エンティティを変更すると、リポジトリはストア クラスに正しく想定しています。</span><span class="sxs-lookup"><span data-stu-id="c0efd-156">Once your logic modifies the domain entities, it assumes the repository class will store them correctly.</span></span> <span data-ttu-id="c0efd-157">ここでの重要なポイントでは、ドメイン モデルとそのドメイン ロジックに対して単体テストを作成します。</span><span class="sxs-lookup"><span data-stu-id="c0efd-157">The important point here is to create unit tests against your domain model and its domain logic.</span></span> <span data-ttu-id="c0efd-158">集計のルートは、DDD でメイン整合性境界です。</span><span class="sxs-lookup"><span data-stu-id="c0efd-158">Aggregate roots are the main consistency boundaries in DDD.</span></span>

### <a name="the-difference-between-the-repository-pattern-and-the-legacy-data-access-class-dal-class-pattern"></a><span data-ttu-id="c0efd-159">リポジトリ パターンと、従来のデータ アクセス クラス (DAL) パターンの違い</span><span class="sxs-lookup"><span data-stu-id="c0efd-159">The difference between the Repository pattern and the legacy Data Access class (DAL class) pattern</span></span>

<span data-ttu-id="c0efd-160">データ アクセス オブジェクトは、記憶域に対するデータ アクセスおよび永続化操作を直接実行します。</span><span class="sxs-lookup"><span data-stu-id="c0efd-160">A data access object directly performs data access and persistence operations against storage.</span></span> <span data-ttu-id="c0efd-161">(EF DbContext を使用する場合) と同じ作業オブジェクトが、これらの更新プログラムの単位のメモリで実行する操作とデータはすぐに実行されませんリポジトリ マークします。</span><span class="sxs-lookup"><span data-stu-id="c0efd-161">A repository marks the data with the operations you want to perform in the memory of a unit of work object (as in EF when using the DbContext), but these updates will not be performed immediately.</span></span>

<span data-ttu-id="c0efd-162">作業の単位は、単一のトランザクションとして一種で、複数の挿入、更新、または削除操作に呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="c0efd-162">A unit of work is referred to as a single transaction that involves multiple insert, update, or delete operations.</span></span> <span data-ttu-id="c0efd-163">簡単に言えば、特定のユーザーの操作 (たとえば、web サイトに登録) のすべての insert、update、および削除トランザクションが処理されることで 1 つのトランザクションを意味します。</span><span class="sxs-lookup"><span data-stu-id="c0efd-163">In simple terms, it means that for a specific user action (for example, registration on a website), all the insert, update, and delete transactions are handled in a single transaction.</span></span> <span data-ttu-id="c0efd-164">これは、対話方法で複数のデータベース トランザクションを処理するよりも効率的です。</span><span class="sxs-lookup"><span data-stu-id="c0efd-164">This is more efficient than handling multiple database transactions in a chattier way.</span></span>

<span data-ttu-id="c0efd-165">コマンドのコードをアプリケーション層からときに、これら複数の永続化操作を 1 つのアクションで後で実行されます。</span><span class="sxs-lookup"><span data-stu-id="c0efd-165">These multiple persistence operations will be performed later in a single action when your code from the application layer commands it.</span></span> <span data-ttu-id="c0efd-166">に基づいて決定された実際のデータベースの記憶域にメモリ内の変更の適用については、通常、[作業単位パターン](http://martinfowler.com/eaaCatalog/unitOfWork.html)です。</span><span class="sxs-lookup"><span data-stu-id="c0efd-166">The decision about applying the in-memory changes to the actual database storage is typically based on the [Unit of Work pattern](http://martinfowler.com/eaaCatalog/unitOfWork.html).</span></span> <span data-ttu-id="c0efd-167">EF には、作業単位のパターンは、DBContext として実装されます。</span><span class="sxs-lookup"><span data-stu-id="c0efd-167">In EF, the Unit of Work pattern is implemented as the DBContext.</span></span>

<span data-ttu-id="c0efd-168">多くの場合、このパターン、または記憶域に対する操作を適用する方法アプリケーションのパフォーマンスを向上させるでき不一致の可能性を低減できます。</span><span class="sxs-lookup"><span data-stu-id="c0efd-168">In many cases, this pattern or way of applying operations against the storage can increase application performance and reduce the possibility of inconsistencies.</span></span> <span data-ttu-id="c0efd-169">意図したすべての操作は 1 つのトランザクションの一部としてコミットされるので、データベース テーブル内のブロック トランザクションが低くなります。</span><span class="sxs-lookup"><span data-stu-id="c0efd-169">Also, it reduces transaction blocking in the database tables, because all the intended operations are committed as part of one transaction.</span></span> <span data-ttu-id="c0efd-170">これは、データベースに対して多数の単独の操作を実行するシステムと比べて効率的です。</span><span class="sxs-lookup"><span data-stu-id="c0efd-170">This is more efficient in comparison to executing many isolated operations against the database.</span></span> <span data-ttu-id="c0efd-171">このため、選択した ORM は多くの小規模で別のトランザクションの実行ではなく、同じトランザクション内でいくつかの更新アクションをグループ化して、データベースに対して実行を最適化することになります。</span><span class="sxs-lookup"><span data-stu-id="c0efd-171">Therefore, the selected ORM will be able to optimize the execution against the database by grouping several update actions within the same transaction, as opposed to many small and separate transaction executions.</span></span>

### <a name="repositories-should-not-be-mandatory"></a><span data-ttu-id="c0efd-172">リポジトリを固定することはできません。</span><span class="sxs-lookup"><span data-stu-id="c0efd-172">Repositories should not be mandatory</span></span>

<span data-ttu-id="c0efd-173">カスタム リポジトリは、前に挙げたの理由により便利ですお eShopOnContainers で順序付けマイクロ サービスの実行方法。</span><span class="sxs-lookup"><span data-stu-id="c0efd-173">Custom repositories are useful for the reasons cited earlier, and that is the approach for the ordering microservice in eShopOnContainers.</span></span> <span data-ttu-id="c0efd-174">ただし、DDD 設計の実装も一般に .NET での開発の不可欠なパターンではありません。</span><span class="sxs-lookup"><span data-stu-id="c0efd-174">However, it is not an essential pattern to implement in a DDD design or even in general development in .NET.</span></span>

<span data-ttu-id="c0efd-175">インスタンスの Jimmy Bogard、このガイドでは、直接フィードバックを提供するときに、次と言います。</span><span class="sxs-lookup"><span data-stu-id="c0efd-175">For instance, Jimmy Bogard, when providing direct feedback for this guide, said the following:</span></span>

<span data-ttu-id="c0efd-176">これが最も大きなフィードバック、可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c0efd-176">This’ll probably be my biggest feedback.</span></span> <span data-ttu-id="c0efd-177">私は本当にない、リポジトリのファン基になる永続化メカニズムの重要な詳細を非表示にするために主にします。</span><span class="sxs-lookup"><span data-stu-id="c0efd-177">I’m really not a fan of repositories, mainly because they hide the important details of the underlying persistence mechanism.</span></span> <span data-ttu-id="c0efd-178">これは、理由進め MediatR のコマンドをすぎます。</span><span class="sxs-lookup"><span data-stu-id="c0efd-178">It’s why I go for MediatR for commands, too.</span></span> <span data-ttu-id="c0efd-179">永続レイヤーのすべての機能を使用して my 集計ルートにそのすべてのドメインの動作をプッシュします。</span><span class="sxs-lookup"><span data-stu-id="c0efd-179">I can use the full power of the persistence layer, and push all that domain behavior into my aggregate roots.</span></span> <span data-ttu-id="c0efd-180">自分のリポジトリを模擬表示したくない通常 – が必要な統合がある実際の作業をテストします。</span><span class="sxs-lookup"><span data-stu-id="c0efd-180">I don’t usually want to mock my repositories – I still need to have that integration test with the real thing.</span></span> <span data-ttu-id="c0efd-181">実際にありませんでしたリポジトリが必要かどうかを意図したもので CQRS を移動します。</span><span class="sxs-lookup"><span data-stu-id="c0efd-181">Going CQRS meant that we didn’t really have a need for repositories any more.</span></span>

<span data-ttu-id="c0efd-182">リポジトリを役に立つことが、集計のパターンとリッチ ドメイン モデルはその方法で、DDD にとって重要ではないということを承認します。</span><span class="sxs-lookup"><span data-stu-id="c0efd-182">We find repositories useful, but we acknowledge that they are not critical for your DDD, in the way that the Aggregate pattern and rich domain model are.</span></span> <span data-ttu-id="c0efd-183">したがって、リポジトリ パターンを使用するか、わかるに合わせてください。</span><span class="sxs-lookup"><span data-stu-id="c0efd-183">Therefore, use the Repository pattern or not, as you see fit.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="c0efd-184">その他の技術情報</span><span class="sxs-lookup"><span data-stu-id="c0efd-184">Additional resources</span></span>

##### <a name="the-repository-pattern"></a><span data-ttu-id="c0efd-185">リポジトリ パターン</span><span class="sxs-lookup"><span data-stu-id="c0efd-185">The Repository pattern</span></span>

-   <span data-ttu-id="c0efd-186">**Edward Hieatt および Rob me です。リポジトリ パターン。** 
     [ *http://martinfowler.com/eaaCatalog/repository.html*](http://martinfowler.com/eaaCatalog/repository.html)</span><span class="sxs-lookup"><span data-stu-id="c0efd-186">**Edward Hieatt and Rob Mee. Repository pattern.**
[*http://martinfowler.com/eaaCatalog/repository.html*](http://martinfowler.com/eaaCatalog/repository.html)</span></span>

-   <span data-ttu-id="c0efd-187">**リポジトリ パターン**
    [*https://msdn.microsoft.com/en-us/library/ff649690.aspx*](https://msdn.microsoft.com/en-us/library/ff649690.aspx)</span><span class="sxs-lookup"><span data-stu-id="c0efd-187">**The Repository pattern**
[*https://msdn.microsoft.com/en-us/library/ff649690.aspx*](https://msdn.microsoft.com/en-us/library/ff649690.aspx)</span></span>

-   <span data-ttu-id="c0efd-188">**リポジトリ パターン: データ持続性の抽象化**
    [*http://deviq.com/repository-pattern/*](http://deviq.com/repository-pattern/)</span><span class="sxs-lookup"><span data-stu-id="c0efd-188">**Repository Pattern: A data persistence abstraction**
[*http://deviq.com/repository-pattern/*](http://deviq.com/repository-pattern/)</span></span>

-   <span data-ttu-id="c0efd-189">**Eric Evans。ドメインに基づく設計: は Tackling Complexity in the Heart of Software です。**</span><span class="sxs-lookup"><span data-stu-id="c0efd-189">**Eric Evans. Domain-Driven Design: Tackling Complexity in the Heart of Software.**</span></span> <span data-ttu-id="c0efd-190">(予約以外の場合は、リポジトリ パターンの詳細についてにが含まれています)[ *https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/*](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)</span><span class="sxs-lookup"><span data-stu-id="c0efd-190">(Book; includes a discussion of the Repository pattern) [*https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/*](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)</span></span>

##### <a name="unit-of-work-pattern"></a><span data-ttu-id="c0efd-191">作業のパターンの単位</span><span class="sxs-lookup"><span data-stu-id="c0efd-191">Unit of Work pattern</span></span>

-   <span data-ttu-id="c0efd-192">**Martin Fowler。作業のパターンの単位。** 
     [ *http://martinfowler.com/eaaCatalog/unitOfWork.html*](http://martinfowler.com/eaaCatalog/unitOfWork.html)</span><span class="sxs-lookup"><span data-stu-id="c0efd-192">**Martin Fowler. Unit of Work pattern.**
[*http://martinfowler.com/eaaCatalog/unitOfWork.html*](http://martinfowler.com/eaaCatalog/unitOfWork.html)</span></span>

<!-- -->

-   <span data-ttu-id="c0efd-193">**ASP.NET MVC アプリケーションのリポジトリと作業パターンの単位を実装する**
    [*https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application*](https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application)</span><span class="sxs-lookup"><span data-stu-id="c0efd-193">**Implementing the Repository and Unit of Work Patterns in an ASP.NET MVC Application**
[*https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application*](https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="c0efd-194">[前](ドメインのイベントの設計の implementation.md) [次へ] (infrastructure-persistence-layer-implemenation-entity-framework-core.md)</span><span class="sxs-lookup"><span data-stu-id="c0efd-194">[Previous] (domain-events-design-implementation.md) [Next] (infrastructure-persistence-layer-implemenation-entity-framework-core.md)</span></span>
