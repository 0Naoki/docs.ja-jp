---
title: "マイクロ サービス ドメイン モデルの設計"
description: "コンテナーの .NET アプリケーションの .NET Microservices アーキテクチャ |マイクロ サービス ドメイン モデルの設計"
keywords: "Docker, マイクロサービス, ASP.NET, コンテナー"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: 455a2c5a39fb9b765b557610ab108f8c75882dbd
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/18/2017
---
# <a name="designing-a-microservice-domain-model"></a><span data-ttu-id="d6c6b-104">マイクロ サービス ドメイン モデルの設計</span><span class="sxs-lookup"><span data-stu-id="d6c6b-104">Designing a microservice domain model</span></span>

<span data-ttu-id="d6c6b-105">*ビジネス マイクロ サービスまたは範囲指定されたコンテキストごとに 1 つのドメインの機能豊富なモデルを定義します。*</span><span class="sxs-lookup"><span data-stu-id="d6c6b-105">*Define one rich domain model for each business microservice or Bounded Context*</span></span>

<span data-ttu-id="d6c6b-106">目標は、ビジネスのマイクロ サービスまたは範囲指定されたコンテキスト (BC) ごとに 1 つのまとまりのあるドメイン モデルを作成します。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-106">Your goal is to create a single cohesive domain model for each business microservice or Bounded Context (BC).</span></span> <span data-ttu-id="d6c6b-107">注意してください、ただしをビジネス継続性やビジネス マイクロ サービスは、いくつかの物理サービスを 1 つのドメイン モデルを共有することもあります合成でした。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-107">Keep in mind, however, that a BC or business microservice could sometimes be composed of several physical services that share a single domain model.</span></span> <span data-ttu-id="d6c6b-108">ドメイン モデルには、ルール、動作、ビジネスの言語、および範囲指定されたコンテキストの 1 つまたはそれが表すビジネス マイクロ サービスの制約をキャプチャする必要があります。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-108">The domain model must capture the rules, behavior, business language, and constraints of the single Bounded Context or business microservice that it represents.</span></span>

## <a name="the-domain-entity-pattern"></a><span data-ttu-id="d6c6b-109">ドメイン エンティティ パターン</span><span class="sxs-lookup"><span data-stu-id="d6c6b-109">The Domain Entity pattern</span></span>

<span data-ttu-id="d6c6b-110">エンティティは、ドメイン オブジェクトを表すし、それらを構成する属性だけでなくとその id、継続性、および時間の経過と共に永続化によって、主に定義します。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-110">Entities represent domain objects and are primarily defined by their identity, continuity, and persistence over time, and not only by the attributes that comprise them.</span></span> <span data-ttu-id="d6c6b-111">Eric Evans は、「その id を使用して、主に定義されているオブジェクトと呼ばれますエンティティ。」</span><span class="sxs-lookup"><span data-stu-id="d6c6b-111">As Eric Evans says, “an object primarily defined by its identity is called an Entity.”</span></span> <span data-ttu-id="d6c6b-112">エンティティは、モデルの基本クラスであるために、モデルでは、ドメイン、非常に重要です。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-112">Entities are very important in the domain model, since they are the base for a model.</span></span> <span data-ttu-id="d6c6b-113">そのため、特定し、それらを慎重に設計する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-113">Therefore, you should identify and design them carefully.</span></span>

<span data-ttu-id="d6c6b-114">*エンティティの id には、複数の microservices または範囲指定されたコンテキストを通過できます。*</span><span class="sxs-lookup"><span data-stu-id="d6c6b-114">*An entity’s identity can cross multiple microservices or Bounded Contexts.*</span></span>

<span data-ttu-id="d6c6b-115">同じ id (ただし、同じエンティティではなく) 複数の境界を付けられたコンテキストまたは microservices モデル化することができます。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-115">The same identity (though not the same entity) can be modeled across multiple Bounded Contexts or microservices.</span></span> <span data-ttu-id="d6c6b-116">ただし、ことを意味しません属性とロジックが同じで、同じエンティティが複数の境界を付けられたコンテキストで実装することです。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-116">However, that does not imply that the same entity, with the same attributes and logic would be implemented in multiple Bounded Contexts.</span></span> <span data-ttu-id="d6c6b-117">代わりに、各範囲指定されたコンテキスト内のエンティティは、その属性とその範囲指定されたコンテキストのドメイン内に必要な動作を制限します。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-117">Instead, entities in each Bounded Context limit their attributes and behaviors to those required in that Bounded Context’s domain.</span></span>

<span data-ttu-id="d6c6b-118">たとえば、buyer エンティティには、ほとんどで、プロファイルまたは identity マイクロ サービス、id を含むユーザー エンティティで定義されているユーザーの属性の場合があります。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-118">For instance, the buyer entity might have most of a person’s attributes that are defined in the user entity in the profile or identity microservice, including the identity.</span></span> <span data-ttu-id="d6c6b-119">順序付けのマイクロ サービスの購入者エンティティ可能性がありますより少ない属性は、購入者が特定のデータだけが注文処理に関連するためです。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-119">But the buyer entity in the ordering microservice might have fewer attributes, because only certain buyer data is related to the order process.</span></span> <span data-ttu-id="d6c6b-120">各マイクロ サービスのコンテキストまたは範囲指定されたコンテキストは、そのドメイン モデルに影響します。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-120">The context of each microservice or Bounded Context impacts its domain model.</span></span>

<span data-ttu-id="d6c6b-121">*ドメイン エンティティがデータの属性を実装するだけでなく動作を実装する必要があります。*</span><span class="sxs-lookup"><span data-stu-id="d6c6b-121">*Domain entities must implement behavior in addition to implementing data attributes*</span></span>

<span data-ttu-id="d6c6b-122">DDD 内のドメイン エンティティには、ドメイン ロジックまたはエンティティのデータ (メモリ内でアクセス オブジェクト) に関連する動作を実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-122">A domain entity in DDD must implement the domain logic or behavior related to the entity data (the object accessed in memory).</span></span> <span data-ttu-id="d6c6b-123">たとえば、order エンティティ クラスの一部として、ビジネス ロジックと発注品目、データの検証、および合計の計算の追加などのタスクのメソッドとして実装されている操作が必要です。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-123">For example, as part of an order entity class you must have business logic and operations implemented as methods for tasks such as adding an order item, data validation, and total calculation.</span></span> <span data-ttu-id="d6c6b-124">エンティティのメソッドの不変性とアプリケーション層にまたがるようにそれらのルールではなく、エンティティのルールように注意します。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-124">The entity’s methods take care of the invariants and rules of the entity instead of having those rules spread across the application layer.</span></span>

<span data-ttu-id="d6c6b-125">図 9-8 は、だけでなくデータの属性が、操作、または関連ドメイン ロジックを持つメソッドを実装しているドメイン エンティティを示しています。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-125">Figure 9-8 shows a domain entity that implements not only data attributes but operations or methods with related domain logic.</span></span>

![](./media/image9.png)

<span data-ttu-id="d6c6b-126">**図 9-8**です。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-126">**Figure 9-8**.</span></span> <span data-ttu-id="d6c6b-127">データと動作を実装するドメイン エンティティの設計の例</span><span class="sxs-lookup"><span data-stu-id="d6c6b-127">Example of a domain entity design implementing data plus behavior</span></span>

<span data-ttu-id="d6c6b-128">もちろん、場合によってことができますをエンティティ クラスの一部として、任意のロジックを実装しないエンティティ。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-128">Of course, sometimes you can have entities that do not implement any logic as part of the entity class.</span></span> <span data-ttu-id="d6c6b-129">集計内の子エンティティで集計ルートにほとんどのロジックが定義されているために、子エンティティが、特別なロジックを持っていない場合に発生します。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-129">This can happen in child entities within an aggregate if the child entity does not have any special logic because most of the logic is defined in the aggregate root.</span></span> <span data-ttu-id="d6c6b-130">ドメイン エンティティでの代わりに、サービス クラスに実装されるロジックの多くのある複雑なマイクロ サービスがあれば、anemic ドメイン モデルで、次のセクションで説明する辿る可能性があります。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-130">If you have a complex microservice that has a lot of logic implemented in the service classes instead of in the domain entities, you could be falling into the anemic domain model, explained in the following section.</span></span>

### <a name="rich-domain-model-versus-anemic-domain-model"></a><span data-ttu-id="d6c6b-131">Anemic ドメイン モデルと豊富なドメイン モデル</span><span class="sxs-lookup"><span data-stu-id="d6c6b-131">Rich domain model versus anemic domain model</span></span>

<span data-ttu-id="d6c6b-132">記事は[AnemicDomainModel](https://martinfowler.com/bliki/AnemicDomainModel.html)、Martin ファウラーが anemic ドメイン モデルをこの方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-132">In his post [AnemicDomainModel](https://martinfowler.com/bliki/AnemicDomainModel.html), Martin Fowler describes an anemic domain model this way:</span></span>

<span data-ttu-id="d6c6b-133">Anemic ドメイン モデルの基本的な現象は、ある一見よう実際の作業です。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-133">The basic symptom of an Anemic Domain Model is that at first blush it looks like the real thing.</span></span> <span data-ttu-id="d6c6b-134">オブジェクトがある、ドメイン領域で、名詞にちなんだ名前多くおよび実際のドメイン モデルの構造と豊富なリレーションシップでこれらのオブジェクトが接続されています。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-134">There are objects, many named after the nouns in the domain space, and these objects are connected with the rich relationships and structure that true domain models have.</span></span> <span data-ttu-id="d6c6b-135">Catch はの動作を確認してすることに注意して、これらのオブジェクトにほとんどすべての動作が存在する get アクセス操作子および set アクセス操作子のバッグより若干となります。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-135">The catch comes when you look at the behavior, and you realize that there is hardly any behavior on these objects, making them little more than bags of getters and setters.</span></span>

<span data-ttu-id="d6c6b-136">もちろん、anemic ドメイン モデルを使用するときにそれらのデータ モデルはから使用するサービス オブジェクトのセット (従来の名前付き、*ビジネス層*) すべてのドメインまたはビジネス ロジックをキャプチャします。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-136">Of course, when you use an anemic domain model, those data models will be used from a set of service objects (traditionally named the *business layer*) which capture all the domain or business logic.</span></span> <span data-ttu-id="d6c6b-137">ビジネス層では、データ モデルの上に装備し、データと同様に、データ モデルを使用します。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-137">The business layer sits on top of the data model and uses the data model just as data.</span></span>

<span data-ttu-id="d6c6b-138">Anemic ドメイン モデルは、手続き型の設計のみです。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-138">The anemic domain model is just a procedural style design.</span></span> <span data-ttu-id="d6c6b-139">Anemic エンティティ オブジェクトは、動作 (メソッド) が不足しているので、実際のオブジェクトではできません。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-139">Anemic entity objects are not real objects because they lack behavior (methods).</span></span> <span data-ttu-id="d6c6b-140">データのプロパティのみ保持あり、したがっていないオブジェクト指向デザインします。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-140">They only hold data properties and thus it is not object-oriented design.</span></span> <span data-ttu-id="d6c6b-141">アウト サービス オブジェクト (ビジネス層) に、すべての動作を記述することによって、最終的に[整然としたプログラム](https://en.wikipedia.org/wiki/Spaghetti_code)または[トランザクション スクリプト](https://martinfowler.com/eaaCatalog/transactionScript.html)利点を紛失したため、ドメイン モデル提供します。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-141">By putting all the behavior out into service objects (the business layer) you essentially end up with [spaghetti code](https://en.wikipedia.org/wiki/Spaghetti_code) or [transaction scripts](https://martinfowler.com/eaaCatalog/transactionScript.html), and therefore you lose the advantages that a domain model provides.</span></span>

<span data-ttu-id="d6c6b-142">マイクロ サービスまたは範囲指定されたコンテキストが非常に単純な場合に関係なく (CRUD サービス)、データのプロパティだけを持つエンティティ オブジェクトの形式で anemic ドメイン モデルが十分でありますおよび DDD のより複雑なパターンを実装する価値があるできない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-142">Regardless, if your microservice or Bounded Context is very simple (a CRUD service), the anemic domain model in the form of entity objects with just data properties might be good enough, and it might not be worth implementing more complex DDD patterns.</span></span> <span data-ttu-id="d6c6b-143">その場合は、ことが永続化モデルでは単に、CRUD 用のデータのみを使用、エンティティを意図的に作成したためです。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-143">In that case, it will be simply a persistence model, because you have intentionally created an entity with only data for CRUD purposes.</span></span>

<span data-ttu-id="d6c6b-144">Microservices アーキテクチャは、各範囲指定されたコンテキストに応じて複数のアーキテクチャのアプローチに最適なためにです。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-144">That is why microservices architectures are perfect for a multi-architectural approach depending on each Bounded Context.</span></span> <span data-ttu-id="d6c6b-145">たとえば、eShopOnContainers で順序マイクロ サービス DDD パターンを実装するが、単純な CRUD サービスである、カタログ マイクロ サービスはしません。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-145">For instance, in eShopOnContainers, the ordering microservice implements DDD patterns, but the catalog microservice, which is a simple CRUD service, does not.</span></span>

<span data-ttu-id="d6c6b-146">一部のユーザーは、anemic ドメイン モデルがアンチ パターンであるとします。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-146">Some people say that the anemic domain model is an anti-pattern.</span></span> <span data-ttu-id="d6c6b-147">実際に実装する新機能によって異なります。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-147">It really depends on what you are implementing.</span></span> <span data-ttu-id="d6c6b-148">場合は、マイクロ サービスを作成する単純なのに十分な (たとえば、CRUD サービス)、次のアンチ パターンではない anemic ドメイン モデル。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-148">If the microservice you are creating is simple enough (for example, a CRUD service), following the anemic domain model it is not an anti-pattern.</span></span> <span data-ttu-id="d6c6b-149">ただし、絶えず変化するビジネス ルールの多くをあるマイクロ サービスのドメインの複雑さに取り組む必要がある場合、anemic ドメイン モデルにはそのマイクロ サービスまたは範囲指定されたコンテキストのアンチ パターン可能性があります。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-149">However, if you need to tackle the complexity of a microservice’s domain that has a lot of ever-changing business rules, the anemic domain model might be an anti-pattern for that microservice or Bounded Context.</span></span> <span data-ttu-id="d6c6b-150">その場合は、リッチとして設計することに加えて、動作のデータを格納しているだけでなく (集計、値オブジェクトなど)、追加の DDD パターンを実装するエンティティとモデルがこのようなマイクロ サービスの長期的な成功の大きなメリットを必要があります。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-150">In that case, designing it as a rich model with entities containing data plus behavior as well as implementing additional DDD patterns (aggregates, value objects, etc.) might have huge benefits for the long-term success of such a microservice.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="d6c6b-151">その他の技術情報</span><span class="sxs-lookup"><span data-stu-id="d6c6b-151">Additional resources</span></span>

-   <span data-ttu-id="d6c6b-152">**DevIQ です。ドメイン エンティティ**
    [*http://deviq.com/entity/*](http://deviq.com/entity/)</span><span class="sxs-lookup"><span data-stu-id="d6c6b-152">**DevIQ. Domain Entity**
[*http://deviq.com/entity/*](http://deviq.com/entity/)</span></span>

-   <span data-ttu-id="d6c6b-153">**Martin Fowler。ドメイン モデル**
    [*https://martinfowler.com/eaaCatalog/domainModel.html*](https://martinfowler.com/eaaCatalog/domainModel.html)</span><span class="sxs-lookup"><span data-stu-id="d6c6b-153">**Martin Fowler. The Domain Model**
[*https://martinfowler.com/eaaCatalog/domainModel.html*](https://martinfowler.com/eaaCatalog/domainModel.html)</span></span>

-   <span data-ttu-id="d6c6b-154">**Martin Fowler。Anemic ドメイン モデル**</span><span class="sxs-lookup"><span data-stu-id="d6c6b-154">**Martin Fowler. The Anemic Domain Model**</span></span>

    <span data-ttu-id="d6c6b-155"><https://martinfowler.com/bliki/AnemicDomainModel.html></span><span class="sxs-lookup"><span data-stu-id="d6c6b-155"><https://martinfowler.com/bliki/AnemicDomainModel.html></span></span>

### <a name="the-value-object-pattern"></a><span data-ttu-id="d6c6b-156">値オブジェクトのパターン</span><span class="sxs-lookup"><span data-stu-id="d6c6b-156">The Value Object pattern</span></span>

<span data-ttu-id="d6c6b-157">前述の Eric Evans が、"多数のオブジェクト id が使用されない概念です。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-157">As Eric Evans has noted, “Many objects do not have conceptual identity.</span></span> <span data-ttu-id="d6c6b-158">これらのオブジェクトについて説明するものの特定の特性。"</span><span class="sxs-lookup"><span data-stu-id="d6c6b-158">These objects describe certain characteristics of a thing.”</span></span>

<span data-ttu-id="d6c6b-159">エンティティには、id が必要ですが、そうでない、システムにある多くのオブジェクトが、値オブジェクトのパターンと同様にします。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-159">An entity requires an identity, but there are many objects in a system that do not, like the Value Object pattern.</span></span> <span data-ttu-id="d6c6b-160">オブジェクトの値は、ドメインの側面を説明する概念ありません id を持つオブジェクトです。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-160">A value object is an object with no conceptual identity that describes a domain aspect.</span></span> <span data-ttu-id="d6c6b-161">これらは一時的にのみ関係するデザイン要素を表すインスタンス化するオブジェクトです。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-161">These are objects that you instantiate to represent design elements that only concern you temporarily.</span></span> <span data-ttu-id="d6c6b-162">関心のある*何*が*した*はします。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-162">You care about *what* they are, not *who* they are.</span></span> <span data-ttu-id="d6c6b-163">例では、数値や文字列が含まれますが、属性のグループなどの上位レベルの概念をすることもできます。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-163">Examples include numbers and strings, but can also be higher-level concepts like groups of attributes.</span></span>

<span data-ttu-id="d6c6b-164">マイクロ サービス内のエンティティのあるものがあります別マイクロ サービス内のエンティティのため、範囲指定されたコンテキスト 2 番目のケースで異なる意味がある可能性。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-164">Something that is an entity in a microservice might not be an entity in another microservice, because in the second case, the Bounded Context might have a different meaning.</span></span> <span data-ttu-id="d6c6b-165">たとえば、電子商取引アプリケーション内のアドレスがないこと id、個人または会社の顧客のプロファイルの属性のグループを表すことがのみため。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-165">For example, an address in an e-commerce application might not have an identity at all, since it might only represent a group of attributes of the customer’s profile for a person or company.</span></span> <span data-ttu-id="d6c6b-166">ここでは、アドレスは、値のオブジェクトとして分類される必要があります。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-166">In this case, the address should be classified as a value object.</span></span> <span data-ttu-id="d6c6b-167">ただし、電力ユーティリティ会社のアプリケーションで顧客の住所をビジネス ドメインあまり重要ででした。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-167">However, in an application for an electric power utility company, the customer address could be important for the business domain.</span></span> <span data-ttu-id="d6c6b-168">そのため、課金システムは、アドレスに直接リンクできるように、アドレスは、id が必要です。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-168">Therefore, the address must have an identity so the billing system can be directly linked to the address.</span></span> <span data-ttu-id="d6c6b-169">その場合は、アドレスは、ドメイン エンティティとして分類する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-169">In that case, an address should be classified as a domain entity.</span></span>

<span data-ttu-id="d6c6b-170">名前と姓を持つユーザーは、エンティティ、通常はであるため、ユーザー id を場合でも、姓と名前が別の一連の値と一致場合などそれらの名前を指すことも、別の担当者です。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-170">A person with a name and surname is usually an entity because a person has identity, even if the name and surname coincide with another set of values, such as if those names also refers to a different person.</span></span>

<span data-ttu-id="d6c6b-171">値オブジェクトはドキュメントで指向データベースを実装して使用し、見やすくリレーショナル データベースと EF などの Orm の管理が困難です。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-171">Value objects are hard to manage in relational databases and ORMs like EF, whereas in document oriented databases they are easier to implement and use.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="d6c6b-172">その他の技術情報</span><span class="sxs-lookup"><span data-stu-id="d6c6b-172">Additional resources</span></span>

-   <span data-ttu-id="d6c6b-173">**Martin Fowler。値オブジェクト パターン**
    [*https://martinfowler.com/bliki/ValueObject.html*](https://martinfowler.com/bliki/ValueObject.html)</span><span class="sxs-lookup"><span data-stu-id="d6c6b-173">**Martin Fowler. Value Object pattern**
[*https://martinfowler.com/bliki/ValueObject.html*](https://martinfowler.com/bliki/ValueObject.html)</span></span>

-   <span data-ttu-id="d6c6b-174">**オブジェクトの値**
    [*http://deviq.com/value-object/*](http://deviq.com/value-object/)</span><span class="sxs-lookup"><span data-stu-id="d6c6b-174">**Value Object**
[*http://deviq.com/value-object/*](http://deviq.com/value-object/)</span></span>

-   <span data-ttu-id="d6c6b-175">**テスト駆動型開発内のオブジェクトを値**
    [*https://leanpub.com/tdd-ebook/read\#leanpub 自動値オブジェクト*](https://leanpub.com/tdd-ebook/read#leanpub-auto-value-objects)</span><span class="sxs-lookup"><span data-stu-id="d6c6b-175">**Value Objects in Test-Driven Development**
[*https://leanpub.com/tdd-ebook/read\#leanpub-auto-value-objects*](https://leanpub.com/tdd-ebook/read#leanpub-auto-value-objects)</span></span>

-   <span data-ttu-id="d6c6b-176">**Eric Evans。ドメインに基づく設計: は Tackling Complexity in the Heart of Software です。**</span><span class="sxs-lookup"><span data-stu-id="d6c6b-176">**Eric Evans. Domain-Driven Design: Tackling Complexity in the Heart of Software.**</span></span> <span data-ttu-id="d6c6b-177">(予約値オブジェクトの説明を含む)。[ *https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/*](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)</span><span class="sxs-lookup"><span data-stu-id="d6c6b-177">(Book; includes a discussion of value objects) [*https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/*](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)</span></span>

### <a name="the-aggregate-pattern"></a><span data-ttu-id="d6c6b-178">集計パターン</span><span class="sxs-lookup"><span data-stu-id="d6c6b-178">The Aggregate pattern</span></span>

<span data-ttu-id="d6c6b-179">ドメイン モデルには、さまざまなデータ エンティティと順序フルフィルメントまたはインベントリなどの機能の重要な領域が制御できるプロセスのクラスターが含まれています。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-179">A domain model contains clusters of different data entities and processes that can control a significant area of functionality, such as order fulfilment or inventory.</span></span> <span data-ttu-id="d6c6b-180">細かい DDD ユニットがあるか、集計は、クラスターまたはグループのエンティティと、まとまりの単位として処理される動作について説明します。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-180">A more fine-grained DDD unit is the aggregate, which describes a cluster or group of entities and behaviors that can be treated as a cohesive unit.</span></span>

<span data-ttu-id="d6c6b-181">通常、必要なトランザクションに基づく集計を定義します。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-181">You usually define an aggregate based on the transactions that you need.</span></span> <span data-ttu-id="d6c6b-182">典型的な例は、発注品目の一覧が含まれている順序です。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-182">A classic example is an order that also contains a list of order items.</span></span> <span data-ttu-id="d6c6b-183">発注品目をエンティティと通常されます。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-183">An order item will usually be an entity.</span></span> <span data-ttu-id="d6c6b-184">集計ルートと通常呼ばれる、そのルート エンティティとして、order エンティティを含むも順序集計内の子エンティティになります。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-184">But it will be a child entity within the order aggregate, which will also contain the order entity as its root entity, typically called an aggregate root.</span></span>

<span data-ttu-id="d6c6b-185">集計を識別するは難しくなります。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-185">Identifying aggregates can be hard.</span></span> <span data-ttu-id="d6c6b-186">集計とは同時に、一致する必要があるオブジェクトのグループが同じオブジェクトのグループを選択し、集計関数をラベルをことはできません。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-186">An aggregate is a group of objects that must be consistent together, but you cannot just pick a group of objects and label them an aggregate.</span></span> <span data-ttu-id="d6c6b-187">ドメインの概念で開始し、その概念に関連する最も一般的なトランザクションで使用されているエンティティについて検討する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-187">You must start with a domain concept and think about the entities that are used in the most common transactions related to that concept.</span></span> <span data-ttu-id="d6c6b-188">トランザクション全体で一貫性を保つ必要があるこれらのエンティティは、どのようなフォームの集計です。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-188">Those entities that need to be transactionally consistent are what forms an aggregate.</span></span> <span data-ttu-id="d6c6b-189">トランザクション操作についての考え方は、集計を識別する最善の方法でが考えられます。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-189">Thinking about transaction operations is probably the best way to identify aggregates.</span></span>

### <a name="the-aggregate-root-or-root-entity-pattern"></a><span data-ttu-id="d6c6b-190">集計ルートまたはルート エンティティ パターン</span><span class="sxs-lookup"><span data-stu-id="d6c6b-190">The Aggregate Root or Root Entity pattern</span></span>

<span data-ttu-id="d6c6b-191">集計は、少なくとも 1 つのエンティティで構成されます。 集計ルート、ルート エンティティまたはプライマリ ientity とも呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-191">An aggregate is composed of at least one entity: the aggregate root, also called root entity or primary ientity.</span></span> <span data-ttu-id="d6c6b-192">さらに、複数の子エンティティおよび値オブジェクトのすべてのエンティティと連携して必要な動作とトランザクションを実装するオブジェクトをこともできます。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-192">Additionally, it can have multiple child entities and value objects, with all entities and objects working together to implement required behavior and transactions.</span></span>

<span data-ttu-id="d6c6b-193">集計ルートの目的は、集計; の一貫性を確保するには集計のメソッドを使用する更新プログラムの唯一のエントリ ポイントである必要があります。 または集計のルート クラスを操作します。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-193">The purpose of an aggregate root is to ensure the consistency of the aggregate; it should be the only entry point for updates to the aggregate through methods or operations in the aggregate root class.</span></span> <span data-ttu-id="d6c6b-194">集計のルートでのみ、集計内のエンティティに変更をする必要があります。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-194">You should make changes to entities within the aggregate only via the aggregate root.</span></span> <span data-ttu-id="d6c6b-195">集約の整合性ガーディアン、すべての不変性と、集計に遵守する必要がありますの一貫性規則を考慮することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-195">It is the aggregate’s consistency guardian, taking into account all the invariants and consistency rules you might need to comply with in your aggregate.</span></span> <span data-ttu-id="d6c6b-196">子エンティティまたは値オブジェクトを個別に変更した場合集計ルートは、集計が有効な状態であることを確認できません。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-196">If you change a child entity or value object independently, the aggregate root cannot ensure that the aggregate is in a valid state.</span></span> <span data-ttu-id="d6c6b-197">厳密でない区間を含むテーブルのようになります。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-197">It would be like a table with a loose leg.</span></span> <span data-ttu-id="d6c6b-198">管理の一貫性は、集計のルートの主な目的です。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-198">Maintaining consistency is the main purpose of the aggregate root.</span></span>

<span data-ttu-id="d6c6b-199">図 9-9、buyer の集計、1 つのエンティティ (集計ルート購入者) が含まれるようにサンプルの集計を表示できます。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-199">In Figure 9-9, you can see sample aggregates like the buyer aggregate, which contains a single entity (the aggregate root Buyer).</span></span> <span data-ttu-id="d6c6b-200">順序の集計には、複数のエンティティとオブジェクトの値が含まれています。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-200">The order aggregate contains multiple entities and a value object.</span></span>

![](./media/image10.png)

<span data-ttu-id="d6c6b-201">**図 9-9**です。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-201">**Figure 9-9**.</span></span> <span data-ttu-id="d6c6b-202">複数の集計の例を 1 つのエンティティ</span><span class="sxs-lookup"><span data-stu-id="d6c6b-202">Example of aggregates with multiple or single entities</span></span>

<span data-ttu-id="d6c6b-203">EShopOnContainers 参照アプリケーションの順序付けマイクロ サービスでは、購入者の集計が領域によっては、追加の子エンティティ可能性があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-203">Note that the Buyer aggregate could have additional child entities, depending on your domain, as it does in the ordering microservice in the eShopOnContainers reference application.</span></span> <span data-ttu-id="d6c6b-204">図 9-9 では、購入者が、集計のルートのみを含む集計の例として、単一のエンティティがである場合のみ示しています。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-204">Figure 9-9 just illustrates a case in which the buyer has a single entity, as an example of an aggregate that contains only an aggregate root.</span></span>

<span data-ttu-id="d6c6b-205">集計の分離を維持し、それらの間に明確な境界を維持するには DDD ドメイン モデルで集計およびのみが外部キー (FK) フィールド間のナビゲーションを直接が行われないように実装されていることをお勧め、 [マイクロ サービス ドメイン モデルを順序付け](https://github.com/dotnet-architecture/eShopOnContainers/blob/master/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Order.cs)eShopOnContainers にします。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-205">In order to maintain separation of aggregates and keep clear boundaries between them, it is a good practice in a DDD domain model to disallow direct navigation between aggregates and only having the foreign key (FK) field, as implemented in the [Ordering microservice domain model](https://github.com/dotnet-architecture/eShopOnContainers/blob/master/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Order.cs) in eShopOnContainers.</span></span> <span data-ttu-id="d6c6b-206">次のコードに示すように、Order エンティティには、購入者ではない、EF 中核となるナビゲーション プロパティの FK フィールドのみがあります。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-206">The Order entity only has a FK field for the buyer, but not an EF Core navigation property, as shown in the following code:</span></span>

```csharp
public class Order : Entity, IAggregateRoot
{
    private DateTime _orderDate;
    public Address Address { get; private set; }
    private int? _buyerId; //FK pointing to a different aggregate root
    public OrderStatus OrderStatus { get; private set; }
}
```

<span data-ttu-id="d6c6b-207">識別して、集計の操作には、研究と経験が必要です。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-207">Identifying and working with aggregates requires research and experience.</span></span> <span data-ttu-id="d6c6b-208">詳細については、次の他のリソースの一覧を参照してください。</span><span class="sxs-lookup"><span data-stu-id="d6c6b-208">For more information, see the following Additional resources list.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="d6c6b-209">その他の技術情報</span><span class="sxs-lookup"><span data-stu-id="d6c6b-209">Additional resources</span></span>

-   <span data-ttu-id="d6c6b-210">**Vaughn Vernon。効果的な集計のデザイン - パート i: 1 つの集計のモデリング**
    [*https://vaughnvernon.co/wordpress/wp-content/uploads/2014/10/DDD\_コミュニティ\_エッセイ\_集計\_一部\_1. pdf*](https://vaughnvernon.co/wordpress/wp-content/uploads/2014/10/DDD_COMMUNITY_ESSAY_AGGREGATES_PART_1.pdf)</span><span class="sxs-lookup"><span data-stu-id="d6c6b-210">**Vaughn Vernon. Effective Aggregate Design - Part I: Modeling a Single Aggregate**
[*https://vaughnvernon.co/wordpress/wp-content/uploads/2014/10/DDD\_COMMUNITY\_ESSAY\_AGGREGATES\_PART\_1.pdf*](https://vaughnvernon.co/wordpress/wp-content/uploads/2014/10/DDD_COMMUNITY_ESSAY_AGGREGATES_PART_1.pdf)</span></span>

-   <span data-ttu-id="d6c6b-211">**Vaughn Vernon。効果的な集計デザインのパート II: 行う集計連携**
    *<https://vaughnvernon.co/wordpress/wp-content/uploads/2014/10/DDD_COMMUNITY_ESSAY_AGGREGATES_PART_2.pdf>*</span><span class="sxs-lookup"><span data-stu-id="d6c6b-211">**Vaughn Vernon. Effective Aggregate Design - Part II: Making Aggregates Work Together**
*<https://vaughnvernon.co/wordpress/wp-content/uploads/2014/10/DDD_COMMUNITY_ESSAY_AGGREGATES_PART_2.pdf> *</span></span>

-   <span data-ttu-id="d6c6b-212">**Vaughn Vernon。効果的な集計デザインのパート III: 検出で洞察の獲得**
    *<https://vaughnvernon.co/wordpress/wp-content/uploads/2014/10/DDD_COMMUNITY_ESSAY_AGGREGATES_PART_3.pdf>*</span><span class="sxs-lookup"><span data-stu-id="d6c6b-212">**Vaughn Vernon. Effective Aggregate Design - Part III: Gaining Insight Through Discovery**
*<https://vaughnvernon.co/wordpress/wp-content/uploads/2014/10/DDD_COMMUNITY_ESSAY_AGGREGATES_PART_3.pdf> *</span></span>

-   <span data-ttu-id="d6c6b-213">**Sergey Grybniak です。DDD 戦術的なデザイン パターン**
    [*https://www.codeproject.com/Articles/1164363/Domain-Driven-Design-Tactical-Design-Patterns-Part*](https://www.codeproject.com/Articles/1164363/Domain-Driven-Design-Tactical-Design-Patterns-Part)</span><span class="sxs-lookup"><span data-stu-id="d6c6b-213">**Sergey Grybniak. DDD Tactical Design Patterns**
[*https://www.codeproject.com/Articles/1164363/Domain-Driven-Design-Tactical-Design-Patterns-Part*](https://www.codeproject.com/Articles/1164363/Domain-Driven-Design-Tactical-Design-Patterns-Part)</span></span>

-   <span data-ttu-id="d6c6b-214">**Chris Richardson です。集計を使用してトランザクション Microservices の開発**
    [*https://www.infoq.com/articles/microservices-aggregates-events-cqrs-part-1-richardson*](https://www.infoq.com/articles/microservices-aggregates-events-cqrs-part-1-richardson)</span><span class="sxs-lookup"><span data-stu-id="d6c6b-214">**Chris Richardson. Developing Transactional Microservices Using Aggregates**
[*https://www.infoq.com/articles/microservices-aggregates-events-cqrs-part-1-richardson*](https://www.infoq.com/articles/microservices-aggregates-events-cqrs-part-1-richardson)</span></span>

-   <span data-ttu-id="d6c6b-215">**DevIQ です。集計パターン**
    [*http://deviq.com/aggregate-pattern/*](http://deviq.com/aggregate-pattern/)</span><span class="sxs-lookup"><span data-stu-id="d6c6b-215">**DevIQ. The Aggregate pattern**
[*http://deviq.com/aggregate-pattern/*](http://deviq.com/aggregate-pattern/)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="d6c6b-216">[前](ddd-指向-microservice.md) [次へ] (net-コア-マイクロ サービスのドメイン-model.md)</span><span class="sxs-lookup"><span data-stu-id="d6c6b-216">[Previous] (ddd-oriented-microservice.md) [Next] (net-core-microservice-domain-model.md)</span></span>
