---
title: "ガベージ コレクションの基礎"
description: "ガベージ コレクションの基礎"
keywords: .NET, .NET Core
author: stevehoag
ms.author: shoag
ms.date: 08/16/2016
ms.topic: article
ms.prod: .net
ms.technology: dotnet-standard
ms.devlang: dotnet
ms.assetid: 9d5fce64-95a4-4609-8eee-b0ac70078cdb
translationtype: Human Translation
ms.sourcegitcommit: b20713600d7c3ddc31be5885733a1e8910ede8c6
ms.openlocfilehash: 78a2d593329f0703c71df2462cfea30b02adff85

---

# <a name="fundamentals-of-garbage-collection"></a>ガベージ コレクションの基礎

共通言語ランタイム (CLR) では、自動メモリ マネージャーとしてガベージ コレクターを使用できます。 次のような利点があります。

* アプリケーションを開発するときにメモリを解放する必要がありません。 

* オブジェクトが効率的にマネージ ヒープに割り当てられます。 

* 使用されなくなったオブジェクトが解放され、メモリがクリアされてその後の割り当てに使用できるようになります。 マネージ オブジェクトは自動的にクリーンな内容で開始されるため、コンストラクターでデータ フィールドごとに初期化する必要はありません。

* オブジェクトで別のオブジェクトの内容を使用できなくすることで、メモリの安全が確保されます。


このトピックでは、ガベージ コレクションの主要な概念について説明します。 このチュートリアルは、次のセクションで構成されています。

* [メモリの基礎](#fundamentals-of-memory)

* [ガベージ コレクションの条件](#conditions-for-a-garbage-collection)

* [マネージ ヒープ](#the-managed-heap)

* [ジェネレーション](#generations)

* [ガベージ コレクションの実行時の動作](#what-happens-during-a-garbage-collection)

* [アンマネージ リソースの操作](#manipulating-unmanaged-resources)

## <a name="fundamentals-of-memory"></a>メモリの基礎

CLR のメモリに関する重要な概念の概要を以下に示します。

* 各プロセスは、分離された独自の仮想アドレス空間を持ちます。 同じコンピューターのすべてのプロセスが同じ物理メモリとページ ファイル (存在する場合) を共有します。

* 32 ビット コンピューターでは、各プロセスが既定で 2 GB のユーザー モード仮想アドレス空間を持ちます。

* アプリケーション開発者が操作するのは仮想アドレス空間だけで、直接物理メモリを操作することはありません。 マネージ ヒープの仮想メモリの割り当てと解放はガベージ コレクターによって行われます。

* 仮想メモリには次の 3 つの状態があります。 

    * 空き。 参照されていない、割り当てに使用できるメモリ ブロックです。

    * 予約済み。 使用できるように確保された、他の割り当て要求には使用できないメモリ ブロックです。 ただし、このメモリ ブロックがコミットされるまではデータを格納できません。 

    * コミット済み。 物理ストレージに割り当てられたメモリ ブロックです。

* 仮想アドレス空間は、断片化することがあります。 断片化とは、アドレス空間に複数の空きブロック (ホールとも呼ばれます) がある状態です。 仮想メモリの割り当てが要求された場合、仮想メモリ マネージャーは、その割り当て要求を満たすのに十分な大きさの単一の空きブロックを見つけなければなりません。 2 GB の空き領域があっても、そのすべての領域が 1 つのアドレス ブロックにないと、2 GB の領域を必要とする割り当ては失敗します。

* メモリが足りなくなるのは、予約する仮想アドレス空間が足りなくなった場合か、コミットする物理領域が足りなくなった場合です。

ページ ファイルは、物理メモリの圧迫度 (物理メモリに対する需要) が低い場合にも使用されます。 最初に物理メモリの圧迫度が高まると、データを格納するための領域を確保するために物理メモリのデータの一部がページ ファイルにバックアップされますが、 そのデータは必要になるまでページングされないため、物理メモリの圧迫度が非常に低い状況でページングが発生する可能性もあります。

## <a name="conditions-for-a-garbage-collection"></a>ガベージ コレクションの条件

ガベージ コレクションは、次のいずれかの条件に当てはまる場合に発生します。

* システムの物理メモリが少ない場合。

* マネージ ヒープで割り当てられたオブジェクトによって使用されているメモリが、許容されるしきい値を超える場合。 このしきい値は、プロセスの進行に合わせて絶えず調整されます。

* [GC.Collect](xref:System.GC.Collect) メソッドが呼び出されます。 ほとんどの場合、ガベージ コレクターは継続して実行されるため、このメソッドを呼び出す必要はありません。 このメソッドは、主に特別な状況やテストで使用されます。 

## <a name="the-managed-heap"></a>マネージ ヒープ

ガベージ コレクターは、CLR によって初期化された後、オブジェクトを格納および管理するためのメモリのセグメントを割り当てます。 オペレーティング システムのネイティブ ヒープに対し、このメモリのことをマネージ ヒープと呼びます。 

マネージ ヒープはマネージ プロセスごとに割り当てられます。 プロセス内のすべてのスレッドは、同じヒープにオブジェクト用のメモリを割り当てます。

> [!IMPORTANT]
> ガベージ コレクターによって割り当てらるセグメントのサイズは実装に固有であり、定期的な更新プログラムによる場合を含め、いつでも変更されることがあります。 アプリでは、セグメント サイズを推測することや、特定のセグメント サイズに依存することを絶対に避けてください。また、セグメントの割り当てに使用可能なメモリの量を構成しようとしてもなりません。 
 
ヒープに割り当てられたオブジェクトが少ないほど、ガベージ コレクターの処理も少なくなります。 そのため、オブジェクトを割り当てるときに、必要な量より多く割り当てないようにしてください。たとえば、15 バイトしか必要がないときに 32 バイトの配列を割り当てないようにしてください。 

ガベージ コレクションがトリガーされると、ガベージ コレクターは、使用されなくなったオブジェクトに占有されているメモリを解放します。 この解放プロセスでは、まとめて移動できるように有効なオブジェクトを圧縮し、使用されなくなったスペースを削除することで、ヒープを小さくします。 これにより、一緒に割り当てられたオブジェクトが同じマネージ ヒープにまとめられ、局所性が保持されます。

ガベージ コレクションの割り込みの動作 (頻度と期間) は、割り当てのボリュームとマネージ ヒープ上の残ったメモリの量によって決まります。 

ヒープは、大きなオブジェクト ヒープと小さなオブジェクト ヒープの 2 つを累積したものと見なすことができます。 

大きなオブジェクト ヒープには、85,000 バイトを超える非常に大きなオブジェクトが格納されます。 大きなオブジェクト ヒープの中のオブジェクトは、通常は配列になります。 インスタンス オブジェクトが極端に大きくなることはほとんどありません。 

## <a name="generations"></a>ジェネレーション

ヒープは、有効期間が長いオブジェクトと有効期間が短いオブジェクトに対処できるようにジェネレーションにまとめられます。 ガベージ コレクションは主に、通常はヒープのごく一部だけを占有する有効期間が短いオブジェクトを解放する場合に発生します。 ヒープのオブジェクトのジェネレーションには次の 3 つがあります。 

* **ジェネレーション 0。** これは一番最初のジェネレーションで、有効期間が短いオブジェクトが格納されます。 有効期間が短いオブジェクトには、たとえば、テンポラリ変数などがあります。 ガベージ コレクションは、このジェネレーションで最も頻繁に発生します。 

  オブジェクトが新しく割り当てられると、大きなオブジェクトの場合以外は、オブジェクトの新しいジェネレーションが形成されて暗黙的にジェネレーション 0 のコレクションになります。大きなオブジェクトの場合は、ジェネレーション 2 のコレクションの大きなオブジェクトのヒープに割り当てられます。

  ジェネレーション 0 では、ほとんどのオブジェクトがガベージ コレクションで解放され、次のジェネレーションには残りません。 

* **ジェネレーション 1。** このジェネレーションには有効期間が短いオブジェクトが格納されます。有効期間が短いオブジェクトと有効期間が長いオブジェクトの間のバッファーとして機能します。 

* **ジェネレーション 2。** このジェネレーションには、有効期間が長いオブジェクトが格納されます。 有効期間が長いオブジェクトには、たとえば、プロセスの存続期間を通じて有効な静的データを含むサーバー アプリケーションのオブジェクトなどがあります。

ガベージ コレクションは、条件に応じて特定のジェネレーションで発生します。 ジェネレーションのコレクションでは、そのジェネレーションとそれよりも前のすべてのジェネレーションのオブジェクトがコレクションの対象になります。 ジェネレーション 2 のガベージ コレクションは、すべてのジェネレーションのすべてのオブジェクト (つまり、マネージ ヒープのすべてのオブジェクト) を解放することから、フル ガベージ コレクションとも呼ばれます。

### <a name="survival-and-promotions"></a>存続と昇格

ガベージ コレクションで解放されなかったオブジェクトは残存オブジェクトと呼ばれ、次のジェネレーションに昇格されます。 ジェネレーション 0 のガベージ コレクションでごみではないと判断されたオブジェクトは、ジェネレーション 1 に昇格されます。ジェネレーション 1 のガベージ コレクションでごみではないと判断されたオブジェクトは、ジェネレーション 2 に昇格されます。ジェネレーション 2 のガベージ コレクションでごみではないと判断されたオブジェクトは、ジェネレーション 2 に残ります。

ガベージ コレクターは、ジェネレーションでごみではないと判断される割合が高いことを検出すると、そのジェネレーションに対する割り当てのしきい値を高くして、次のジェネレーションで十分なサイズの解放されたメモリを受け取ることができるようにします。 CLR は、アプリケーションのワーキング セットが大きくなりすぎないようにすることと、ガベージ コレクションに時間がかかりすぎないようにすることに注意して、それらの 2 つの優先事項のバランスを絶えず調整します。

### <a name="ephemeral-generations-and-segments"></a>短期のジェネレーションとセグメント

ジェネレーション 0 および 1 のオブジェクトは有効期間が短いことから、それらのジェネレーションのことを短期ジェネレーションと呼びます。 

短期ジェネレーションは、短期セグメントと呼ばれるメモリ セグメントに割り当てる必要があります。 ガベージ コレクターによって新しいセグメントが取得されると、いずれも新しい短期セグメントになり、ジェネレーション 0 のガベージ コレクションで残ったオブジェクトが格納されます。 古い短期セグメントは新しいジェネレーション 2 のセグメントになります。 


短期セグメントには、ジェネレーション 2 のオブジェクトも含めることができます。 ジェネレーション 2 のオブジェクトでは複数のセグメントを使用できます (プロセスでの必要に応じてメモリが許容できる限りいくつでも使用できます)。 

短期ガベージ コレクションによって解放されるメモリの量は、短期セグメントのサイズまでに限られます。 解放されるメモリの量は、使用されなくなったオブジェクトに占有されていた領域に比例します。

## <a name="what-happens-during-a-garbage-collection"></a>ガベージ コレクションの実行時の動作

ガベージ コレクションには次のフェーズがあります。 

* マーキング フェーズ。有効なすべてのオブジェクトを探し、そのリストを作成します。

* 再配置フェーズ。圧縮するオブジェクトへの参照を更新します。 

* 圧縮フェーズ。使用されなくなったオブジェクトに占有されている領域を解放し、残ったオブジェクトを圧縮します。 圧縮フェーズでは、ガベージ コレクションで残ったオブジェクトをセグメントの後ろに移動します。 

ジェネレーション 2 のコレクションでは複数のセグメントを占有できるため、ジェネレーション 2 に昇格されたオブジェクトはより古いセグメントに移動できます。 ジェネレーション 1 とジェネレーション 2 の残存オブジェクトは、どちらもジェネレーション 2 に昇格されるため、別のセグメントに移動できます。 

通常、大きなオブジェクト ヒープは圧縮されません。これは、大きなオブジェクトをコピーするとパフォーマンスが低下するためです。 ただし [GCSettings.LargeObjectHeapCompactionMode](xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode) プロパティを使用して、大きなオブジェクト ヒープを必要に応じて圧縮できます。 

ガベージ コレクターは、次の情報に基づいてオブジェクトが有効かどうかを判断します。 

* **スタック ルート。** Just-In-Time (JIT) コンパイラとスタック ウォーカーによって提供されるスタック変数。

* **ガベージ コレクション ハンドル。** マネージ オブジェクトを参照するハンドル。これらのハンドルは、ユーザー コードまたは共通言語ランタイムで割り当てることができます。

* **静的データ。** 他のオブジェクトを参照している可能性があるアプリケーション ドメインの静的オブジェクト。 静的オブジェクトはそれぞれのアプリケーション ドメインで追跡されます。

ガベージ コレクションが開始される前に、そのガベージ コレクションをトリガーしたスレッドを除くすべてのマネージ スレッドが中断されます。

次の図は、ガベージ コレクションを発生させて他のスレッドの中断を引き起こすスレッドを示しています。

![スレッドがガベージ コレクションを発生させる場合](./media/fundamentals/393001.png)

ガベージ コレクションを発生させるスレッド

## <a name="manipulating-unmanaged-resources"></a>アンマネージ リソースの操作

ガベージ コレクターではマネージ ヒープのメモリのみを追跡するため、マネージ オブジェクトでネイティブのファイル ハンドルを使用してアンマネージ オブジェクトを参照している場合は、そのアンマネージ オブジェクトを明示的に解放する必要があります。

マネージ オブジェクトのユーザーは、オブジェクトで使用されているネイティブ リソースを破棄できません。 そのため、クリーンアップを行うには、マネージ オブジェクトをファイナライズ可能にします。 ファイナライズは、オブジェクトが使用されなくなったときに実行するクリーンアップ アクションで構成されます。 マネージ オブジェクトが使用されなくなると、ファイナライザー メソッドで指定されたクリーンアップ アクションが実行されます。

ファイナライズ可能なオブジェクトが使用されなくなったことが検出されると、クリーンアップ アクションを実行するためにファイナライザーによってキューに入れられますが、オブジェクト自体は次のジェネレーションに昇格されます。 そのため、そのジェネレーションで次のガベージ コレクション (次回のガベージ コレクションではない場合もあります) が発生するまで、オブジェクトが解放されたかどうかは確認できません。

## <a name="see-also"></a>関連項目

[.NET のガベージ コレクション](gc.md)



<!--HONumber=Nov16_HO3-->


