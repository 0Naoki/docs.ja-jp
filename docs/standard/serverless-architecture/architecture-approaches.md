---
title: サーバーレス アプリのアーキテクチャ アプローチ
description: アーキテクチャの概要については、サーバーレスに N 層アーキテクチャからのクラウド ベースのエンタープライズ アプリケーションを構築するために近くなります。
author: JEREMYLIKNESS
ms.author: jeliknes
ms.date: 06/26/2018
ms.openlocfilehash: 04ad383586f974bb2dccc4623a9a254f5668dab4
ms.sourcegitcommit: ccd8c36b0d74d99291d41aceb14cf98d74dc9d2b
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/10/2018
ms.locfileid: "53126746"
---
# <a name="architecture-approaches"></a>アーキテクチャのアプローチ

エンタープライズアプリケーションを設計するために既存のアプローチを理解することは、サーバレスで果たす役割を明確にするのに役立ちます。 ソフトウェア開発は何十年にも渡って進化を遂げた多くのアプローチとパターンがあり、すべてがそれぞれ長所と短所を持っています。 多くの場合、究極のソリューションは、単一のアプローチを決定するのではなく、いくつかのアプローチを統合することになるかもしれません。 移行シナリオでは、あるアーキテクチャのアプローチから、ハイブリッドなアーキテクチャーのアプローチへのシフトすることがしばしばあります。

この章では、エンタープライズアプリケーションの論理アーキテクチャ パターンと物理アーキテクチャ パターンの概要を説明します。

## <a name="architecture-patterns"></a>アーキテクチャーパターン

最新のビジネスアプリケーションは、さまざまなアーキテクチャーパターンに従っています。 このセクションでは、一般的なパターンの調査を表します。 ここで示したパターンでは、必ずしもすべてのベストプラクティスはありませんが、さまざまな方法を示しています。

詳細については、次を参照してください。 [Azure アプリケーション アーキテクチャ ガイド](https://docs.microsoft.com/azure/architecture/guide/)します。

## <a name="monoliths"></a>モノリス

多くのビジネスアプリケーションは、モノリスパターンに従っています。 レガシーアプリケーションは、モノリスに実装されていることがよくあります。 モノリスパターンでは、アプリケーションが1つのデプロイに含まれていることが問題です。 データベースの呼び出しからユーザーインターフェースまですべてが、同じコードベースに含まれています。

![モノリシック アーキテクチャ](./media/monolith-architecture.png)

モノリスのアプローチにもいくつかの利点はあります。 1つのコードベースをプルして作業を開始するのは簡単です。 構築時間は短縮され、テスト環境の作成は新しいコピーを提供するのと同じくらいシンプルです。 モノリスは、複数のコンポーネントまたはアプリケーションを含むように設計されています。

残念なことに、モノリスパターンはスケールで破綻する傾向があります。 モノリスのアプローチの主な欠点は次のとおりです。

* 同じコードベースで並列して作業するのは困難
* どんな些細な変更でも、アプリケーション全体を新しいバージョンにデプロイする必要がある
* リファクタリングは、潜在的にアプリケーション全体に影響を及ぼす
* 多くの場合、スケールする唯一のソリューションは、リソースが集約されたモノリスのコピーを複数作ることです。
* システムの拡張や他システムとの結合といったインテグレーションは難しい可能性があります。
* テストは、モノリス全体の構成をする必要があるため難しい可能性があります。
* コードの再利用は困難であり、多くの場合、他のアプリは元のコードのコピーを持つことになります。

多くの企業は、モノリスのアプリケーションを移行する機会としてクラウドに注目し、同時により有用なパターンにリファクタリングします。 個々のアプリケーションやコンポーネントを切り離して、個別に保守、デプロイ、およびスケーリングできるようにするのが一般的です。

## <a name="n-layer-applications"></a>N層アプリケーション

N層アプリケーションは、アプリケーションのロジックを特定のレイヤーに分けます。 最も一般的なレイヤーは次の通りです。

* ユーザーインターフェイス
* ビジネスロジック
* データアクセス

他の層には、ミドルウェア、バッチ処理、および API が含まれるでしょう。 レイヤーは論理的であることに注意することが重要です。 それらは独立して開発されますが、すべて同じターゲットプラットフォームに展開されることがあります。

![N 層アーキテクチャ](./media/n-layer-architecture.png)

N層のアプローチには、次のようないくつかの利点があります。

* リファクタリングは、レイヤーに分離されます。
* チームできます個別にビルド、テスト、展開、および別のレイヤーを維持します。
* レイヤーをスワップ アウト、たとえば、データ層は UI レイヤーに変更することがなく複数のデータベースをアクセス可能性があります。

サーバーレスは、1つまたは複数のレイヤーを実装できます。

## <a name="microservices"></a>マイクロサービス

**[マイクロ サービス](https://docs.microsoft.com/azure/architecture/guide/architecture-styles/microservices)** アーキテクチャが含まれる共通の特徴を含みます。

* アプリケーションは、いくつかの小さなサービスで構成されます。
* 各サービスは、独自のプロセスで実行されます。
* サービスは、ビジネス ドメインの周囲に配置されます。
* サービスは、通常、トランスポートとして HTTP を使用して軽量の Api 経由で通信します。
* サービスのデプロイし、は個別にアップグレードできます。
* サービスが 1 つのデータ ストアに依存します。
* システムはエラーを考慮して設計されていて、アプリには、特定のサービスが失敗する場合でも引き続きを実行できます。

マイクロサービスは、他のアーキテクチャのアプローチと相互に排他的である必要はありません。 例えばN層アーキテクチャでは、中間層にマイクロサービスを利用することができます。 IIS ホスト上の仮想ディレクトリからコンテナーまで、様々な方法でマイクロサービスの実装が可能です。 マイクロサービスの特性は、サーバーレス実装に特に適しています。

![マイクロサービス アーキテクチャ](./media/microservices-architecture.png)

マイクロサービス アーキテクチャの利点は次のとおりです。

* リファクタリングは、単一のサービスごとに分離できます。
* 各サービスは互いに独立してアップグレードできます。
* 回復性と弾力性は、各サービスの要求に合わせて調整することができます。
* 開発は、異なるチームや異なるプラットフォーム間で並行して行われます。
* サービスが分離されていることで、包括的なテストの記述が容易です。

マイクロサービスには、以下のような課題があります。

* 利用可能なサービスとその呼び出し方法の決定
* 各サービスのライフサイクルの管理
* 各サービスがどのようにアプリケーション全体にフィットするかの理解
* 異なるサービス間で行われた呼び出しの完全なシステムテスト

最終的には、後述するサーバーレスの利点を活用するなど、これらすべての課題に対処するためのソリューションがあります。

>[!div class="step-by-step"]
>[前へ](index.md)
>[次へ](architecture-deployment-approaches.md)