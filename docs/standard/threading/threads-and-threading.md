---
title: スレッドおよびスレッド処理
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- multiple threads
- threading [.NET Framework]
- threading [.NET Framework], multiple threads
ms.assetid: 5baac3aa-e603-4fa6-9f89-0f2c1084e6b1
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: ef464b0d4c22d04d42f9b6f953abefe7582b4957
ms.sourcegitcommit: c7f3e2e9d6ead6cc3acd0d66b10a251d0c66e59d
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 09/09/2018
ms.locfileid: "44188541"
---
# <a name="threads-and-threading"></a><span data-ttu-id="e5200-102">スレッドおよびスレッド処理</span><span class="sxs-lookup"><span data-stu-id="e5200-102">Threads and Threading</span></span>
<span data-ttu-id="e5200-103">オペレーティング システムは、実行している異なるアプリケーションを分離するために、プロセスを使います。</span><span class="sxs-lookup"><span data-stu-id="e5200-103">Operating systems use processes to separate the different applications that they are executing.</span></span> <span data-ttu-id="e5200-104">スレッドはオペレーティング システムがプロセッサ時間を割り当てる基本単位であり、複数のスレッドがそのプロセスの内部でコードを実行できます。</span><span class="sxs-lookup"><span data-stu-id="e5200-104">Threads are the basic unit to which an operating system allocates processor time, and more than one thread can be executing code inside that process.</span></span> <span data-ttu-id="e5200-105">各スレッドは、例外ハンドラー、スケジューリングの優先順位、スレッドがスケジュールされるまでシステムがスレッド コンテキストを保存するために使用する構造体のセットを保持しています。</span><span class="sxs-lookup"><span data-stu-id="e5200-105">Each thread maintains exception handlers, a scheduling priority, and a set of structures the system uses to save the thread context until it is scheduled.</span></span> <span data-ttu-id="e5200-106">スレッド コンテキストには、スレッドがシームレスに実行を再開するために必要なすべての情報 (スレッドの CPU レジスタとスタックのセットなど) が含まれ、スレッドのホスト プロセスのアドレス空間内に保持されます。</span><span class="sxs-lookup"><span data-stu-id="e5200-106">The thread context includes all the information the thread needs to seamlessly resume execution, including the thread's set of CPU registers and stack, in the address space of the thread's host process.</span></span>  
  
 <span data-ttu-id="e5200-107">さらに、.NET Framework では、オペレーティング システムのプロセスが、アプリケーション ドメインと呼ばれ、<xref:System.AppDomain?displayProperty=nameWithType> によって表される、軽量のマネージド サブプロセスに細分化されます。</span><span class="sxs-lookup"><span data-stu-id="e5200-107">The .NET Framework further subdivides an operating system process into lightweight managed subprocesses, called application domains, represented by <xref:System.AppDomain?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e5200-108">1 つ以上のマネージド スレッド (<xref:System.Threading.Thread?displayProperty=nameWithType> によって表されます) が、同じマネージド プロセス内の任意の数のアプリケーション ドメインで実行できます。</span><span class="sxs-lookup"><span data-stu-id="e5200-108">One or more managed threads (represented by <xref:System.Threading.Thread?displayProperty=nameWithType>) can run in one or any number of application domains within the same managed process.</span></span> <span data-ttu-id="e5200-109">各アプリケーション ドメインは 1 つのスレッドで開始しますが、そのアプリケーション ドメイン内のコードは、追加のアプリケーション ドメインと追加のスレッドを作成できます。</span><span class="sxs-lookup"><span data-stu-id="e5200-109">Although each application domain is started with a single thread, code in that application domain can create additional application domains and additional threads.</span></span> <span data-ttu-id="e5200-110">結果として、マネージド スレッドは同じマネージド プロセス内のアプリケーション ドメイン間を自由に移動できます。ただ 1 つのスレッドが複数のアプリケーション ドメイン間を移動していることもあります。</span><span class="sxs-lookup"><span data-stu-id="e5200-110">The result is that a managed thread can move freely between application domains inside the same managed process; you might have only one thread moving among several application domains.</span></span>  
  
 <span data-ttu-id="e5200-111">オペレーティング システムがプリエンプティブなマルチタスク処理をサポートしていると、複数プロセスからの複数スレッドの同時実行の効果が作り出されます。</span><span class="sxs-lookup"><span data-stu-id="e5200-111">An operating system that supports preemptive multitasking creates the effect of simultaneous execution of multiple threads from multiple processes.</span></span> <span data-ttu-id="e5200-112">そのためには、利用可能なプロセッサ時間がそれを必要とするスレッドの間で分割され、プロセッサ時間のスライスが各スレッドに次々に割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="e5200-112">It does this by dividing the available processor time among the threads that need it, allocating a processor time slice to each thread one after another.</span></span> <span data-ttu-id="e5200-113">タイム スライスが経過すると現在実行中のスレッドは中断されて、別のスレッドが実行を再開します。</span><span class="sxs-lookup"><span data-stu-id="e5200-113">The currently executing thread is suspended when its time slice elapses, and another thread resumes running.</span></span> <span data-ttu-id="e5200-114">システムは、スレッドを切り替えるとき、割り込まれたスレッドのスレッド コンテキストを保存し、スレッド キュー内の次のスレッドの保存されているスレッド コンテキストを再度読み込みます。</span><span class="sxs-lookup"><span data-stu-id="e5200-114">When the system switches from one thread to another, it saves the thread context of the preempted thread and reloads the saved thread context of the next thread in the thread queue.</span></span>  
  
 <span data-ttu-id="e5200-115">タイム スライスの長さは、オペレーティング システムとプロセッサによって異なります。</span><span class="sxs-lookup"><span data-stu-id="e5200-115">The length of the time slice depends on the operating system and the processor.</span></span> <span data-ttu-id="e5200-116">各タイム スライスは小さいため、プロセッサが 1 つだけであっても、複数のスレッドが同時に実行しているように見えます。</span><span class="sxs-lookup"><span data-stu-id="e5200-116">Because each time slice is small, multiple threads appear to be executing at the same time, even if there is only one processor.</span></span> <span data-ttu-id="e5200-117">実際には、これはマルチプロセッサ システムの場合であり、実行可能なスレッドは利用可能なプロセッサ間に分散されます。</span><span class="sxs-lookup"><span data-stu-id="e5200-117">This is actually the case on multiprocessor systems, where the executable threads are distributed among the available processors.</span></span>  
  
## <a name="when-to-use-multiple-threads"></a><span data-ttu-id="e5200-118">複数のスレッドを使用する場合</span><span class="sxs-lookup"><span data-stu-id="e5200-118">When To Use Multiple Threads</span></span>  
 <span data-ttu-id="e5200-119">ユーザーの介入を必要とするソフトウェアは、よいユーザー エクスペリエンスを提供するため、できる限り早くユーザーのアクティビティに応答する必要があります。</span><span class="sxs-lookup"><span data-stu-id="e5200-119">Software that requires user interaction must react to the user's activities as rapidly as possible to provide a rich user experience.</span></span> <span data-ttu-id="e5200-120">ただし同時に、できるだけ速くユーザーにデータを提示するために必要な計算を実行する必要もあります。</span><span class="sxs-lookup"><span data-stu-id="e5200-120">At the same time, however, it must do the calculations necessary to present data to the user as fast as possible.</span></span> <span data-ttu-id="e5200-121">アプリケーションが実行スレッドを 1 つしか使っていない場合は、[非同期プログラミング](../../../docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)と [.NET Framework リモート処理](https://msdn.microsoft.com/library/eccb1d31-0a22-417a-97fd-f4f1f3aa4462)または ASP.NET を使って作成された [XML Web サービス](https://msdn.microsoft.com/library/1e64af78-d705-4384-b08d-591a45f4379c)を組み合わせて、そのコンピューター自体の処理時間に加えて他のコンピューターの処理時間を使うことにより、応答性を向上させ、アプリケーションのデータ処理時間を減らすことができます。</span><span class="sxs-lookup"><span data-stu-id="e5200-121">If your application uses only one thread of execution, you can combine [asynchronous programming](../../../docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md) with[.NET Framework remoting](https://msdn.microsoft.com/library/eccb1d31-0a22-417a-97fd-f4f1f3aa4462) or [XML Web services](https://msdn.microsoft.com/library/1e64af78-d705-4384-b08d-591a45f4379c) created using ASP.NET to use the processing time of other computers in addition to that of your own to increase responsiveness to the user and decrease the data processing time of your application.</span></span> <span data-ttu-id="e5200-122">入力/出力の多い処理を行っている場合は、I/O 完了ポートを使ってアプリケーションの応答性を高めることもできます。</span><span class="sxs-lookup"><span data-stu-id="e5200-122">If you are doing intensive input/output work, you can also use I/O completion ports to increase your application's responsiveness.</span></span>  
  
### <a name="advantages-of-multiple-threads"></a><span data-ttu-id="e5200-123">複数スレッドの長所</span><span class="sxs-lookup"><span data-stu-id="e5200-123">Advantages of Multiple Threads</span></span>  
 <span data-ttu-id="e5200-124">ただし、複数のスレッドを使うことは、ユーザーへの応答性を向上させ、ほぼ同時にジョブの完了に必要なデータを処理するために利用できる、最も強力な方法です。</span><span class="sxs-lookup"><span data-stu-id="e5200-124">Using more than one thread, however, is the most powerful technique available to increase responsiveness to the user and process the data necessary to get the job done at almost the same time.</span></span> <span data-ttu-id="e5200-125">1 プロセッサのコンピューターでは、複数のスレッドによってこの効果を作り出すことができ、ユーザー イベントの間の短い時間を利用してバックグラウンドでデータを処理します。</span><span class="sxs-lookup"><span data-stu-id="e5200-125">On a computer with one processor, multiple threads can create this effect, taking advantage of the small periods of time in between user events to process the data in the background.</span></span> <span data-ttu-id="e5200-126">たとえば、別のスレッドが同じアプリケーション内でワークシートの他の部分を再計算中に、ユーザーはスプレッドシートを編集できます。</span><span class="sxs-lookup"><span data-stu-id="e5200-126">For example, a user can edit a spreadsheet while another thread is recalculating other parts of the spreadsheet within the same application.</span></span>  
  
 <span data-ttu-id="e5200-127">アプリケーションを変更しなくても、複数のプロセッサを搭載したコンピューターでアプリケーションを実行するだけで、ユーザーの満足度が著しく向上します。</span><span class="sxs-lookup"><span data-stu-id="e5200-127">Without modification, the same application would dramatically increase user satisfaction when run on a computer with more than one processor.</span></span> <span data-ttu-id="e5200-128">1 つのアプリケーション ドメインが複数のスレッドを使うことにより、次のタスクを実行できます。</span><span class="sxs-lookup"><span data-stu-id="e5200-128">Your single application domain could use multiple threads to accomplish the following tasks:</span></span>  
  
-   <span data-ttu-id="e5200-129">ネットワーク経由で Web サーバーやデータベースと通信します。</span><span class="sxs-lookup"><span data-stu-id="e5200-129">Communicate over a network, to a Web server, and to a database.</span></span>  
  
-   <span data-ttu-id="e5200-130">長い時間がかかる操作を実行します。</span><span class="sxs-lookup"><span data-stu-id="e5200-130">Perform operations that take a large amount of time.</span></span>  
  
-   <span data-ttu-id="e5200-131">優先順位が異なるタスクを区別します。</span><span class="sxs-lookup"><span data-stu-id="e5200-131">Distinguish tasks of varying priority.</span></span> <span data-ttu-id="e5200-132">たとえば、高優先度のスレッドでタイム クリティカルなタスクを管理し、低優先度のスレッドで他のタスクを実行します。</span><span class="sxs-lookup"><span data-stu-id="e5200-132">For example, a high-priority thread manages time-critical tasks, and a low-priority thread performs other tasks.</span></span>  
  
-   <span data-ttu-id="e5200-133">ユーザー インターフェイスの応答性を維持しながら、バックグラウンド タスクに時間を割り当てることができます。</span><span class="sxs-lookup"><span data-stu-id="e5200-133">Allow the user interface to remain responsive, while allocating time to background tasks.</span></span>  
  
### <a name="disadvantages-of-multiple-threads"></a><span data-ttu-id="e5200-134">複数スレッドの短所</span><span class="sxs-lookup"><span data-stu-id="e5200-134">Disadvantages of Multiple Threads</span></span>  
 <span data-ttu-id="e5200-135">使うスレッドの数をできるだけ少なくすることをお勧めします。そうすることで、オペレーティング システムのリソースの使用量が最小限になり、パフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="e5200-135">It is recommended that you use as few threads as possible, thereby minimizing the use of operating-system resources and improving performance.</span></span> <span data-ttu-id="e5200-136">スレッド処理には、アプリケーションの設計時に考慮する必要のあるリソースの要件と競合の可能性もあります。</span><span class="sxs-lookup"><span data-stu-id="e5200-136">Threading also has resource requirements and potential conflicts to be considered when designing your application.</span></span> <span data-ttu-id="e5200-137">リソースの要件は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="e5200-137">The resource requirements are as follows:</span></span>  
  
-   <span data-ttu-id="e5200-138">システムは、プロセス、**AppDomain** オブジェクト、およびスレッドで必要なコンテキスト情報にメモリを消費します。</span><span class="sxs-lookup"><span data-stu-id="e5200-138">The system consumes memory for the context information required by processes, **AppDomain** objects, and threads.</span></span> <span data-ttu-id="e5200-139">したがって、作成できるプロセス、**AppDomain** オブジェクト、スレッドの数は、利用可能なメモリによって制限されます。</span><span class="sxs-lookup"><span data-stu-id="e5200-139">Therefore, the number of processes, **AppDomain** objects, and threads that can be created is limited by available memory.</span></span>  
  
-   <span data-ttu-id="e5200-140">多数のスレッドを追跡すると、大量のプロセッサ時間を消費します。</span><span class="sxs-lookup"><span data-stu-id="e5200-140">Keeping track of a large number of threads consumes significant processor time.</span></span> <span data-ttu-id="e5200-141">スレッドが多すぎる場合、そのほとんどは処理があまり進行しません。</span><span class="sxs-lookup"><span data-stu-id="e5200-141">If there are too many threads, most of them will not make significant progress.</span></span> <span data-ttu-id="e5200-142">現在のスレッドのほとんどが 1 つのプロセスに含まれる場合、他のプロセスのスレッドはスケジュールの頻度が低下します。</span><span class="sxs-lookup"><span data-stu-id="e5200-142">If most of the current threads are in one process, threads in other processes are scheduled less frequently.</span></span>  
  
-   <span data-ttu-id="e5200-143">多数のスレッドを使うコード実行の制御は複雑であり、多くのバグの原因になる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="e5200-143">Controlling code execution with many threads is complex, and can be a source of many bugs.</span></span>  
  
-   <span data-ttu-id="e5200-144">スレッドを破棄するときは、発生する可能性があることを認識し、それらの問題に対処する必要があります。</span><span class="sxs-lookup"><span data-stu-id="e5200-144">Destroying threads requires knowing what could happen and handling those issues.</span></span>  
  
 <span data-ttu-id="e5200-145">リソースへの共有アクセスを提供すると、競合が発生する場合があります。</span><span class="sxs-lookup"><span data-stu-id="e5200-145">Providing shared access to resources can create conflicts.</span></span> <span data-ttu-id="e5200-146">競合を避けるには、共有リソースを同期するか、共有リソースへのアクセスを制御する必要があります。</span><span class="sxs-lookup"><span data-stu-id="e5200-146">To avoid conflicts, you must synchronize, or control the access to, shared resources.</span></span> <span data-ttu-id="e5200-147">(同じアプリケーション ドメイン内または異なるアプリケーション ドメイン内の) アクセスを適切に同期できないと、デッドロック (2 つのスレッドが相互の完了を待って応答を停止すること) や競合状態 (2 つのイベントのタイミングに対する予測できない重大な依存のために異常な結果が発生するとき) などの問題が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="e5200-147">Failure to synchronize access properly (in the same or different application domains) can lead to problems such as deadlocks (in which two threads stop responding while each waits for the other to complete) and race conditions (when an anomalous result occurs due to an unexpected critical dependence on the timing of two events).</span></span> <span data-ttu-id="e5200-148">システムが提供する同期オブジェクトを使って、複数のスレッド間のリソース共有を調整できます。</span><span class="sxs-lookup"><span data-stu-id="e5200-148">The system provides synchronization objects that can be used to coordinate resource sharing among multiple threads.</span></span> <span data-ttu-id="e5200-149">スレッドの数を減らすと、リソースの同期が容易になります。</span><span class="sxs-lookup"><span data-stu-id="e5200-149">Reducing the number of threads makes it easier to synchronize resources.</span></span>  
  
 <span data-ttu-id="e5200-150">同期が必要なリソースは次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="e5200-150">Resources that require synchronization include:</span></span>  
  
-   <span data-ttu-id="e5200-151">システム リソース (通信ポートなど)。</span><span class="sxs-lookup"><span data-stu-id="e5200-151">System resources (such as communications ports).</span></span>  
  
-   <span data-ttu-id="e5200-152">複数のプロセスによって共有されるリソース (ファイル ハンドルなど)。</span><span class="sxs-lookup"><span data-stu-id="e5200-152">Resources shared by multiple processes (such as file handles).</span></span>  
  
-   <span data-ttu-id="e5200-153">複数のスレッドによってアクセスされる 1 つのアプリケーション ドメインのリソース (グローバル フィールド、静的フィールド、インスタンス フィールドなど)。</span><span class="sxs-lookup"><span data-stu-id="e5200-153">The resources of a single application domain (such as global, static, and instance fields) accessed by multiple threads.</span></span>  
  
### <a name="threading-and-application-design"></a><span data-ttu-id="e5200-154">スレッド処理とアプリケーションの設計</span><span class="sxs-lookup"><span data-stu-id="e5200-154">Threading and Application Design</span></span>  
 <span data-ttu-id="e5200-155">一般に、他のスレッドをブロックしない比較的短いタスクの複数のスレッドを処理する場合で、タスクの特定のスケジューリングを予期しないときは、<xref:System.Threading.ThreadPool> クラスを使うのが最も簡単な方法です。</span><span class="sxs-lookup"><span data-stu-id="e5200-155">In general, using the <xref:System.Threading.ThreadPool> class is the easiest way to handle multiple threads for relatively short tasks that will not block other threads and when you do not expect any particular scheduling of the tasks.</span></span> <span data-ttu-id="e5200-156">ただし、独自のスレッドを作成するにはいくつかの理由があります。</span><span class="sxs-lookup"><span data-stu-id="e5200-156">However, there are a number of reasons to create your own threads:</span></span>  
  
-   <span data-ttu-id="e5200-157">タスクに特定の優先順位を設定する必要がある場合。</span><span class="sxs-lookup"><span data-stu-id="e5200-157">If you need a task to have a particular priority.</span></span>  
  
-   <span data-ttu-id="e5200-158">タスクの実行時間が長くなる (したがって他のタスクをブロックする) 可能性がある場合。</span><span class="sxs-lookup"><span data-stu-id="e5200-158">If you have a task that might run a long time (and therefore block other tasks).</span></span>  
  
-   <span data-ttu-id="e5200-159">シングルスレッド アパートメントにスレッドを配置する必要がある場合 (すべての **ThreadPool** スレッドはマルチスレッド アパートメント内です)。</span><span class="sxs-lookup"><span data-stu-id="e5200-159">If you need to place threads into a single-threaded apartment (all **ThreadPool** threads are in the multithreaded apartment).</span></span>  
  
-   <span data-ttu-id="e5200-160">スレッドに関連付けられた安定した ID が必要な場合。</span><span class="sxs-lookup"><span data-stu-id="e5200-160">If you need a stable identity associated with the thread.</span></span> <span data-ttu-id="e5200-161">たとえば、名前でスレッドを中止、中断、または探索するには、専用のスレッドを使う必要があります。</span><span class="sxs-lookup"><span data-stu-id="e5200-161">For example, you should use a dedicated thread to abort that thread, suspend it, or discover it by name.</span></span>  
  
-   <span data-ttu-id="e5200-162">ユーザー インターフェイスと対話するバックグラウンド スレッドを実行する必要がある場合、.NET Framework バージョン 2.0 は、イベントを使って通信し、ユーザー インターフェイス スレッドへのスレッド間マーシャリングを行う、<xref:System.ComponentModel.BackgroundWorker> コンポーネントを提供します。</span><span class="sxs-lookup"><span data-stu-id="e5200-162">If you need to run background threads that interact with the user interface, the .NET Framework version 2.0 provides a <xref:System.ComponentModel.BackgroundWorker> component that communicates using events, with cross-thread marshaling to the user-interface thread.</span></span>  
  
### <a name="threading-and-exceptions"></a><span data-ttu-id="e5200-163">スレッド処理と例外</span><span class="sxs-lookup"><span data-stu-id="e5200-163">Threading and Exceptions</span></span>  
 <span data-ttu-id="e5200-164">スレッドで例外を処理します。</span><span class="sxs-lookup"><span data-stu-id="e5200-164">Do handle exceptions in threads.</span></span> <span data-ttu-id="e5200-165">スレッドでハンドルされない例外は、バックグラウンド スレッドであっても、一般に、プロセスを終了します。</span><span class="sxs-lookup"><span data-stu-id="e5200-165">Unhandled exceptions in threads, even background threads, generally terminate the process.</span></span> <span data-ttu-id="e5200-166">この規則には、次の 3 つの例外があります。</span><span class="sxs-lookup"><span data-stu-id="e5200-166">There are three exceptions to this rule:</span></span>  
  
-   <span data-ttu-id="e5200-167"><xref:System.Threading.Thread.Abort%2A> が呼び出されたため、スレッドで <xref:System.Threading.ThreadAbortException> がスローされる。</span><span class="sxs-lookup"><span data-stu-id="e5200-167">A <xref:System.Threading.ThreadAbortException> is thrown in a thread because <xref:System.Threading.Thread.Abort%2A> was called.</span></span>  
  
-   <span data-ttu-id="e5200-168">アプリケーション ドメインがアンロードされているため、スレッドで <xref:System.AppDomainUnloadedException> がスローされる。</span><span class="sxs-lookup"><span data-stu-id="e5200-168">An <xref:System.AppDomainUnloadedException> is thrown in a thread because the application domain is being unloaded.</span></span>  
  
-   <span data-ttu-id="e5200-169">共通言語ランタイムまたはホスト プロセスがスレッドを終了する。</span><span class="sxs-lookup"><span data-stu-id="e5200-169">The common language runtime or a host process terminates the thread.</span></span>  
  
 <span data-ttu-id="e5200-170">詳しくは、「[マネージド スレッドの例外](../../../docs/standard/threading/exceptions-in-managed-threads.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="e5200-170">For more information, see [Exceptions in Managed Threads](../../../docs/standard/threading/exceptions-in-managed-threads.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e5200-171">.NET Framework Version 1.0 および 1.1 では、スレッド プールのスレッドでのものなど、一部の例外は共通言語ランタイムによって通知なしにトラップされます。</span><span class="sxs-lookup"><span data-stu-id="e5200-171">In the .NET Framework versions 1.0 and 1.1, the common language runtime silently traps some exceptions, for example in thread pool threads.</span></span> <span data-ttu-id="e5200-172">このため、アプリケーション状態が破損し、最終的にアプリケーションが停止することになり、デバッグが困難になることがあります。</span><span class="sxs-lookup"><span data-stu-id="e5200-172">This may corrupt application state and eventually cause applications to hang, which might be very difficult to debug.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="e5200-173">関連項目</span><span class="sxs-lookup"><span data-stu-id="e5200-173">See also</span></span>

- <xref:System.Threading.ThreadPool>  
- <xref:System.ComponentModel.BackgroundWorker>  
- [<span data-ttu-id="e5200-174">マルチスレッド処理のためのデータの同期</span><span class="sxs-lookup"><span data-stu-id="e5200-174">Synchronizing Data for Multithreading</span></span>](../../../docs/standard/threading/synchronizing-data-for-multithreading.md)  
- [<span data-ttu-id="e5200-175">マネージド スレッド プール</span><span class="sxs-lookup"><span data-stu-id="e5200-175">The Managed Thread Pool</span></span>](../../../docs/standard/threading/the-managed-thread-pool.md)
