---
title: Windows でのマネージ スレッド処理とアンマネージ スレッド処理
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- threading [.NET Framework], unmanaged
- threading [.NET Framework], managed
- managed threading
ms.assetid: 4fb6452f-c071-420d-9e71-da16dee7a1eb
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 50e709c8b5de505b17efea8ddf333633b2bd7400
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/04/2018
---
# <a name="managed-and-unmanaged-threading-in-windows"></a><span data-ttu-id="7c9a8-102">Windows でのマネージ スレッド処理とアンマネージ スレッド処理</span><span class="sxs-lookup"><span data-stu-id="7c9a8-102">Managed and Unmanaged Threading in Windows</span></span>
<span data-ttu-id="7c9a8-103">共通言語ランタイムにより作成されたスレッド、マネージ環境に入ってコードを実行するランタイム外部で作成されたスレッドなど、すべてのスレッドの管理は、 <xref:System.Threading.Thread> クラスを使用して行われます。</span><span class="sxs-lookup"><span data-stu-id="7c9a8-103">Management of all threads is done through the <xref:System.Threading.Thread> class, including threads created by the common language runtime and those created outside the runtime that enter the managed environment to execute code.</span></span> <span data-ttu-id="7c9a8-104">ランタイムは、プロセス内のスレッドのうち、マネージ実行環境内でコードを実行したすべてのスレッドを監視します。</span><span class="sxs-lookup"><span data-stu-id="7c9a8-104">The runtime monitors all the threads in its process that have ever executed code within the managed execution environment.</span></span> <span data-ttu-id="7c9a8-105">その他のスレッドは追跡しません。</span><span class="sxs-lookup"><span data-stu-id="7c9a8-105">It does not track any other threads.</span></span> <span data-ttu-id="7c9a8-106">ランタイムがマネージ オブジェクトを COM オブジェクトとしてアンマネージ環境に公開するため、スレッドは COM 相互運用を使用してマネージ実行環境に入ることができます。また、COM [DllGetClassObject](https://msdn.microsoft.com/library/ms680760.aspx) 関数やプラットフォーム呼び出しを介してマネージ実行環境に入ることもできます。</span><span class="sxs-lookup"><span data-stu-id="7c9a8-106">Threads can enter the managed execution environment through COM interop (because the runtime exposes managed objects as COM objects to the unmanaged world), the COM [DllGetClassObject](https://msdn.microsoft.com/library/ms680760.aspx) function, and platform invoke.</span></span>  
  
 <span data-ttu-id="7c9a8-107">ただしアンマネージ スレッドが COM 呼び出し可能ラッパーなどを介してランタイムに入ると、システムがそのスレッド ローカル ストアで内部マネージ <xref:System.Threading.Thread> オブジェクトを検索します。</span><span class="sxs-lookup"><span data-stu-id="7c9a8-107">When an unmanaged thread enters the runtime through, for example, a COM callable wrapper, the system checks the thread-local store of that thread to look for an internal managed <xref:System.Threading.Thread> object.</span></span> <span data-ttu-id="7c9a8-108">このオブジェクトが見つかった場合、ランタイムは既にこのスレッドを認識しています。</span><span class="sxs-lookup"><span data-stu-id="7c9a8-108">If one is found, the runtime is already aware of this thread.</span></span> <span data-ttu-id="7c9a8-109">見つからない場合、ランタイムは新しい <xref:System.Threading.Thread> オブジェクトを作成し、そのスレッドのスレッド ローカル ストアにインストールします。</span><span class="sxs-lookup"><span data-stu-id="7c9a8-109">If it cannot find one, however, the runtime builds a new <xref:System.Threading.Thread> object and installs it in the thread-local store of that thread.</span></span>  
  
 <span data-ttu-id="7c9a8-110">マネージ スレッド処理では、<xref:System.Threading.Thread.GetHashCode%2A?displayProperty=nameWithType> は安定したマネージ スレッド ID です。</span><span class="sxs-lookup"><span data-stu-id="7c9a8-110">In managed threading, <xref:System.Threading.Thread.GetHashCode%2A?displayProperty=nameWithType> is the stable managed thread identification.</span></span> <span data-ttu-id="7c9a8-111">この値は、取得されたアプリケーション ドメインに関係なく、スレッドの有効期間にわたって他のスレッドの値と競合することはありません。</span><span class="sxs-lookup"><span data-stu-id="7c9a8-111">For the lifetime of your thread, it will not collide with the value from any other thread, regardless of the application domain from which you obtain this value.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7c9a8-112">オペレーティング システム **ThreadId** とマネージ スレッドの間には固定的な関係はありません。これは、アンマネージ ホストがマネージ スレッドとアンマネージ スレッドの間の関係を制御できるためです。</span><span class="sxs-lookup"><span data-stu-id="7c9a8-112">An operating-system **ThreadId** has no fixed relationship to a managed thread, because an unmanaged host can control the relationship between managed and unmanaged threads.</span></span> <span data-ttu-id="7c9a8-113">特に、高度なホストはファイバー API を使用して、多数のマネージ スレッドを同一オペレーティング システム スレッドに対してスケジュールしたり、マネージ スレッドを異なるオペレーティング システム スレッド間で移動したりできます。</span><span class="sxs-lookup"><span data-stu-id="7c9a8-113">Specifically, a sophisticated host can use the Fiber API to schedule many managed threads against the same operating system thread, or to move a managed thread among different operating system threads.</span></span>  
  
## <a name="mapping-from-win32-threading-to-managed-threading"></a><span data-ttu-id="7c9a8-114">WIn32 スレッド処理とマネージ スレッド処理の対応付け</span><span class="sxs-lookup"><span data-stu-id="7c9a8-114">Mapping from Win32 Threading to Managed Threading</span></span>  
 <span data-ttu-id="7c9a8-115">Win32 スレッド処理要素とほぼそれに対応するランタイムの対応付けを次の表に示します。</span><span class="sxs-lookup"><span data-stu-id="7c9a8-115">The following table maps Win32 threading elements to their approximate runtime equivalent.</span></span> <span data-ttu-id="7c9a8-116">この対応付けは、同一の機能性を示すものではありません。</span><span class="sxs-lookup"><span data-stu-id="7c9a8-116">Note that this mapping does not represent identical functionality.</span></span> <span data-ttu-id="7c9a8-117">たとえば **TerminateThread** は **finally** 句の実行やリソースの解放は行わず、また防止することはできません。</span><span class="sxs-lookup"><span data-stu-id="7c9a8-117">For example, **TerminateThread** does not execute **finally** clauses or free up resources, and cannot be prevented.</span></span> <span data-ttu-id="7c9a8-118">ただし <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> はすべてのロールバック コードを実行し、すべてのリソースを解放します。また、<xref:System.Threading.Thread.ResetAbort%2A> を使用して拒否することができます。</span><span class="sxs-lookup"><span data-stu-id="7c9a8-118">However, <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> executes all your rollback code, reclaims all the resources, and can be denied using <xref:System.Threading.Thread.ResetAbort%2A>.</span></span> <span data-ttu-id="7c9a8-119">機能について推測する前に、このドキュメントを詳しくお読みください。</span><span class="sxs-lookup"><span data-stu-id="7c9a8-119">Be sure to read the documentation closely before making assumptions about functionality.</span></span>  
  
|<span data-ttu-id="7c9a8-120">Win32</span><span class="sxs-lookup"><span data-stu-id="7c9a8-120">In Win32</span></span>|<span data-ttu-id="7c9a8-121">共通言語ランタイム</span><span class="sxs-lookup"><span data-stu-id="7c9a8-121">In the common language runtime</span></span>|  
|--------------|------------------------------------|  
|<span data-ttu-id="7c9a8-122">**CreateThread**</span><span class="sxs-lookup"><span data-stu-id="7c9a8-122">**CreateThread**</span></span>|<span data-ttu-id="7c9a8-123">**Thread** と <xref:System.Threading.ThreadStart>の組み合わせ</span><span class="sxs-lookup"><span data-stu-id="7c9a8-123">Combination of **Thread** and <xref:System.Threading.ThreadStart></span></span>|  
|<span data-ttu-id="7c9a8-124">**TerminateThread**</span><span class="sxs-lookup"><span data-stu-id="7c9a8-124">**TerminateThread**</span></span>|<xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="7c9a8-125">**SuspendThread**</span><span class="sxs-lookup"><span data-stu-id="7c9a8-125">**SuspendThread**</span></span>|<xref:System.Threading.Thread.Suspend%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="7c9a8-126">**ResumeThread**</span><span class="sxs-lookup"><span data-stu-id="7c9a8-126">**ResumeThread**</span></span>|<xref:System.Threading.Thread.Resume%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="7c9a8-127">**Sleep**</span><span class="sxs-lookup"><span data-stu-id="7c9a8-127">**Sleep**</span></span>|<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="7c9a8-128">スレッド ハンドルの**WaitForSingleObject** </span><span class="sxs-lookup"><span data-stu-id="7c9a8-128">**WaitForSingleObject** on the thread handle</span></span>|<xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="7c9a8-129">**ExitThread**</span><span class="sxs-lookup"><span data-stu-id="7c9a8-129">**ExitThread**</span></span>|<span data-ttu-id="7c9a8-130">同等の機能がありません</span><span class="sxs-lookup"><span data-stu-id="7c9a8-130">No equivalent</span></span>|  
|<span data-ttu-id="7c9a8-131">**GetCurrentThread**</span><span class="sxs-lookup"><span data-stu-id="7c9a8-131">**GetCurrentThread**</span></span>|<xref:System.Threading.Thread.CurrentThread%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="7c9a8-132">**SetThreadPriority**</span><span class="sxs-lookup"><span data-stu-id="7c9a8-132">**SetThreadPriority**</span></span>|<xref:System.Threading.Thread.Priority%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="7c9a8-133">同等の機能がありません</span><span class="sxs-lookup"><span data-stu-id="7c9a8-133">No equivalent</span></span>|<xref:System.Threading.Thread.Name%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="7c9a8-134">同等の機能がありません</span><span class="sxs-lookup"><span data-stu-id="7c9a8-134">No equivalent</span></span>|<xref:System.Threading.Thread.IsBackground%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="7c9a8-135">**CoInitializeEx** (OLE32.DLL) に類似</span><span class="sxs-lookup"><span data-stu-id="7c9a8-135">Close to **CoInitializeEx** (OLE32.DLL)</span></span>|<xref:System.Threading.Thread.ApartmentState%2A?displayProperty=nameWithType>|  
  
## <a name="managed-threads-and-com-apartments"></a><span data-ttu-id="7c9a8-136">マネージ スレッドと COM アパートメント</span><span class="sxs-lookup"><span data-stu-id="7c9a8-136">Managed Threads and COM Apartments</span></span>  
 <span data-ttu-id="7c9a8-137">マネージ スレッドには、[シングル スレッド](https://msdn.microsoft.com/library/windows/desktop/ms680112.aspx) アパートメントをホストするか、[マルチ スレッド](https://msdn.microsoft.com/library/windows/desktop/ms693421.aspx) アパートメントをホストするかを示すようマークすることができます </span><span class="sxs-lookup"><span data-stu-id="7c9a8-137">A managed thread can be marked to indicate that it will host a [single-threaded](https://msdn.microsoft.com/library/windows/desktop/ms680112.aspx) or [multithreaded](https://msdn.microsoft.com/library/windows/desktop/ms693421.aspx) apartment.</span></span> <span data-ttu-id="7c9a8-138">(COM スレッド アーキテクチャの詳細については、「[プロセス、スレッド、アパートメント](https://msdn.microsoft.com/library/windows/desktop/ms693344.aspx)」を参照してください。)<xref:System.Threading.Thread.GetApartmentState%2A> クラスの <xref:System.Threading.Thread.SetApartmentState%2A>、<xref:System.Threading.Thread.TrySetApartmentState%2A>、および <xref:System.Threading.Thread> の各スレッドは、スレッドのアパートメント状態を返して割り当てます。</span><span class="sxs-lookup"><span data-stu-id="7c9a8-138">(For more information on the COM threading architecture, see [Processes, threads, and Apartments](https://msdn.microsoft.com/library/windows/desktop/ms693344.aspx).) The <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods of the <xref:System.Threading.Thread> class return and assign the apartment state of a thread.</span></span> <span data-ttu-id="7c9a8-139">状態が設定されていない場合、<xref:System.Threading.Thread.GetApartmentState%2A> は <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> を返します。</span><span class="sxs-lookup"><span data-stu-id="7c9a8-139">If the state has not been set, <xref:System.Threading.Thread.GetApartmentState%2A> returns <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="7c9a8-140">プロパティは、スレッドが <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> 状態の場合にのみ設定することができます。設定できるのは、1 つのスレッドにつき 1 回だけです。</span><span class="sxs-lookup"><span data-stu-id="7c9a8-140">The property can be set only when the thread is in the <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> state; it can be set only once for a thread.</span></span>  
  
 <span data-ttu-id="7c9a8-141">スレッド開始前にアパートメントの状態が設定されていない場合、このスレッドはマルチスレッド アパートメント (MTA) として初期化されます。</span><span class="sxs-lookup"><span data-stu-id="7c9a8-141">If the apartment state is not set before the thread is started, the thread is initialized as a multithreaded apartment (MTA).</span></span> <span data-ttu-id="7c9a8-142">ファイナライザー スレッドと、 <xref:System.Threading.ThreadPool> により制御されるすべてのスレッドは MTA です。</span><span class="sxs-lookup"><span data-stu-id="7c9a8-142">The finalizer thread and all threads controlled by <xref:System.Threading.ThreadPool> are MTA.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="7c9a8-143">アプリケーションのスタートアップ コードでは、アパートメントの状態を制御する方法は、 <xref:System.MTAThreadAttribute> または <xref:System.STAThreadAttribute> をエントリ ポイント プロシージャに適用する方法だけです。</span><span class="sxs-lookup"><span data-stu-id="7c9a8-143">For application startup code, the only way to control apartment state is to apply the <xref:System.MTAThreadAttribute> or the <xref:System.STAThreadAttribute> to the entry point procedure.</span></span> <span data-ttu-id="7c9a8-144">.NET Framework 1.0 と 1.1 では、 <xref:System.Threading.Thread.ApartmentState%2A> プロパティを最初のコード行として設定できます。</span><span class="sxs-lookup"><span data-stu-id="7c9a8-144">In the .NET Framework 1.0 and 1.1, the <xref:System.Threading.Thread.ApartmentState%2A> property can be set as the first line of code.</span></span> <span data-ttu-id="7c9a8-145">.NET Framework 2.0 ではこの設定は許可されていません。</span><span class="sxs-lookup"><span data-stu-id="7c9a8-145">This is not permitted in the .NET Framework 2.0.</span></span>  
  
 <span data-ttu-id="7c9a8-146">COM に対して公開されるマネージ オブジェクトは、フリー スレッド マーシャラーを集約した場合と同様に動作します。</span><span class="sxs-lookup"><span data-stu-id="7c9a8-146">Managed objects that are exposed to COM behave as if they had aggregated the free-threaded marshaler.</span></span> <span data-ttu-id="7c9a8-147">つまり、フリースレッドな方法ですべての COM アパートメントから呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="7c9a8-147">In other words, they can be called from any COM apartment in a free-threaded manner.</span></span> <span data-ttu-id="7c9a8-148">このフリー スレッドな動作を示さないマネージ オブジェクトは、<xref:System.EnterpriseServices.ServicedComponent> または <xref:System.Runtime.InteropServices.StandardOleMarshalObject> から派生したオブジェクトだけです。</span><span class="sxs-lookup"><span data-stu-id="7c9a8-148">The only managed objects that do not exhibit this free-threaded behavior are those objects that derive from <xref:System.EnterpriseServices.ServicedComponent> or <xref:System.Runtime.InteropServices.StandardOleMarshalObject>.</span></span>  
  
 <span data-ttu-id="7c9a8-149">マネージ環境では、コンテキストおよびコンテキストにバインディングされたインスタンスを使用しない場合には <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> はサポートされません。</span><span class="sxs-lookup"><span data-stu-id="7c9a8-149">In the managed world, there is no support for the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> unless you use contexts and context-bound managed instances.</span></span> <span data-ttu-id="7c9a8-150">Enterprise Services を使う場合は、オブジェクトを <xref:System.EnterpriseServices.ServicedComponent> (<xref:System.ContextBoundObject> から派生したオブジェクト) から派生する必要があります。</span><span class="sxs-lookup"><span data-stu-id="7c9a8-150">If you are using Enterprise Services, then your object must derive from <xref:System.EnterpriseServices.ServicedComponent> (which is itself derived from <xref:System.ContextBoundObject>).</span></span>  
  
 <span data-ttu-id="7c9a8-151">マネージ コードは、COM オブジェクトを呼び出すときには常に COM 規則に従います。</span><span class="sxs-lookup"><span data-stu-id="7c9a8-151">When managed code calls out to COM objects, it always follows COM rules.</span></span> <span data-ttu-id="7c9a8-152">つまり、OLE32 によって示される COM アパートメント プロキシと COM+ 1.0 コンテキスト ラッパーを介して呼び出します。</span><span class="sxs-lookup"><span data-stu-id="7c9a8-152">In other words, it calls through COM apartment proxies and COM+ 1.0 context wrappers as dictated by OLE32.</span></span>  
  
## <a name="blocking-issues"></a><span data-ttu-id="7c9a8-153">ブロッキングの問題</span><span class="sxs-lookup"><span data-stu-id="7c9a8-153">Blocking Issues</span></span>  
 <span data-ttu-id="7c9a8-154">アンマネージ コードでスレッドをブロックしているオペレーティング システムに対し、そのスレッドがアンマネージ呼び出しを実行する場合、ランタイムは <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> または <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> に対してその呼び出しを制御しません。</span><span class="sxs-lookup"><span data-stu-id="7c9a8-154">If a thread makes an unmanaged call into the operating system that has blocked the thread in unmanaged code, the runtime will not take control of it for <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> or <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="7c9a8-155"><xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> では、スレッドが再びマネージ コードに入ると、ランタイムはスレッドを **Abort** 対象としてマークし、スレッドを制御します。</span><span class="sxs-lookup"><span data-stu-id="7c9a8-155">In the case of <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>, the runtime marks the thread for **Abort** and takes control of it when it re-enters managed code.</span></span> <span data-ttu-id="7c9a8-156">アンマネージ ブロックではなくマネージ ブロックを使用することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="7c9a8-156">It is preferable for you to use managed blocking rather than unmanaged blocking.</span></span> <span data-ttu-id="7c9a8-157"><xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>、<xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType>、<xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType>、<xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>、<xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>、<xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType>、<xref:System.GC.WaitForPendingFinalizers%2A?displayProperty=nameWithType> などはすべて、<xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> と <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> に応答します。</span><span class="sxs-lookup"><span data-stu-id="7c9a8-157"><xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>,<xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType>, <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>, <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType>, <xref:System.GC.WaitForPendingFinalizers%2A?displayProperty=nameWithType>, and so on are all responsive to <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> and to <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="7c9a8-158">また、スレッドがシングルスレッド アパート内にある場合、これらのマネージ ブロック操作はすべて、スレッドがブロックされている間でもアパートメント内で正しくメッセージ ポンプを行います。</span><span class="sxs-lookup"><span data-stu-id="7c9a8-158">Also, if your thread is in a single-threaded apartment, all these managed blocking operations will correctly pump messages in your apartment while your thread is blocked.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="7c9a8-159">参照</span><span class="sxs-lookup"><span data-stu-id="7c9a8-159">See Also</span></span>  
 <xref:System.Threading.Thread.ApartmentState%2A?displayProperty=nameWithType>  
 <xref:System.Threading.ThreadState>  
 <xref:System.EnterpriseServices.ServicedComponent>  
 <xref:System.Threading.Thread>  
 <xref:System.Threading.Monitor>
