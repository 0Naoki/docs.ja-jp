---
title: '方法: JoinBlock を使用して複数のソースからデータを読み込む'
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Task Parallel Library, dataflows
- TPL dataflow library, joining blocks in
- dataflow blocks, joining in TPL
ms.assetid: e9c1ada4-ac57-4704-87cb-2f5117f8151d
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: bd00c91daf2811ecba01b77d51a74740027ced5e
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/04/2018
---
# <a name="how-to-use-joinblock-to-read-data-from-multiple-sources"></a><span data-ttu-id="bbd36-102">方法: JoinBlock を使用して複数のソースからデータを読み込む</span><span class="sxs-lookup"><span data-stu-id="bbd36-102">How to: Use JoinBlock to Read Data From Multiple Sources</span></span>
<span data-ttu-id="bbd36-103">このドキュメントでは、複数のソースからデータを使用できるときに <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> クラスを使用して操作を実行する方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="bbd36-103">This document explains how to use the <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> class to perform an operation when data is available from multiple sources.</span></span> <span data-ttu-id="bbd36-104">また、最短一致モードを使い、複数の結合ブロックを有効にして、データ ソースをより効率的に共有する方法についても説明します。</span><span class="sxs-lookup"><span data-stu-id="bbd36-104">It also demonstrates how to use non-greedy mode to enable multiple join blocks to share a data source more efficiently.</span></span>

[!INCLUDE [tpl-install-instructions](../../../includes/tpl-install-instructions.md)]

## <a name="example"></a><span data-ttu-id="bbd36-105">例</span><span class="sxs-lookup"><span data-stu-id="bbd36-105">Example</span></span>  
 <span data-ttu-id="bbd36-106">次の例では、3 つのリソースの種類 (`NetworkResource`、`FileResource`、および `MemoryResource`) を定義し、リソースが使用できるようになったときに操作を実行します。</span><span class="sxs-lookup"><span data-stu-id="bbd36-106">The following example defines three resource types, `NetworkResource`, `FileResource`, and `MemoryResource`, and performs operations when resources become available.</span></span> <span data-ttu-id="bbd36-107">この例では、最初の操作を実行するために `NetworkResource` と `MemoryResource` のペアが必要であり、2 番目の操作を実行するために `FileResource` と `MemoryResource` のペアが必要です。</span><span class="sxs-lookup"><span data-stu-id="bbd36-107">This example requires a `NetworkResource` and `MemoryResource` pair in order to perform the first operation and a `FileResource` and `MemoryResource` pair in order to perform the second operation.</span></span> <span data-ttu-id="bbd36-108">必要なすべてのリソースを使用できるようになったときにこれらの操作を実行できるようにするために、この例では <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> クラスを使用します。</span><span class="sxs-lookup"><span data-stu-id="bbd36-108">To enable these operations to occur when all required resources are available, this example uses the <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> class.</span></span> <span data-ttu-id="bbd36-109"><xref:System.Threading.Tasks.Dataflow.JoinBlock%602> オブジェクトがすべてのソースからデータを受け取ると、そのデータをターゲット (この例では <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> オブジェクト) に伝達します。</span><span class="sxs-lookup"><span data-stu-id="bbd36-109">When a <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> object receives data from all sources, it propagates that data to its target, which in this example is an <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> object.</span></span> <span data-ttu-id="bbd36-110">どちらの <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> オブジェクトも `MemoryResource` オブジェクトの共有プールから読み取ります。</span><span class="sxs-lookup"><span data-stu-id="bbd36-110">Both <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> objects read from a shared pool of `MemoryResource` objects.</span></span>  
  
 [!code-csharp[TPLDataflow_NonGreedyJoin#1](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_nongreedyjoin/cs/nongreedyjoin.cs#1)]
 [!code-vb[TPLDataflow_NonGreedyJoin#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_nongreedyjoin/vb/nongreedyjoin.vb#1)]  
  
 <span data-ttu-id="bbd36-111">`MemoryResource` オブジェクトの共有プールを効率的に使用するために、この例では、<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> プロパティを `False` に設定した <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions> オブジェクトを指定して、最短一致モードで動作する <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> オブジェクトを作成します。</span><span class="sxs-lookup"><span data-stu-id="bbd36-111">To enable efficient use of the shared pool of `MemoryResource` objects, this example specifies a <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions> object that has the <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> property set to `False` to create <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> objects that act in non-greedy mode.</span></span> <span data-ttu-id="bbd36-112">最短一致の結合ブロックの場合、各ソースから使用できるようになるまで、すべての受信メッセージは延期されます。</span><span class="sxs-lookup"><span data-stu-id="bbd36-112">A non-greedy join block postpones all incoming messages until one is available from each source.</span></span> <span data-ttu-id="bbd36-113">延期されたメッセージのいずれかが別のブロックで受け入れられた場合、結合ブロックはプロセスを再開します。</span><span class="sxs-lookup"><span data-stu-id="bbd36-113">If any of the postponed messages were accepted by another block, the join block restarts the process.</span></span> <span data-ttu-id="bbd36-114">最短一致モードでは、1 つ以上のソース ブロックを共有する結合ブロックが、他のブロックがデータを待機するときに転送を進めることができます。</span><span class="sxs-lookup"><span data-stu-id="bbd36-114">Non-greedy mode enables join blocks that share one or more source blocks to make forward progress as the other blocks wait for data.</span></span> <span data-ttu-id="bbd36-115">この例では、`MemoryResource` オブジェクトが `memoryResources` プールに追加された場合、その 2 番目のデータ ソースを受け取る最初の結合ブロックが転送を進めることができます。</span><span class="sxs-lookup"><span data-stu-id="bbd36-115">In this example, if a `MemoryResource` object is added to the `memoryResources` pool, the first join block to receive its second data source can make forward progress.</span></span> <span data-ttu-id="bbd36-116">この例で、既定である最長一致モードを使用する場合、1 つの結合ブロックが `MemoryResource` オブジェクトを受け取り、2 番目のリソースを使用できるようになるまで待機することができます。</span><span class="sxs-lookup"><span data-stu-id="bbd36-116">If this example were to use greedy mode, which is the default, one join block might take the `MemoryResource` object and wait for the second resource to become available.</span></span> <span data-ttu-id="bbd36-117">ただし、他の結合ブロックに使用できる 2 番目のデータ ソースがある場合は、`MemoryResource` オブジェクトが他の結合ブロックによって取得されているため、転送を進めることはできません。</span><span class="sxs-lookup"><span data-stu-id="bbd36-117">However, if the other join block has its second data source available, it cannot make forward progress because the `MemoryResource` object has been taken by the other join block.</span></span>  
  
## <a name="compiling-the-code"></a><span data-ttu-id="bbd36-118">コードのコンパイル</span><span class="sxs-lookup"><span data-stu-id="bbd36-118">Compiling the Code</span></span>  
 <span data-ttu-id="bbd36-119">コード例をコピーし、Visual Studio プロジェクトに貼り付けるか、`DataflowNonGreedyJoin.cs` (Visual Basic では `DataflowNonGreedyJoin.vb`) という名前のファイルに貼り付けてから、Visual Studio のコマンド プロンプト ウィンドウで次のコマンドを実行します。</span><span class="sxs-lookup"><span data-stu-id="bbd36-119">Copy the example code and paste it in a Visual Studio project, or paste it in a file that is named `DataflowNonGreedyJoin.cs` (`DataflowNonGreedyJoin.vb` for Visual Basic), and then run the following command in a Visual Studio Command Prompt window.</span></span>  
  
 <span data-ttu-id="bbd36-120">Visual C#</span><span class="sxs-lookup"><span data-stu-id="bbd36-120">Visual C#</span></span>  
  
 <span data-ttu-id="bbd36-121">**csc.exe /r:System.Threading.Tasks.Dataflow.dll DataflowNonGreedyJoin.cs**</span><span class="sxs-lookup"><span data-stu-id="bbd36-121">**csc.exe /r:System.Threading.Tasks.Dataflow.dll DataflowNonGreedyJoin.cs**</span></span>  
  
 <span data-ttu-id="bbd36-122">Visual Basic</span><span class="sxs-lookup"><span data-stu-id="bbd36-122">Visual Basic</span></span>  
  
 <span data-ttu-id="bbd36-123">**vbc.exe /r:System.Threading.Tasks.Dataflow.dll DataflowNonGreedyJoin.vb**</span><span class="sxs-lookup"><span data-stu-id="bbd36-123">**vbc.exe /r:System.Threading.Tasks.Dataflow.dll DataflowNonGreedyJoin.vb**</span></span>  
  
## <a name="robust-programming"></a><span data-ttu-id="bbd36-124">信頼性の高いプログラミング</span><span class="sxs-lookup"><span data-stu-id="bbd36-124">Robust Programming</span></span>  
 <span data-ttu-id="bbd36-125">最短一致の結合を使用すると、アプリケーションのデッドロックを防ぐのにも役立ちます。</span><span class="sxs-lookup"><span data-stu-id="bbd36-125">The use of non-greedy joins can also help you prevent deadlock in your application.</span></span> <span data-ttu-id="bbd36-126">ソフトウェア アプリケーションで、2 つ以上のプロセスがそれぞれリソースを確保し、別のプロセスがリソースを解放するのをお互いに待機すると、*デッドロック*が発生します。</span><span class="sxs-lookup"><span data-stu-id="bbd36-126">In a software application, *deadlock* occurs when two or more processes each hold a resource and mutually wait for another process to release some other resource.</span></span> <span data-ttu-id="bbd36-127">2 つの <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> オブジェクトを定義するアプリケーションを考えてみましょう。</span><span class="sxs-lookup"><span data-stu-id="bbd36-127">Consider an application that defines two <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> objects.</span></span> <span data-ttu-id="bbd36-128">両方のオブジェクトは、それぞれ 2 つの共有ソース ブロックからデータを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="bbd36-128">Both objects each read data from two shared source blocks.</span></span> <span data-ttu-id="bbd36-129">最長一致モードでは、一方の結合ブロックが最初のソースから読み取り、もう一方の結合ブロックが 2 番目のソースから読み取る場合、どちらの結合ブロックも他方がリソースを解放するまで待機するため、アプリケーションがデッドロックする可能性があります。</span><span class="sxs-lookup"><span data-stu-id="bbd36-129">In greedy mode, if one join block reads from the first source and the second join block reads from the second source, the application might deadlock because both join blocks mutually wait for the other to release its resource.</span></span> <span data-ttu-id="bbd36-130">最短一致モードの場合、各結合ブロックは、すべてのデータを使用できる場合にのみソースから読み取ります。そのため、デッドロックのリスクはなくなります。</span><span class="sxs-lookup"><span data-stu-id="bbd36-130">In non-greedy mode, each join block reads from its sources only when all data is available, and therefore, the risk of deadlock is eliminated.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="bbd36-131">参照</span><span class="sxs-lookup"><span data-stu-id="bbd36-131">See Also</span></span>  
 [<span data-ttu-id="bbd36-132">データフロー</span><span class="sxs-lookup"><span data-stu-id="bbd36-132">Dataflow</span></span>](../../../docs/standard/parallel-programming/dataflow-task-parallel-library.md)
