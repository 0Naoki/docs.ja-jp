---
title: "PLINQ および TPL 用のカスタム パーティショナー"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords: tasks, partitioners
ms.assetid: 96153688-9a01-47c4-8430-909cee9a2887
caps.latest.revision: "19"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: 12d234b86b0067178d54d2fdcb5d37ceaee6109d
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/21/2017
---
# <a name="custom-partitioners-for-plinq-and-tpl"></a><span data-ttu-id="be5d3-102">PLINQ および TPL 用のカスタム パーティショナー</span><span class="sxs-lookup"><span data-stu-id="be5d3-102">Custom Partitioners for PLINQ and TPL</span></span>
<span data-ttu-id="be5d3-103">データ ソースでの操作を並列化の重要な手順のいずれかを*パーティション*ソースを複数のセクションでは複数のスレッドで同時にアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="be5d3-103">To parallelize an operation on a data source, one of the essential steps is to *partition* the source into multiple sections that can be accessed concurrently by multiple threads.</span></span> <span data-ttu-id="be5d3-104">PLINQ およびタスク並列ライブラリ (TPL) は、並列クエリを記述する場合に透過的に機能する既定のパーティションを提供または<xref:System.Threading.Tasks.Parallel.ForEach%2A>ループします。</span><span class="sxs-lookup"><span data-stu-id="be5d3-104">PLINQ and the Task Parallel Library (TPL) provide default partitioners that work transparently when you write a parallel query or <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop.</span></span> <span data-ttu-id="be5d3-105">高度なシナリオは、独自のパーティショナーで接続できます。</span><span class="sxs-lookup"><span data-stu-id="be5d3-105">For more advanced scenarios, you can plug in your own partitioner.</span></span>  
  
## <a name="kinds-of-partitioning"></a><span data-ttu-id="be5d3-106">パーティション分割の種類</span><span class="sxs-lookup"><span data-stu-id="be5d3-106">Kinds of Partitioning</span></span>  
 <span data-ttu-id="be5d3-107">さまざまな方法でデータ ソースのパーティションがあります。</span><span class="sxs-lookup"><span data-stu-id="be5d3-107">There are many ways to partition a data source.</span></span> <span data-ttu-id="be5d3-108">複数のスレッドが複数のサブシーケンスにソースを物理的に分離するのではなく、プロセス、元のソース シーケンスに連携して、最も効率的な方法では、します。</span><span class="sxs-lookup"><span data-stu-id="be5d3-108">In the most efficient approaches, multiple threads cooperate to process the original source sequence, rather than physically separating the source into multiple subsequences.</span></span> <span data-ttu-id="be5d3-109">配列、およびその他のインデックス化されたソースなど<xref:System.Collections.IList>コレクションの長さがあらかじめわかっている*範囲パーティション分割*は最も単純な種類のパーティション分割します。</span><span class="sxs-lookup"><span data-stu-id="be5d3-109">For arrays and other indexed sources such as <xref:System.Collections.IList> collections where the length is known in advance, *range partitioning* is the simplest kind of partitioning.</span></span> <span data-ttu-id="be5d3-110">すべてのスレッドでは、ソースの範囲を上書きするか、他のスレッドによって上書きされることがなく処理できるように一意の開始と終了時刻、インデックスを受け取ります。</span><span class="sxs-lookup"><span data-stu-id="be5d3-110">Every thread receives unique beginning and ending indexes, so that it can process its range of the source without overwriting or being overwritten by any other thread.</span></span> <span data-ttu-id="be5d3-111">範囲パーティション分割に関連するオーバーヘッドが初期の作業の範囲を作成します。追加の同期は必要ありませんにします。</span><span class="sxs-lookup"><span data-stu-id="be5d3-111">The only overhead involved in range partitioning is the initial work of creating the ranges; no additional synchronization is required after that.</span></span> <span data-ttu-id="be5d3-112">そのため、作業負荷が均等に限り、良好なパフォーマンスを実現できます。</span><span class="sxs-lookup"><span data-stu-id="be5d3-112">Therefore, it can provide good performance as long as the workload is divided evenly.</span></span> <span data-ttu-id="be5d3-113">範囲パーティション分割の欠点は、1 つのスレッドが早く終了した場合は、他のスレッドの作業を完了を支援ことできませんです。</span><span class="sxs-lookup"><span data-stu-id="be5d3-113">A disadvantage of range partitioning is that if one thread finishes early, it cannot help the other threads finish their work.</span></span>  
  
 <span data-ttu-id="be5d3-114">リンク リストまたは他のコレクションの長さが不明の場合は、使用することができます*チャンクがパーティション分割*です。</span><span class="sxs-lookup"><span data-stu-id="be5d3-114">For linked lists or other collections whose length is not known, you can use *chunk partitioning*.</span></span> <span data-ttu-id="be5d3-115">チャンクがパーティション分割のすべてのスレッドまたはタスクを並列ループまたはクエリでいくつかの 1 つのチャンクでソース要素を使用、それらを処理返ってくると、追加の要素を取得します。</span><span class="sxs-lookup"><span data-stu-id="be5d3-115">In chunk partitioning, every thread or task in a parallel loop or query consumes some number of source elements in one chunk, processes them, and then comes back to retrieve additional elements.</span></span> <span data-ttu-id="be5d3-116">パーティショナーは、すべての要素が分散されると、重複がないようにします。</span><span class="sxs-lookup"><span data-stu-id="be5d3-116">The partitioner ensures that all elements are distributed and that there are no duplicates.</span></span> <span data-ttu-id="be5d3-117">チャンクのサイズがあります。</span><span class="sxs-lookup"><span data-stu-id="be5d3-117">A chunk may be any size.</span></span> <span data-ttu-id="be5d3-118">説明されているパーティショナーなど[する方法: 実装の動的なパーティション](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)1 つだけの要素が含まれているチャンクを作成します。</span><span class="sxs-lookup"><span data-stu-id="be5d3-118">For example, the partitioner that is demonstrated in [How to: Implement Dynamic Partitions](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md) creates chunks that contain just one element.</span></span> <span data-ttu-id="be5d3-119">チャンクが大きすぎていない限り、この種類のパーティション分割は本質的に負荷分散のスレッドに要素の割り当てがあらかじめ決定されないためです。</span><span class="sxs-lookup"><span data-stu-id="be5d3-119">As long as the chunks are not too large, this kind of partitioning is inherently load-balancing because the assignment of elements to threads is not pre-determined.</span></span> <span data-ttu-id="be5d3-120">ただし、パーティショナーはオーバーヘッドが増加する、同期、スレッドが別のチャンクを取得するたびにします。</span><span class="sxs-lookup"><span data-stu-id="be5d3-120">However, the partitioner does incur the synchronization overhead each time the thread needs to get another chunk.</span></span> <span data-ttu-id="be5d3-121">このような場合に発生する同期の量は、チャンクのサイズに反比例します。</span><span class="sxs-lookup"><span data-stu-id="be5d3-121">The amount of synchronization incurred in these cases is inversely proportional to the size of the chunks.</span></span>  
  
 <span data-ttu-id="be5d3-122">一般に、range パーティション分割は高速な場合にのみ、デリゲートの実行時間な小規模から中、ソースが多数の要素、および各パーティションの合計作業時間はほぼ同等です。</span><span class="sxs-lookup"><span data-stu-id="be5d3-122">In general, range partitioning is only faster when the execution time of the delegate is small to moderate, and the source has a large number of elements, and the total work of each partition is roughly equivalent.</span></span> <span data-ttu-id="be5d3-123">チャンクがパーティション分割は、ほとんどの場合、一般に高速ではこのためです。</span><span class="sxs-lookup"><span data-stu-id="be5d3-123">Chunk partitioning is therefore generally faster in most cases.</span></span> <span data-ttu-id="be5d3-124">少数の要素またはデリゲートの実行時間が長いと、ソース、チャンクと範囲パーティション分割のパフォーマンスはほぼ同じです。</span><span class="sxs-lookup"><span data-stu-id="be5d3-124">On sources with a small number of elements or longer execution times for the delegate, then the performance of chunk and range partitioning is about equal.</span></span>  
  
 <span data-ttu-id="be5d3-125">TPL パーティショナーでは、パーティションの数が動的もサポートします。</span><span class="sxs-lookup"><span data-stu-id="be5d3-125">The TPL partitioners also support a dynamic number of partitions.</span></span> <span data-ttu-id="be5d3-126">つまり、たとえばパーティション上の実行時を作成できる場合、<xref:System.Threading.Tasks.Parallel.ForEach%2A>ループは新しいタスクを生成します。</span><span class="sxs-lookup"><span data-stu-id="be5d3-126">This means they can create partitions on-the-fly, for example, when the <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop spawns a new task.</span></span> <span data-ttu-id="be5d3-127">この機能は、ループ自体と共にスケール パーティショナーを使用します。</span><span class="sxs-lookup"><span data-stu-id="be5d3-127">This feature enables the partitioner to scale together with the loop itself.</span></span> <span data-ttu-id="be5d3-128">動的パーティショナーも本質的に負荷分散できます。</span><span class="sxs-lookup"><span data-stu-id="be5d3-128">Dynamic partitioners are also inherently load-balancing.</span></span> <span data-ttu-id="be5d3-129">カスタム パーティショナーを作成するときにから使用できるようにする動的なパーティショニングをサポートする必要があります、<xref:System.Threading.Tasks.Parallel.ForEach%2A>ループします。</span><span class="sxs-lookup"><span data-stu-id="be5d3-129">When you create a custom partitioner, you must support dynamic partitioning to be consumable from a <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop.</span></span>  
  
### <a name="configuring-load-balancing-partitioners-for-plinq"></a><span data-ttu-id="be5d3-130">負荷分散の PLINQ パーティショナーを構成します。</span><span class="sxs-lookup"><span data-stu-id="be5d3-130">Configuring Load Balancing Partitioners for PLINQ</span></span>  
 <span data-ttu-id="be5d3-131">一部のオーバー ロード、<xref:System.Collections.Concurrent.Partitioner.Create%2A?displayProperty=nameWithType>メソッドでは、配列の場合、パーティショナーを作成できます。 または<xref:System.Collections.IList>ソースと、スレッド間でワークロードのバランスをとるしようとする必要がありますかどうかを指定します。</span><span class="sxs-lookup"><span data-stu-id="be5d3-131">Some overloads of the <xref:System.Collections.Concurrent.Partitioner.Create%2A?displayProperty=nameWithType> method let you create a partitioner for an array or <xref:System.Collections.IList> source and specify whether it should attempt to balance the workload among the threads.</span></span> <span data-ttu-id="be5d3-132">パーティショナーを負荷分散を構成する場合は、チャンクがパーティション分割を使用すると、し、要素に渡されます小さいチャンク内の各パーティションには要求に応じてします。</span><span class="sxs-lookup"><span data-stu-id="be5d3-132">When the partitioner is configured to load-balance, chunk partitioning is used, and the elements are handed off to each partition in small chunks as they are requested.</span></span> <span data-ttu-id="be5d3-133">これにより、すべてのパーティションがまでループ全体を処理する要素を持つクエリが完了することを確認します。</span><span class="sxs-lookup"><span data-stu-id="be5d3-133">This approach helps ensure that all partitions have elements to process until the entire loop or query is completed.</span></span> <span data-ttu-id="be5d3-134">負荷分散のいずれかのパーティション分割を提供するその他のオーバー ロードを使用できます<xref:System.Collections.IEnumerable>ソース。</span><span class="sxs-lookup"><span data-stu-id="be5d3-134">An additional overload can be used to provide load-balancing partitioning of any <xref:System.Collections.IEnumerable> source.</span></span>  
  
 <span data-ttu-id="be5d3-135">一般に、負荷分散には、要素を要求する比較的多くの場合、パーティショナーからパーティションが必要です。</span><span class="sxs-lookup"><span data-stu-id="be5d3-135">In general, load balancing requires the partitions to request elements relatively frequently from the partitioner.</span></span> <span data-ttu-id="be5d3-136">これに対し、静的パーティション分割を実行するパーティショナーで割り当てることができます要素各パーティショナーを一度にすべての範囲またはチャンクがパーティション分割を使用しています。</span><span class="sxs-lookup"><span data-stu-id="be5d3-136">By contrast, a partitioner that does static partitioning can assign the elements to each partitioner all at once by using either range or chunk partitioning.</span></span> <span data-ttu-id="be5d3-137">負荷分散よりも少ないオーバーヘッドが必要ですが、1 つのスレッドが他よりもはるかに多くの作業終了した場合の実行に長い時間がかかる場合があります。</span><span class="sxs-lookup"><span data-stu-id="be5d3-137">This requires less overhead than load balancing, but it might take longer to execute if one thread ends up with significantly more work than the others.</span></span> <span data-ttu-id="be5d3-138">既定では IList または、配列が渡される PLINQ 常に範囲パーティション分割を使用せず、負荷分散します。</span><span class="sxs-lookup"><span data-stu-id="be5d3-138">By default when it is passed an IList or an array, PLINQ always uses range partitioning without load balancing.</span></span> <span data-ttu-id="be5d3-139">PLINQ の負荷分散を有効にするを使用して、`Partitioner.Create`メソッドを次の例で示すようにします。</span><span class="sxs-lookup"><span data-stu-id="be5d3-139">To enable load balancing for PLINQ, use the `Partitioner.Create` method, as shown in the following example.</span></span>  
  
 [!code-csharp[TPL_Partitioners#02](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_partitioners/cs/partitioners.cs#02)]
 [!code-vb[TPL_Partitioners#02](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_partitioners/vb/partitionsnippets_vb.vb#02)]  
  
 <span data-ttu-id="be5d3-140">かどうかをロードを使用する、特定のシナリオで分散テストし、代表的な負荷とコンピューターの構成を完了する操作に要する時間を測定する最善の方法です。</span><span class="sxs-lookup"><span data-stu-id="be5d3-140">The best way to determine whether to use load balancing in any given scenario is to experiment and measure how long it takes operations to complete under representative loads and computer configurations.</span></span> <span data-ttu-id="be5d3-141">たとえば、静的パーティション分割が飛躍的に向上するいくつかのコアだけをあるマルチコア コンピューター上でが速度低下を比較的多くのコアを持つコンピューター上になることがあります。</span><span class="sxs-lookup"><span data-stu-id="be5d3-141">For example, static partitioning might provide significant speedup on a multi-core computer that has only a few cores, but it might result in slowdowns on computers that have relatively many cores.</span></span>  
  
 <span data-ttu-id="be5d3-142">次の表の使用可能なオーバー ロード、<xref:System.Collections.Concurrent.Partitioner.Create%2A>メソッドです。</span><span class="sxs-lookup"><span data-stu-id="be5d3-142">The following table lists the available overloads of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> method.</span></span> <span data-ttu-id="be5d3-143">これらのできるパーティショナーが PLINQ でのみ使用するだけではありませんか<xref:System.Threading.Tasks.Task>です。</span><span class="sxs-lookup"><span data-stu-id="be5d3-143">These partitioners are not limited to use only with PLINQ or <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="be5d3-144">また、任意のカスタム parallel コンストラクトにも使用できます。</span><span class="sxs-lookup"><span data-stu-id="be5d3-144">They can also be used with any custom parallel construct.</span></span>  
  
|<span data-ttu-id="be5d3-145">オーバー ロード</span><span class="sxs-lookup"><span data-stu-id="be5d3-145">Overload</span></span>|<span data-ttu-id="be5d3-146">使用して負荷分散</span><span class="sxs-lookup"><span data-stu-id="be5d3-146">Uses load balancing</span></span>|  
|--------------|-------------------------|  
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>|<span data-ttu-id="be5d3-147">Always</span><span class="sxs-lookup"><span data-stu-id="be5d3-147">Always</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28%60%600%5B%5D%2CSystem.Boolean%29>|<span data-ttu-id="be5d3-148">ブール型の引数が true として指定されている場合</span><span class="sxs-lookup"><span data-stu-id="be5d3-148">When the Boolean argument is specified as true</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28System.Collections.Generic.IList%7B%60%600%7D%2CSystem.Boolean%29>|<span data-ttu-id="be5d3-149">ブール型の引数が true として指定されている場合</span><span class="sxs-lookup"><span data-stu-id="be5d3-149">When the Boolean argument is specified as true</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int32%2CSystem.Int32%29>|<span data-ttu-id="be5d3-150">Never</span><span class="sxs-lookup"><span data-stu-id="be5d3-150">Never</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int32%2CSystem.Int32%2CSystem.Int32%29>|<span data-ttu-id="be5d3-151">Never</span><span class="sxs-lookup"><span data-stu-id="be5d3-151">Never</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int64%2CSystem.Int64%29>|<span data-ttu-id="be5d3-152">Never</span><span class="sxs-lookup"><span data-stu-id="be5d3-152">Never</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int64%2CSystem.Int64%2CSystem.Int64%29>|<span data-ttu-id="be5d3-153">Never</span><span class="sxs-lookup"><span data-stu-id="be5d3-153">Never</span></span>|  
  
### <a name="configuring-static-range-partitioners-for-parallelforeach"></a><span data-ttu-id="be5d3-154">Parallel.ForEach の静的範囲パーティショナーを構成します。</span><span class="sxs-lookup"><span data-stu-id="be5d3-154">Configuring Static Range Partitioners for Parallel.ForEach</span></span>  
 <span data-ttu-id="be5d3-155"><xref:System.Threading.Tasks.Parallel.For%2A>ループ、ループの本体が代理人としてメソッドを提供します。</span><span class="sxs-lookup"><span data-stu-id="be5d3-155">In a <xref:System.Threading.Tasks.Parallel.For%2A> loop, the body of the loop is provided to the method as a delegate.</span></span> <span data-ttu-id="be5d3-156">デリゲートを呼び出すのコストは、仮想メソッドの呼び出しとほぼ同じです。</span><span class="sxs-lookup"><span data-stu-id="be5d3-156">The cost of invoking that delegate is about the same as a virtual method call.</span></span> <span data-ttu-id="be5d3-157">一部のシナリオでは、並列ループの本体が小さい各ループ反復でデリゲートの呼び出しのコストが大幅になる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="be5d3-157">In some scenarios, the body of a parallel loop might be small enough that the cost of the delegate invocation on each loop iteration becomes significant.</span></span> <span data-ttu-id="be5d3-158">このような状況のいずれかを使用できる、<xref:System.Collections.Concurrent.Partitioner.Create%2A>オーバー ロードを作成する、<xref:System.Collections.Generic.IEnumerable%601>ソース要素の上の範囲パーティションのです。</span><span class="sxs-lookup"><span data-stu-id="be5d3-158">In such situations, you can use one of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> overloads to create an <xref:System.Collections.Generic.IEnumerable%601> of range partitions over the source elements.</span></span> <span data-ttu-id="be5d3-159">次に、この範囲のコレクションを渡すことができます、<xref:System.Threading.Tasks.Parallel.ForEach%2A>メソッド本体を持つ、通常から成る`for`ループします。</span><span class="sxs-lookup"><span data-stu-id="be5d3-159">Then, you can pass this collection of ranges to a <xref:System.Threading.Tasks.Parallel.ForEach%2A> method whose body consists of a regular `for` loop.</span></span> <span data-ttu-id="be5d3-160">この方法の利点は、デリゲートを呼び出すコストが、範囲ごとではなく、一度に 1 つの要素 1 回だけ発生することです。</span><span class="sxs-lookup"><span data-stu-id="be5d3-160">The benefit of this approach is that the delegate invocation cost is incurred only once per range, rather than once per element.</span></span> <span data-ttu-id="be5d3-161">次の例では、基本的なパターンを示します。</span><span class="sxs-lookup"><span data-stu-id="be5d3-161">The following example demonstrates the basic pattern.</span></span>  
  
 [!code-csharp[TPL_Partitioners#01](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_partitioners/cs/partitioner01.cs#01)]
 [!code-vb[TPL_Partitioners#01](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_partitioners/vb/partitionercreate01.vb#01)]  
  
 <span data-ttu-id="be5d3-162">ループ内のすべてのスレッドが受け取る独自<xref:System.Tuple%602>最初と最後の指定されたサブ範囲のインデックス値を格納しています。</span><span class="sxs-lookup"><span data-stu-id="be5d3-162">Every thread in the loop receives its own <xref:System.Tuple%602> that contains the starting and ending index values in the specified sub-range.</span></span> <span data-ttu-id="be5d3-163">内部`for`ループには、`fromInclusive`と`toExclusive`にループ、配列値または<xref:System.Collections.IList>直接です。</span><span class="sxs-lookup"><span data-stu-id="be5d3-163">The inner `for` loop uses the `fromInclusive` and `toExclusive` values to loop over the array or the <xref:System.Collections.IList> directly.</span></span>  
  
 <span data-ttu-id="be5d3-164">1 つ、<xref:System.Collections.Concurrent.Partitioner.Create%2A>オーバー ロードでは、パーティション、およびパーティションの数のサイズを指定することができます。</span><span class="sxs-lookup"><span data-stu-id="be5d3-164">One of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> overloads lets you specify the size of the partitions, and the number of partitions.</span></span> <span data-ttu-id="be5d3-165">このオーバー ロードは、要素ごとの作業が 1 つの要素の 1 つでも仮想メソッドの呼び出しがパフォーマンスに大きな影響を及ぼしますがかなり低いシナリオで使用できます。</span><span class="sxs-lookup"><span data-stu-id="be5d3-165">This overload can be used in scenarios where the work per element is so low that even one virtual method call per element has a noticeable impact on performance.</span></span>  
  
## <a name="custom-partitioners"></a><span data-ttu-id="be5d3-166">カスタム パーティショナー</span><span class="sxs-lookup"><span data-stu-id="be5d3-166">Custom Partitioners</span></span>  
 <span data-ttu-id="be5d3-167">一部のシナリオで意義またはであっても、独自のパーティショナーを実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="be5d3-167">In some scenarios, it might be worthwhile or even required to implement your own partitioner.</span></span> <span data-ttu-id="be5d3-168">たとえば、既定のクラスの内部構造の知識に基づいてパーティショナー設定できるより効率的に分割するカスタム コレクション クラスがあります。</span><span class="sxs-lookup"><span data-stu-id="be5d3-168">For example, you might have a custom collection class that you can partition more efficiently than the default partitioners can, based on your knowledge of the internal structure of the class.</span></span> <span data-ttu-id="be5d3-169">または、ソース コレクション内の異なる場所にある要素を処理する時間の知識に基づいてさまざまなサイズの範囲パーティションを作成することがあります。</span><span class="sxs-lookup"><span data-stu-id="be5d3-169">Or, you may want to create range partitions of varying sizes based on your knowledge of how long it will take to process elements at different locations in the source collection.</span></span>  
  
 <span data-ttu-id="be5d3-170">基本的なカスタム パーティショナーを作成するには、派生クラスを<xref:System.Collections.Concurrent.Partitioner%601?displayProperty=nameWithType>し、次の表に示すように、仮想メソッドをオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="be5d3-170">To create a basic custom partitioner, derive a class from <xref:System.Collections.Concurrent.Partitioner%601?displayProperty=nameWithType> and override the virtual methods, as described in the following table.</span></span>  
  
|||  
|-|-|  
|<xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>|<span data-ttu-id="be5d3-171">このメソッドは、メイン スレッドによって 1 回呼び出され、IList(IEnumerator(TSource)) を返します。</span><span class="sxs-lookup"><span data-stu-id="be5d3-171">This method is called once by the main thread and returns an IList(IEnumerator(TSource)).</span></span> <span data-ttu-id="be5d3-172">ループまたはクエリでは、各ワーカー スレッドを呼び出すことができます`GetEnumerator`を取得する一覧で、<xref:System.Collections.Generic.IEnumerator%601>個別のパーティション上でします。</span><span class="sxs-lookup"><span data-stu-id="be5d3-172">Each worker thread in the loop or query can call `GetEnumerator` on the list to retrieve a <xref:System.Collections.Generic.IEnumerator%601> over a distinct partition.</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="be5d3-173">返す`true`を実装する場合<xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>、それ以外の場合、`false`です。</span><span class="sxs-lookup"><span data-stu-id="be5d3-173">Return `true` if you implement <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, otherwise, `false`.</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>|<span data-ttu-id="be5d3-174">場合<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>は`true`、このメソッドは、の代わりに必要に応じて呼び出すことができる<xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>です。</span><span class="sxs-lookup"><span data-stu-id="be5d3-174">If <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> is `true`, this method can optionally be called instead of <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span></span>|  
  
 <span data-ttu-id="be5d3-175">結果は並べ替え可能なである必要があります、またはインデックス付きのアクセスを必要な要素から派生し、<xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType>次の表に示すように、仮想メソッドをオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="be5d3-175">If the results must be sortable or you require indexed access into the elements, then derive from <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> and override its virtual methods as described in the following table.</span></span>  
  
|||  
|-|-|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetPartitions%2A>|<span data-ttu-id="be5d3-176">このメソッドは、メイン スレッドによって 1 回呼び出されるを返します、`IList(IEnumerator(TSource))`です。</span><span class="sxs-lookup"><span data-stu-id="be5d3-176">This method is called once by the main thread and returns an `IList(IEnumerator(TSource))`.</span></span> <span data-ttu-id="be5d3-177">ループまたはクエリでは、各ワーカー スレッドを呼び出すことができます`GetEnumerator`を取得する一覧で、<xref:System.Collections.Generic.IEnumerator%601>個別のパーティション上でします。</span><span class="sxs-lookup"><span data-stu-id="be5d3-177">Each worker thread in the loop or query can call `GetEnumerator` on the list to retrieve a <xref:System.Collections.Generic.IEnumerator%601> over a distinct partition.</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="be5d3-178">返す`true`を実装する場合<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>。 それ以外の場合は false。</span><span class="sxs-lookup"><span data-stu-id="be5d3-178">Return `true` if you implement <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>; otherwise, false.</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>|<span data-ttu-id="be5d3-179">通常、これだけ呼び出します<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>です。</span><span class="sxs-lookup"><span data-stu-id="be5d3-179">Typically, this just calls <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>.</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>|<span data-ttu-id="be5d3-180">場合<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>は`true`、このメソッドは、の代わりに必要に応じて呼び出すことができる<xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>です。</span><span class="sxs-lookup"><span data-stu-id="be5d3-180">If <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> is `true`, this method can optionally be called instead of <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span></span>|  
  
 <span data-ttu-id="be5d3-181">次の表に、追加方法の詳細については、3 種類のパーティショナーを実装の負荷分散、<xref:System.Collections.Concurrent.OrderablePartitioner%601>クラスです。</span><span class="sxs-lookup"><span data-stu-id="be5d3-181">The following table provides additional details about how the three kinds of load-balancing partitioners implement the <xref:System.Collections.Concurrent.OrderablePartitioner%601> class.</span></span>  
  
|<span data-ttu-id="be5d3-182">メソッドとプロパティ</span><span class="sxs-lookup"><span data-stu-id="be5d3-182">Method/Property</span></span>|<span data-ttu-id="be5d3-183">IList 配列の負荷分散なし/</span><span class="sxs-lookup"><span data-stu-id="be5d3-183">IList / Array without Load Balancing</span></span>|<span data-ttu-id="be5d3-184">IList 配列の負荷分散/</span><span class="sxs-lookup"><span data-stu-id="be5d3-184">IList / Array with Load Balancing</span></span>|<span data-ttu-id="be5d3-185">IEnumerable</span><span class="sxs-lookup"><span data-stu-id="be5d3-185">IEnumerable</span></span>|  
|----------------------|-------------------------------------------|----------------------------------------|-----------------|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>|<span data-ttu-id="be5d3-186">範囲パーティション分割を使用します。</span><span class="sxs-lookup"><span data-stu-id="be5d3-186">Uses range partitioning</span></span>|<span data-ttu-id="be5d3-187">使用して指定された partitionCount のリスト用に最適化された、チャンクがパーティション分割</span><span class="sxs-lookup"><span data-stu-id="be5d3-187">Uses chunk partitioning optimized for Lists for the partitionCount specified</span></span>|<span data-ttu-id="be5d3-188">静的な数のパーティションを作成することでパーティション分割チャンクを使用します。</span><span class="sxs-lookup"><span data-stu-id="be5d3-188">Uses chunk partitioning by creating a static number of partitions.</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A?displayProperty=nameWithType>|<span data-ttu-id="be5d3-189">例外のスローをサポートしていません。</span><span class="sxs-lookup"><span data-stu-id="be5d3-189">Throws not-supported exception</span></span>|<span data-ttu-id="be5d3-190">使用してリスト用に最適化された、チャンクがパーティション分割および動的なパーティション</span><span class="sxs-lookup"><span data-stu-id="be5d3-190">Uses chunk partitioning optimized for Lists and dynamic partitions</span></span>|<span data-ttu-id="be5d3-191">パーティションの数が動的に作成して使用してチャンクがパーティション分割します。</span><span class="sxs-lookup"><span data-stu-id="be5d3-191">Uses chunk partitioning by creating a dynamic number of partitions.</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysOrderedInEachPartition%2A>|<span data-ttu-id="be5d3-192">`true` を返します。</span><span class="sxs-lookup"><span data-stu-id="be5d3-192">Returns `true`</span></span>|<span data-ttu-id="be5d3-193">`true` を返します。</span><span class="sxs-lookup"><span data-stu-id="be5d3-193">Returns `true`</span></span>|<span data-ttu-id="be5d3-194">`true` を返します。</span><span class="sxs-lookup"><span data-stu-id="be5d3-194">Returns `true`</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysOrderedAcrossPartitions%2A>|<span data-ttu-id="be5d3-195">`true` を返します。</span><span class="sxs-lookup"><span data-stu-id="be5d3-195">Returns `true`</span></span>|<span data-ttu-id="be5d3-196">`false` を返します。</span><span class="sxs-lookup"><span data-stu-id="be5d3-196">Returns `false`</span></span>|<span data-ttu-id="be5d3-197">`false` を返します。</span><span class="sxs-lookup"><span data-stu-id="be5d3-197">Returns `false`</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysNormalized%2A>|<span data-ttu-id="be5d3-198">`true` を返します。</span><span class="sxs-lookup"><span data-stu-id="be5d3-198">Returns `true`</span></span>|<span data-ttu-id="be5d3-199">`true` を返します。</span><span class="sxs-lookup"><span data-stu-id="be5d3-199">Returns `true`</span></span>|<span data-ttu-id="be5d3-200">`true` を返します。</span><span class="sxs-lookup"><span data-stu-id="be5d3-200">Returns `true`</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="be5d3-201">`false` を返します。</span><span class="sxs-lookup"><span data-stu-id="be5d3-201">Returns `false`</span></span>|<span data-ttu-id="be5d3-202">`true` を返します。</span><span class="sxs-lookup"><span data-stu-id="be5d3-202">Returns `true`</span></span>|<span data-ttu-id="be5d3-203">`true` を返します。</span><span class="sxs-lookup"><span data-stu-id="be5d3-203">Returns `true`</span></span>|  
  
### <a name="dynamic-partitions"></a><span data-ttu-id="be5d3-204">動的なパーティション</span><span class="sxs-lookup"><span data-stu-id="be5d3-204">Dynamic Partitions</span></span>  
 <span data-ttu-id="be5d3-205">パーティショナーをで使用する場合、<xref:System.Threading.Tasks.Parallel.ForEach%2A>メソッド、する必要がありますを動的なパーティションの数を返します。</span><span class="sxs-lookup"><span data-stu-id="be5d3-205">If you intend the partitioner to be used in a <xref:System.Threading.Tasks.Parallel.ForEach%2A> method, you must be able to return a dynamic number of partitions.</span></span> <span data-ttu-id="be5d3-206">つまり、パーティショナーがループの実行中にいつでもは新しいパーティションのオンデマンドの列挙子を指定できる点です。</span><span class="sxs-lookup"><span data-stu-id="be5d3-206">This means that the partitioner can supply an enumerator for a new partition on-demand at any time during loop execution.</span></span> <span data-ttu-id="be5d3-207">基本的には、ループは、新しい並列タスクを追加するたびに、そのタスク用の新しいパーティションを要求します。</span><span class="sxs-lookup"><span data-stu-id="be5d3-207">Basically, whenever the loop adds a new parallel task, it requests a new partition for that task.</span></span> <span data-ttu-id="be5d3-208">並べ替え可能であるデータを必要とする場合から派生して<xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType>できるように、各パーティション内の各項目に一意のインデックスが割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="be5d3-208">If you require the data to be orderable, then derive from <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> so that each item in each partition is assigned a unique index.</span></span>  
  
 <span data-ttu-id="be5d3-209">詳細については、および例に、次を参照してください。[する方法: 動的パーティションを実装する](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)です。</span><span class="sxs-lookup"><span data-stu-id="be5d3-209">For more information, and an example, see [How to: Implement Dynamic Partitions](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
### <a name="contract-for-partitioners"></a><span data-ttu-id="be5d3-210">パーティショナーのコントラクト</span><span class="sxs-lookup"><span data-stu-id="be5d3-210">Contract for Partitioners</span></span>  
 <span data-ttu-id="be5d3-211">カスタム パーティショナーを実装するときにこれらのガイドラインに従ってを確実に正しい PLINQ 対話と<xref:System.Threading.Tasks.Parallel.ForEach%2A>TPL で。</span><span class="sxs-lookup"><span data-stu-id="be5d3-211">When you implement a custom partitioner, follow these guidelines to help ensure correct interaction with PLINQ and <xref:System.Threading.Tasks.Parallel.ForEach%2A> in the TPL:</span></span>  
  
-   <span data-ttu-id="be5d3-212">場合<xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>が 0 の引数を指定して呼び出された以下の`partitionsCount`、スロー<xref:System.ArgumentOutOfRangeException>です。</span><span class="sxs-lookup"><span data-stu-id="be5d3-212">If <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> is called with an argument of zero or less for `partitionsCount`, throw <xref:System.ArgumentOutOfRangeException>.</span></span> <span data-ttu-id="be5d3-213">PLINQ および TPL に渡すことはありませんが、`partitionCount`を 0 に等しい、それでもをお勧めする可能性を防ぐ必要があります。</span><span class="sxs-lookup"><span data-stu-id="be5d3-213">Although PLINQ and TPL will never pass in a `partitionCount` equal to 0, we nevertheless recommend that you guard against the possibility.</span></span>  
  
-   <span data-ttu-id="be5d3-214"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>および<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>を常に返します`partitionsCount`パーティションの数。</span><span class="sxs-lookup"><span data-stu-id="be5d3-214"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> and <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A> should always return `partitionsCount` number of partitions.</span></span> <span data-ttu-id="be5d3-215">パーティショナーは、データが不足するいるし、メソッドは、残りのパーティションごとに空の列挙子を返す必要があります、要求されると、同じ数のパーティションを作成することはできません。</span><span class="sxs-lookup"><span data-stu-id="be5d3-215">If the partitioner runs out of data and cannot create as many partitions as requested, then the method should return an empty enumerator for each of the remaining partitions.</span></span> <span data-ttu-id="be5d3-216">PLINQ および TPL の両方がそれ以外の場合、スローされます、<xref:System.InvalidOperationException>です。</span><span class="sxs-lookup"><span data-stu-id="be5d3-216">Otherwise, both PLINQ and TPL will throw an <xref:System.InvalidOperationException>.</span></span>  
  
-   <span data-ttu-id="be5d3-217"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>、 <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>、 <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>、および<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>返りません`null`(`Nothing` Visual Basic で)。</span><span class="sxs-lookup"><span data-stu-id="be5d3-217"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>, <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>, <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, and <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A> should never return `null` (`Nothing` in Visual Basic).</span></span> <span data-ttu-id="be5d3-218">場合は、PLINQ は TPL をスロー/、<xref:System.InvalidOperationException>です。</span><span class="sxs-lookup"><span data-stu-id="be5d3-218">If they do, PLINQ / TPL will throw an <xref:System.InvalidOperationException>.</span></span>  
  
-   <span data-ttu-id="be5d3-219">パーティションを返すメソッドでは、完全かつ一意に列挙できるデータ ソースのパーティションが返す常にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="be5d3-219">Methods that return partitions should always return partitions that can fully and uniquely enumerate the data source.</span></span> <span data-ttu-id="be5d3-220">ありません、データ ソースまたはスキップした項目の重複するパーティショナーのデザインに必要な場合を除き、します。</span><span class="sxs-lookup"><span data-stu-id="be5d3-220">There should be no duplication in the data source or skipped items unless specifically required by the design of the partitioner.</span></span> <span data-ttu-id="be5d3-221">この規則に従わない場合の出力順がスクランブルされる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="be5d3-221">If this rule is not followed, then the output order may be scrambled.</span></span>  
  
-   <span data-ttu-id="be5d3-222">出力順がスクランブルないように、次のブール型の getter は、次の値を常に正確に返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="be5d3-222">The following Boolean getters must always accurately return the following values so that the output order is not scrambled:</span></span>  
  
    -   <span data-ttu-id="be5d3-223">`KeysOrderedInEachPartition`: 各パーティションは、増加するキーのインデックスを持つ要素を返します。</span><span class="sxs-lookup"><span data-stu-id="be5d3-223">`KeysOrderedInEachPartition`: Each partition returns elements with increasing key indices.</span></span>  
  
    -   <span data-ttu-id="be5d3-224">`KeysOrderedAcrossPartitions`: すべてのパーティションのパーティション内のキー インデックス、返された*すれば*パーティション内のキーのインデックスよりも高い*すれば*-1 です。</span><span class="sxs-lookup"><span data-stu-id="be5d3-224">`KeysOrderedAcrossPartitions`: For all partitions that are returned, the key indices in partition *i* are higher than the key indices in partition *i*-1.</span></span>  
  
    -   <span data-ttu-id="be5d3-225">`KeysNormalized`: すべてのキー インデックスは 0 から始まる、置かず単調に増加します。</span><span class="sxs-lookup"><span data-stu-id="be5d3-225">`KeysNormalized`: All key indices are monotonically increasing without gaps, starting from zero.</span></span>  
  
-   <span data-ttu-id="be5d3-226">すべてのインデックスは一意である必要があります。</span><span class="sxs-lookup"><span data-stu-id="be5d3-226">All indices must be unique.</span></span> <span data-ttu-id="be5d3-227">インデックスを重複できない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="be5d3-227">There may not be duplicate indices.</span></span> <span data-ttu-id="be5d3-228">この規則に従わない場合の出力順がスクランブルされる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="be5d3-228">If this rule is not followed, then the output order may be scrambled.</span></span>  
  
-   <span data-ttu-id="be5d3-229">すべてのインデックスを負にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="be5d3-229">All indices must be nonnegative.</span></span> <span data-ttu-id="be5d3-230">この規則に従わない場合、PLINQ/TPL は例外をスロー可能性があります。</span><span class="sxs-lookup"><span data-stu-id="be5d3-230">If this rule is not followed, then PLINQ/TPL may throw exceptions.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="be5d3-231">関連項目</span><span class="sxs-lookup"><span data-stu-id="be5d3-231">See Also</span></span>  
 [<span data-ttu-id="be5d3-232">並列プログラミング</span><span class="sxs-lookup"><span data-stu-id="be5d3-232">Parallel Programming</span></span>](../../../docs/standard/parallel-programming/index.md)  
 [<span data-ttu-id="be5d3-233">方法: 動的パーティションを実装する</span><span class="sxs-lookup"><span data-stu-id="be5d3-233">How to: Implement Dynamic Partitions</span></span>](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)  
 [<span data-ttu-id="be5d3-234">方法: 静的パーティション分割用にパーティショナーを実装する</span><span class="sxs-lookup"><span data-stu-id="be5d3-234">How to: Implement a Partitioner for Static Partitioning</span></span>](../../../docs/standard/parallel-programming/how-to-implement-a-partitioner-for-static-partitioning.md)
