---
title: ガベージ コレクションの基礎
description: ガベージ コレクターのしくみと、パフォーマンスを最適化するための構成方法について説明します。
ms.date: 03/08/2018
ms.technology: dotnet-standard
helpviewer_keywords:
- garbage collection, generations
- garbage collection, background garbage collection
- garbage collection, concurrent garbage collection
- garbage collection, server garbage collection
- garbage collection, workstation garbage collection
- garbage collection, managed heap
ms.assetid: 67c5a20d-1be1-4ea7-8a9a-92b0b08658d2
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 8d3ac6acf756a0ac468eb4483432467429ed91ca
ms.sourcegitcommit: 155012a8a826ee8ab6aa49b1b3a3b532e7b7d9bd
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 06/04/2019
ms.locfileid: "66483288"
---
# <a name="fundamentals-of-garbage-collection"></a><span data-ttu-id="79075-103">ガベージ コレクションの基礎</span><span class="sxs-lookup"><span data-stu-id="79075-103">Fundamentals of garbage collection</span></span>
<a name="top"></a> <span data-ttu-id="79075-104">共通言語ランタイム (CLR) では、自動メモリ マネージャーとしてガベージ コレクターを使用できます。</span><span class="sxs-lookup"><span data-stu-id="79075-104">In the common language runtime (CLR), the garbage collector serves as an automatic memory manager.</span></span> <span data-ttu-id="79075-105">次のような利点があります。</span><span class="sxs-lookup"><span data-stu-id="79075-105">It provides the following benefits:</span></span>  
  
- <span data-ttu-id="79075-106">アプリケーションを開発するときにメモリを解放する必要がありません。</span><span class="sxs-lookup"><span data-stu-id="79075-106">Enables you to develop your application without having to free memory.</span></span>  
  
- <span data-ttu-id="79075-107">オブジェクトが効率的にマネージド ヒープに割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="79075-107">Allocates objects on the managed heap efficiently.</span></span>  
  
- <span data-ttu-id="79075-108">使用されなくなったオブジェクトが解放され、メモリがクリアされてその後の割り当てに使用できるようになります。</span><span class="sxs-lookup"><span data-stu-id="79075-108">Reclaims objects that are no longer being used, clears their memory, and keeps the memory available for future allocations.</span></span> <span data-ttu-id="79075-109">マネージド オブジェクトは自動的にクリーンな内容で開始されるため、コンストラクターでデータ フィールドごとに初期化する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="79075-109">Managed objects automatically get clean content to start with, so their constructors do not have to initialize every data field.</span></span>  
  
- <span data-ttu-id="79075-110">オブジェクトで別のオブジェクトの内容を使用できなくすることで、メモリの安全が確保されます。</span><span class="sxs-lookup"><span data-stu-id="79075-110">Provides memory safety by making sure that an object cannot use the content of another object.</span></span>  
  
 <span data-ttu-id="79075-111">このトピックでは、ガベージ コレクションの主要な概念について説明します。</span><span class="sxs-lookup"><span data-stu-id="79075-111">This topic describes the core concepts of garbage collection.</span></span> 
 
<a name="fundamentals_of_memory"></a>   
## <a name="fundamentals-of-memory"></a><span data-ttu-id="79075-112">メモリの基礎</span><span class="sxs-lookup"><span data-stu-id="79075-112">Fundamentals of memory</span></span>  
 <span data-ttu-id="79075-113">CLR のメモリに関する重要な概念の概要を以下に示します。</span><span class="sxs-lookup"><span data-stu-id="79075-113">The following list summarizes important CLR memory concepts.</span></span>  
  
- <span data-ttu-id="79075-114">各プロセスは、分離された独自の仮想アドレス空間を持ちます。</span><span class="sxs-lookup"><span data-stu-id="79075-114">Each process has its own, separate virtual address space.</span></span> <span data-ttu-id="79075-115">同じコンピューターのすべてのプロセスが同じ物理メモリとページ ファイル (存在する場合) を共有します。</span><span class="sxs-lookup"><span data-stu-id="79075-115">All processes on the same computer share the same physical memory, and share the page file if there is one.</span></span>  
  
- <span data-ttu-id="79075-116">32 ビット コンピューターでは、各プロセスが既定で 2 GB のユーザー モード仮想アドレス空間を持ちます。</span><span class="sxs-lookup"><span data-stu-id="79075-116">By default, on 32-bit computers, each process has a 2-GB user-mode virtual address space.</span></span>  
  
- <span data-ttu-id="79075-117">アプリケーション開発者が操作するのは仮想アドレス空間だけで、直接物理メモリを操作することはありません。</span><span class="sxs-lookup"><span data-stu-id="79075-117">As an application developer, you work only with virtual address space and never manipulate physical memory directly.</span></span> <span data-ttu-id="79075-118">マネージド ヒープの仮想メモリの割り当てと解放はガベージ コレクターによって行われます。</span><span class="sxs-lookup"><span data-stu-id="79075-118">The garbage collector allocates and frees virtual memory for you on the managed heap.</span></span>  
  
     <span data-ttu-id="79075-119">ネイティブ コードを記述する場合は、Win32 関数を使用して仮想アドレス空間を操作します。</span><span class="sxs-lookup"><span data-stu-id="79075-119">If you are writing native code, you use Win32 functions to work with the virtual address space.</span></span> <span data-ttu-id="79075-120">ネイティブ ヒープの仮想メモリの割り当てと解放はこれらの関数によって行われます。</span><span class="sxs-lookup"><span data-stu-id="79075-120">These functions allocate and free virtual memory for you on native heaps.</span></span>  
  
- <span data-ttu-id="79075-121">仮想メモリには次の 3 つの状態があります。</span><span class="sxs-lookup"><span data-stu-id="79075-121">Virtual memory can be in three states:</span></span>  
  
    - <span data-ttu-id="79075-122">空き。</span><span class="sxs-lookup"><span data-stu-id="79075-122">Free.</span></span> <span data-ttu-id="79075-123">参照されていない、割り当てに使用できるメモリ ブロックです。</span><span class="sxs-lookup"><span data-stu-id="79075-123">The block of memory has no references to it and is available for allocation.</span></span>  
  
    - <span data-ttu-id="79075-124">予約済み。</span><span class="sxs-lookup"><span data-stu-id="79075-124">Reserved.</span></span> <span data-ttu-id="79075-125">使用できるように確保された、他の割り当て要求には使用できないメモリ ブロックです。</span><span class="sxs-lookup"><span data-stu-id="79075-125">The block of memory is available for your use and cannot be used for any other allocation request.</span></span> <span data-ttu-id="79075-126">ただし、このメモリ ブロックがコミットされるまではデータを格納できません。</span><span class="sxs-lookup"><span data-stu-id="79075-126">However, you cannot store data to this memory block until it is committed.</span></span>  
  
    - <span data-ttu-id="79075-127">コミット済み。</span><span class="sxs-lookup"><span data-stu-id="79075-127">Committed.</span></span> <span data-ttu-id="79075-128">物理ストレージに割り当てられたメモリ ブロックです。</span><span class="sxs-lookup"><span data-stu-id="79075-128">The block of memory is assigned to physical storage.</span></span>  
  
- <span data-ttu-id="79075-129">仮想アドレス空間は、断片化することがあります。</span><span class="sxs-lookup"><span data-stu-id="79075-129">Virtual address space can get fragmented.</span></span> <span data-ttu-id="79075-130">断片化とは、アドレス空間に複数の空きブロック (ホールとも呼ばれます) がある状態です。</span><span class="sxs-lookup"><span data-stu-id="79075-130">This means that there are free blocks, also known as holes, in the address space.</span></span> <span data-ttu-id="79075-131">仮想メモリの割り当てが要求された場合、仮想メモリ マネージャーは、その割り当て要求を満たすのに十分な大きさの単一の空きブロックを見つけなければなりません。</span><span class="sxs-lookup"><span data-stu-id="79075-131">When a virtual memory allocation is requested, the virtual memory manager has to find a single free block that is large enough to satisfy that allocation request.</span></span> <span data-ttu-id="79075-132">2 GB の空き領域があっても、そのすべての空き領域が 1 つのアドレス ブロックの中にない場合、2 GB の領域を必要とする割り当ては失敗します。</span><span class="sxs-lookup"><span data-stu-id="79075-132">Even if you have 2 GB of free space, the allocation that requires 2 GB will be unsuccessful unless all of that free space is in a single address block.</span></span>  
  
- <span data-ttu-id="79075-133">メモリが足りなくなるのは、予約する仮想アドレス空間が足りなくなった場合か、コミットする物理領域が足りなくなった場合です。</span><span class="sxs-lookup"><span data-stu-id="79075-133">You can run out of memory if you run out of virtual address space to reserve or physical space to commit.</span></span>  
  
 <span data-ttu-id="79075-134">ページ ファイルは、物理メモリの圧迫度 (物理メモリに対する需要) が低い場合にも使用されます。</span><span class="sxs-lookup"><span data-stu-id="79075-134">Your page file is used even if physical memory pressure (that is, demand for physical memory) is low.</span></span> <span data-ttu-id="79075-135">最初に物理メモリの圧迫度が高まると、データを格納するための領域を確保するために物理メモリのデータの一部がページ ファイルにバックアップされますが、</span><span class="sxs-lookup"><span data-stu-id="79075-135">The first time your physical memory pressure is high, the operating system must make room in physical memory to store data, and it backs up some of the data that is in physical memory to the page file.</span></span> <span data-ttu-id="79075-136">そのデータは必要になるまでページングされないため、物理メモリの圧迫度が非常に低い状況でページングが発生する可能性もあります。</span><span class="sxs-lookup"><span data-stu-id="79075-136">That data is not paged until it is needed, so it is possible to encounter paging in situations where the physical memory pressure is very low.</span></span> 
 
 [<span data-ttu-id="79075-137">ページのトップへ</span><span class="sxs-lookup"><span data-stu-id="79075-137">Back to top</span></span>](#top)  
  
<a name="conditions_for_a_garbage_collection"></a>   
## <a name="conditions-for-a-garbage-collection"></a><span data-ttu-id="79075-138">ガベージ コレクションの条件</span><span class="sxs-lookup"><span data-stu-id="79075-138">Conditions for a garbage collection</span></span>  
 <span data-ttu-id="79075-139">ガベージ コレクションは、次のいずれかの条件に当てはまる場合に発生します。</span><span class="sxs-lookup"><span data-stu-id="79075-139">Garbage collection occurs when one of the following conditions is true:</span></span>  
  
- <span data-ttu-id="79075-140">システムの物理メモリが少ない場合。</span><span class="sxs-lookup"><span data-stu-id="79075-140">The system has low physical memory.</span></span> <span data-ttu-id="79075-141">OS からのメモリ不足通知またはホストによって示されたメモリ不足のいずれかによって検出されます。</span><span class="sxs-lookup"><span data-stu-id="79075-141">This is detected by either the low memory notification from the OS or low memory indicated by the host.</span></span>
  
- <span data-ttu-id="79075-142">マネージド ヒープで割り当てられたオブジェクトによって使用されているメモリが、許容されるしきい値を超える場合。</span><span class="sxs-lookup"><span data-stu-id="79075-142">The memory that is used by allocated objects on the managed heap surpasses an acceptable threshold.</span></span> <span data-ttu-id="79075-143">このしきい値は、プロセスの進行に合わせて絶えず調整されます。</span><span class="sxs-lookup"><span data-stu-id="79075-143">This threshold is continuously adjusted as the process runs.</span></span>  
  
- <span data-ttu-id="79075-144"><xref:System.GC.Collect%2A?displayProperty=nameWithType> メソッドが呼び出された場合。</span><span class="sxs-lookup"><span data-stu-id="79075-144">The <xref:System.GC.Collect%2A?displayProperty=nameWithType> method is called.</span></span> <span data-ttu-id="79075-145">ほとんどの場合、ガベージ コレクターは継続して実行されるため、このメソッドを呼び出す必要はありません。</span><span class="sxs-lookup"><span data-stu-id="79075-145">In almost all cases, you do not have to call this method, because the garbage collector runs continuously.</span></span> <span data-ttu-id="79075-146">このメソッドは、主に特別な状況やテストで使用されます。</span><span class="sxs-lookup"><span data-stu-id="79075-146">This method is primarily used for unique situations and testing.</span></span>  
  
 [<span data-ttu-id="79075-147">ページのトップへ</span><span class="sxs-lookup"><span data-stu-id="79075-147">Back to top</span></span>](#top)  
  
<a name="the_managed_heap"></a>   
## <a name="the-managed-heap"></a><span data-ttu-id="79075-148">マネージド ヒープ</span><span class="sxs-lookup"><span data-stu-id="79075-148">The managed heap</span></span>  
 <span data-ttu-id="79075-149">ガベージ コレクターは、CLR によって初期化された後、オブジェクトを格納および管理するためのメモリのセグメントを割り当てます。</span><span class="sxs-lookup"><span data-stu-id="79075-149">After the garbage collector is initialized by the CLR, it allocates a segment of memory to store and manage objects.</span></span> <span data-ttu-id="79075-150">オペレーティング システムのネイティブ ヒープに対し、このメモリのことをマネージド ヒープと呼びます。</span><span class="sxs-lookup"><span data-stu-id="79075-150">This memory is called the managed heap, as opposed to a native heap in the operating system.</span></span>  
  
 <span data-ttu-id="79075-151">マネージド ヒープはマネージド プロセスごとに割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="79075-151">There is a managed heap for each managed process.</span></span> <span data-ttu-id="79075-152">プロセス内のすべてのスレッドは、同じヒープにオブジェクト用のメモリを割り当てます。</span><span class="sxs-lookup"><span data-stu-id="79075-152">All threads in the process allocate memory for objects on the same heap.</span></span>  
  
 <span data-ttu-id="79075-153">メモリを予約するために、ガベージ コレクターは Win32 [VirtualAlloc](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) 関数を呼び出し、マネージド アプリケーション用のメモリのセグメントを一度に 1 つずつ予約します。</span><span class="sxs-lookup"><span data-stu-id="79075-153">To reserve memory, the garbage collector calls the Win32 [VirtualAlloc](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) function, and reserves one segment of memory at a time for managed applications.</span></span> <span data-ttu-id="79075-154">また、ガベージ コレクターは、必要に応じてセグメントを予約したり、Win32 [VirtualFree](/windows/desktop/api/memoryapi/nf-memoryapi-virtualfree) 関数を呼び出すことで (オブジェクトのセグメントをクリアしてから) セグメントを解放してオペレーティング システムに戻したりします。</span><span class="sxs-lookup"><span data-stu-id="79075-154">The garbage collector also reserves segments as needed, and releases segments back to the operating system (after clearing them of any objects) by calling the Win32 [VirtualFree](/windows/desktop/api/memoryapi/nf-memoryapi-virtualfree) function.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="79075-155">ガベージ コレクターによって割り当てらるセグメントのサイズは実装に固有であり、定期的な更新プログラムによる場合を含め、いつでも変更されることがあります。</span><span class="sxs-lookup"><span data-stu-id="79075-155">The size of segments allocated by the garbage collector is implementation-specific and is subject to change at any time, including in periodic updates.</span></span> <span data-ttu-id="79075-156">アプリでは、セグメント サイズを推測することや、特定のセグメント サイズに依存することを絶対に避けてください。また、セグメントの割り当てに使用可能なメモリの量を構成しようとしてもなりません。</span><span class="sxs-lookup"><span data-stu-id="79075-156">Your app should never make assumptions about or depend on a particular segment size, nor should it attempt to configure the amount of memory available for segment allocations.</span></span>  
  
 <span data-ttu-id="79075-157">ヒープに割り当てられたオブジェクトが少ないほど、ガベージ コレクターの処理も少なくなります。</span><span class="sxs-lookup"><span data-stu-id="79075-157">The fewer objects allocated on the heap, the less work the garbage collector has to do.</span></span> <span data-ttu-id="79075-158">そのため、オブジェクトを割り当てるときに、必要な量より多く割り当てないようにしてください。たとえば、15 バイトしか必要がないときに 32 バイトの配列を割り当てないようにしてください。</span><span class="sxs-lookup"><span data-stu-id="79075-158">When you allocate objects, do not use rounded-up values that exceed your needs, such as allocating an array of 32 bytes when you need only 15 bytes.</span></span>  
  
 <span data-ttu-id="79075-159">ガベージ コレクションがトリガーされると、ガベージ コレクターは、使用されなくなったオブジェクトに占有されているメモリを解放します。</span><span class="sxs-lookup"><span data-stu-id="79075-159">When a garbage collection is triggered, the garbage collector reclaims the memory that is occupied by dead objects.</span></span> <span data-ttu-id="79075-160">この解放プロセスでは、まとめて移動できるように有効なオブジェクトを圧縮し、使用されなくなったスペースを削除することで、ヒープを小さくします。</span><span class="sxs-lookup"><span data-stu-id="79075-160">The reclaiming process compacts live objects so that they are moved together, and the dead space is removed, thereby making the heap smaller.</span></span> <span data-ttu-id="79075-161">これにより、一緒に割り当てられたオブジェクトが同じマネージド ヒープにまとめられ、局所性が保持されます。</span><span class="sxs-lookup"><span data-stu-id="79075-161">This ensures that objects that are allocated together stay together on the managed heap, to preserve their locality.</span></span>  
  
 <span data-ttu-id="79075-162">ガベージ コレクションの割り込みの動作 (頻度と期間) は、割り当てのボリュームとマネージド ヒープ上の残ったメモリの量によって決まります。</span><span class="sxs-lookup"><span data-stu-id="79075-162">The intrusiveness (frequency and duration) of garbage collections is the result of the volume of allocations and the amount of survived memory on the managed heap.</span></span>  
  
 <span data-ttu-id="79075-163">ヒープは、[大きなオブジェクト ヒープ](large-object-heap.md)と小さなオブジェクト ヒープの 2 つを累積したものと見なすことができます。</span><span class="sxs-lookup"><span data-stu-id="79075-163">The heap can be considered as the accumulation of two heaps: the [large object heap](large-object-heap.md) and the small object heap.</span></span>  
  
 <span data-ttu-id="79075-164">[大きなオブジェクト ヒープ](large-object-heap.md)には、85,000 バイトを超える非常に大きなオブジェクトが格納されます。</span><span class="sxs-lookup"><span data-stu-id="79075-164">The [large object heap](large-object-heap.md) contains very large objects that are 85,000 bytes and larger.</span></span> <span data-ttu-id="79075-165">大きなオブジェクト ヒープの中のオブジェクトは、通常は配列になります。</span><span class="sxs-lookup"><span data-stu-id="79075-165">The objects on the large object heap are usually arrays.</span></span> <span data-ttu-id="79075-166">インスタンス オブジェクトが極端に大きくなることはほとんどありません。</span><span class="sxs-lookup"><span data-stu-id="79075-166">It is rare for an instance object to be extremely large.</span></span>  
  
 [<span data-ttu-id="79075-167">ページのトップへ</span><span class="sxs-lookup"><span data-stu-id="79075-167">Back to top</span></span>](#top)  
  
<a name="generations"></a>   
## <a name="generations"></a><span data-ttu-id="79075-168">ジェネレーション</span><span class="sxs-lookup"><span data-stu-id="79075-168">Generations</span></span>  
 <span data-ttu-id="79075-169">ヒープは、有効期間が長いオブジェクトと有効期間が短いオブジェクトに対処できるようにジェネレーションにまとめられます。</span><span class="sxs-lookup"><span data-stu-id="79075-169">The heap is organized into generations so it can handle long-lived and short-lived objects.</span></span> <span data-ttu-id="79075-170">ガベージ コレクションは主に、通常はヒープのごく一部だけを占有する有効期間が短いオブジェクトを解放する場合に発生します。</span><span class="sxs-lookup"><span data-stu-id="79075-170">Garbage collection primarily occurs with the reclamation of short-lived objects that typically occupy only a small part of the heap.</span></span> <span data-ttu-id="79075-171">ヒープのオブジェクトのジェネレーションには次の 3 つがあります。</span><span class="sxs-lookup"><span data-stu-id="79075-171">There are three generations of objects on the heap:</span></span>  
  
- <span data-ttu-id="79075-172">**ジェネレーション 0**。</span><span class="sxs-lookup"><span data-stu-id="79075-172">**Generation 0**.</span></span> <span data-ttu-id="79075-173">これは一番最初のジェネレーションで、有効期間が短いオブジェクトが格納されます。</span><span class="sxs-lookup"><span data-stu-id="79075-173">This is the youngest generation and contains short-lived objects.</span></span> <span data-ttu-id="79075-174">有効期間が短いオブジェクトには、たとえば、テンポラリ変数などがあります。</span><span class="sxs-lookup"><span data-stu-id="79075-174">An example of a short-lived object is a temporary variable.</span></span> <span data-ttu-id="79075-175">ガベージ コレクションは、このジェネレーションで最も頻繁に発生します。</span><span class="sxs-lookup"><span data-stu-id="79075-175">Garbage collection occurs most frequently in this generation.</span></span>  
  
     <span data-ttu-id="79075-176">オブジェクトが新しく割り当てられると、大きなオブジェクトの場合以外は、オブジェクトの新しいジェネレーションが形成されて暗黙的にジェネレーション 0 のコレクションになります。大きなオブジェクトの場合は、ジェネレーション 2 のコレクションの大きなオブジェクトのヒープに割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="79075-176">Newly allocated objects form a new generation of objects and are implicitly generation 0 collections, unless they are large objects, in which case they go on the large object heap in a generation 2 collection.</span></span>  
  
     <span data-ttu-id="79075-177">ジェネレーション 0 では、ほとんどのオブジェクトがガベージ コレクションで解放され、次のジェネレーションには残りません。</span><span class="sxs-lookup"><span data-stu-id="79075-177">Most objects are reclaimed for garbage collection in generation 0 and do not survive to the next generation.</span></span>  
  
- <span data-ttu-id="79075-178">**ジェネレーション 1**。</span><span class="sxs-lookup"><span data-stu-id="79075-178">**Generation 1**.</span></span> <span data-ttu-id="79075-179">このジェネレーションには有効期間が短いオブジェクトが格納されます。有効期間が短いオブジェクトと有効期間が長いオブジェクトの間のバッファーとして機能します。</span><span class="sxs-lookup"><span data-stu-id="79075-179">This generation contains short-lived objects and serves as a buffer between short-lived objects and long-lived objects.</span></span>  
  
- <span data-ttu-id="79075-180">**ジェネレーション 2**。</span><span class="sxs-lookup"><span data-stu-id="79075-180">**Generation 2**.</span></span> <span data-ttu-id="79075-181">このジェネレーションには、有効期間が長いオブジェクトが格納されます。</span><span class="sxs-lookup"><span data-stu-id="79075-181">This generation contains long-lived objects.</span></span> <span data-ttu-id="79075-182">有効期間が長いオブジェクトには、たとえば、プロセスの存続期間を通じて有効な静的データを含むサーバー アプリケーションのオブジェクトなどがあります。</span><span class="sxs-lookup"><span data-stu-id="79075-182">An example of a long-lived object is an object in a server application that contains static data that is live for the duration of the process.</span></span>  
  
 <span data-ttu-id="79075-183">ガベージ コレクションは、条件に応じて特定のジェネレーションで発生します。</span><span class="sxs-lookup"><span data-stu-id="79075-183">Garbage collections occur on specific generations as conditions warrant.</span></span> <span data-ttu-id="79075-184">ジェネレーションのコレクションでは、そのジェネレーションとそれよりも前のすべてのジェネレーションのオブジェクトがコレクションの対象になります。</span><span class="sxs-lookup"><span data-stu-id="79075-184">Collecting a generation means collecting objects in that generation and all its younger generations.</span></span> <span data-ttu-id="79075-185">ジェネレーション 2 のガベージ コレクションは、すべてのジェネレーションのすべてのオブジェクト (つまり、マネージド ヒープのすべてのオブジェクト) を解放することから、フル ガベージ コレクションとも呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="79075-185">A generation 2 garbage collection is also known as a full garbage collection, because it reclaims all objects in all generations (that is, all objects in the managed heap).</span></span>  
  
### <a name="survival-and-promotions"></a><span data-ttu-id="79075-186">存続と昇格</span><span class="sxs-lookup"><span data-stu-id="79075-186">Survival and promotions</span></span>  
 <span data-ttu-id="79075-187">ガベージ コレクションで解放されなかったオブジェクトは残存オブジェクトと呼ばれ、次のジェネレーションに昇格されます。</span><span class="sxs-lookup"><span data-stu-id="79075-187">Objects that are not reclaimed in a garbage collection are known as survivors, and are promoted to the next generation.</span></span> <span data-ttu-id="79075-188">ジェネレーション 0 のガベージ コレクションでごみではないと判断されたオブジェクトは、ジェネレーション 1 に昇格されます。ジェネレーション 1 のガベージ コレクションでごみではないと判断されたオブジェクトは、ジェネレーション 2 に昇格されます。ジェネレーション 2 のガベージ コレクションでごみではないと判断されたオブジェクトは、ジェネレーション 2 に残ります。</span><span class="sxs-lookup"><span data-stu-id="79075-188">Objects that survive a generation 0 garbage collection are promoted to generation 1; objects that survive a generation 1 garbage collection are promoted to generation 2; and objects that survive a generation 2 garbage collection remain in generation 2.</span></span>  
  
 <span data-ttu-id="79075-189">ガベージ コレクターは、ジェネレーションでごみではないと判断される割合が高いことを検出すると、そのジェネレーションに対する割り当てのしきい値を高くして、次のジェネレーションで十分なサイズの解放されたメモリを受け取ることができるようにします。</span><span class="sxs-lookup"><span data-stu-id="79075-189">When the garbage collector detects that the survival rate is high in a generation, it increases the threshold of allocations for that generation, so the next collection gets a substantial size of reclaimed memory.</span></span> <span data-ttu-id="79075-190">CLR は、アプリケーションのワーキング セットが大きくなりすぎないようにすることと、ガベージ コレクションに時間がかかりすぎないようにすることに注意して、それらの 2 つの優先事項のバランスを絶えず調整します。</span><span class="sxs-lookup"><span data-stu-id="79075-190">The CLR continually balances two priorities: not letting an application's working set get too big and not letting the garbage collection take too much time.</span></span>  
  
### <a name="ephemeral-generations-and-segments"></a><span data-ttu-id="79075-191">短期のジェネレーションとセグメント</span><span class="sxs-lookup"><span data-stu-id="79075-191">Ephemeral generations and segments</span></span>  
 <span data-ttu-id="79075-192">ジェネレーション 0 および 1 のオブジェクトは有効期間が短いことから、それらのジェネレーションのことを短期ジェネレーションと呼びます。</span><span class="sxs-lookup"><span data-stu-id="79075-192">Because objects in generations 0 and 1 are short-lived, these generations are known as the ephemeral generations.</span></span>  
  
 <span data-ttu-id="79075-193">短期ジェネレーションは、短期セグメントと呼ばれるメモリ セグメントに割り当てる必要があります。</span><span class="sxs-lookup"><span data-stu-id="79075-193">Ephemeral generations must be allocated in the memory segment that is known as the ephemeral segment.</span></span> <span data-ttu-id="79075-194">ガベージ コレクターによって新しいセグメントが取得されると、いずれも新しい短期セグメントになり、ジェネレーション 0 のガベージ コレクションで残ったオブジェクトが格納されます。</span><span class="sxs-lookup"><span data-stu-id="79075-194">Each new segment acquired by the garbage collector becomes the new ephemeral segment and contains the objects that survived a generation 0 garbage collection.</span></span> <span data-ttu-id="79075-195">古い短期セグメントは新しいジェネレーション 2 のセグメントになります。</span><span class="sxs-lookup"><span data-stu-id="79075-195">The old ephemeral segment becomes the new generation 2 segment.</span></span>  
  
 <span data-ttu-id="79075-196">短期セグメントのサイズは、システムが 32 ビット 64 ビットのどちらであるか、および実行されているガベージ コレクターの種類に応じて異なります。</span><span class="sxs-lookup"><span data-stu-id="79075-196">The size of the ephemeral segment varies depending on whether a system is 32- or 64-bit, and on the type of garbage collector it is running.</span></span> <span data-ttu-id="79075-197">既定の値を次の表に示します。</span><span class="sxs-lookup"><span data-stu-id="79075-197">Default values are shown in the following table.</span></span>  
  
||<span data-ttu-id="79075-198">32 ビット</span><span class="sxs-lookup"><span data-stu-id="79075-198">32-bit</span></span>|<span data-ttu-id="79075-199">64 ビット</span><span class="sxs-lookup"><span data-stu-id="79075-199">64-bit</span></span>|  
|-|-------------|-------------|  
|<span data-ttu-id="79075-200">ワークステーションの GC</span><span class="sxs-lookup"><span data-stu-id="79075-200">Workstation GC</span></span>|<span data-ttu-id="79075-201">16 MB</span><span class="sxs-lookup"><span data-stu-id="79075-201">16 MB</span></span>|<span data-ttu-id="79075-202">256 MB</span><span class="sxs-lookup"><span data-stu-id="79075-202">256 MB</span></span>|  
|<span data-ttu-id="79075-203">サーバーの GC</span><span class="sxs-lookup"><span data-stu-id="79075-203">Server GC</span></span>|<span data-ttu-id="79075-204">64 MB</span><span class="sxs-lookup"><span data-stu-id="79075-204">64 MB</span></span>|<span data-ttu-id="79075-205">4 GB</span><span class="sxs-lookup"><span data-stu-id="79075-205">4 GB</span></span>|  
|<span data-ttu-id="79075-206">サーバーの GC (論理 CPU が 4 個以上の場合)</span><span class="sxs-lookup"><span data-stu-id="79075-206">Server GC with > 4 logical CPUs</span></span>|<span data-ttu-id="79075-207">32 MB</span><span class="sxs-lookup"><span data-stu-id="79075-207">32 MB</span></span>|<span data-ttu-id="79075-208">2 GB</span><span class="sxs-lookup"><span data-stu-id="79075-208">2 GB</span></span>|  
|<span data-ttu-id="79075-209">サーバーの GC (論理 CPU が 8 個以上の場合)</span><span class="sxs-lookup"><span data-stu-id="79075-209">Server GC with > 8 logical CPUs</span></span>|<span data-ttu-id="79075-210">16 MB</span><span class="sxs-lookup"><span data-stu-id="79075-210">16 MB</span></span>|<span data-ttu-id="79075-211">1 GB</span><span class="sxs-lookup"><span data-stu-id="79075-211">1 GB</span></span>|  
  
 <span data-ttu-id="79075-212">短期セグメントには、ジェネレーション 2 のオブジェクトも含めることができます。</span><span class="sxs-lookup"><span data-stu-id="79075-212">The ephemeral segment can include generation 2 objects.</span></span> <span data-ttu-id="79075-213">ジェネレーション 2 のオブジェクトでは複数のセグメントを使用できます (プロセスでの必要に応じてメモリが許容できる限りいくつでも使用できます)。</span><span class="sxs-lookup"><span data-stu-id="79075-213">Generation 2 objects can use multiple segments (as many as your process requires and memory allows for).</span></span>  
  
 <span data-ttu-id="79075-214">短期ガベージ コレクションによって解放されるメモリの量は、短期セグメントのサイズまでに限られます。</span><span class="sxs-lookup"><span data-stu-id="79075-214">The amount of freed memory from an ephemeral garbage collection is limited to the size of the ephemeral segment.</span></span> <span data-ttu-id="79075-215">解放されるメモリの量は、使用されなくなったオブジェクトに占有されていた領域に比例します。</span><span class="sxs-lookup"><span data-stu-id="79075-215">The amount of memory that is freed is proportional to the space that was occupied by the dead objects.</span></span>  
  
 [<span data-ttu-id="79075-216">ページのトップへ</span><span class="sxs-lookup"><span data-stu-id="79075-216">Back to top</span></span>](#top)  
  
<a name="what_happens_during_a_garbage_collection"></a>   
## <a name="what-happens-during-a-garbage-collection"></a><span data-ttu-id="79075-217">ガベージ コレクションの実行時の動作</span><span class="sxs-lookup"><span data-stu-id="79075-217">What happens during a garbage collection</span></span>  
 <span data-ttu-id="79075-218">ガベージ コレクションには次のフェーズがあります。</span><span class="sxs-lookup"><span data-stu-id="79075-218">A garbage collection has the following phases:</span></span>  
  
- <span data-ttu-id="79075-219">マーキング フェーズ。有効なすべてのオブジェクトを探し、そのリストを作成します。</span><span class="sxs-lookup"><span data-stu-id="79075-219">A marking phase that finds and creates a list of all live objects.</span></span>  
  
- <span data-ttu-id="79075-220">再配置フェーズ。圧縮するオブジェクトへの参照を更新します。</span><span class="sxs-lookup"><span data-stu-id="79075-220">A relocating phase that updates the references to the objects that will be compacted.</span></span>  
  
- <span data-ttu-id="79075-221">圧縮フェーズ。使用されなくなったオブジェクトに占有されている領域を解放し、残ったオブジェクトを圧縮します。</span><span class="sxs-lookup"><span data-stu-id="79075-221">A compacting phase that reclaims the space occupied by the dead objects and compacts the surviving objects.</span></span> <span data-ttu-id="79075-222">圧縮フェーズでは、ガベージ コレクションで残ったオブジェクトをセグメントの後ろに移動します。</span><span class="sxs-lookup"><span data-stu-id="79075-222">The compacting phase moves objects that have survived a garbage collection toward the older end of the segment.</span></span>  
  
     <span data-ttu-id="79075-223">ジェネレーション 2 のコレクションでは複数のセグメントを占有できるため、ジェネレーション 2 に昇格されたオブジェクトはより古いセグメントに移動できます。</span><span class="sxs-lookup"><span data-stu-id="79075-223">Because generation 2 collections can occupy multiple segments, objects that are promoted into generation 2 can be moved into an older segment.</span></span> <span data-ttu-id="79075-224">ジェネレーション 1 とジェネレーション 2 の残存オブジェクトは、どちらもジェネレーション 2 に昇格されるため、別のセグメントに移動できます。</span><span class="sxs-lookup"><span data-stu-id="79075-224">Both generation 1 and generation 2 survivors can be moved to a different segment, because they are promoted to generation 2.</span></span>  
  
     <span data-ttu-id="79075-225">通常、大きなオブジェクト ヒープは圧縮されません。これは、大きなオブジェクトをコピーするとパフォーマンスが低下するためです。</span><span class="sxs-lookup"><span data-stu-id="79075-225">Ordinarily, the large object heap is not compacted, because copying large objects imposes a performance penalty.</span></span> <span data-ttu-id="79075-226">ただし .NET Framework 4.5.1 以降では、<xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> プロパティを使用して、大きなオブジェクト ヒープを必要に応じて圧縮できます。</span><span class="sxs-lookup"><span data-stu-id="79075-226">However, starting with the .NET Framework 4.5.1, you can use the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property to compact the large object heap on demand.</span></span>  
  
 <span data-ttu-id="79075-227">ガベージ コレクターは、次の情報に基づいてオブジェクトが有効かどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="79075-227">The garbage collector uses the following information to determine whether objects are live:</span></span>  
  
- <span data-ttu-id="79075-228">**スタック ルート**。</span><span class="sxs-lookup"><span data-stu-id="79075-228">**Stack roots**.</span></span> <span data-ttu-id="79075-229">Just-In-Time (JIT) コンパイラとスタック ウォーカーによって提供されるスタック変数。</span><span class="sxs-lookup"><span data-stu-id="79075-229">Stack variables provided by the just-in-time (JIT) compiler and stack walker.</span></span> <span data-ttu-id="79075-230">JIT の最適化では、スタック変数がガベージ コレクターに報告されるコードの領域が延長または短縮される可能性があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="79075-230">Note that JIT optimizations can lengthen or shorten regions of code within which stack variables are reported to the garbage collector.</span></span>
  
- <span data-ttu-id="79075-231">**ガベージ コレクション ハンドル**。</span><span class="sxs-lookup"><span data-stu-id="79075-231">**Garbage collection handles**.</span></span> <span data-ttu-id="79075-232">マネージド オブジェクトを参照するハンドル。これらのハンドルは、ユーザー コードまたは共通言語ランタイムで割り当てることができます。</span><span class="sxs-lookup"><span data-stu-id="79075-232">Handles that point to managed objects and that can be allocated by user code or by the common language runtime.</span></span>  
  
- <span data-ttu-id="79075-233">**静的データ**。</span><span class="sxs-lookup"><span data-stu-id="79075-233">**Static data**.</span></span> <span data-ttu-id="79075-234">他のオブジェクトを参照している可能性があるアプリケーション ドメインの静的オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="79075-234">Static objects in application domains that could be referencing other objects.</span></span> <span data-ttu-id="79075-235">静的オブジェクトはそれぞれのアプリケーション ドメインで追跡されます。</span><span class="sxs-lookup"><span data-stu-id="79075-235">Each application domain keeps track of its static objects.</span></span>  
  
 <span data-ttu-id="79075-236">ガベージ コレクションが開始される前に、そのガベージ コレクションをトリガーしたスレッドを除くすべてのマネージド スレッドが中断されます。</span><span class="sxs-lookup"><span data-stu-id="79075-236">Before a garbage collection starts, all managed threads are suspended except for the thread that triggered the garbage collection.</span></span>  
  
 <span data-ttu-id="79075-237">次の図は、ガベージ コレクションを発生させて他のスレッドの中断を引き起こすスレッドを示しています。</span><span class="sxs-lookup"><span data-stu-id="79075-237">The following illustration shows a thread that triggers a garbage collection and causes the other threads to be suspended.</span></span>  
  
 <span data-ttu-id="79075-238">![スレッドがガベージ コレクションを発生させる場合](../../../docs/standard/garbage-collection/media/gc-triggered.png "GC_Triggered")</span><span class="sxs-lookup"><span data-stu-id="79075-238">![When a thread triggers a Garbage Collection](../../../docs/standard/garbage-collection/media/gc-triggered.png "GC_Triggered")</span></span>  
<span data-ttu-id="79075-239">ガベージ コレクションを発生させるスレッド</span><span class="sxs-lookup"><span data-stu-id="79075-239">Thread that triggers a garbage collection</span></span>  
  
 [<span data-ttu-id="79075-240">ページのトップへ</span><span class="sxs-lookup"><span data-stu-id="79075-240">Back to top</span></span>](#top)  
  
<a name="manipulating_unmanaged_resources"></a>   
## <a name="manipulating-unmanaged-resources"></a><span data-ttu-id="79075-241">アンマネージ リソースの操作</span><span class="sxs-lookup"><span data-stu-id="79075-241">Manipulating unmanaged resources</span></span>  
 <span data-ttu-id="79075-242">ガベージ コレクターではマネージド ヒープのメモリのみを追跡するため、マネージド オブジェクトでネイティブのファイル ハンドルを使用してアンマネージド オブジェクトを参照している場合は、そのアンマネージド オブジェクトを明示的に解放する必要があります。</span><span class="sxs-lookup"><span data-stu-id="79075-242">If your managed objects reference unmanaged objects by using their native file handles, you have to explicitly free the unmanaged objects, because the garbage collector tracks memory only on the managed heap.</span></span>  
  
 <span data-ttu-id="79075-243">マネージド オブジェクトのユーザーは、オブジェクトで使用されているネイティブ リソースを破棄できません。</span><span class="sxs-lookup"><span data-stu-id="79075-243">Users of your managed object may not dispose the native resources used by the object.</span></span> <span data-ttu-id="79075-244">そのため、クリーンアップを行うには、マネージド オブジェクトをファイナライズ可能にします。</span><span class="sxs-lookup"><span data-stu-id="79075-244">To perform the cleanup, you can make your managed object finalizable.</span></span> <span data-ttu-id="79075-245">ファイナライズは、オブジェクトが使用されなくなったときに実行するクリーンアップ アクションで構成されます。</span><span class="sxs-lookup"><span data-stu-id="79075-245">Finalization consists of cleanup actions that you execute when the object is no longer in use.</span></span> <span data-ttu-id="79075-246">マネージド オブジェクトが使用されなくなると、ファイナライザー メソッドで指定されたクリーンアップ アクションが実行されます。</span><span class="sxs-lookup"><span data-stu-id="79075-246">When your managed object dies, it performs cleanup actions that are specified in its finalizer method.</span></span>  
  
 <span data-ttu-id="79075-247">ファイナライズ可能なオブジェクトが使用されなくなったことが検出されると、クリーンアップ アクションを実行するためにファイナライザーによってキューに入れられますが、オブジェクト自体は次のジェネレーションに昇格されます。</span><span class="sxs-lookup"><span data-stu-id="79075-247">When a finalizable object is discovered to be dead, its finalizer is put in a queue so that its cleanup actions are executed, but the object itself is promoted to the next generation.</span></span> <span data-ttu-id="79075-248">そのため、そのジェネレーションで次のガベージ コレクション (次回のガベージ コレクションではない場合もあります) が発生するまで、オブジェクトが解放されたかどうかは確認できません。</span><span class="sxs-lookup"><span data-stu-id="79075-248">Therefore, you have to wait until the next garbage collection that occurs on that generation (which is not necessarily the next garbage collection) to determine whether the object has been reclaimed.</span></span>  
  
 [<span data-ttu-id="79075-249">ページのトップへ</span><span class="sxs-lookup"><span data-stu-id="79075-249">Back to top</span></span>](#top)  
  
<a name="workstation_and_server_garbage_collection"></a>   
## <a name="workstation-and-server-garbage-collection"></a><span data-ttu-id="79075-250">ワークステーションとサーバーのガベージ コレクション</span><span class="sxs-lookup"><span data-stu-id="79075-250">Workstation and server garbage collection</span></span>  
 <span data-ttu-id="79075-251">ガベージ コレクターは、さまざまなシナリオに対応できるように自動的に調整されます。</span><span class="sxs-lookup"><span data-stu-id="79075-251">The garbage collector is self-tuning and can work in a wide variety of scenarios.</span></span> <span data-ttu-id="79075-252">構成ファイルの設定を使って、作業負荷の特性に基づいてガベージ コレクションの種類を設定できます。</span><span class="sxs-lookup"><span data-stu-id="79075-252">You can use a configuration file setting to set the type of garbage collection based on the characteristics of the workload.</span></span> <span data-ttu-id="79075-253">CLR には、次の種類のガベージ コレクションが用意されています。</span><span class="sxs-lookup"><span data-stu-id="79075-253">The CLR provides the following types of garbage collection:</span></span>  
  
- <span data-ttu-id="79075-254">ワークステーションのガベージ コレクション。すべてのクライアント ワークステーションとスタンドアロンの PC を対象としたオプションです。</span><span class="sxs-lookup"><span data-stu-id="79075-254">Workstation garbage collection, which is for all client workstations and stand-alone PCs.</span></span> <span data-ttu-id="79075-255">これは、ランタイム構成スキーマの [\<gcServer> 要素](../../../docs/framework/configure-apps/file-schema/runtime/gcserver-element.md)の既定の設定です。</span><span class="sxs-lookup"><span data-stu-id="79075-255">This is the default setting for the [\<gcServer> element](../../../docs/framework/configure-apps/file-schema/runtime/gcserver-element.md) in the runtime configuration schema.</span></span>  
  
     <span data-ttu-id="79075-256">ワークステーションのガベージ コレクションは、同時実行または非同時実行のどちらかで実行できます。</span><span class="sxs-lookup"><span data-stu-id="79075-256">Workstation garbage collection can be concurrent or non-concurrent.</span></span> <span data-ttu-id="79075-257">同時実行ガベージ コレクションでは、ガベージ コレクションの実行中にマネージド スレッドの操作を続けることができます。</span><span class="sxs-lookup"><span data-stu-id="79075-257">Concurrent garbage collection enables managed threads to continue operations during a garbage collection.</span></span>  
  
     <span data-ttu-id="79075-258">以降、.NET Framework 4 では、バック グラウンド ガベージ コレクションには、同時実行ガベージ コレクションが置き換えられます。</span><span class="sxs-lookup"><span data-stu-id="79075-258">Starting with the .NET Framework 4, background garbage collection replaces concurrent garbage collection.</span></span>  
  
- <span data-ttu-id="79075-259">サーバーのガベージ コレクション。高いスループットとスケーラビリティが必要なサーバー アプリケーションを対象としたオプションです。</span><span class="sxs-lookup"><span data-stu-id="79075-259">Server garbage collection, which is intended for server applications that need high throughput and scalability.</span></span> <span data-ttu-id="79075-260">サーバーのガベージ コレクションは、非同時実行ガベージ コレクションまたはバックグラウンド ガベージ コレクションである場合があります。</span><span class="sxs-lookup"><span data-stu-id="79075-260">Server garbage collection can be non-concurrent or background.</span></span>  
  
 <span data-ttu-id="79075-261">次の図は、サーバー上でガベージ コレクションを実行する専用のスレッドを示しています。</span><span class="sxs-lookup"><span data-stu-id="79075-261">The following illustration shows the dedicated threads that perform the garbage collection on a server.</span></span>  
  
 <span data-ttu-id="79075-262">![サーバー ガベージ コレクション スレッド](../../../docs/standard/garbage-collection/media/gc-server.png "GC_Server")</span><span class="sxs-lookup"><span data-stu-id="79075-262">![Server Garbage Collection Threads](../../../docs/standard/garbage-collection/media/gc-server.png "GC_Server")</span></span>  
<span data-ttu-id="79075-263">サーバー ガベージ コレクション</span><span class="sxs-lookup"><span data-stu-id="79075-263">Server garbage collection</span></span>  
  
### <a name="configuring-garbage-collection"></a><span data-ttu-id="79075-264">ガベージ コレクションの構成</span><span class="sxs-lookup"><span data-stu-id="79075-264">Configuring garbage collection</span></span>  
 <span data-ttu-id="79075-265">ランタイム構成スキーマの [\<gcServer> 要素](../../../docs/framework/configure-apps/file-schema/runtime/gcserver-element.md)を使用して、CLR で実行するガベージ コレクションの種類を指定できます。</span><span class="sxs-lookup"><span data-stu-id="79075-265">You can use the [\<gcServer> element](../../../docs/framework/configure-apps/file-schema/runtime/gcserver-element.md) of the runtime configuration schema to specify the type of garbage collection you want the CLR to perform.</span></span> <span data-ttu-id="79075-266">この要素の `enabled` 属性が `false` (既定値) に設定されている場合、ワークステーションのガベージ コレクションが実行されます。</span><span class="sxs-lookup"><span data-stu-id="79075-266">When this element's `enabled` attribute is set to `false` (the default), the CLR performs workstation garbage collection.</span></span> <span data-ttu-id="79075-267">`enabled` 属性を `true`に設定すると、サーバーのガベージ コレクションが実行されます。</span><span class="sxs-lookup"><span data-stu-id="79075-267">When you set the `enabled` attribute to `true`, the CLR performs server garbage collection.</span></span>  
  
 <span data-ttu-id="79075-268">同時実行ガベージ コレクションは、ランタイム構成スキーマの [\<gcConcurrent> 要素](../../../docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md)を使用して指定します。</span><span class="sxs-lookup"><span data-stu-id="79075-268">Concurrent garbage collection is specified with the [\<gcConcurrent> element](../../../docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) of the runtime configuration schema.</span></span> <span data-ttu-id="79075-269">既定値は `enabled`です。</span><span class="sxs-lookup"><span data-stu-id="79075-269">The default setting is `enabled`.</span></span> <span data-ttu-id="79075-270">この設定は、同時実行ガベージ コレクションとバックグラウンド ガベージ コレクションの両方を制御します。</span><span class="sxs-lookup"><span data-stu-id="79075-270">This setting controls both concurrent and background garbage collection.</span></span>  
  
 <span data-ttu-id="79075-271">サーバーのガベージ コレクションは、アンマネージ ホスト インターフェイスを使用して指定することもできます。</span><span class="sxs-lookup"><span data-stu-id="79075-271">You can also specify server garbage collection with unmanaged hosting interfaces.</span></span> <span data-ttu-id="79075-272">ASP.NET および SQL Server では、アプリケーションがそのいずれかの環境内でホストされている場合、自動的にサーバーのガベージ コレクションが有効になることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="79075-272">Note that ASP.NET and SQL Server enable server garbage collection automatically if your application is hosted inside one of these environments.</span></span>  
  
### <a name="comparing-workstation-and-server-garbage-collection"></a><span data-ttu-id="79075-273">ワークステーションとサーバーのガベージ コレクションの比較</span><span class="sxs-lookup"><span data-stu-id="79075-273">Comparing workstation and server garbage collection</span></span>  
 <span data-ttu-id="79075-274">ワークステーションのガベージ コレクションにおける、スレッド処理とパフォーマンスについての注意点を次に示します。</span><span class="sxs-lookup"><span data-stu-id="79075-274">The following are threading and performance considerations for workstation garbage collection:</span></span>  
  
- <span data-ttu-id="79075-275">コレクションは、ガベージ コレクションをトリガーしたユーザー スレッドで、それと同じ優先順位で実行されます。</span><span class="sxs-lookup"><span data-stu-id="79075-275">The collection occurs on the user thread that triggered the garbage collection and remains at the same priority.</span></span> <span data-ttu-id="79075-276">ユーザー スレッドは一般に通常の優先順位で実行されるため、その場合 (通常の優先順位のスレッドで実行された場合)、ガベージ コレクターの CPU 時間が他のスレッドと競合します。</span><span class="sxs-lookup"><span data-stu-id="79075-276">Because user threads typically run at normal priority, the garbage collector (which runs on a normal priority thread) must compete with other threads for CPU time.</span></span>  
  
     <span data-ttu-id="79075-277">ネイティブ コードを実行しているスレッドは中断されません。</span><span class="sxs-lookup"><span data-stu-id="79075-277">Threads that are running native code are not suspended.</span></span>  
  
- <span data-ttu-id="79075-278">プロセッサが 1 つしかないコンピューターでは、[\<gcServer>](../../../docs/framework/configure-apps/file-schema/runtime/gcserver-element.md) の設定に関係なく、常にワークステーションのガベージ コレクションが使用されます。</span><span class="sxs-lookup"><span data-stu-id="79075-278">Workstation garbage collection is always used on a computer that has only one processor, regardless of the [\<gcServer>](../../../docs/framework/configure-apps/file-schema/runtime/gcserver-element.md) setting.</span></span> <span data-ttu-id="79075-279">サーバーのガベージ コレクションを指定した場合、CLR は、コンカレンシーを無効にしてワークステーションのガベージ コレクションを使用します。</span><span class="sxs-lookup"><span data-stu-id="79075-279">If you specify server garbage collection, the CLR uses workstation garbage collection with concurrency disabled.</span></span>  
  
 <span data-ttu-id="79075-280">サーバーのガベージ コレクションにおける、スレッド処理とパフォーマンスについての注意点を次に示します。</span><span class="sxs-lookup"><span data-stu-id="79075-280">The following are threading and performance considerations for server garbage collection:</span></span>  
  
- <span data-ttu-id="79075-281">コレクションは、 `THREAD_PRIORITY_HIGHEST` の優先順位で実行される複数の専用スレッドで実行されます。</span><span class="sxs-lookup"><span data-stu-id="79075-281">The collection occurs on multiple dedicated threads that are running at `THREAD_PRIORITY_HIGHEST` priority level.</span></span>  
  
- <span data-ttu-id="79075-282">ヒープおよびガベージ コレクションを実行するための専用スレッドは CPU ごとに 1 つずつ用意され、複数のヒープのコレクションが同時に行われます。</span><span class="sxs-lookup"><span data-stu-id="79075-282">A heap and a dedicated thread to perform garbage collection are provided for each CPU, and the heaps are collected at the same time.</span></span> <span data-ttu-id="79075-283">各ヒープには小さなオブジェクト ヒープと大きなオブジェクト ヒープがあり、どのヒープもユーザー コードからアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="79075-283">Each heap contains a small object heap and a large object heap, and all heaps can be accessed by user code.</span></span> <span data-ttu-id="79075-284">異なるヒープのオブジェクトを相互に参照できます。</span><span class="sxs-lookup"><span data-stu-id="79075-284">Objects on different heaps can refer to each other.</span></span>  
  
- <span data-ttu-id="79075-285">複数のガベージ コレクション スレッドが連携して処理を行うため、同じサイズのヒープを処理した場合、サーバーのガベージ コレクションの方がワークステーションのガベージ コレクションよりも高速です。</span><span class="sxs-lookup"><span data-stu-id="79075-285">Because multiple garbage collection threads work together, server garbage collection is faster than workstation garbage collection on the same size heap.</span></span>  
  
- <span data-ttu-id="79075-286">一般に、サーバーのガベージ コレクションの方が、格納されるセグメントのサイズは大きくなります。</span><span class="sxs-lookup"><span data-stu-id="79075-286">Server garbage collection often has larger size segments.</span></span> <span data-ttu-id="79075-287">ただし、これは一般論に過ぎません。セグメントのサイズは実装に固有であり、変更されることがあります。</span><span class="sxs-lookup"><span data-stu-id="79075-287">Note, however, that this is only a generalization: segment size is implementation-specific and is subject to change.</span></span> <span data-ttu-id="79075-288">アプリをチューニングする時に、ガベージ コレクターによって割り当てられるセグメントのサイズに関して何らかの仮定をすることは避けてください。</span><span class="sxs-lookup"><span data-stu-id="79075-288">You should make no assumptions about the size of segments allocated by the garbage collector when tuning your app.</span></span>  
  
- <span data-ttu-id="79075-289">サーバーのガベージ コレクションでは、リソースが大量に消費されることがあります。</span><span class="sxs-lookup"><span data-stu-id="79075-289">Server garbage collection can be resource-intensive.</span></span> <span data-ttu-id="79075-290">たとえば、4 つのプロセッサを搭載したコンピューターで 12 のプロセスを実行する場合、そのすべてでサーバーのガベージ コレクションを使用するには、48 の専用のガベージ コレクション スレッドが必要です。</span><span class="sxs-lookup"><span data-stu-id="79075-290">For example, if you have 12 processes running on a computer that has 4 processors, there will be 48 dedicated garbage collection threads if they are all using server garbage collection.</span></span> <span data-ttu-id="79075-291">メモリの負荷が高い状況で、すべてのプロセスがガベージ コレクションの処理を開始した場合、ガベージ コレクターは 48 のスレッドをスケジュールすることになります。</span><span class="sxs-lookup"><span data-stu-id="79075-291">In a high memory load situation, if all the processes start doing garbage collection, the garbage collector will have 48 threads to schedule.</span></span>  
  
 <span data-ttu-id="79075-292">実行するアプリケーションのインスタンスが数百に及ぶ場合は、同時実行ガベージ コレクションを無効にしてワークステーションのガベージ コレクションを使用することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="79075-292">If you are running hundreds of instances of an application, consider using workstation garbage collection with concurrent garbage collection disabled.</span></span> <span data-ttu-id="79075-293">これによって、コンテキストの切り替えが少なくなり、パフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="79075-293">This will result in less context switching, which can improve performance.</span></span>  
  
 [<span data-ttu-id="79075-294">ページのトップへ</span><span class="sxs-lookup"><span data-stu-id="79075-294">Back to top</span></span>](#top)  
  
<a name="concurrent_garbage_collection"></a>   
## <a name="concurrent-garbage-collection"></a><span data-ttu-id="79075-295">同時実行ガベージ コレクション</span><span class="sxs-lookup"><span data-stu-id="79075-295">Concurrent garbage collection</span></span>  
 <span data-ttu-id="79075-296">ワークステーションまたはサーバーのガベージ コレクションでは、同時実行ガベージ コレクションを有効にすることで、複数のスレッドを同時に実行できます。同時実行ガベージ コレクションでは、コレクションの実行中は、ほとんどの場合、ガベージ コレクションの処理を行う専用のスレッドが使用されます。</span><span class="sxs-lookup"><span data-stu-id="79075-296">In workstation or server garbage collection, you can enable concurrent garbage collection, which enables threads to run concurrently with a dedicated thread that performs the garbage collection for most of the duration of the collection.</span></span> <span data-ttu-id="79075-297">このオプションは、ジェネレーション 2 のガベージ コレクションにのみ影響します。ジェネレーション 0 と 1 の処理はすぐに終了するため、常に非同時実行で行われます。</span><span class="sxs-lookup"><span data-stu-id="79075-297">This option affects only garbage collections in generation 2; generations 0 and 1 are always non-concurrent because they finish very fast.</span></span>  
  
 <span data-ttu-id="79075-298">同時実行ガベージ コレクションでは、コレクションの一時停止を最小限にすることで、インタラクティブ アプリケーションの応答性を高めることができます。</span><span class="sxs-lookup"><span data-stu-id="79075-298">Concurrent garbage collection enables interactive applications to be more responsive by minimizing pauses for a collection.</span></span> <span data-ttu-id="79075-299">マネージド スレッドは、同時実行ガベージ コレクションのスレッドが実行されている間も、ほぼ常に処理を続けることができます。</span><span class="sxs-lookup"><span data-stu-id="79075-299">Managed threads can continue to run most of the time while the concurrent garbage collection thread is running.</span></span> <span data-ttu-id="79075-300">そのため、ガベージ コレクションの実行中の一時停止が短くなります。</span><span class="sxs-lookup"><span data-stu-id="79075-300">This results in shorter pauses while a garbage collection is occurring.</span></span>  
  
 <span data-ttu-id="79075-301">複数のプロセスを実行している場合にパフォーマンスを向上させるには、同時実行ガベージ コレクションを無効にします。</span><span class="sxs-lookup"><span data-stu-id="79075-301">To improve performance when several processes are running, disable concurrent garbage collection.</span></span> <span data-ttu-id="79075-302">[\<gcConcurrent> 要素](../../../docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md)をアプリの構成ファイルに追加し、`enabled` 属性の値を `"false"` に設定することで、これを行うことができます。</span><span class="sxs-lookup"><span data-stu-id="79075-302">You can do this by adding a [\<gcConcurrent> element](../../../docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) to the app's configuration file and setting the value of its `enabled` attribute to `"false"`.</span></span>  
  
 <span data-ttu-id="79075-303">同時実行ガベージ コレクションは、専用のスレッドで実行されます。</span><span class="sxs-lookup"><span data-stu-id="79075-303">Concurrent garbage collection is performed on a dedicated thread.</span></span> <span data-ttu-id="79075-304">既定では、CLR は、同時実行ガベージ コレクションを有効にしてワークステーションのガベージ コレクションを実行します。</span><span class="sxs-lookup"><span data-stu-id="79075-304">By default, the CLR runs workstation garbage collection with concurrent garbage collection enabled.</span></span> <span data-ttu-id="79075-305">これは、シングルプロセッサのコンピューターでもマルチプロセッサのコンピューターでも同じです。</span><span class="sxs-lookup"><span data-stu-id="79075-305">This is true for single-processor and multi-processor computers.</span></span>  
  
 <span data-ttu-id="79075-306">同時実行ガベージ コレクションの実行中にヒープに小さなオブジェクトを割り当てる機能は、同時実行ガベージ コレクションの開始時に短期セグメントに残っていたオブジェクトによって制限されます。</span><span class="sxs-lookup"><span data-stu-id="79075-306">Your ability to allocate small objects on the heap during a concurrent garbage collection is limited by the objects left on the ephemeral segment when a concurrent garbage collection starts.</span></span> <span data-ttu-id="79075-307">セグメントの最後に達した後は、同時実行ガベージ コレクションが終了するまで、小さなオブジェクトを割り当てる必要があるマネージド スレッドは中断されたままになります。</span><span class="sxs-lookup"><span data-stu-id="79075-307">As soon as you reach the end of the segment, you will have to wait for the concurrent garbage collection to finish while managed threads that have to make small object allocations are suspended.</span></span>  
  
 <span data-ttu-id="79075-308">同時実行ガベージ コレクションのワーキング セットは、同時実行コレクションの実行中にオブジェクトを割り当てることができるように (非同時実行ガベージ コレクションに比べて) 若干大きくなっています。</span><span class="sxs-lookup"><span data-stu-id="79075-308">Concurrent garbage collection has a slightly bigger working set (compared with non-concurrent garbage collection), because you can allocate objects during concurrent collection.</span></span> <span data-ttu-id="79075-309">ただし、オブジェクトを割り当てるとそれもワーキング セットの一部になるため、パフォーマンスに影響することがあります。</span><span class="sxs-lookup"><span data-stu-id="79075-309">However, this can affect performance, because the objects that you allocate become part of your working set.</span></span> <span data-ttu-id="79075-310">基本的に、同時実行ガベージ コレクションでは、ある程度の CPU およびメモリと引き換えに一時停止が短くなります。</span><span class="sxs-lookup"><span data-stu-id="79075-310">Essentially, concurrent garbage collection trades some CPU and memory for shorter pauses.</span></span>  
  
 <span data-ttu-id="79075-311">次の図は、別々の専用のスレッドで実行される同時実行ガベージ コレクションを示しています。</span><span class="sxs-lookup"><span data-stu-id="79075-311">The following illustration shows concurrent garbage collection performed on a separate dedicated thread.</span></span>  
  
 <span data-ttu-id="79075-312">![同時実行ガベージ コレクションのスレッド](../../../docs/standard/garbage-collection/media/gc-concurrent.png "GC_Concurrent")</span><span class="sxs-lookup"><span data-stu-id="79075-312">![Concurrent Garbage Collection Threads](../../../docs/standard/garbage-collection/media/gc-concurrent.png "GC_Concurrent")</span></span>  
<span data-ttu-id="79075-313">同時実行ガベージ コレクション</span><span class="sxs-lookup"><span data-stu-id="79075-313">Concurrent garbage collection</span></span>  
  
 [<span data-ttu-id="79075-314">ページのトップへ</span><span class="sxs-lookup"><span data-stu-id="79075-314">Back to top</span></span>](#top)  
  
<a name="background_garbage_collection"></a>   
## <a name="background-workstation-garbage-collection"></a><span data-ttu-id="79075-315">バックグラウンド ワークステーション ガベージ コレクション</span><span class="sxs-lookup"><span data-stu-id="79075-315">Background workstation garbage collection</span></span>  
 <span data-ttu-id="79075-316">バックグラウンド ガベージ コレクションでは、ジェネレーション 2 のコレクションの実行中に、必要に応じて短期ジェネレーション (0 および 1) のコレクションが行われます。</span><span class="sxs-lookup"><span data-stu-id="79075-316">In background garbage collection, ephemeral generations (0 and 1) are collected as needed while the collection of generation 2 is in progress.</span></span> <span data-ttu-id="79075-317">バックグラウンド ガベージ コレクションの設定はありません。同時実行ガベージ コレクションを有効にすると自動的に有効になります。</span><span class="sxs-lookup"><span data-stu-id="79075-317">There is no setting for background garbage collection; it is automatically enabled with concurrent garbage collection.</span></span> <span data-ttu-id="79075-318">バックグラウンド ガベージ コレクションは同時実行ガベージ コレクションに代わるものです。</span><span class="sxs-lookup"><span data-stu-id="79075-318">Background garbage collection is a replacement for concurrent garbage collection.</span></span> <span data-ttu-id="79075-319">同時実行ガベージ コレクションと同様に、バックグラウンド ガベージ コレクションは専用のスレッドで実行され、ジェネレーション 2 のコレクションにのみ適用されます。</span><span class="sxs-lookup"><span data-stu-id="79075-319">As with concurrent garbage collection, background garbage collection is performed on a dedicated thread and is applicable only to generation 2 collections.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="79075-320">バックグラウンド ガベージ コレクションは、.NET Framework 4 以降のバージョンでのみ使用できます。</span><span class="sxs-lookup"><span data-stu-id="79075-320">Background garbage collection is available only in the .NET Framework 4 and later versions.</span></span> <span data-ttu-id="79075-321">.NET Framework 4 では、ワークステーション ガベージ コレクションのみでサポートされます。</span><span class="sxs-lookup"><span data-stu-id="79075-321">In the .NET Framework 4, it is supported only for workstation garbage collection.</span></span> <span data-ttu-id="79075-322">.NET Framework 4.5 以降では、バックグラウンド ガベージ コレクションは、ワークステーションとサーバーのガベージ コレクションの両方で使用できます。</span><span class="sxs-lookup"><span data-stu-id="79075-322">Starting with the .NET Framework 4.5, background garbage collection is available for both workstation and server garbage collection.</span></span>  
  
 <span data-ttu-id="79075-323">バックグラウンド ガベージ コレクションの実行中に行われる短期ジェネレーションに対するコレクションのことを、フォアグラウンド ガベージ コレクションと呼びます。</span><span class="sxs-lookup"><span data-stu-id="79075-323">A collection on ephemeral generations during background garbage collection is known as foreground garbage collection.</span></span> <span data-ttu-id="79075-324">フォアグラウンド ガベージ コレクションが発生すると、マネージド スレッドはすべて中断されます。</span><span class="sxs-lookup"><span data-stu-id="79075-324">When foreground garbage collections occur, all managed threads are suspended.</span></span>  
  
 <span data-ttu-id="79075-325">バックグラウンド ガベージ コレクションの実行中にジェネレーション 0 に十分なオブジェクトが割り当てられていれば、CLR はジェネレーション 0 またはジェネレーション 1 のフォアグラウンド ガベージ コレクションを実行します。</span><span class="sxs-lookup"><span data-stu-id="79075-325">When background garbage collection is in progress and you have allocated enough objects in generation 0, the CLR performs a generation 0 or generation 1 foreground garbage collection.</span></span> <span data-ttu-id="79075-326">バックグラウンド ガベージ コレクションの専用スレッドは、フォアグラウンド ガベージ コレクションの要求がないかどうかをセーフ ポイントで頻繁に確認します。</span><span class="sxs-lookup"><span data-stu-id="79075-326">The dedicated background garbage collection thread checks at frequent safe points to determine whether there is a request for foreground garbage collection.</span></span> <span data-ttu-id="79075-327">要求があると、バックグラウンド コレクションを中断して、フォアグラウンド ガベージ コレクションを実行します。</span><span class="sxs-lookup"><span data-stu-id="79075-327">If there is, the background collection suspends itself so that foreground garbage collection can occur.</span></span> <span data-ttu-id="79075-328">フォアグラウンド ガベージ コレクションが完了すると、バックグラウンド ガベージ コレクションの専用スレッドとユーザー スレッドが再開されます。</span><span class="sxs-lookup"><span data-stu-id="79075-328">After the foreground garbage collection is completed, the dedicated background garbage collection thread and user threads resume.</span></span>  
  
 <span data-ttu-id="79075-329">バックグラウンド ガベージ コレクションでは、バックグラウンド ガベージ コレクションの実行中に短期ガベージ コレクションが発生する可能性があるため、同時実行ガベージ コレクションによる割り当ての制限が解除されます。</span><span class="sxs-lookup"><span data-stu-id="79075-329">Background garbage collection removes allocation restrictions imposed by concurrent garbage collection, because ephemeral garbage collections can occur during background garbage collection.</span></span> <span data-ttu-id="79075-330">つまり、バックグラウンド ガベージ コレクションで短期ジェネレーションの使用されなくなったオブジェクトを削除でき、また、ジェネレーション 1 のガベージ コレクションの実行中に必要に応じてヒープを拡張することもできます。</span><span class="sxs-lookup"><span data-stu-id="79075-330">This means that background garbage collection can remove dead objects in ephemeral generations and can also expand the heap if needed during a generation 1 garbage collection.</span></span>  
  
<span data-ttu-id="79075-331">次の図は、ワークステーション上の別々の専用スレッドで実行されるバックグラウンド ガベージ コレクションを示しています。</span><span class="sxs-lookup"><span data-stu-id="79075-331">The following illustration shows background garbage collection performed on a separate dedicated thread on a workstation:</span></span>
  
 ![バックグラウンド ワークステーション ガベージ コレクションを示す図。](./media/fundamentals/background-workstation-garbage-collection.png)
   
 [<span data-ttu-id="79075-333">ページのトップへ</span><span class="sxs-lookup"><span data-stu-id="79075-333">Back to top</span></span>](#top)  
  
<a name="background_server_garbage_collection"></a>   
## <a name="background-server-garbage-collection"></a><span data-ttu-id="79075-334">バックグラウンド サーバー ガベージ コレクション</span><span class="sxs-lookup"><span data-stu-id="79075-334">Background server garbage collection</span></span>  
 <span data-ttu-id="79075-335">.NET Framework 4.5 以降では、サーバーのバックグラウンド ガベージ コレクションは、サーバーのガベージ コレクションの既定のモードです。</span><span class="sxs-lookup"><span data-stu-id="79075-335">Starting with the .NET Framework 4.5, background server garbage collection is the default mode for server garbage collection.</span></span> <span data-ttu-id="79075-336">このモードを選択するには、ランタイム構成スキーマで [\<gcServer> 要素](../../../docs/framework/configure-apps/file-schema/runtime/gcserver-element.md)の `enabled` 属性を `true` に設定します。</span><span class="sxs-lookup"><span data-stu-id="79075-336">To choose this mode, set the `enabled` attribute of the [\<gcServer> element](../../../docs/framework/configure-apps/file-schema/runtime/gcserver-element.md) to `true` in the runtime configuration schema.</span></span> <span data-ttu-id="79075-337">このモードは、前のセクションで説明したワークステーションのバックグラウンド ガベージ コレクションと同様に機能しますが、いくつかの違いがあります。</span><span class="sxs-lookup"><span data-stu-id="79075-337">This mode functions similarly to background workstation garbage collection, described in the previous section, but there are a few differences.</span></span> <span data-ttu-id="79075-338">ワークステーションのバックグラウンド ガベージ コレクションでは専用のバックグラウンド ガベージ コレクション スレッドを 1 つ使用します。これに対して、サーバーのバックグラウンド ガベージ コレクションでは複数のスレッドを使用し、通常、論理プロセッサごとに専用のスレッドが使用されます。</span><span class="sxs-lookup"><span data-stu-id="79075-338">Background workstation garbage collection uses one dedicated background garbage collection thread, whereas background server garbage collection uses multiple threads, typically a dedicated thread for each logical processor.</span></span> <span data-ttu-id="79075-339">ワークステーションのバックグラウンド ガベージ コレクション スレッドとは異なり、これらのスレッドはタイムアウトになりません。</span><span class="sxs-lookup"><span data-stu-id="79075-339">Unlike the workstation background garbage collection thread, these threads do not time out.</span></span>  
  
 <span data-ttu-id="79075-340">次の図は、サーバー上の別々の専用スレッドで実行されるバックグラウンド ガベージ コレクションを示しています。</span><span class="sxs-lookup"><span data-stu-id="79075-340">The following illustration shows background garbage collection performed on a separate dedicated thread on a server:</span></span>  
  
 ![バックグラウンド サーバー ガベージ コレクションを示す図。](./media/fundamentals/background-server-garbage-collection.png)  
  
## <a name="see-also"></a><span data-ttu-id="79075-342">関連項目</span><span class="sxs-lookup"><span data-stu-id="79075-342">See also</span></span>

- [<span data-ttu-id="79075-343">ガベージ コレクション</span><span class="sxs-lookup"><span data-stu-id="79075-343">Garbage Collection</span></span>](../../../docs/standard/garbage-collection/index.md)
