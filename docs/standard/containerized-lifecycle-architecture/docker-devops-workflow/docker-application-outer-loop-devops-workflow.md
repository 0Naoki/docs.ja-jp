---
title: "Docker アプリケーションの外側のループ DevOps ワークフローの手順を実行します。"
description: "Microsoft プラットフォームとツールが、Docker のコンテナー化アプリケーションのライフ サイクル"
keywords: "Docker, マイクロサービス, ASP.NET, コンテナー"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 09/22/2017
ms.openlocfilehash: 070d174cde9e80f542865f5617b1c702a07a8018
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/21/2017
---
# <a name="steps-in-the-outer-loop-devops-workflow-for-a-docker-application"></a><span data-ttu-id="1dbd8-104">Docker アプリケーションの外側のループ DevOps ワークフローの手順を実行します。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-104">Steps in the outer-loop DevOps workflow for a Docker application</span></span>

<span data-ttu-id="1dbd8-105">図 5-1 では、DevOps 外側のループのワークフローを構成する手順の説明、エンド ツー エンドの図を表示します。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-105">Figure 5-1 presents an end-to-end depiction of the steps comprising the DevOps outer-loop workflow.</span></span>

![](./media/image1.png)

<span data-ttu-id="1dbd8-106">Microsoft ツールと Docker のアプリケーションの図 5-1: DevOps 外側のループのワークフロー</span><span class="sxs-lookup"><span data-stu-id="1dbd8-106">Figure 5-1: DevOps outer-loop workflow for Docker applications with Microsoft tools</span></span>

<span data-ttu-id="1dbd8-107">ここで、これらの各手順で詳しく調べてみましょう。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-107">Now, let's examine each of these steps in greater detail.</span></span>

## <a name="step-1-inner-loop-development-workflow"></a><span data-ttu-id="1dbd8-108">手順 1: 内部ループ開発ワークフロー</span><span class="sxs-lookup"><span data-stu-id="1dbd8-108">Step 1: Inner-loop development workflow</span></span>

<span data-ttu-id="1dbd8-109">この手順の第 4 章で詳しく説明していますに要約すると、ここでは外側のループ開始位置となる、開発者が CI パイプライン アクションの開始 (Git) のようなソース管理の管理システムにコードをプッシュする時点。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-109">This step is explained in detail in Chapter 4, but, to recap, here is where the outer-loop begins, the moment at which a developer pushes code to the source control management system (like Git) initiating CI pipeline actions.</span></span>

## <a name="step-2-source-code-control-integration-and-management-with-visual-studio-team-services-and-git"></a><span data-ttu-id="1dbd8-110">手順 2: ソース コード管理の統合と Visual Studio Team Services および Git と管理</span><span class="sxs-lookup"><span data-stu-id="1dbd8-110">Step 2: Source-Code Control integration and management with Visual Studio Team Services and Git</span></span>

<span data-ttu-id="1dbd8-111">この手順で、チーム内で複数の開発者からのすべてのコードの統合のバージョンを収集するバージョン コントロール システムに用意する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-111">At this step, you need to have a version-control system to gather a consolidated version of all the code coming from the different developers in the team.</span></span>

<span data-ttu-id="1dbd8-112">アプリケーションに Docker イメージを送信する必要がありますいないを強調する重要な場合でも、ソース コード管理 (SCC) とソース コード管理には、1 秒性質 DevOps ライフで Docker アプリケーションを作成するときにほとんどの開発者のサイクルがないように見えるあります、直接、グローバル Docker レジストリに (Azure コンテナー レジストリや Docker Hub) など、開発者のマシンからです。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-112">Even though source-code control (SCC) and source-code management might seem second-nature to most developers, when creating Docker applications in a DevOps life cycle, it is critical to emphasize that you must not submit the Docker images with the application directly to the global Docker Registry (like Azure Container Registry or Docker Hub) from the developer's machine.</span></span> <span data-ttu-id="1dbd8-113">反対に、グローバル ビルドまたは (Git) のようなソース コード リポジトリに基づく CI パイプラインでは統合されているソース コードでのみがリリースされ、運用環境に展開するには、Docker イメージを作成しなければなりません。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-113">On the contrary, the Docker images to be released and deployed to production environments must be created solely on the source code that is being integrated in your global build or CI pipeline based on your source-code repository (like Git).</span></span>

<span data-ttu-id="1dbd8-114">独自のマシン内でテストするときに、開発者だけでそれ自体には、開発者によって生成されるローカルのイメージを使用してください。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-114">The local images generated by the developers themselves should be used just by the developers when testing within their own machines.</span></span> <span data-ttu-id="1dbd8-115">これは、DevOps パイプライン SCC コードからアクティブ化が必要であるためです。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-115">This is why it is critical to have the DevOps pipeline activated from the SCC code.</span></span>

<span data-ttu-id="1dbd8-116">Visual Studio Team Services と Team Foundation Server は、Git と Team Foundation バージョン管理をサポートします。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-116">Visual Studio Team Services and Team Foundation Server support Git and Team Foundation Version Control.</span></span> <span data-ttu-id="1dbd8-117">それらの間を選択して、エンド ツー エンドの Microsoft のエクスペリエンスを使用します。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-117">You can choose between them and use it for an end-to-end Microsoft experience.</span></span> <span data-ttu-id="1dbd8-118">ただし、管理することもできます (GitHub、内部設置型の Git リポジトリ、Subversion など) の外部のリポジトリで自分のコードに接続して、DevOps CI パイプラインの開始点として、コードを取得することもできます。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-118">However, you also can manage your code in external repositories (like GitHub, on-premises Git repositories, or Subversion) and still be able to connect to it and get the code as the starting point for your DevOps CI pipeline.</span></span>

## <a name="step-3-build-ci-integrate-and-test-with-visual-studio-team-services-and-docker"></a><span data-ttu-id="1dbd8-119">手順 3: ビルド、構成項目、統合、および Visual Studio Team Services と Docker を使用してテスト</span><span class="sxs-lookup"><span data-stu-id="1dbd8-119">Step 3: Build, CI, Integrate, and Test with Visual Studio Team Services and Docker</span></span>

<span data-ttu-id="1dbd8-120">最新のソフトウェアのテストおよび配信のための標準として CI が生じました。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-120">CI has emerged as a standard for modern software testing and delivery.</span></span> <span data-ttu-id="1dbd8-121">Docker ソリューションでは、開発と運用チーム間での問題を明確に分離を維持します。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-121">The Docker solution maintains a clear separation of concerns between the development and operations teams.</span></span> <span data-ttu-id="1dbd8-122">Docker images の不変性により、どのような開発、テスト CI、を通じてし、実稼働環境で実行の間で反復可能な配置。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-122">The immutability of Docker images ensures a repeatable deployment between what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="1dbd8-123">開発者ラップトップの docker エンジンが展開されているし、テスト インフラストラクチャは、環境間でのコンテナーをポータブルです。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-123">Docker Engine deployed across the developer laptops and test infrastructure makes the containers portable across environments.</span></span>

<span data-ttu-id="1dbd8-124">この時点では、送信の正しいコードのバージョン管理システムにある場合は、後にする必要があります、*ビルド サービス*にコードを取得し、グローバルのビルドとテストを実行します。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-124">At this point, after you have a version-control system with the correct code submitted, you need a *build service* to pick up the code and run the global build and tests.</span></span>

<span data-ttu-id="1dbd8-125">ここでは (構成項目、ビルド、テスト) の内部ワークフローでは、コード リポジトリ (Git など)、ビルド サーバーに、(Visual Studio Team Services)、Docker エンジンと Docker のレジストリで構成される CI パイプラインの構築に関するです。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-125">The internal workflow for this step (CI, build, test) is about the construction of a CI pipeline consisting of your code repository (Git, etc.), your build server (Visual Studio Team Services), Docker Engine, and a Docker Registry.</span></span>

<span data-ttu-id="1dbd8-126">行えます Visual Studio Team Services 基盤としてのアプリケーションを構築および、CI パイプラインを設定し、組み込みの「アイテム」を公開するため"アーティファクト リポジトリに、"次の手順で説明されています。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-126">You can use Visual Studio Team Services as the foundation for building your applications and setting your CI pipeline, and for publishing the built "artifacts" to an "artifacts repository," which is explained in the next step.</span></span>

<span data-ttu-id="1dbd8-127">Docker を使用して、展開、「最終的なアイテム」のときに展開するのには、アプリケーションまたはサービスを使用してイメージを Docker 内に埋め込まれます。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-127">When using Docker for the deployment, the "final artifacts" to be deployed are Docker images with your application or services embedded within them.</span></span> <span data-ttu-id="1dbd8-128">それらのイメージのプッシュまたはに発行された、 *Docker レジストリ*(Azure コンテナー レジストリに持つことができますなまたは Docker Hub レジストリには、一般的な公式の基本イメージの使用と同様にパブリックのいずれかのようにプライベート リポジトリ)。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-128">Those images are pushed or published to a *Docker Registry* (a private repository like the ones you can have in Azure Container Registry, or a public one like Docker Hub Registry, which is commonly used for official base images).</span></span>

<span data-ttu-id="1dbd8-129">ここでは、基本的な概念: 構成項目のパイプラインは Git などのソース コード管理リポジトリへのコミットによってオフ開始になります。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-129">Here is the basic concept: The CI pipeline will be kicked-off by a commit to an SCC repository like Git.</span></span> <span data-ttu-id="1dbd8-130">図 5-2 に示すように、コミットは Docker コンテナー内でビルド ジョブを実行し、そのジョブの正常完了時に、Docker イメージを Docker レジストリにプッシュする Visual Studio Team Services になります。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-130">The commit will cause Visual Studio Team Services to run a build job within a Docker container and, upon successful completion of that job, push a Docker image to the Docker Registry, as illustrated in Figure 5-2.</span></span>

![](./media/image2.png)

<span data-ttu-id="1dbd8-131">図 5-2: 必要な手順で構成項目</span><span class="sxs-lookup"><span data-stu-id="1dbd8-131">Figure 5-2: The steps involved in CI</span></span>

<span data-ttu-id="1dbd8-132">Docker と Visual Studio Team Services でワークフローの構成項目の基本的な手順を次に示します。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-132">Here are the basic CI workflow steps with Docker and Visual Studio Team Services:</span></span>

1.  <span data-ttu-id="1dbd8-133">開発者は、(Git または Visual Studio Team Services、GitHub など) のソース コード管理リポジトリへのコミットをプッシュします。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-133">The developer pushes a commit to an SCC repository (Git/Visual Studio Team Services, GitHub, etc.).</span></span>

2.  <span data-ttu-id="1dbd8-134">Visual Studio Team Services または Git を使用している構成項目は、Visual Studio Team Services で、チェック ボックスを選択するだけであることを意味するには、構築されます。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-134">If you're using Visual Studio Team Services or Git, CI is built in, which means that it is as simple as selecting a check box in Visual Studio Team Services.</span></span> <span data-ttu-id="1dbd8-135">(GitHub) などの外部の SCC を使用している場合、 *webhook*更新プログラムの Visual Studio Team Services の通知または Git と GitHub にプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-135">If you're using an external SCC (like GitHub), a *webhook* will notify Visual Studio Team Services of the update or push to Git/GitHub.</span></span>

3.  <span data-ttu-id="1dbd8-136">Visual Studio Team Services では、イメージだけでなく、アプリケーションおよびテストのコードを記述する、DockerFile を含む、ソース コード管理リポジトリを取得します。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-136">Visual Studio Team Services pulls the SCC repository, including the DockerFile describing the image as well as the application and test code.</span></span>

4.  <span data-ttu-id="1dbd8-137">Visual Studio Team Services では、Docker イメージをビルドし、ビルド番号のラベル付けします。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-137">Visual Studio Team Services builds a Docker image and labels it with a build number.</span></span>

5.  <span data-ttu-id="1dbd8-138">Visual Studio Team Services では、プロビジョニング済みの Docker ホスト内で、Docker コンテナーをインスタンス化し、適切なテストを実行します。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-138">Visual Studio Team Services instantiates the Docker container within the provisioned Docker Host, and runs the appropriate tests.</span></span>

6.  <span data-ttu-id="1dbd8-139">「試みられたビルド」がわかるように、イメージが最初にわかりやすい名前を付け、テストが成功した場合は、(のように"/1.0.0"またはその他の任意のラベル)、Docker レジストリ (Docker Hub、Azure にコンテナー レジストリ、DTR など) プッシュし、</span><span class="sxs-lookup"><span data-stu-id="1dbd8-139">If the tests are successful, the image is first relabeled to a meaningful name so that you know it is a "blessed build" (like "/1.0.0" or any other label), and then pushed up to your Docker Registry (Docker Hub, Azure Container Registry, DTR, etc.)</span></span>

### <a name="implementing-the-ci-pipeline-with-visual-studio-team-services-and-the-docker-extension-for-visual-studio-team-services"></a><span data-ttu-id="1dbd8-140">Visual Studio Team Services 用の Visual Studio Team Services と Docker 拡張機能を使用して、CI パイプラインの実装</span><span class="sxs-lookup"><span data-stu-id="1dbd8-140">Implementing the CI pipeline with Visual Studio Team Services and the Docker extension for Visual Studio Team Services</span></span>

<span data-ttu-id="1dbd8-141">[Visual Studio Team Services の Docker 拡張](https://aka.ms/vstsdockerextension)CI パイプラインを Docker イメージを作成、認証済みの Docker レジストリに Docker イメージをプッシュ、または実行する Docker images によって提供されるその他の操作を実行するタスクを追加しますDocker CLI です。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-141">The [Visual Studio Team Services Docker extension](https://aka.ms/vstsdockerextension) adds a task to your CI pipeline with which you can build Docker images, push Docker images to an authenticated Docker registry, run Docker images, or run other operations offered by the Docker CLI.</span></span> <span data-ttu-id="1dbd8-142">また、ビルド、プッシュ、および multicontainer Docker アプリケーションを実行または Docker 構成 CLI で提供される他の操作を実行して、図 5-3 に示すように使用できる Docker Compose のタスクを追加します。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-142">It also adds a Docker Compose task that you can use to build, push, and run multicontainer Docker applications, or run other operations offered by the Docker Compose CLI, as shown in Figure 5-3.</span></span>

![](./media/image3.png)

<span data-ttu-id="1dbd8-143">図 5-3: Visual Studio Team Services での Docker CI パイプライン</span><span class="sxs-lookup"><span data-stu-id="1dbd8-143">Figure 5-3: The Docker CI pipeline in Visual Studio Team Services</span></span>

<span data-ttu-id="1dbd8-144">Docker 拡張機能は、Docker ホストとコンテナーのイメージ レジストリ、サービス エンドポイントを使用できます。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-144">The Docker extension can use service endpoints for Docker hosts and for container or image registries.</span></span> <span data-ttu-id="1dbd8-145">(現在必要カスタム Visual Studio Team Services エージェント) です。 使用可能な場合は、ローカル Docker ホストを使用する既定のタスクそれ以外の場合、Docker ホストの接続を提供することが必要です。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-145">The tasks default to using a local Docker host if available (this currently requires a custom Visual Studio Team Services agent); otherwise, they require that you provide a Docker host connection.</span></span> <span data-ttu-id="1dbd8-146">認証されると、イメージのプッシュなどの Docker レジストリに依存する操作は、レジストリの接続、Docker を提供することが必要です。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-146">Actions that depend on being authenticated with a Docker registry, such as pushing an image, require that you provide a Docker registry connection.</span></span>

<span data-ttu-id="1dbd8-147">Visual Studio Team Services Docker 拡張機能では、Visual Studio Team Services アカウントで、次のコンポーネントがインストールされます。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-147">The Visual Studio Team Services Docker extension installs the following components in your Visual Studio Team Services account:</span></span>

-   <span data-ttu-id="1dbd8-148">Docker レジストリに接続するためのサービス エンドポイント</span><span class="sxs-lookup"><span data-stu-id="1dbd8-148">A service endpoint for connecting to a Docker registry</span></span>

-   <span data-ttu-id="1dbd8-149">Docker コンテナー ホストに接続するためのサービス エンドポイント</span><span class="sxs-lookup"><span data-stu-id="1dbd8-149">A service endpoint for connecting to a Docker Container Host</span></span>

-   <span data-ttu-id="1dbd8-150">Docker タスクを次を行うには:</span><span class="sxs-lookup"><span data-stu-id="1dbd8-150">A Docker task to do the following:</span></span>

-   <span data-ttu-id="1dbd8-151">イメージを構築します。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-151">Build an image</span></span>

-   <span data-ttu-id="1dbd8-152">レジストリにイメージまたはリポジトリをプッシュします。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-152">Push an image or a repository to a registry</span></span>

-   <span data-ttu-id="1dbd8-153">コンテナーのイメージを実行します。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-153">Run an image in a container</span></span>

-   <span data-ttu-id="1dbd8-154">Docker コマンドを実行します。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-154">Run a Docker command</span></span>

-   <span data-ttu-id="1dbd8-155">Docker Compose Docker Compose コマンドを実行するタスク</span><span class="sxs-lookup"><span data-stu-id="1dbd8-155">A Docker Compose task to run a Docker Compose command</span></span>

<span data-ttu-id="1dbd8-156">これらの Visual Studio Team Services タスクでビルド Linux Docker ホストと VM のプロビジョニングと優先 Docker レジストリ (Azure コンテナー レジストリ、Docker Hub、プライベートの Docker DTR またはその他の任意の Docker レジストリ) で、Docker CI パイプラインを作成することができます、非常に一貫した方法です。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-156">With these Visual Studio Team Services tasks, a build Linux-Docker Host/VM provisioned in Azure and your preferred Docker registry (Azure Container Registry, Docker Hub, private Docker DTR, or any other Docker registry) you can assemble your Docker CI pipeline in a very consistent way.</span></span>

<span data-ttu-id="1dbd8-157">***要件:***</span><span class="sxs-lookup"><span data-stu-id="1dbd8-157">***Requirements:***</span></span>

-   <span data-ttu-id="1dbd8-158">Visual Studio Team Services、または内部設置型インストールの場合、Team Foundation Server 2015 Update 3 以降。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-158">Visual Studio Team Services, or for on-premises installations, Team Foundation Server 2015 Update 3 or later.</span></span>

-   <span data-ttu-id="1dbd8-159">Docker バイナリが含まれている Visual Studio Team Services エージェント。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-159">A Visual Studio Team Services agent that has the Docker binaries.</span></span>

<span data-ttu-id="1dbd8-160">1 つ作成する簡単な方法は、Docker を使用して、Visual Studio Team Services エージェントの Docker イメージに基づいて、コンテナーを実行するにです。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-160">An easy way to create one of these is to use Docker to run a container based on the Visual Studio Team Services agent Docker image.</span></span>

<span data-ttu-id="1dbd8-161">**詳細については** パイプラインおよびチュートリアルを表示する、次のサイトを参照してください。 Visual Studio Team Services Docker CI をまとめることの詳細を読むため。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-161">**More info** To read more about assembling a Visual Studio Team Services Docker CI pipeline and to view walkthroughs, visit the following sites:</span></span>

<span data-ttu-id="1dbd8-162">Docker のコンテナーとして、Visual Studio Team Services エージェントを実行している: [https://hub.docker.com/r/\ microsoft/vsts エージェント/](https://hub.docker.com/r/microsoft/vsts-agent/)</span><span class="sxs-lookup"><span data-stu-id="1dbd8-162">Running a Visual Studio Team Services agent as a Docker container: [https://hub.docker.com/r/\ microsoft/vsts-agent/](https://hub.docker.com/r/microsoft/vsts-agent/)</span></span>

<span data-ttu-id="1dbd8-163">VSTS Docker 拡張機能: <https://aka.ms/vstsdockerextension></span><span class="sxs-lookup"><span data-stu-id="1dbd8-163">VSTS Docker extension: <https://aka.ms/vstsdockerextension></span></span>

<span data-ttu-id="1dbd8-164">Visual Studio Team Services と .NET Core Linux Docker イメージを構築します<https://blogs.msdn.microsoft.com/stevelasker/2016/06/13/building-net-core-linux-docker-images-with-visual-studio-team-services/。></span><span class="sxs-lookup"><span data-stu-id="1dbd8-164">Building .NET Core Linux Docker images with Visual Studio Team Services: <https://blogs.msdn.microsoft.com/stevelasker/2016/06/13/building-net-core-linux-docker-images-with-visual-studio-team-services/></span></span>

<span data-ttu-id="1dbd8-165">Docker のサポートとマシンを作成する Visual Studio チーム Linux ベース サービスの構築: <http://donovanbrown.com/post/2016/06/03/Building-a-Linux-Based-Visual-Studio-Team-Service-Build-Machine-with-Docker-Support></span><span class="sxs-lookup"><span data-stu-id="1dbd8-165">Building a Linux-based Visual Studio Team Service build machine with Docker support: <http://donovanbrown.com/post/2016/06/03/Building-a-Linux-Based-Visual-Studio-Team-Service-Build-Machine-with-Docker-Support></span></span>

### <a name="integrate-test-and-validate-multicontainer-docker-applications"></a><span data-ttu-id="1dbd8-166">統合、テスト、および multicontainer Docker アプリケーションを検証</span><span class="sxs-lookup"><span data-stu-id="1dbd8-166">Integrate, test, and validate multicontainer Docker applications</span></span>

<span data-ttu-id="1dbd8-167">通常、ほとんどの Docker アプリケーションは 1 つのコンテナーではなく、複数のコンテナーの構成されます。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-167">Typically, most Docker applications are composed of multiple containers rather than a single container.</span></span> <span data-ttu-id="1dbd8-168">良い例は、マイクロ サービスあたり 1 つのコンテナーが microservices 指向アプリケーションです。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-168">A good example is a microservices-oriented application for which you would have one container per microservice.</span></span> <span data-ttu-id="1dbd8-169">しかし、microservices アプローチ パターンに厳密に従うと、しなくてもは Docker アプリケーションは、複数のコンテナーまたはサービスの構成は非常に高い可能性。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-169">But, even without strictly following the microservices approach patterns, it is very probable that your Docker application would be composed of multiple containers or services.</span></span>

<span data-ttu-id="1dbd8-170">したがって、CI パイプライン内のアプリケーションのコンテナーを作成するには後もする必要が展開、統合、および全体をそのすべてのコンテナーまたはさらに、コンテナーが、テスト クラスターにも統合 Docker ホスト内でアプリケーションをテストします。分散されます。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-170">Therefore, after building the application containers in the CI pipeline, you also need to deploy, integrate, and test the application as a whole with all of its containers within an integration Docker host or even into a test cluster to which your containers are distributed.</span></span>

<span data-ttu-id="1dbd8-171">1 つのホストを使用している場合は、docker など Docker コマンドを使用するをビルドしてテストし、検証の 1 つの VM で Docker 環境に関連するコンテナーの展開を作成します。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-171">If you're using a single host, you can use Docker commands such as docker-compose to build and deploy related containers to test and validate the Docker environment in a single VM.</span></span> <span data-ttu-id="1dbd8-172">しかし、DC/OS、Kubernetes、Docker Swarm など、orchestrator のクラスターで作業している場合、別のメカニズムや、選択したクラスター/スケジューラによって、orchestrator を使用してコンテナーを展開する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-172">But, if you are working with an orchestrator cluster like DC/OS, Kubernetes, or Docker Swarm, you need to deploy your containers through a different mechanism or orchestrator, depending on your selected cluster/scheduler.</span></span>

<span data-ttu-id="1dbd8-173">Docker コンテナーに対して実行するテストのいくつかの種類を次に示します。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-173">Following are several types of tests that you can run against Docker containers:</span></span>

-   <span data-ttu-id="1dbd8-174">Docker コンテナーの単体テスト</span><span class="sxs-lookup"><span data-stu-id="1dbd8-174">Unit tests for Docker containers</span></span>

-   <span data-ttu-id="1dbd8-175">相互に関連するアプリケーションまたは microservices のテストのグループ</span><span class="sxs-lookup"><span data-stu-id="1dbd8-175">Testing groups of interrelated applications or microservices</span></span>

-   <span data-ttu-id="1dbd8-176">運用環境と「カナリア」のリリースでのテストします。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-176">Test in production and "canary" releases</span></span>

<span data-ttu-id="1dbd8-177">重要な点は、統合および機能のテストを実行する場合は、コンテナーの外部からそれらのテストを実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-177">The important point is that when running integration and functional tests, you must run those tests from outside of the containers.</span></span> <span data-ttu-id="1dbd8-178">テストを定義できず、コンテナーは、実稼働環境にデプロイするものとまったく同じにする必要のある静的なイメージに基づいているために、展開する場合は、コンテナー内で実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-178">Tests must not be defined and run within the containers that you are deploying, because the containers are based on static images that should be exactly like those that you will be deploying into production.</span></span>

<span data-ttu-id="1dbd8-179">複数のクラスター (クラスター、ステージング クラスター、および運用クラスターのテスト) のテストより高度なシナリオをテストするときに、非常に可能なオプションは、さまざまなクラスターでテストをレジストリにイメージを発行することです。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-179">A very feasible option when testing more advanced scenarios like testing several clusters (test cluster, staging cluster, and production cluster) is to publish the images to a registry to test in various clusters.</span></span>

### <a name="push-the-custom-application-docker-image-into-your-global-docker-registry"></a><span data-ttu-id="1dbd8-180">グローバル Docker レジストリをカスタム アプリケーションの Docker イメージをプッシュします。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-180">Push the custom application Docker image into your global Docker Registry</span></span>

<span data-ttu-id="1dbd8-181">Docker images をテストして検証した後にタグを付けるし、Docker レジストリに公開します。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-181">After the Docker images have been tested and validated, you'll want to tag and publish them to your Docker registry.</span></span> <span data-ttu-id="1dbd8-182">Docker レジストリは Docker アプリケーション ライフ サイクルにおける重要な部分は QA および実稼働環境に展開する、カスタムのテスト (別名「試みられたイメージの場合」) を格納する一元的な場所になっているためです。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-182">The Docker registry is a critical piece in the Docker application life cycle because it is the central place where you store your custom test (aka "blessed images") to be deployed into QA and production environments.</span></span>

<span data-ttu-id="1dbd8-183">方法 (Git など)、ソース コード管理リポジトリに格納されているアプリケーション コードは、「ソースの情報源」と同様に、Docker レジストリは、「ソース唯一の情報源」QA または実稼働環境に展開するには、バイナリのアプリケーションまたはビット用です。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-183">Similar to how the application code stored in your SCC repository (Git, etc.) is your "source of truth," the Docker registry is your "source of truth" for your binary application or bits to be deployed to the QA or production environments.</span></span>

<span data-ttu-id="1dbd8-184">通常、する可能性がありますまたは必要なカスタム イメージのプライベート リポジトリ プライベート リポジトリのいずれか Azure コンテナー レジストリにまたは Docker Trusted Registry と同様に、内部設置型のレジストリに (のような制限されたアクセス権を持つパブリック クラウドのレジストリでDocker Hub) が、ここでは最後にコードがオープン ソースではない場合に、仕入先のセキュリティを信頼する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-184">Typically, you might want to have your private repositories for your custom images either in a private repository in Azure Container Registry or in an on-premises registry like Docker Trusted Registry, or in a public-cloud registry with restricted access (like Docker Hub), although in this last case if your code is not open source, you must trust the vendor's security.</span></span> <span data-ttu-id="1dbd8-185">どちらにしても、これによってこれを行う方法は非常に類似したと最終的には、docker push コマンドに基づいて、図 5-4 に示されているです。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-185">Either way, the method by which you do this is pretty similar and ultimately based on the docker push command, as depicted in Figure 5-4.</span></span>

![](./media/image4.png)

<span data-ttu-id="1dbd8-186">図 5-4: カスタム イメージを Docker レジストリに公開します。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-186">Figure 5-4: Publishing custom images to Docker Registry</span></span>

<span data-ttu-id="1dbd8-187">Azure コンテナー レジストリ、Amazon Web Services コンテナー レジストリ、Google にコンテナー レジストリ、Quay レジストリなどのクラウドのベンダーから Docker レジストリの複数のサービス提供しています。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-187">There are multiple offerings of Docker registries from cloud vendors like Azure Container Registry, Amazon Web Services Container Registry, Google Container Registry, Quay Registry, and so on.</span></span>

<span data-ttu-id="1dbd8-188">図 5-5 に示すようには、Visual Studio Team Services Docker 拡張機能を使用して、(Azure コンテナー レジストリ) のような認証済みの Docker レジストリへの複数のタグで、docker compose.yml ファイルで定義されているサービスのイメージのセットをプッシュできます。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-188">Using the Visual Studio Team Services Docker extension, you can push a set of service images defined by a docker-compose.yml file, with multiple tags, to an authenticated Docker registry (like Azure Container Registry), as shown in Figure 5-5.</span></span>

![](./media/image5.png)

<span data-ttu-id="1dbd8-189">図 5-5: Docker のレジストリへの発行のカスタム イメージを Visual Studio Team Services を使用します。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-189">Figure 5-5: Using Visual Studio Team Services to publishing custom images to a Docker Registry</span></span>

<span data-ttu-id="1dbd8-190">**詳細については** 詳細を確認する Visual Studio Team Services の Docker 拡張機能についてに移動<https://aka.ms/vstsdockerextension>です。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-190">**More info** To read more about the Docker extension for Visual Studio Team Services, go to <https://aka.ms/vstsdockerextension>.</span></span> <span data-ttu-id="1dbd8-191">Azure コンテナー レジストリに関する詳細については、するには<https://aka.ms/azurecontainerregistry>です。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-191">To learn more about Azure Container Registry, go to <https://aka.ms/azurecontainerregistry>.</span></span>

## <a name="step-4-cd-deploy"></a><span data-ttu-id="1dbd8-192">手順 4: CD、展開</span><span class="sxs-lookup"><span data-stu-id="1dbd8-192">Step 4: CD, Deploy</span></span>

<span data-ttu-id="1dbd8-193">Docker images の不変性により、反復可能な展開、新機能が開発された CI、を通じてテストや実稼働環境で実行されます。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-193">The immutability of Docker images ensures a repeatable deployment with what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="1dbd8-194">所持している複数の環境に展開したり Docker レジストリ (プライベートまたはパブリック) に発行されたアプリケーションの Docker イメージを作成したら、(、品質保証、運用など、ステージング、) Visual Studio Team Services を使用して、CD パイプラインからパイプラインのタスクまたは Visual Studio Team Services のリリース管理されます。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-194">After you have the application Docker images published in your Docker registry (either private or public), you can deploy them to the several environments that you might have (production, QA, staging, etc.) from your CD pipeline by using Visual Studio Team Services pipeline tasks or Visual Studio Team Services Release Management.</span></span>

<span data-ttu-id="1dbd8-195">ただし、この時点によって異なります Docker アプリケーションの種類を展開します。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-195">However, at this point it depends on what kind of Docker application you are deploying.</span></span> <span data-ttu-id="1dbd8-196">ような複雑なアプリケーションを展開すると非常に異なるアプリケーションを配置する単純な (構成と展開の観点から)、モノリシックと同様に、いくつかのコンテナーやサービスを構成するアプリケーションで展開されたいくつかのサーバーまたは Vm には、ハイパー機能を備えた microservices 指向アプリケーションです。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-196">Deploying a simple application (from a composition and deployment point of view) like a monolithic application comprising a few containers or services and deployed to a few servers or VMs is very different from deploying a more complex application like a microservices-oriented application with hyperscale capabilities.</span></span> <span data-ttu-id="1dbd8-197">これら 2 つのシナリオは、次のセクションで説明します。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-197">These two scenarios are explained in the following sections.</span></span>

### <a name="deploying-composed-docker-applications-to-multiple-docker-environments"></a><span data-ttu-id="1dbd8-198">Docker の複数の環境に Docker アプリケーションの展開で構成されます。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-198">Deploying composed Docker applications to multiple Docker environments</span></span>

<span data-ttu-id="1dbd8-199">最初に、複雑なシナリオを確認してみましょう: 単純な Docker ホスト (Vm またはサーバー) が 1 つの環境または複数の環境に展開する (QA、ステージング、および実稼働)。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-199">Let's look first at the less-complex scenario: deploying to simple Docker hosts (VMs or servers) in a single environment or multiple environments (QA, staging, and production).</span></span> <span data-ttu-id="1dbd8-200">このシナリオで内部的には、CD パイプラインできますを使用して docker-図 5-6 に示すように、コンテナーまたはサービスの関連するそのセットと Docker アプリケーションを展開する (Visual Studio Team Services の展開タスク) から作成します。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-200">In this scenario, internally your CD pipeline can use docker-compose (from your Visual Studio Team Services deployment tasks) to deploy the Docker applications with its related set of containers or services, as illustrated in Figure 5-6.</span></span>

![](./media/image6.png)

<span data-ttu-id="1dbd8-201">図 5-6: 単純な Docker ホスト環境のレジストリへのアプリケーションのコンテナーの展開</span><span class="sxs-lookup"><span data-stu-id="1dbd8-201">Figure 5-6: Deploying application containers to simple Docker host environments registry</span></span>

<span data-ttu-id="1dbd8-202">図 5-7 は、タスクの追加 ダイアログ ボックスで作成する Docker をクリックして、Visual Studio Team Services を使用して、QA/テスト環境に、ビルドの構成項目を接続する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-202">Figure 5-7 highlights how you can connect your build CI to QA/test environments via Visual Studio Team Services by clicking Docker Compose in the Add Task dialog box.</span></span> <span data-ttu-id="1dbd8-203">ただし、ステージング環境または実稼働環境に展開する、ときに通常機能を使用するリリース管理の複数の環境を処理 (などの QA、ステージング、および実稼働)。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-203">However, when deploying to staging or production environments, you would usually use Release Management features handling multiple environments (like QA, staging, and production).</span></span> <span data-ttu-id="1dbd8-204">を 1 つの Docker ホストに配置する場合、Visual Studio Team Services を使用して、タスクの"Docker Compose"(docker を呼び出すことです-フードの下部のコマンドを作成) します。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-204">If you're deploying to single Docker hosts, it is using the Visual Studio Team Services "Docker Compose" task (which is invoking the docker-compose up command under the hood).</span></span> <span data-ttu-id="1dbd8-205">を Azure のコンテナー サービスに配置する場合は、次のセクションで説明するよう、Docker の展開タスクを使用します。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-205">If you're deploying to Azure Container Service, it uses the Docker Deployment task, as explained in the section that follows.</span></span>

![](./media/image7.png)

<span data-ttu-id="1dbd8-206">図 5-7: Visual Studio Team Services パイプラインで Docker Compose タスクを追加します。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-206">Figure 5-7: Adding a Docker Compose task in a Visual Studio Team Services pipeline</span></span>

<span data-ttu-id="1dbd8-207">Visual Studio Team Services でリリースを作成するときに、一連の入力の成果物がかかります。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-207">When you create a release in Visual Studio Team Services, it takes a set of input artifacts.</span></span> <span data-ttu-id="1dbd8-208">これらが意図されていないリリースの有効期間を通じて変更可能な複数の環境。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-208">These are intended to be immutable throughout the lifetime of the release across multiple environments.</span></span> <span data-ttu-id="1dbd8-209">コンテナーを導入するときに、入力の成果物を展開するレジストリ内のイメージを識別します。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-209">When you introduce containers, the input artifacts identify images in a registry to deploy.</span></span> <span data-ttu-id="1dbd8-210">これら識別方法によっては同じリリースでは、"myimage:latest"docker-compose ファイルから参照するとき最も明白なケースの全期間にわたって、保証はありません。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-210">Depending on how these are identified, they are not guaranteed to remain the same throughout the duration of the release, the most obvious case being when you reference "myimage:latest" from a docker-compose file.</span></span>

<span data-ttu-id="1dbd8-211">Visual Studio Team Services の Docker 拡張機能により特定のレジストリのイメージが含まれているビルド成果物を生成する機能のダイジェスト バイナリと同じイメージを一意に識別することが保証されることができます。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-211">The Docker extension for Visual Studio Team Services gives you the ability to generate build artifacts that contain specific registry image digests that are guaranteed to uniquely identify the same image binary.</span></span> <span data-ttu-id="1dbd8-212">これらは、何か、リリースへの入力として使用します。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-212">These are what you really want to use as input to a release.</span></span>

### <a name="managing-releases-to-docker-environments-by-using-visual-studio-team-services-release-management"></a><span data-ttu-id="1dbd8-213">Visual Studio Team Services のリリースの管理を使用して Docker 環境にリリースを管理します。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-213">Managing releases to Docker environments by using Visual Studio Team Services Release Management</span></span>

<span data-ttu-id="1dbd8-214">Visual Studio Team Services 拡張機能を使用することができます新しいイメージを構築する、Docker レジストリに発行して、Linux または Windows のホストで実行および docker などのコマンドを使用して、ビジュアルなどのアプリケーションが全体として複数のコンテナーを展開する構成Studio Team Services のリリース管理の機能は図 5-8 に示すように複数の環境の対象としています。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-214">Through the Visual Studio Team Services extensions, you can build a new image, publish it to a Docker registry, run it on Linux or Windows hosts, and use commands such as docker-compose to deploy multiple containers as an entire application, all through the Visual Studio Team Services Release Management capabilities intended for multiple environments, as shown in Figure 5-8.</span></span>

![](./media/image8.png)

<span data-ttu-id="1dbd8-215">図 5-8: Visual Studio Team Services のリリースの管理から Visual Studio Team Services Docker Compose のタスクを構成します。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-215">Figure 5-8: Configuring Visual Studio Team Services Docker Compose tasks from Visual Studio Team Services Release Management</span></span>

<span data-ttu-id="1dbd8-216">ただしに注意してください、図 5-6 に示すように、図 5-8 での実装のシナリオは (単純な Docker ホストおよび Vm への導入とが 1 つのコンテナーやイメージごとのインスタンスは存在) 非常に基本的な可能性があります。、開発またはテスト sc に対してのみ使用する必要があります。enarios です。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-216">However, keep in mind that the scenario shown in Figure 5-6 and implemented in Figure 5-8 is pretty basic (it is deploying to simple Docker hosts and VMs, and there will be a single container or instance per image) and probably should be used only for development or test scenarios.</span></span> <span data-ttu-id="1dbd8-217">ほとんどのエンタープライズ実稼働のシナリオでは、高可用性 (HA) が必要とし、負荷分散の間で複数のノード、サーバーを Vm、および「インテリジェント フェールオーバー」ようにする場合は、サーバーまたはノードの管理が容易なスケーラビリティが失敗した場合は、そのサービスとコンテナーは、別のホスト サーバーまたは VM に移動されます。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-217">In most enterprise production scenarios, you would want to have High Availability (HA) and easy-to-manage scalability by load balancing across multiple nodes, servers, and VMs, plus "intelligent failovers" so that if a server or node fails, its services and containers will be moved to another host server or VM.</span></span> <span data-ttu-id="1dbd8-218">その場合は、コンテナーのクラスター、orchestrators、スケジューラなどのより高度なテクノロジする必要があります。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-218">In that case, you need more advanced technologies like container clusters, orchestrators, and schedulers.</span></span> <span data-ttu-id="1dbd8-219">したがって、それらのクラスターを展開する方法は、次のセクションで説明されている高度なシナリオを正確にです。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-219">Thus, the way to deploy to those clusters is precisely through the advanced scenarios explained in the next section.</span></span>

### <a name="deploying-complex-docker-applications-to-docker-clusters-dcos-kubernetes-and-docker-swarm"></a><span data-ttu-id="1dbd8-220">複雑な Docker アプリケーション Docker clusters (DC/OS、Kubernetes と Docker Swarm) を展開します。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-220">Deploying complex Docker applications to Docker clusters (DC/OS, Kubernetes, and Docker Swarm)</span></span>

<span data-ttu-id="1dbd8-221">分散アプリケーションの性質は、分散もコンピューティング リソースが必要です。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-221">The nature of distributed applications requires compute resources that are also distributed.</span></span> <span data-ttu-id="1dbd8-222">実稼働スケール機能には、クラスタ リング高い拡張性を提供する機能がある必要があり、プールされたリソースに基づいて HA です。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-222">To have production-scale capabilities, you need to have clustering capabilities that provide high scalability and HA based on pooled resources.</span></span>

<span data-ttu-id="1dbd8-223">コンテナーを Docker Swarm などの CLI ツールからそれらのクラスターを手動で展開でした (を使用するように[docker サービスを作成](https://docs.docker.com/engine/swarm/swarm-tutorial/deploy-service/)) または web UI など[続きマラソン](https://mesosphere.github.io/marathon/docs/marathon-ui.html)DC OS/クラスター、ですが、行う必要がありますまたは管理などの目的でスケール アウトまたは監視目的でのみ punctual 展開のテストを予約されています。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-223">You could deploy containers manually to those clusters from a CLI tool such as Docker Swarm (like using [docker service create](https://docs.docker.com/engine/swarm/swarm-tutorial/deploy-service/)) or a web UI such as [Mesosphere Marathon](https://mesosphere.github.io/marathon/docs/marathon-ui.html) for DC/OS clusters, but you should reserve that only for punctual deployment testing or for management purposes like scaling-out or monitoring purposes.</span></span>

<span data-ttu-id="1dbd8-224">CD の観点から Visual Studio Team Services 具体的には、タスクを実行できます特別に作成された展開から、Visual Studio Team Services のリリース管理環境でクラスターの分散をコンテナー化アプリケーションを展開します。コンテナー サービス、図 5-9 に示すようにします。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-224">From a CD point of view, and Visual Studio Team Services specifically, you can run specially made deployment tasks from your Visual Studio Team Services Release Management environments which will deploy your containerized applications to distributed clusters in Container Service, as illustrated in Figure 5-9.</span></span>

![](./media/image9.png)

<span data-ttu-id="1dbd8-225">図 5-9: コンテナー サービスへの分散アプリケーションの展開</span><span class="sxs-lookup"><span data-stu-id="1dbd8-225">Figure 5-9: Deploying distributed applications to Container Service</span></span>

<span data-ttu-id="1dbd8-226">最初に、配置時に特定のクラスターまたは orchestrators は従来の特定の展開スクリプトと使用できます (つまり、続き DC/OS または Kubernetes Docker と Docker のさまざまな配置メカニズムがある各 orchestrator あたりメカニズムSwarm) の代わりに簡単かつ使いやすい docker-作成ツールの docker compose.yml 定義ファイルに基づいています。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-226">Initially, when deploying to certain clusters or orchestrators, you would traditionally use specific deployment scripts and mechanisms per each orchestrator (that is, Mesosphere DC/OS or Kubernetes have different deployment mechanisms than Docker and Docker Swarm) instead of the simpler and easy-to-use docker-compose tool based on the docker-compose.yml definition file.</span></span> <span data-ttu-id="1dbd8-227">ただし、図 5 ~ 10 に示すように、Microsoft Visual Studio Team Services Docker の展開のタスクのおかげで今すぐまたことができますに展開する DC/OS Microsoft では、「翻訳」を実行するために、使い慣れた docker compose.yml ファイルを使用するだけで (から、docker compose.yml ファイル DC/OS で必要なその他の形式)。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-227">However, thanks to the Microsoft Visual Studio Team Services Docker Deploy task, shown in Figure 5-10, you now also can deploy to DC/OS by just using your familiar docker-compose.yml file because Microsoft performs that "translation" for you (from your docker-compose.yml file to other formats needed by DC/OS).</span></span>

![](./media/image10.png)

<span data-ttu-id="1dbd8-228">図 5-10: Docker の展開タスクを環境の RM に追加します。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-228">Figure 5-10: Adding the Docker Deploy task to your Environment RM</span></span>

<span data-ttu-id="1dbd8-229">図 5-11 では、Docker の展開タスクを編集し、対象の型 (Azure コンテナー サービス DC/OS、ここでは)、Docker 構成ファイル、および Docker レジストリ接続 (Azure コンテナー レジストリ Docker Hub など) を指定する方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-229">Figure 5-11 demonstrates how you can edit the Docker Deploy task and specify the Target Type (Azure Container Service DC/OS, in this case), your Docker Compose File, and the Docker Registry connection (like Azure Container Registry or Docker Hub).</span></span> <span data-ttu-id="1dbd8-230">これは、タスクが DC OS/クラスター内のコンテナーとして配置するのにすぐに使用できるカスタム Docker イメージを取得する場所です。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-230">This is where the task will retrieve your ready-to-use custom Docker images to be deployed as containers in the DC/OS cluster.</span></span>

![](./media/image11.png)

<span data-ttu-id="1dbd8-231">図 5-11: Docker の展開タスクの定義の展開を Azure コンテナー サービス DC/OS</span><span class="sxs-lookup"><span data-stu-id="1dbd8-231">Figure 5-11: Docker Deploy task definition deploying to Azure Container Service DC/OS</span></span>

<span data-ttu-id="1dbd8-232">**詳細については** 詳細を確認する、CD には、Visual Studio Team Services と Docker のパイプラインは、次のサイトを参照してください。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-232">**More info** To read more about the CD pipeline with Visual Studio Team Services and Docker, visit the following sites:</span></span>

<span data-ttu-id="1dbd8-233">Docker と Azure のコンテナー サービスの visual Studio Team Services の拡張機能: [https://aka.ms/\ vstsdockerextension](https://aka.ms/vstsdockerextension)</span><span class="sxs-lookup"><span data-stu-id="1dbd8-233">Visual Studio Team Services extension for Docker and Azure Container Service: [https://aka.ms/\ vstsdockerextension](https://aka.ms/vstsdockerextension)</span></span>

<span data-ttu-id="1dbd8-234">Azure のコンテナー サービス: <https://aka.ms/azurecontainerservice></span><span class="sxs-lookup"><span data-stu-id="1dbd8-234">Azure Container Service: <https://aka.ms/azurecontainerservice></span></span>

<span data-ttu-id="1dbd8-235">続き DC/OS: <https://mesosphere.com/product/></span><span class="sxs-lookup"><span data-stu-id="1dbd8-235">Mesosphere DC/OS: <https://mesosphere.com/product/></span></span>

## <a name="step-5-run-and-manage"></a><span data-ttu-id="1dbd8-236">手順 5: 実行し、管理</span><span class="sxs-lookup"><span data-stu-id="1dbd8-236">Step 5: Run and manage</span></span>

<span data-ttu-id="1dbd8-237">実行しており、アプリケーションを管理するため、運用版でエンタープライズ レベルは、されでは、それ自体の操作の種類のための主な話題と人数がそのレベル (IT 操作) のこの領域の大きいスコープだけでなく、全体を次に充てること説明にチャプターです。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-237">Because running and managing applications at enterprise-production level is a major subject in and of itself, and due to the type of operations and people working at that level (IT operations) as well as the large scope of this area, we have devoted the entire next chapter to explaining it.</span></span>

## <a name="step-6-monitor-and-diagnose"></a><span data-ttu-id="1dbd8-238">手順 6: 監視および診断</span><span class="sxs-lookup"><span data-stu-id="1dbd8-238">Step 6: Monitor and diagnose</span></span>

<span data-ttu-id="1dbd8-239">このトピックの内容もについては次のチャプター IT 運用チームで実稼働システムで実行されるタスクの一部としてただし、この手順で取得した情報は、アプリケーションが継続的に向上できるように、開発チームにフィードする必要がありますを強調する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-239">This topic also is covered in the next chapter as part of the tasks that IT operations performs in production systems; however, is important to highlight that the insights obtained in this step must feed back to the development team so that the application is constantly improved.</span></span> <span data-ttu-id="1dbd8-240">その観点も DevOps の一部が、タスクや操作がによって実行される通常 IT です。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-240">From that point of view, it is also part of DevOps, although the tasks and operations are usually performed by IT.</span></span>

<span data-ttu-id="1dbd8-241">監視と診断が 100 %devops の領域の場合にのみ、監視プロセスおよびテスト シナリオまたは beta 環境に対して、開発チームによって実行される分析です。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-241">Only when monitoring and diagnostics are 100 percent within the realm of DevOps are the monitoring processes and analytics performed by the development team against testing or beta environments.</span></span> <span data-ttu-id="1dbd8-242">これには、ロード テストを実行するか、ベータ版または、ベータ テストしようとしている、新しいバージョンの QA 環境を監視するだけでは行われます。</span><span class="sxs-lookup"><span data-stu-id="1dbd8-242">This is done either by performing load testing or simply by monitoring beta or QA environments, where beta testers are trying the new versions.</span></span>

>[!div class="step-by-step"]
<span data-ttu-id="1dbd8-243">[前](index.md) [次へ] (../run-manage-monitor-docker-environments/index.md)</span><span class="sxs-lookup"><span data-stu-id="1dbd8-243">[Previous] (index.md) [Next] (../run-manage-monitor-docker-environments/index.md)</span></span>
