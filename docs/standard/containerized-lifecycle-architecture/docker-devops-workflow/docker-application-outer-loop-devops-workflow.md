---
title: Docker アプリケーションの外側のループ DevOps ワークフローの手順を実行します。
description: DevOps ワークフローの「外側のループ」手順を説明します
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 02/15/2019
ms.openlocfilehash: 495e717787c346e451c2f79ef4200b478577aa9d
ms.sourcegitcommit: 58fc0e6564a37fa1b9b1b140a637e864c4cf696e
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/08/2019
ms.locfileid: "57676201"
---
# <a name="steps-in-the-outer-loop-devops-workflow-for-a-docker-application"></a><span data-ttu-id="e9fe8-103">Docker アプリケーションの外側のループ DevOps ワークフローの手順を実行します。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-103">Steps in the outer-loop DevOps workflow for a Docker application</span></span>

<span data-ttu-id="e9fe8-104">図 5-1 は、DevOps の外側のループのワークフローを構成する手順の説明、エンド ツー エンドの図を表示します。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-104">Figure 5-1 presents an end-to-end depiction of the steps comprising the DevOps outer-loop workflow.</span></span>

![この図では、DevOps の「外側のループ」を示します。](./media/image1.png)

<span data-ttu-id="e9fe8-108">**図 5-1**します。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-108">**Figure 5-1**.</span></span> <span data-ttu-id="e9fe8-109">Microsoft ツールと Docker アプリケーション DevOps 外側のループのワークフロー</span><span class="sxs-lookup"><span data-stu-id="e9fe8-109">DevOps outer-loop workflow for Docker applications with Microsoft tools</span></span>

<span data-ttu-id="e9fe8-110">次に、それぞれの手順を詳しく見ていきましょう。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-110">Now, let's examine each of these steps in greater detail.</span></span>

## <a name="step-1-inner-loop-development-workflow"></a><span data-ttu-id="e9fe8-111">手順 1: 内部ループ開発ワークフロー</span><span class="sxs-lookup"><span data-stu-id="e9fe8-111">Step 1: Inner-loop development workflow</span></span>

<span data-ttu-id="e9fe8-112">この手順は、第 4 章で詳しく説明を要約すると、ここでは、外側のループ開始位置となる、開発者が CI パイプラインのアクションの開始 (Git) のようなソース コントロール管理システムにコードをプッシュする時点。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-112">This step is explained in detail in Chapter 4, but, to recap, here is where the outer-loop begins, the moment at which a developer pushes code to the source control management system (like Git) initiating CI pipeline actions.</span></span>

## <a name="step-2-source-code-control-integration-and-management-with-azure-devops-services-and-git"></a><span data-ttu-id="e9fe8-113">手順 2: ソース コード管理の統合と Azure DevOps サービスと Git による管理</span><span class="sxs-lookup"><span data-stu-id="e9fe8-113">Step 2: Source-Code Control integration and management with Azure DevOps Services and Git</span></span>

<span data-ttu-id="e9fe8-114">この手順では、チームのさまざまな開発者から、すべてのコードの統合されたバージョンを収集するバージョン管理システムに用意する必要があります。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-114">At this step, you need to have a version-control system to gather a consolidated version of all the code coming from the different developers in the team.</span></span>

<span data-ttu-id="e9fe8-115">アプリケーションを Docker イメージを送信する必要がありますいないを強調するために重要な場合でも、ソース コード管理 (SCC) とソース コード管理には、習慣にほとんどの開発者、DevOps ライフで Docker アプリケーションを作成するときのサイクルと思われる場合があります、直接、グローバル Docker レジストリに (Azure Container Registry や Docker Hub) など、開発者のマシンから。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-115">Even though source-code control (SCC) and source-code management might seem second-nature to most developers, when creating Docker applications in a DevOps life cycle, it's critical to emphasize that you must not submit the Docker images with the application directly to the global Docker Registry (like Azure Container Registry or Docker Hub) from the developer's machine.</span></span> <span data-ttu-id="e9fe8-116">反対に、グローバル ビルドまたはソース コード リポジトリ (Git) などに基づく CI パイプラインで、統合されることは、ソース コードのみにリリースされ、運用環境に展開する Docker イメージを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-116">On the contrary, the Docker images to be released and deployed to production environments must be created solely on the source code that's being integrated in your global build or CI pipeline based on your source-code repository (like Git).</span></span>

<span data-ttu-id="e9fe8-117">独自のマシン内でテストするときに、それらにより、開発者によって生成される、ローカルのイメージを使用だけください。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-117">The local images, generated by developers, should just be used by them when testing within their own machines.</span></span> <span data-ttu-id="e9fe8-118">その理由は DevOps パイプラインを SCC コードからアクティブ化することが重要です。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-118">That's why it's critical to have the DevOps pipeline activated from the SCC code.</span></span>

<span data-ttu-id="e9fe8-119">Azure DevOps サービスと Team Foundation Server は、Git と Team Foundation バージョン管理をサポートします。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-119">Azure DevOps Services and Team Foundation Server support Git and Team Foundation Version Control.</span></span> <span data-ttu-id="e9fe8-120">それらの間を選択し、エンド ツー エンドの Microsoft エクスペリエンスを使用できます。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-120">You can choose between them and use it for an end-to-end Microsoft experience.</span></span> <span data-ttu-id="e9fe8-121">ただし、管理することもできます (GitHub、Git リポジトリをオンプレミス、または Subversion) ような外部リポジトリでは、コードとそれに接続し、DevOps の CI パイプラインの開始点としてコードを取得できます。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-121">However, you also can manage your code in external repositories (like GitHub, on-premises Git repositories, or Subversion) and still be able to connect to it and get the code as the starting point for your DevOps CI pipeline.</span></span>

## <a name="step-3-build-ci-integrate-and-test-with-azure-devops-services-and-docker"></a><span data-ttu-id="e9fe8-122">手順 3: ビルド、CI、統合、および Azure DevOps を使用してテスト サービスと Docker</span><span class="sxs-lookup"><span data-stu-id="e9fe8-122">Step 3: Build, CI, Integrate, and Test with Azure DevOps Services and Docker</span></span>

<span data-ttu-id="e9fe8-123">CI が最新のソフトウェアのテストおよび配信のための標準として登場しました。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-123">CI has emerged as a standard for modern software testing and delivery.</span></span> <span data-ttu-id="e9fe8-124">Docker ソリューションでは、開発および運用チーム間での問題を明確に分離を維持します。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-124">The Docker solution maintains a clear separation of concerns between the development and operations teams.</span></span> <span data-ttu-id="e9fe8-125">Docker イメージの不変性により、どのような開発、CI、テストおよび運用環境で実行が間に反復可能なデプロイ。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-125">The immutability of Docker images ensures a repeatable deployment between what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="e9fe8-126">Docker エンジン開発者向けのノート パソコンに展開し、テスト インフラストラクチャは、環境間で、コンテナーを移植性。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-126">Docker Engine deployed across the developer laptops and test infrastructure makes the containers portable across environments.</span></span>

<span data-ttu-id="e9fe8-127">この時点で、送信された正しいコードにバージョン管理システムがある必要があります、*サービスを構築*コードを選択し、グローバル ビルドとテストを実行します。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-127">At this point, after you have a version-control system with the correct code submitted, you need a *build service* to pick up the code and run the global build and tests.</span></span>

<span data-ttu-id="e9fe8-128">(CI、ビルド、テスト) この手順の内部ワークフローとは、ビルド サーバー (Azure DevOps サービス)、Docker エンジンと Docker レジストリをコード リポジトリ (Git など) から成る CI パイプラインを作成する方法。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-128">The internal workflow for this step (CI, build, test) is about the construction of a CI pipeline consisting of your code repository (Git, etc.), your build server (Azure DevOps Services), Docker Engine, and a Docker Registry.</span></span>

<span data-ttu-id="e9fe8-129">できますサービスを使用する Azure DevOps の基盤として、アプリケーションを構築および、CI のパイプラインを設定するため、組み込みの「アイテム」を公開するため"アーティファクト リポジトリに、"については、次の手順で説明します。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-129">You can use Azure DevOps Services as the foundation for building your applications and setting your CI pipeline, and for publishing the built "artifacts" to an "artifacts repository," which is explained in the next step.</span></span>

<span data-ttu-id="e9fe8-130">Docker を使用して、展開は、「最終的な成果物」ときに展開するのには、アプリケーションやサービスを使用した Docker イメージ内に埋め込まれます。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-130">When using Docker for the deployment, the "final artifacts" to be deployed are Docker images with your application or services embedded within them.</span></span> <span data-ttu-id="e9fe8-131">これらのイメージのプッシュまたは発行を*Docker レジストリ*(Azure Container Registry で使用できるはまたはの公式の基本イメージの一般的な使用の Docker Hub レジストリなどのパブリック 1 などのプライベート リポジトリ)。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-131">Those images are pushed or published to a *Docker Registry* (a private repository like the ones you can have in Azure Container Registry, or a public one like Docker Hub Registry, which is commonly used for official base images).</span></span>

<span data-ttu-id="e9fe8-132">基本的な概念を次に示します。CI パイプラインは、Git などのソース コード管理リポジトリにコミットしてから開始されます。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-132">Here is the basic concept: The CI pipeline will be kicked-off by a commit to an SCC repository like Git.</span></span> <span data-ttu-id="e9fe8-133">図 5-2 に示すように、コミットは、Docker コンテナー内のビルド ジョブを実行し、そのジョブが正常に完了すると、Docker レジストリに Docker イメージをプッシュする DevOps サービスを Azure になります。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-133">The commit will cause Azure DevOps Services to run a build job within a Docker container and, upon successful completion of that job, push a Docker image to the Docker Registry, as illustrated in Figure 5-2.</span></span>

![外側のループの最初の部分を実行、コードから、手順 1 ~ 3 では、デバッグ、および検証し、ビルドとテストの CI 手順まで、コード リポジトリ](./media/image2.png)

<span data-ttu-id="e9fe8-135">**図 5-2**</span><span class="sxs-lookup"><span data-stu-id="e9fe8-135">**Figure 5-2**.</span></span> <span data-ttu-id="e9fe8-136">CI で必要な手順</span><span class="sxs-lookup"><span data-stu-id="e9fe8-136">The steps involved in CI</span></span>

<span data-ttu-id="e9fe8-137">Docker と Azure DevOps サービスの基本的な CI ワークフロー手順を次に示します。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-137">Here are the basic CI workflow steps with Docker and Azure DevOps Services:</span></span>

1. <span data-ttu-id="e9fe8-138">開発者は、ソース コード管理リポジトリ (Git または Azure DevOps Services、GitHub など) にコミットをプッシュします。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-138">The developer pushes a commit to an SCC repository (Git/Azure DevOps Services, GitHub, etc.).</span></span>

2. <span data-ttu-id="e9fe8-139">Azure DevOps Services または Git を使用している場合は、CI ビルドは、Azure DevOps サービスのチェック ボックスを選択するだけであることを意味します。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-139">If you're using Azure DevOps Services or Git, CI is built in, which means that it's as simple as selecting a check box in Azure DevOps Services.</span></span> <span data-ttu-id="e9fe8-140">(GitHub) などの外部の SCC を使用している場合、`webhook`更新プログラムの DevOps サービスを Azure に通知または Git と GitHub にプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-140">If you're using an external SCC (like GitHub), a `webhook` will notify Azure DevOps Services of the update or push to Git/GitHub.</span></span>

3. <span data-ttu-id="e9fe8-141">Azure DevOps サービスは、イメージだけでなく、アプリケーションとテストのコードを記述する Dockerfile を含む、SCC リポジトリをプルします。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-141">Azure DevOps Services pulls the SCC repository, including the Dockerfile describing the image, as well as the application and test code.</span></span>

4. <span data-ttu-id="e9fe8-142">Azure DevOps サービスは、Docker イメージをビルドおよびビルド番号のラベルします。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-142">Azure DevOps Services builds a Docker image and labels it with a build number.</span></span>

5. <span data-ttu-id="e9fe8-143">Azure DevOps サービスは、プロビジョニング済みの Docker ホスト内の Docker コンテナーをインスタンス化し、適切なテストを実行します。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-143">Azure DevOps Services instantiates the Docker container within the provisioned Docker Host, and runs the appropriate tests.</span></span>

6. <span data-ttu-id="e9fe8-144">「試みられたビルド」がわかるように、イメージが最初にわかりやすい名前を付け、テストが成功した場合は、(のように"/1.0.0"またはその他の任意のラベル)、(Docker Hub、Azure Container Registry、DTR など)、Docker レジストリにプッシュし、</span><span class="sxs-lookup"><span data-stu-id="e9fe8-144">If the tests are successful, the image is first relabeled to a meaningful name so that you know it's a "blessed build" (like "/1.0.0" or any other label), and then pushed up to your Docker Registry (Docker Hub, Azure Container Registry, DTR, etc.)</span></span>

### <a name="implementing-the-ci-pipeline-with-azure-devops-services-and-the-docker-extension-for-azure-devops-services"></a><span data-ttu-id="e9fe8-145">Azure DevOps サービス用の Azure DevOps サービスと Docker 拡張機能を使用して、CI パイプラインの実装</span><span class="sxs-lookup"><span data-stu-id="e9fe8-145">Implementing the CI pipeline with Azure DevOps Services and the Docker extension for Azure DevOps Services</span></span>

<span data-ttu-id="e9fe8-146">Visual Studio の Azure DevOps サービスには、ビルド (&)、CI/CD パイプラインを Docker イメージを作成、認証済みの Docker レジストリに Docker イメージをプッシュ、または実行する Docker イメージ、によって提供されるその他の操作を実行に使用できるリリース テンプレートが含まれています。Docker CLI。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-146">Visual Studio Azure DevOps Services contains Build & Release Templates that you can use in your CI/CD pipeline with which you can build Docker images, push Docker images to an authenticated Docker registry, run Docker images, or run other operations offered by the Docker CLI.</span></span> <span data-ttu-id="e9fe8-147">また、ビルド、プッシュ、およびマルチ コンテナー Docker アプリケーションを実行または図 5-3 に示すように Docker Compose CLI によって提供されるその他の操作を実行に使用できる Docker Compose のタスクを追加します。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-147">It also adds a Docker Compose task that you can use to build, push, and run multi-container Docker applications, or run other operations offered by the Docker Compose CLI, as shown in Figure 5-3.</span></span>

![Azure DevOps での Docker の CI パイプラインのブラウザー ビュー](./media/image3.png)

<span data-ttu-id="e9fe8-149">**図 5-3**</span><span class="sxs-lookup"><span data-stu-id="e9fe8-149">**Figure 5-3**.</span></span> <span data-ttu-id="e9fe8-150">ビルド & リリース テンプレートと関連するタスクを含む Azure DevOps サービスで Docker CI パイプラインです。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-150">The Docker CI pipeline in Azure DevOps Services including Build & Release Templates and associated tasks.</span></span>

<span data-ttu-id="e9fe8-151">これらのテンプレートとタスクを使用するにはビルド/テストおよびデプロイする CI/CD アーティファクトを作成する Azure Service Fabric、Azure Kubernetes サービス、および類似のサービスです。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-151">You can use these templates and tasks to construct your CI/CD artifacts to Build / Test and Deploy in Azure Service Fabric, Azure Kubernetes Service, and similar offerings.</span></span>

<span data-ttu-id="e9fe8-152">これらの Visual Studio Team Services タスクとビルドを Linux Docker ホスト/VM Azure でプロビジョニングし、(Azure Container Registry、Docker Hub、プライベート Docker DTR、またはその他の任意の Docker レジストリ)、優先の Docker レジストリの Docker の CI パイプラインをアセンブルできます、非常に一貫した方法です。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-152">With these Visual Studio Team Services tasks, a build Linux-Docker Host/VM provisioned in Azure and your preferred Docker registry (Azure Container Registry, Docker Hub, private Docker DTR, or any other Docker registry) you can assemble your Docker CI pipeline in a very consistent way.</span></span>

<span data-ttu-id="e9fe8-153">***要件:***</span><span class="sxs-lookup"><span data-stu-id="e9fe8-153">***Requirements:***</span></span>

- <span data-ttu-id="e9fe8-154">Azure DevOps サービス、またはオンプレミス インストールの場合、Team Foundation Server 2015 Update 3 またはそれ以降。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-154">Azure DevOps Services, or for on-premises installations, Team Foundation Server 2015 Update 3 or later.</span></span>

- <span data-ttu-id="e9fe8-155">Docker バイナリを含む Azure DevOps サービス エージェント。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-155">An Azure DevOps Services agent that has the Docker binaries.</span></span>

  <span data-ttu-id="e9fe8-156">これらのエージェントのいずれかを作成する簡単な方法では、Docker を使用して、Azure DevOps サービス エージェントの Docker イメージに基づくコンテナーを実行します。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-156">An easy way to create one of these agents is to use Docker to run a container based on the Azure DevOps Services agent Docker image.</span></span>

> [!情報]<span data-ttu-id="e9fe8-157"> をクリックし、Azure DevOps サービスの Docker CI のアセンブリについての詳細はパイプラインし、チュートリアルの表示を読み取り、これらのサイトを参照してください。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-157"> To read more about assembling an Azure DevOps Services Docker CI pipeline and view the walkthroughs, visit these sites:</span></span>
>
> - <span data-ttu-id="e9fe8-158">Docker コンテナーとして、Visual Studio Team Services (今すぐ Azure DevOps サービス) エージェントを実行します \。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-158">Running a Visual Studio Team Services (Now Azure DevOps Services) agent as a Docker container: \\</span></span>
>   [*https://hub.docker.com/r/microsoft/vsts-agent/*](https://hub.docker.com/r/microsoft/vsts-agent/)
>
> - <span data-ttu-id="e9fe8-159">Azure DevOps サービスを使用した .NET Core Linux Docker イメージを構築します \。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-159">Building .NET Core Linux Docker images with Azure DevOps Services: \\</span></span>
>   [*https://blogs.msdn.microsoft.com/stevelasker/2016/06/13/building-net-core-linux-docker-images-with-visual-studio-team-services/*](https://blogs.msdn.microsoft.com/stevelasker/2016/06/13/building-net-core-linux-docker-images-with-visual-studio-team-services/)
>
> - <span data-ttu-id="e9fe8-160">Docker サポートし、マシンを構築する Linux ベースの Visual Studio チーム サービスの構築: \\</span><span class="sxs-lookup"><span data-stu-id="e9fe8-160">Building a Linux-based Visual Studio Team Service build machine with Docker support: \\</span></span>
>   [*http://donovanbrown.com/post/2016/06/03/Building-a-Linux-Based-Visual-Studio-Team-Service-Build-Machine-with-Docker-Support*](http://donovanbrown.com/post/2016/06/03/Building-a-Linux-Based-Visual-Studio-Team-Service-Build-Machine-with-Docker-Support)

### <a name="integrate-test-and-validate-multi-container-docker-applications"></a><span data-ttu-id="e9fe8-161">統合、テスト、およびマルチ コンテナー Docker アプリケーションの検証</span><span class="sxs-lookup"><span data-stu-id="e9fe8-161">Integrate, test, and validate multi-container Docker applications</span></span>

<span data-ttu-id="e9fe8-162">通常、1 つのコンテナーではなく、複数のコンテナーの Docker アプリケーションのほとんどがで構成されます。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-162">Typically, most Docker applications are composed of multiple containers rather than a single container.</span></span> <span data-ttu-id="e9fe8-163">良い例は、マイクロ サービスごとに 1 つのコンテナーが、マイクロ サービス指向アプリケーションです。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-163">A good example is a microservices-oriented application for which you would have one container per microservice.</span></span> <span data-ttu-id="e9fe8-164">ただし、マイクロ サービス アプローチのパターンに厳密に従うと、なくては Docker アプリケーションは、複数のコンテナーまたはサービスの構成は可能性の高い。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-164">But, even without strictly following the microservices approach patterns, it's probable that your Docker application would be composed of multiple containers or services.</span></span>

<span data-ttu-id="e9fe8-165">そのため、CI パイプラインでアプリケーション コンテナーをビルドした後も必要があります、展開、統合、およびすべての統合の Docker ホスト内で、またはさらには、コンテナーがテスト クラスターには、そのコンテナー全体のアプリケーションをテストするには分散されます。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-165">Therefore, after building the application containers in the CI pipeline, you also need to deploy, integrate, and test the application as a whole with all of its containers within an integration Docker host or even into a test cluster to which your containers are distributed.</span></span>

<span data-ttu-id="e9fe8-166">1 つのホストを使用している場合は、docker などの Docker コマンドを使用することができます-ビルドしてデプロイをテストし、1 つの VM で Docker 環境を検証関連のコンテナーを作成します。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-166">If you're using a single host, you can use Docker commands such as docker-compose to build and deploy related containers to test and validate the Docker environment in a single VM.</span></span> <span data-ttu-id="e9fe8-167">しかし、DC/OS、Kubernetes、Docker Swarm などをオーケストレーター クラスタを使用している場合、別のメカニズムや、選択したクラスター/スケジューラによって、orchestrator、コンテナーをデプロイする必要があります。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-167">But, if you're working with an orchestrator cluster like DC/OS, Kubernetes, or Docker Swarm, you need to deploy your containers through a different mechanism or orchestrator, depending on your selected cluster/scheduler.</span></span>

<span data-ttu-id="e9fe8-168">次に、Docker コンテナーに対して実行できるテストの種類をいくつか示します。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-168">Following are several types of tests that you can run against Docker containers:</span></span>

- <span data-ttu-id="e9fe8-169">Docker コンテナー用の単体テスト</span><span class="sxs-lookup"><span data-stu-id="e9fe8-169">Unit tests for Docker containers</span></span>

- <span data-ttu-id="e9fe8-170">相互に関連するアプリケーションやマイクロ サービスのグループのテスト</span><span class="sxs-lookup"><span data-stu-id="e9fe8-170">Testing groups of interrelated applications or microservices</span></span>

- <span data-ttu-id="e9fe8-171">運用環境と「カナリア」のリリースでのテストします。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-171">Test in production and "canary" releases</span></span>

<span data-ttu-id="e9fe8-172">重要な点は、統合と機能テストを実行するときに、コンテナーの外部からそれらのテストを実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-172">The important point is that when running integration and functional tests, you must run those tests from outside of the containers.</span></span> <span data-ttu-id="e9fe8-173">テストは含まれているまたはコンテナーが必要がありますが、運用環境にデプロイするものとまったく同じように静的なイメージに基づいているため、デプロイするコンテナーで実行できません。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-173">Tests are not contained or run in the containers you're deploying, because the containers are based on static images that should be exactly like the ones you'll be deploying to production.</span></span>

<span data-ttu-id="e9fe8-174">実用的なオプションでは、いくつかのクラスター (クラスター、クラスターのステージング、および運用環境のクラスターのテスト) を含むなどのシナリオより高度なテスト時に、さまざまなクラスターでテストできますのでをレジストリにイメージを発行することです。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-174">A practical option when testing more advanced scenarios, like including several clusters (test cluster, staging cluster, and production cluster) is to publish the images to a registry, so it can be tested in various clusters.</span></span>

### <a name="push-the-custom-application-docker-image-into-your-global-docker-registry"></a><span data-ttu-id="e9fe8-175">グローバルな Docker レジストリをカスタム アプリケーションの Docker イメージをプッシュします。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-175">Push the custom application Docker image into your global Docker Registry</span></span>

<span data-ttu-id="e9fe8-176">Docker イメージをテストおよび検証した後にタグ付けし、Docker レジストリに公開します。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-176">After the Docker images have been tested and validated, you'll want to tag and publish them to your Docker registry.</span></span> <span data-ttu-id="e9fe8-177">Docker レジストリは重要な部分を Docker アプリケーションのライフ サイクルの QA および実稼動環境にデプロイするのには、カスタム テスト (「試みられたイメージ」とも呼ばれます) を格納する中央の場所です。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-177">The Docker registry is a critical piece in the Docker application life cycle because it's the central place where you store your custom test (also known as "blessed images") to be deployed into QA and production environments.</span></span>

<span data-ttu-id="e9fe8-178">方法、ソース コード管理リポジトリ (Git など) に格納されているアプリケーション コードは、「普遍の情報源」と同様に、Docker レジストリは、「ソース実のところの」、QA 環境または運用環境にデプロイするには、バイナリのアプリケーションやビットです。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-178">Similar to how the application code stored in your SCC repository (Git, etc.) is your "source of truth," the Docker registry is your "source of truth" for your binary application or bits to be deployed to the QA or production environments.</span></span>

<span data-ttu-id="e9fe8-179">通常、Azure コンテナー レジストリまたは Docker Trusted Registry のように、オンプレミスのレジストリまたは (制限付きのアクセス権を持つパブリック クラウドのレジストリで、カスタム イメージのプライベート リポジトリをプライベート リポジトリのいずれかがする可能性があります。Docker Hub)、この最後の場合、コードがオープン ソースの場合でも、ベンダーのセキュリティを信頼する必要があります。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-179">Typically, you might want to have your private repositories for your custom images either in a private repository in Azure Container Registry or in an on-premises registry like Docker Trusted Registry, or in a public-cloud registry with restricted access (like Docker Hub), although in this last case if your code is not open source, you must trust the vendor's security.</span></span> <span data-ttu-id="e9fe8-180">どちらの方法を使用するメソッドはのようなに基づいて、`docker push`コマンド、図 5-4 に示すようにします。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-180">Either way, the method you use is similar and is based on the `docker push` command, as shown in Figure 5-4.</span></span>

![統合を構築して (CI) のテスト手順 3 では、プライベートまたはパブリック レジストリに結果の docker イメージを発行する可能性があります。](./media/image4.png)

<span data-ttu-id="e9fe8-182">**図 5-4**</span><span class="sxs-lookup"><span data-stu-id="e9fe8-182">**Figure 5-4**.</span></span> <span data-ttu-id="e9fe8-183">カスタム イメージを Docker レジストリに発行</span><span class="sxs-lookup"><span data-stu-id="e9fe8-183">Publishing custom images to Docker Registry</span></span>

<span data-ttu-id="e9fe8-184">Azure Container Registry、Amazon Web Services Container Registry、Google Container Registry、Quay レジストリなどのクラウド ベンダーからの Docker レジストリの複数のサービス提供しています。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-184">There are multiple offerings of Docker registries from cloud vendors like Azure Container Registry, Amazon Web Services Container Registry, Google Container Registry, Quay Registry, and so on.</span></span>

<span data-ttu-id="e9fe8-185">Docker タスクを使用して、定義したサービスのイメージのセットをプッシュすることができます、`docker-compose.yml`ファイル (Azure Container Registry) などの認証済みの Docker レジストリに、複数のタグと図 5-5 に示すようにします。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-185">Using the Docker tasks, you can push a set of service images defined by a `docker-compose.yml` file, with multiple tags, to an authenticated Docker registry (like Azure Container Registry), as shown in Figure 5-5.</span></span>

![Azure DevOps からレジストリにイメージを発行する手順のブラウザー ビュー。](./media/image5.png)

<span data-ttu-id="e9fe8-187">**図 5-5**</span><span class="sxs-lookup"><span data-stu-id="e9fe8-187">**Figure 5-5**.</span></span> <span data-ttu-id="e9fe8-188">Azure DevOps サービスを使用して Docker レジストリにカスタム イメージを発行する</span><span class="sxs-lookup"><span data-stu-id="e9fe8-188">Using Azure DevOps Services to publishing custom images to a Docker Registry</span></span>

> [!情報]<span data-ttu-id="e9fe8-189"> Azure Container Registry の詳細については、次を参照してください。<https://aka.ms/azurecontainerregistry>します。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-189"> For more information about Azure Container Registry, see <https://aka.ms/azurecontainerregistry>.</span></span>

## <a name="step-4-cd-deploy"></a><span data-ttu-id="e9fe8-190">手順 4: CD、展開</span><span class="sxs-lookup"><span data-stu-id="e9fe8-190">Step 4: CD, Deploy</span></span>

<span data-ttu-id="e9fe8-191">Docker イメージの不変性により、反復可能な展開に何が開発、CI、テストし、運用環境で実行します。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-191">The immutability of Docker images ensures a repeatable deployment with what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="e9fe8-192">所持している複数の環境に展開したり、Docker レジストリ (プライベートまたはパブリック) で公開されているアプリケーションの Docker イメージを作成したら、(運用、QA、ステージングなど) Azure DevOps サービスを使用して、CD パイプラインからパイプラインのタスクまたは Azure DevOps サービス リリース管理されます。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-192">After you have the application Docker images published in your Docker registry (either private or public), you can deploy them to the several environments that you might have (production, QA, staging, etc.) from your CD pipeline by using Azure DevOps Services pipeline tasks or Azure DevOps Services Release Management.</span></span>

<span data-ttu-id="e9fe8-193">ただし、この時点でそれに依存展開する Docker アプリケーションの種類。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-193">However, at this point it depends on what kind of Docker application you're deploying.</span></span> <span data-ttu-id="e9fe8-194">簡単なアプリケーション (構成と展開の観点から)、モノリシックのように、いくつかのコンテナーやサービスを構成するアプリケーションと展開をいくつかのサーバーまたは Vm を展開するとは異なるような複雑なアプリケーションを展開します。ハイパー スケール機能を備えたマイクロ サービス指向アプリケーションです。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-194">Deploying a simple application (from a composition and deployment point of view) like a monolithic application comprising a few containers or services and deployed to a few servers or VMs is different from deploying a more complex application like a microservices-oriented application with hyperscale capabilities.</span></span> <span data-ttu-id="e9fe8-195">これら 2 つのシナリオは、次のセクションについて説明します。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-195">These two scenarios are explained in the following sections.</span></span>

### <a name="deploying-composed-docker-applications-to-multiple-docker-environments"></a><span data-ttu-id="e9fe8-196">複数の Docker 環境への Docker アプリケーションの展開で構成されています</span><span class="sxs-lookup"><span data-stu-id="e9fe8-196">Deploying composed Docker applications to multiple Docker environments</span></span>

<span data-ttu-id="e9fe8-197">最初に、複雑なシナリオを見てみましょう。 単純で Docker ホスト (Vm またはサーバー) 環境を 1 つまたは複数の環境に展開する (品質保証、ステージング、および運用)。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-197">Let's look first at the less-complex scenario: deploying to simple Docker hosts (VMs or servers) in a single environment or multiple environments (QA, staging, and production).</span></span> <span data-ttu-id="e9fe8-198">このシナリオで内部的には、CD パイプラインできますを使用して docker-図 5-6 に示すようにコンテナーやサービス、その関連する一連の Docker アプリケーションを展開する (Azure DevOps サービス展開タスク) から作成します。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-198">In this scenario, internally your CD pipeline can use docker-compose (from your Azure DevOps Services deployment tasks) to deploy the Docker applications with its related set of containers or services, as illustrated in Figure 5-6.</span></span>

![CD のデプロイ手順 (4) q などのさまざまな環境に発行することができます (&)、ステージングと運用します。](./media/image6.png)

<span data-ttu-id="e9fe8-200">**図 5-6**します。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-200">**Figure 5-6**.</span></span> <span data-ttu-id="e9fe8-201">単純な Docker ホスト環境のレジストリにアプリケーション コンテナーのデプロイ</span><span class="sxs-lookup"><span data-stu-id="e9fe8-201">Deploying application containers to simple Docker host environments registry</span></span>

<span data-ttu-id="e9fe8-202">図 5-7 は、タスクの追加 ダイアログ ボックスの Docker Compose をクリックして、Azure DevOps サービスを使用して、QA/テスト環境にビルド、CI を接続する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-202">Figure 5-7 highlights how you can connect your build CI to QA/test environments via Azure DevOps Services by clicking Docker Compose in the Add Task dialog box.</span></span> <span data-ttu-id="e9fe8-203">ただし、ステージング環境または運用環境を展開する場合は、通常使用する Release Management の機能が複数の環境を処理 (などの QA、ステージング、および運用)。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-203">However, when deploying to staging or production environments, you would usually use Release Management features handling multiple environments (like QA, staging, and production).</span></span> <span data-ttu-id="e9fe8-204">Azure DevOps サービスを使用して単一の Docker ホストにデプロイする場合は"Docker Compose"タスク (を呼び出すことは、`docker-compose up`内部的にはコマンド)。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-204">If you're deploying to single Docker hosts, it is using the Azure DevOps Services "Docker Compose" task (which is invoking the `docker-compose up` command under the hood).</span></span> <span data-ttu-id="e9fe8-205">Azure Container Service にデプロイする場合は、以下のセクションで説明したように、Docker デプロイ タスクを使用します。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-205">If you're deploying to Azure Container Service, it uses the Docker Deployment task, as explained in the section that follows.</span></span>

![ブラウザー ビューの Docker Compose のタスクを追加します。](./media/image7.png)

<span data-ttu-id="e9fe8-207">**図 5-7**</span><span class="sxs-lookup"><span data-stu-id="e9fe8-207">**Figure 5-7**.</span></span> <span data-ttu-id="e9fe8-208">Azure DevOps サービス パイプラインで Docker Compose のタスクを追加します。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-208">Adding a Docker Compose task in an Azure DevOps Services pipeline</span></span>

<span data-ttu-id="e9fe8-209">Azure DevOps サービスで、リリースを作成するときに、一連の入力の成果物がかかります。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-209">When you create a release in Azure DevOps Services, it takes a set of input artifacts.</span></span> <span data-ttu-id="e9fe8-210">これらの成果物が意図されていない変更可能なリリースの有効期間のすべての環境で。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-210">These artifacts are intended to be immutable for the lifetime of the release, across all environments.</span></span> <span data-ttu-id="e9fe8-211">コンテナーを導入するときに、入力の成果物を展開する、レジストリ内のイメージを識別します。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-211">When you introduce containers, the input artifacts identify images in a registry to deploy.</span></span> <span data-ttu-id="e9fe8-212">これらのイメージの識別方法に応じてする保証はありません、最も明白なケースが参照すると、リリースの全期間にわたって同じまま`myimage:latest`から、`docker-compose`ファイル。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-212">Depending on how these images are identified, they are not guaranteed to remain the same throughout the duration of the release, the most obvious case being when you reference `myimage:latest` from a `docker-compose` file.</span></span>

<span data-ttu-id="e9fe8-213">Azure DevOps サービス テンプレートが表示ダイジェストとなる特定のレジストリのイメージが含まれているビルド成果物を生成する機能と同じイメージのバイナリを一意に識別することが保証されます。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-213">The Azure DevOps Services templates give you the ability to generate build artifacts that contain specific registry image digests that are guaranteed to uniquely identify the same image binary.</span></span> <span data-ttu-id="e9fe8-214">これらは実際に、リリースへの入力として使用します。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-214">These are what you really want to use as input to a release.</span></span>

### <a name="managing-releases-to-docker-environments-by-using-azure-devops-services-release-management"></a><span data-ttu-id="e9fe8-215">Azure DevOps Services Release Management を使用して Docker 環境にリリースを管理します。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-215">Managing releases to Docker environments by using Azure DevOps Services Release Management</span></span>

<span data-ttu-id="e9fe8-216">Azure DevOps サービス テンプレートを新しいイメージをビルド、Docker レジストリに発行して、Linux または Windows のホストで実行してのコマンドを使用します`docker-compose`Azure DevOps などのアプリケーションが全体として複数のコンテナーをデプロイするには。図 5-8 に示すように複数の環境用リリース管理機能をサービスします。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-216">Through the Azure DevOps Services templates, you can build a new image, publish it to a Docker registry, run it on Linux or Windows hosts, and use commands such as `docker-compose` to deploy multiple containers as an entire application, all through the Azure DevOps Services Release Management capabilities intended for multiple environments, as shown in Figure 5-8.</span></span>

![Azure DevOps, Docker の構成のブラウザー ビューでは、リリースを作成します。](./media/image8.png)

<span data-ttu-id="e9fe8-218">**図 5-8**.</span><span class="sxs-lookup"><span data-stu-id="e9fe8-218">**Figure 5-8**.</span></span> <span data-ttu-id="e9fe8-219">Azure DevOps サービス Release Management から Azure DevOps サービスの Docker Compose のタスクを構成します。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-219">Configuring Azure DevOps Services Docker Compose tasks from Azure DevOps Services Release Management</span></span>

<span data-ttu-id="e9fe8-220">ただし、図 5-6 に示すように、図 5-8 の実装のシナリオは、単純なものにしてください (単一の Docker ホストと Vm への展開は、および 1 つのコンテナーまたはイメージごとのインスタンス) と、おそらく、開発またはテスト sce に対してのみ使用する必要がありますnarios します。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-220">However, keep in mind that the scenario shown in Figure 5-6 and implemented in Figure 5-8 is a simple one (it's deploying to single Docker hosts and VMs, and there will be a single container or instance per image) and probably should be used only for development or test scenarios.</span></span> <span data-ttu-id="e9fe8-221">高可用性 (HA) と管理が容易なスケーラビリティが複数のノード、サーバー、Vm、および「インテリジェントなフェールオーバー」の間で負荷分散をするほとんどのエンタープライズ運用環境シナリオで、サーバーまたはノードが失敗した場合、そのサービスとコンテナー別のホスト サーバーまたは VM に移動されます。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-221">In most enterprise production scenarios, you would want to have High Availability (HA) and easy-to-manage scalability by load balancing across multiple nodes, servers, and VMs, plus "intelligent failovers" so if a server or node fails, its services and containers will be moved to another host server or VM.</span></span> <span data-ttu-id="e9fe8-222">その場合は、クラスターのコンテナー、オーケストレーター、およびスケジューラなどのより高度なテクノロジ必要があります。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-222">In that case, you need more advanced technologies such as container clusters, orchestrators, and schedulers.</span></span> <span data-ttu-id="e9fe8-223">したがって、これらのクラスターにデプロイする方法は、高度なシナリオを処理することで、[次へ] のセクションで説明します。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-223">Thus, the way to deploy to those clusters is by handling the advanced scenarios explained in the next section.</span></span>

### <a name="deploying-docker-applications-to-docker-clusters"></a><span data-ttu-id="e9fe8-224">Docker クラスターへの Docker アプリケーションの展開</span><span class="sxs-lookup"><span data-stu-id="e9fe8-224">Deploying Docker applications to Docker clusters</span></span>

<span data-ttu-id="e9fe8-225">分散アプリケーションの性質も分散されるコンピューティング リソースが必要です。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-225">The nature of distributed applications requires compute resources that are also distributed.</span></span> <span data-ttu-id="e9fe8-226">運用規模の機能には、高いスケーラビリティとプールされたリソースに基づく、高可用性を提供する機能をクラスタ リングにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-226">To have production-scale capabilities, you need to have clustering capabilities that provide high scalability and high availability based on pooled resources.</span></span>

<span data-ttu-id="e9fe8-227">コンテナーを CLI ツールまたは web UI からこれらのクラスターに手動でデプロイできますが、その種のスポット展開のテストに手動の作業を予約する必要があります。 またはスケール アウトや監視などの管理のため。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-227">You could deploy containers manually to those clusters from a CLI tool or a web UI, but you should reserve that kind of manual work to spot deployment testing or management purposes like scaling-out or monitoring.</span></span>

<span data-ttu-id="e9fe8-228">CD の観点と Azure DevOps サービスから具体的には、タスクを実行できます特別に作成された展開から、Azure DevOps サービス リリース管理環境をコンテナーに分散クラスターにコンテナー化されたアプリケーションを展開します。図 5-9 に示すようには、サービスです。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-228">From a CD point of view, and Azure DevOps Services specifically, you can run specially made deployment tasks from your Azure DevOps Services Release Management environments that will deploy your containerized applications to distributed clusters in Container Service, as illustrated in Figure 5-9.</span></span>

![CD のデプロイ手順 (4) はオーケストレーターを使ってクラスターにも発行できます。](./media/image9.png)

<span data-ttu-id="e9fe8-230">**図 5-9**</span><span class="sxs-lookup"><span data-stu-id="e9fe8-230">**Figure 5-9**.</span></span> <span data-ttu-id="e9fe8-231">分散アプリケーションをコンテナー サービスを展開します。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-231">Deploying distributed applications to Container Service</span></span>

<span data-ttu-id="e9fe8-232">最初を特定のクラスターやオーケストレーターに展開する場合は従来使用して特定の展開スクリプトと各オーケストレーター (Kubernetes およびさまざまな展開メカニズムがある Service Fabric) メカニズムではなく、単純です使いやすい`docker-compose`に基づいてツール、`docker-compose.yml`定義ファイル。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-232">Initially, when deploying to certain clusters or orchestrators, you would traditionally use specific deployment scripts and mechanisms per each orchestrator (that is, Kubernetes and Service Fabric have different deployment mechanisms) instead of the simpler and easy-to-use `docker-compose` tool based on the `docker-compose.yml` definition file.</span></span> <span data-ttu-id="e9fe8-233">ただし、図 5-10 に示すように、Azure DevOps サービスの Docker デプロイ タスクに協力してくれたするようになりましたデプロイこともできますサポートされているオーケストレーターを使い慣れたを使用するだけで`docker-compose.yml`ツールが「変換」を実行するためのファイル (、から`docker-compose.yml`をオーケストレーターで必要な形式のファイル)。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-233">However, thanks to the Azure DevOps Services Docker Deploy task, shown in Figure 5-10, you now also can deploy to the supported orchestrators by just using your familiar `docker-compose.yml` file because the tool performs that “translation” for you (from your `docker-compose.yml` file to the format needed by the orchestrator).</span></span>

![タスク カタログ内の Docker を示す、Azure DevOps のブラウザー ビューでは、タスクをデプロイします。](./media/image10.png)

<span data-ttu-id="e9fe8-235">**図 5-10**</span><span class="sxs-lookup"><span data-stu-id="e9fe8-235">**Figure 5-10**.</span></span> <span data-ttu-id="e9fe8-236">RM 環境への Docker デプロイ タスクの追加</span><span class="sxs-lookup"><span data-stu-id="e9fe8-236">Adding the Docker Deploy task to your Environment RM</span></span>

<span data-ttu-id="e9fe8-237">図 5-11 は、Docker の展開タスクを編集し、対象の型 (Azure Container Service DC/OS、ここでは)、Docker Compose ファイル、および (Azure Container Registry や Docker Hub) などの Docker レジストリ接続を指定する方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-237">Figure 5-11 demonstrates how you can edit the Docker Deploy task and specify the Target Type (Azure Container Service DC/OS, in this case), your Docker Compose File, and the Docker Registry connection (like Azure Container Registry or Docker Hub).</span></span> <span data-ttu-id="e9fe8-238">これは、すぐに使用できるカスタム Docker イメージとして、クラスター内のコンテナー デプロイを取得するタスク。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-238">This is the task that will retrieve your ready-to-use custom Docker images to be deployed as containers in the cluster.</span></span>

![Azure DevOps, のブラウザー ビューは、orchestrator タスクの定義を展開します。](./media/image11.png)

<span data-ttu-id="e9fe8-240">**図 5-11**</span><span class="sxs-lookup"><span data-stu-id="e9fe8-240">**Figure 5-11**.</span></span> <span data-ttu-id="e9fe8-241">Docker デプロイ タスクの定義を展開する Azure Container Service DC/OS に</span><span class="sxs-lookup"><span data-stu-id="e9fe8-241">Docker Deploy task definition deploying to Azure Container Service DC/OS</span></span>

> [!詳細情報]<span data-ttu-id="e9fe8-242"> に関する Azure DevOps サービスと Docker の CD パイプラインを次を参照してください。 <https://azure.microsoft.com/services/devops/pipelines></span><span class="sxs-lookup"><span data-stu-id="e9fe8-242"> To read more about the CD pipeline with Azure DevOps Services and Docker, visit <https://azure.microsoft.com/services/devops/pipelines></span></span>

## <a name="step-5-run-and-manage"></a><span data-ttu-id="e9fe8-243">手順 5: 実行し、管理</span><span class="sxs-lookup"><span data-stu-id="e9fe8-243">Step 5: Run and manage</span></span>

<span data-ttu-id="e9fe8-244">エンタープライズ運用レベルは、し、それ自体のと操作の種類のための主要なサブジェクトと、ユーザーがこの領域の大きなスコープとそのレベル (IT 運用) にとって、全体の次の章に充てるを実行していると、アプリケーションを管理するため、これを説明します。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-244">Because running and managing applications at enterprise-production level is a major subject in and of itself, and due to the type of operations and people working at that level (IT operations) as well as the large scope of this area, the entire next chapter is devoted to explaining it.</span></span>

## <a name="step-6-monitor-and-diagnose"></a><span data-ttu-id="e9fe8-245">手順 6: 監視し、診断</span><span class="sxs-lookup"><span data-stu-id="e9fe8-245">Step 6: Monitor and diagnose</span></span>

<span data-ttu-id="e9fe8-246">このトピックでは、次についても説明、タスクの一部として章実稼働システムでその IT を実行しますただしが、アプリケーションが頻繁に改善するために、開発チームにこの手順で得られた知見をフィードする必要がありますを強調表示に重要です。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-246">This topic also is covered in the next chapter as part of the tasks that IT performs in production systems; however, is important to highlight that the insights obtained in this step must feed back to the development team so that the application is constantly improved.</span></span> <span data-ttu-id="e9fe8-247">そのポイントの表示からもの一部では、DevOps タスクと操作によって実行が一般的ですが IT です。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-247">From that point of view, it's also part of DevOps, although the tasks and operations are commonly performed by IT.</span></span>

<span data-ttu-id="e9fe8-248">監視と診断は、DevOps の領域内の 100% の場合にのみは、監視のプロセスとまたはベータ版のテスト環境に対して、開発チームによって実行された分析です。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-248">Only when monitoring and diagnostics are 100% within the realm of DevOps are the monitoring processes and analytics performed by the development team against testing or beta environments.</span></span> <span data-ttu-id="e9fe8-249">これは、ロード テストを実行するか、ベータ版またはベータ テスト担当者が新しいバージョンを試みている、QA 環境を監視します。</span><span class="sxs-lookup"><span data-stu-id="e9fe8-249">This is done either by performing load testing or by monitoring beta or QA environments, where beta testers are trying the new versions.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="e9fe8-250">[前へ](index.md)
>[次へ](create-ci-cd-pipelines-azure-devops-services-aspnetcore-kubernetes.md)</span><span class="sxs-lookup"><span data-stu-id="e9fe8-250">[Previous](index.md)
[Next](create-ci-cd-pipelines-azure-devops-services-aspnetcore-kubernetes.md)</span></span>
