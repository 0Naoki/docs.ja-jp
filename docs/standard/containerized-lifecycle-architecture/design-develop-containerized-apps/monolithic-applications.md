---
title: モノリシック アプリケーション
description: モノリシック アプリケーションをコンテナー化の主要な概念を理解します。
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 11/23/2018
ms.openlocfilehash: 056f4bd8abf5c482855f38e45435b67b487769fb
ms.sourcegitcommit: 30e2fe5cc4165aa6dde7218ec80a13def3255e98
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/13/2019
ms.locfileid: "56221356"
---
# <a name="monolithic-applications"></a><span data-ttu-id="fb998-103">モノリシック アプリケーション</span><span class="sxs-lookup"><span data-stu-id="fb998-103">Monolithic applications</span></span>

<span data-ttu-id="fb998-104">このシナリオでは、1 つのモノリシックな web アプリケーションまたはサービスを構築、コンテナーとして展開します。</span><span class="sxs-lookup"><span data-stu-id="fb998-104">In this scenario, you are building a single and monolithic web application or service and deploying it as a container.</span></span> <span data-ttu-id="fb998-105">アプリケーション内で、構造体できない可能性がありますモノリシック;いくつかのライブラリ、コンポーネント、またはさらにはレイヤー (アプリケーション層、ドメイン層、データ アクセス層など) を構成する場合があります。</span><span class="sxs-lookup"><span data-stu-id="fb998-105">Within the application, the structure might not be monolithic; it might comprise several libraries, components, or even layers (application layer, domain layer, data access layer, etc.).</span></span> <span data-ttu-id="fb998-106">外部で 1 つのプロセス、単一の web アプリケーション、または 1 つのサービスのように、1 つのコンテナーになります。</span><span class="sxs-lookup"><span data-stu-id="fb998-106">Externally, it is a single container, like a single process, single web application, or single service.</span></span>

<span data-ttu-id="fb998-107">このモデルを管理するには、アプリケーションを表す単一のコンテナーを展開します。</span><span class="sxs-lookup"><span data-stu-id="fb998-107">To manage this model, you deploy a single container to represent the application.</span></span> <span data-ttu-id="fb998-108">これを拡大するには、ロード バランサーを前面に配置してコピーをいくつか追加します。</span><span class="sxs-lookup"><span data-stu-id="fb998-108">To scale it, just add a few more copies with a load balancer in front.</span></span> <span data-ttu-id="fb998-109">わかりやすくするため、1 つのコンテナーまたは仮想マシン (VM) で 1 つの展開の管理に由来します。</span><span class="sxs-lookup"><span data-stu-id="fb998-109">The simplicity comes from managing a single deployment in a single container or virtual machine (VM).</span></span>

<span data-ttu-id="fb998-110">次のコンテナーがのみ、この操作を 1 つと、1 つのプロセスでは、プリンシパル、モノリシック パターンが競合します。</span><span class="sxs-lookup"><span data-stu-id="fb998-110">Following the principal that a container does one thing only, and does it in one process, the monolithic pattern is in conflict.</span></span> <span data-ttu-id="fb998-111">図 4-1 に示すように、複数のコンポーネント/ライブラリ、または内部レイヤーを各コンテナーを含めることができます。</span><span class="sxs-lookup"><span data-stu-id="fb998-111">You can include multiple components/libraries or internal layers within each container, as illustrated in Figure 4-1.</span></span>

![](./media/image1.png)

<span data-ttu-id="fb998-112">図 4-1:モノリシック アプリケーションのアーキテクチャの例</span><span class="sxs-lookup"><span data-stu-id="fb998-112">Figure 4-1: An example of monolithic application architecture</span></span>

<span data-ttu-id="fb998-113">このアプローチの欠点は、またはアプリケーションを拡張、スケーリングする必要な場合は取得されます。</span><span class="sxs-lookup"><span data-stu-id="fb998-113">The downside to this approach comes if or when the application grows, requiring it to scale.</span></span> <span data-ttu-id="fb998-114">アプリケーション全体がスケーリングすれば、実際には問題ではありません。</span><span class="sxs-lookup"><span data-stu-id="fb998-114">If the entire application scaled, it's not really a problem.</span></span> <span data-ttu-id="fb998-115">ただし、ほとんどの場合、アプリケーションのいくつかの部分はチョーク ポイントをスケーリングするには、必要とするその他のコンポーネントを使用する小さい。</span><span class="sxs-lookup"><span data-stu-id="fb998-115">However, in most cases, a few parts of the application are the choke points that require scaling, whereas other components are used less.</span></span>

<span data-ttu-id="fb998-116">一般的な e コマースの例を使用して、可能性の高いが必要な製品情報のコンポーネントをスケーリングします。</span><span class="sxs-lookup"><span data-stu-id="fb998-116">Using the typical e-commerce example, what you likely need is to scale the product information component.</span></span> <span data-ttu-id="fb998-117">製品を購入するユーザーよりも多くのユーザーが製品を参照します。</span><span class="sxs-lookup"><span data-stu-id="fb998-117">Many more customers browse products than purchase them.</span></span> <span data-ttu-id="fb998-118">より多くの顧客が、支払いパイプラインではなくバスケットを使用します。</span><span class="sxs-lookup"><span data-stu-id="fb998-118">More customers use their basket than use the payment pipeline.</span></span> <span data-ttu-id="fb998-119">コメントを追加したり、購入履歴を表示したりする顧客はそれほどいません。</span><span class="sxs-lookup"><span data-stu-id="fb998-119">Fewer customers add comments or view their purchase history.</span></span> <span data-ttu-id="fb998-120">ごく少数のコンテンツとマーケティング キャンペーンを管理する必要がある 1 つのリージョン内の従業員がある可能性があります。</span><span class="sxs-lookup"><span data-stu-id="fb998-120">And you likely have only a handful of employees, in a single region, that need to manage the content and marketing campaigns.</span></span> <span data-ttu-id="fb998-121">モノリシックな設計をスケールすることによって複数回のコードをすべて配置されます。</span><span class="sxs-lookup"><span data-stu-id="fb998-121">By scaling the monolithic design, all of the code is deployed multiple times.</span></span>

<span data-ttu-id="fb998-122">ほかに、"スケール-すべての"アプリケーション全体とすべてのインスタンスの完全に再展開を完全に再テストの問題、1 つのコンポーネントへの変更を必要とします。</span><span class="sxs-lookup"><span data-stu-id="fb998-122">In addition to the "scale-everything" problem, changes to a single component require complete retesting of the entire application as well as a complete redeployment of all the instances.</span></span>

<span data-ttu-id="fb998-123">モノリシック アプローチは一般的であり、多くの組織はこのアーキテクチャのメソッドを使用して開発します。</span><span class="sxs-lookup"><span data-stu-id="fb998-123">The monolithic approach is common, and many organizations are developing with this architectural method.</span></span> <span data-ttu-id="fb998-124">多くは利用制限が発生する他のユーザーが、十分な結果では良いです。</span><span class="sxs-lookup"><span data-stu-id="fb998-124">Many enjoy good enough results, whereas others encounter limits.</span></span> <span data-ttu-id="fb998-125">ツールとインフラストラクチャが複雑すぎて、Soa を構築し、必要性が表示していないために、このモデルでアプリケーションを設計多く — まで、アプリが成長しました。</span><span class="sxs-lookup"><span data-stu-id="fb998-125">Many designed their applications in this model because the tools and infrastructure were too difficult to build SOAs, and they didn't see the need—until the app grew.</span></span>

<span data-ttu-id="fb998-126">インフラストラクチャの観点からは、各サーバーは、同じホスト内で多くのアプリケーションを実行し、図 4-2 に示すように、リソース使用量に効率の許容の比率があります。</span><span class="sxs-lookup"><span data-stu-id="fb998-126">From an infrastructure perspective, each server can run many applications within the same host and have an acceptable ratio of efficiency in your resources usage, as shown in Figure 4-2.</span></span>

![](./media/image2.png)

<span data-ttu-id="fb998-127">図 4-2:複数のアプリ/コンテナーを実行しているホスト</span><span class="sxs-lookup"><span data-stu-id="fb998-127">Figure 4-2: A host running multiple apps/containers</span></span>

<span data-ttu-id="fb998-128">インスタンスごとに専用の Vm を使用して、Azure のモノリシック アプリケーションをデプロイできます。</span><span class="sxs-lookup"><span data-stu-id="fb998-128">You can deploy monolithic applications in Azure by using dedicated VMs for each instance.</span></span> <span data-ttu-id="fb998-129">使用して[Azure VM Scale Sets](https://docs.microsoft.com/azure/virtual-machine-scale-sets/)Vm を簡単にスケールすることができます。</span><span class="sxs-lookup"><span data-stu-id="fb998-129">Using [Azure VM Scale Sets](https://docs.microsoft.com/azure/virtual-machine-scale-sets/), you can scale the VMs easily.</span></span> <span data-ttu-id="fb998-130">[Azure App Service](https://azure.microsoft.com/services/app-service/) では、VM の管理を必要とせずに、モノリシック アプリケーションを実行し、インスタンスを簡単にスケーリングすることができます。</span><span class="sxs-lookup"><span data-stu-id="fb998-130">[Azure App Services](https://azure.microsoft.com/services/app-service/) can run monolithic applications and easily scale instances without having to manage the VMs.</span></span> <span data-ttu-id="fb998-131">2016 年以降、Azure App Services は、特定、展開を簡素化も、Docker コンテナーの単一インスタンスを実行できます。</span><span class="sxs-lookup"><span data-stu-id="fb998-131">Since 2016, Azure App Services can run single instances of Docker containers, as well, simplifying the deployment.</span></span> <span data-ttu-id="fb998-132">また、Docker を使用して、Docker ホストとして 1 つの VM をデプロイして実行する複数のインスタンス。</span><span class="sxs-lookup"><span data-stu-id="fb998-132">And, using Docker, you can deploy a single VM as a Docker host and run multiple instances.</span></span> <span data-ttu-id="fb998-133">図 4-3 に示すようには、Azure バランサーを使用して、スケーリングを管理できます。</span><span class="sxs-lookup"><span data-stu-id="fb998-133">Using the Azure balancer, as illustrated in the Figure 4-3, you can manage scaling.</span></span>

![](./media/image3.png)

<span data-ttu-id="fb998-134">図 4-3:Docker アプリケーションのアプリ/コンテナーが 1 つをスケール アウトの複数のホスト</span><span class="sxs-lookup"><span data-stu-id="fb998-134">Figure 4-3: Multiple hosts scaling-out a single Docker application apps/containers</span></span>

<span data-ttu-id="fb998-135">従来の展開手法を使用してさまざまなホストに展開を管理することができます。</span><span class="sxs-lookup"><span data-stu-id="fb998-135">You can manage the deployment to the various hosts via traditional deployment techniques.</span></span> <span data-ttu-id="fb998-136">ようなコマンドを使用して Docker ホストを管理することができます`docker run`継続的デリバリー (CD) パイプラインは、この電子書籍の後半で説明などのオートメーションによって手動でします。</span><span class="sxs-lookup"><span data-stu-id="fb998-136">You can manage Docker hosts by using commands like `docker run` manually, through automation such as Continuous Delivery (CD) pipelines, which we explain later in this e-book.</span></span>

## <a name="monolithic-application-deployed-as-a-container"></a><span data-ttu-id="fb998-137">コンテナーとして展開するモノリシック アプリケーション</span><span class="sxs-lookup"><span data-stu-id="fb998-137">Monolithic application deployed as a container</span></span>

<span data-ttu-id="fb998-138">モノリシック展開を管理するコンテナーを使用する利点があります。</span><span class="sxs-lookup"><span data-stu-id="fb998-138">There are benefits to using containers to manage monolithic deployments.</span></span> <span data-ttu-id="fb998-139">コンテナーのインスタンスをスケーリングする処理は、追加の VM を展開するよりもはるかに高速で簡単です。</span><span class="sxs-lookup"><span data-stu-id="fb998-139">Scaling the instances of containers is far faster and easier than deploying additional VMs.</span></span> <span data-ttu-id="fb998-140">VM スケール セットは、Docker コンテナーをホストに必要な Vm をスケールする優れた機能は、セットアップに時間がかかります。</span><span class="sxs-lookup"><span data-stu-id="fb998-140">Although VM Scale Sets are a great feature to scale VMs, which are required to host your Docker containers, they take time to set up.</span></span> <span data-ttu-id="fb998-141">アプリのインスタンスとして展開する場合、アプリの構成は VM の一部として管理されます。</span><span class="sxs-lookup"><span data-stu-id="fb998-141">When deployed as app instances, the configuration of the app is managed as part of the VM.</span></span>

<span data-ttu-id="fb998-142">更新プログラムを Docker イメージとして展開する方がはるかに高速で、ネットワークの効率が高くなります。</span><span class="sxs-lookup"><span data-stu-id="fb998-142">Deploying updates as Docker images is far faster and network efficient.</span></span> <span data-ttu-id="fb998-143">Vn インスタンスは、追加の Vm による追加のコストを排除し、Vn 1 インスタンスと同じホストで設定できます。</span><span class="sxs-lookup"><span data-stu-id="fb998-143">The Vn instances can be set up on the same hosts as your Vn-1 instances, eliminating added costs resulting from additional VMs.</span></span> <span data-ttu-id="fb998-144">通常、docker イメージは、秒、ロールアウトが高速化で起動します。</span><span class="sxs-lookup"><span data-stu-id="fb998-144">Docker images typically start in seconds, speeding rollouts.</span></span> <span data-ttu-id="fb998-145">呼び出しと同じくらい簡単では Docker インスタンスの破棄、`docker stop`コマンドは、通常は 1 秒未満で完了します。</span><span class="sxs-lookup"><span data-stu-id="fb998-145">Tearing down a Docker instance is as easy as invoking the `docker stop` command, typically completing in less than a second.</span></span>

<span data-ttu-id="fb998-146">コンテナーが本質的に、設計上不変なので、決して更新スクリプトをいくつかの特定の構成またはファイルがディスク上の残りのアカウントを忘れたために、Vm の破損について心配する必要があります。</span><span class="sxs-lookup"><span data-stu-id="fb998-146">Because containers are inherently immutable, by design, you never need to worry about corrupted VMs because an update script forgot to account for some specific configuration or file left on disk.</span></span>

<span data-ttu-id="fb998-147">モノリシック アプリケーションは Docker の恩恵がメリットのヒントのみ面しています。</span><span class="sxs-lookup"><span data-stu-id="fb998-147">Although monolithic apps can benefit from Docker, we're touching on only the tips of the benefits.</span></span> <span data-ttu-id="fb998-148">コンテナーの管理の大きな利点は、さまざまなインスタンスと各コンテナー インスタンスのライフ サイクルを管理するコンテナー オーケストレーターに展開するから取得されます。</span><span class="sxs-lookup"><span data-stu-id="fb998-148">The larger benefits of managing containers comes from deploying with container orchestrators that manage the various instances and life cycle of each container instance.</span></span> <span data-ttu-id="fb998-149">モノリシック アプリケーションを、スケーリング、開発、および展開を個別に実行できるサブシステムに分割することが、マイクロサービスの領域への入り口になります。</span><span class="sxs-lookup"><span data-stu-id="fb998-149">Breaking up the monolithic application into subsystems that can be scaled, developed, and deployed individually is your entry point into the realm of microservices.</span></span>

## <a name="publishing-a-single-docker-container-app-to-azure-app-service"></a><span data-ttu-id="fb998-150">Azure App Service への 1 つの Docker コンテナー アプリの発行</span><span class="sxs-lookup"><span data-stu-id="fb998-150">Publishing a single Docker container app to Azure App Service</span></span>

<span data-ttu-id="fb998-151">いずれかを Azure にデプロイされたコンテナーのクイック検証を取得するか、アプリ、単に単一のコンテナー アプリを Azure App Services は、スケーラブルな単一のコンテナー サービスを提供する優れた方法を提供します。</span><span class="sxs-lookup"><span data-stu-id="fb998-151">Either because you want to get a quick validation of a container deployed to Azure or because the app is simply a single-container app, Azure App Services provides a great way to provide scalable single-container services.</span></span>

<span data-ttu-id="fb998-152">直感的に Azure App Service を使用してとさせることができ、優れた Git を提供するため、迅速に実行されているコードへの統合は Microsoft Visual studio でビルドし、直接 Azure にデプロイします。</span><span class="sxs-lookup"><span data-stu-id="fb998-152">Using Azure App Service is intuitive and you can get up and running quickly because it provides great Git integration to take your code, build it in Microsoft Visual Studio, and directly deploy it to Azure.</span></span> <span data-ttu-id="fb998-153">従来 (Docker を使用しない) 必要があるその他の機能、フレームワーク、または依存関係では、App Services でサポートされていない場合、Azure チームは、App Service でこれらの依存関係を更新するまで待機するために必要かなどの他のサービスに切り替えることが、Service Fabric、Cloud Services、またはプレーン Vm、対象のコントロールをさらがあるし、アプリケーションの必要なコンポーネントやフレームワークをインストールできます。</span><span class="sxs-lookup"><span data-stu-id="fb998-153">But, traditionally (with no Docker), if you needed other capabilities, frameworks, or dependencies that aren't supported in App Services, you needed to wait for it until the Azure team updates those dependencies in App Service or switched to other services like Service Fabric, Cloud Services, or even plain VMs, for which you have further control and can install a required component or framework for your application.</span></span>

<span data-ttu-id="fb998-154">ここで、ただし、(2016 年 11 月に Microsoft Connect 2016 で発表された) Visual Studio 2017 を使用する場合に、図の 4‑4 のように、Azure App Service でコンテナーをサポートできるようにするアプリの環境で何でも含めるとします。</span><span class="sxs-lookup"><span data-stu-id="fb998-154">Now, however, (announced at Microsoft Connect 2016 in November 2016) and as shown in Figure 4‑4, when using Visual Studio 2017, container support in Azure App Service gives you the ability to include whatever you want in your app environment.</span></span> <span data-ttu-id="fb998-155">コンテナーで実行しているため、アプリに依存関係を追加した場合、ファイルまたは Docker イメージでこれらの依存関係をなどの機能を取得します。</span><span class="sxs-lookup"><span data-stu-id="fb998-155">If you added a dependency to your app, because you are running it in a container, you get the capability of including those dependencies in your Dockerfile or Docker image.</span></span>

![](./media/image4.png)

<span data-ttu-id="fb998-156">図 4-4:Visual Studio のアプリ/コンテナーから Azure App Service にコンテナーを発行する.</span><span class="sxs-lookup"><span data-stu-id="fb998-156">Figure 4-4: Publishing a container to Azure App Service from Visual Studio apps/containers</span></span>

<span data-ttu-id="fb998-157">図 4-4 も発行フローが Azure Container Registry (レジストリを Azure 内の展開に近く、および Azure Active Directory グループとアカウントによって保護された) は、コンテナー レジストリをまたはその他の任意の Docker レジストリを介してイメージをプッシュすることを示していますDocker Hub やオンプレミス レジストリなど。</span><span class="sxs-lookup"><span data-stu-id="fb998-157">Figure 4-4 also shows that the publish flow pushes an image through a Container Registry, which can be the Azure Container Registry (a registry near to your deployments in Azure and secured by Azure Active Directory groups and accounts) or any other Docker Registry like Docker Hub or on-premises registries.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="fb998-158">[前へ](common-container-design-principles.md)
>[次へ](state-and-data-in-docker-applications.md)</span><span class="sxs-lookup"><span data-stu-id="fb998-158">[Previous](common-container-design-principles.md)
[Next](state-and-data-in-docker-applications.md)</span></span>