---
title: モノリシック アプリケーション
description: Microsoft プラットフォームとツールでコンテナー化された Docker アプリケーションのライフサイクル
ms.prod: .net
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 09/22/2017
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: 9be0ac088a90bd34bb93550925d2e0aee5b91a21
ms.sourcegitcommit: 9a4fe1a1c37b26532654b4bbe22d702237950009
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/16/2018
---
# <a name="monolithic-applications"></a><span data-ttu-id="cf74c-103">モノリシック アプリケーション</span><span class="sxs-lookup"><span data-stu-id="cf74c-103">Monolithic applications</span></span>

<span data-ttu-id="cf74c-104">このシナリオで単一引用符と単一の web アプリケーションやサービスを構築しているコンテナーとして展開します。</span><span class="sxs-lookup"><span data-stu-id="cf74c-104">In this scenario, you are building a single and monolithic web application or service and deploying it as a container.</span></span> <span data-ttu-id="cf74c-105">アプリケーション内で、構造体できない可能性がありますモノリシックです。いくつかのライブラリ、コンポーネント、または (アプリケーション レイヤーでドメイン層、データ アクセス層など) でもレイヤーを構成する場合があります。</span><span class="sxs-lookup"><span data-stu-id="cf74c-105">Within the application, the structure might not be monolithic; it might comprise several libraries, components, or even layers (application layer, domain layer, data access layer, etc.).</span></span> <span data-ttu-id="cf74c-106">外部で、1 つのプロセス、1 つの web アプリケーション、または 1 つのサービスと同様に、1 つのコンテナーであります。</span><span class="sxs-lookup"><span data-stu-id="cf74c-106">Externally, it is a single container, like a single process, single web application, or single service.</span></span>

<span data-ttu-id="cf74c-107">このモデルを管理するには、アプリケーションを表す単一のコンテナーを展開します。</span><span class="sxs-lookup"><span data-stu-id="cf74c-107">To manage this model, you deploy a single container to represent the application.</span></span> <span data-ttu-id="cf74c-108">これを拡張するためをロード バランサーを前面にで、いくつかの複数コピーを追加します。</span><span class="sxs-lookup"><span data-stu-id="cf74c-108">To scale it, just add a few more copies with a load balancer in front.</span></span> <span data-ttu-id="cf74c-109">簡単な 1 つのコンテナーまたは仮想マシン (VM) で単一の展開の管理に由来します。</span><span class="sxs-lookup"><span data-stu-id="cf74c-109">The simplicity comes from managing a single deployment in a single container or virtual machine (VM).</span></span>

<span data-ttu-id="cf74c-110">次のコンテナーが 1 つの操作のみと、1 つのプロセスでは、プリンシパルは、モノリシックなパターンは、競合です。</span><span class="sxs-lookup"><span data-stu-id="cf74c-110">Following the principal that a container does one thing only, and does it in one process, the monolithic pattern is in conflict.</span></span> <span data-ttu-id="cf74c-111">図 4-1 に示すように、複数のコンポーネント/ライブラリまたは各コンテナー内の内部のレイヤーを含めることができます。</span><span class="sxs-lookup"><span data-stu-id="cf74c-111">You can include multiple components/libraries or internal layers within each container, as illustrated in Figure 4-1.</span></span>

![](./media/image1.png)

<span data-ttu-id="cf74c-112">図 4-1: モノリシック アプリケーション アーキテクチャの例</span><span class="sxs-lookup"><span data-stu-id="cf74c-112">Figure 4-1: An example of monolithic application architecture</span></span>

<span data-ttu-id="cf74c-113">このアプローチの欠点がある場合、またはアプリケーションが増大すると、拡張を必要とする場合。</span><span class="sxs-lookup"><span data-stu-id="cf74c-113">The downside to this approach comes if or when the application grows, requiring it to scale.</span></span> <span data-ttu-id="cf74c-114">アプリケーション全体がスケーリングすれば、実際には問題ではありません。</span><span class="sxs-lookup"><span data-stu-id="cf74c-114">If the entire application scaled, it's not really a problem.</span></span> <span data-ttu-id="cf74c-115">ただし、ほとんどの場合、アプリケーションのいくつかの部分は、チョーク ポイントをスケーリングを必要とするその他のコンポーネントがあまり使用されてます。</span><span class="sxs-lookup"><span data-stu-id="cf74c-115">However, in most cases, a few parts of the application are the choke points that require scaling, whereas other components are used less.</span></span>

<span data-ttu-id="cf74c-116">一般的な e コマースの使用例を使用して、、製品情報コンポーネントを拡張するは必要な場合が多くあります。</span><span class="sxs-lookup"><span data-stu-id="cf74c-116">Using the typical e-commerce example, what you likely need is to scale the product information component.</span></span> <span data-ttu-id="cf74c-117">製品を購入するユーザーよりも多くのユーザーが製品を参照します。</span><span class="sxs-lookup"><span data-stu-id="cf74c-117">Many more customers browse products than purchase them.</span></span> <span data-ttu-id="cf74c-118">より多くの顧客が、支払いパイプラインではなくバスケットを使用します。</span><span class="sxs-lookup"><span data-stu-id="cf74c-118">More customers use their basket than use the payment pipeline.</span></span> <span data-ttu-id="cf74c-119">コメントを追加したり、購入履歴を表示したりする顧客はそれほどいません。</span><span class="sxs-lookup"><span data-stu-id="cf74c-119">Fewer customers add comments or view their purchase history.</span></span> <span data-ttu-id="cf74c-120">コンテンツやマーケティング キャンペーンを管理する必要がある 1 つの領域内の従業員のほんの一部のみがある可能性があります。</span><span class="sxs-lookup"><span data-stu-id="cf74c-120">And you likely have only a handful of employees, in a single region, that need to manage the content and marketing campaigns.</span></span> <span data-ttu-id="cf74c-121">モノリシックな設計をスケーリングでは、複数回のすべてのコードが配置されます。</span><span class="sxs-lookup"><span data-stu-id="cf74c-121">By scaling the monolithic design, all of the code is deployed multiple times.</span></span>

<span data-ttu-id="cf74c-122">加え、"スケールのすべての"アプリケーション全体とすべてのインスタンスの再配置の完了の完全な再テスト問題、1 つのコンポーネントへの変更を必要とします。</span><span class="sxs-lookup"><span data-stu-id="cf74c-122">In addition to the "scale-everything" problem, changes to a single component require complete retesting of the entire application as well as a complete redeployment of all the instances.</span></span>

<span data-ttu-id="cf74c-123">モノリシックなアプローチは一般的では、多くの組織は、このアーキテクチャのメソッドを使用して開発する.</span><span class="sxs-lookup"><span data-stu-id="cf74c-123">The monolithic approach is common, and many organizations are developing with this architectural method.</span></span> <span data-ttu-id="cf74c-124">多くをご利用いただけます良い十分な結果の制限が発生する他のユーザーがします。</span><span class="sxs-lookup"><span data-stu-id="cf74c-124">Many enjoy good enough results, whereas others encounter limits.</span></span> <span data-ttu-id="cf74c-125">ツールとインフラストラクチャが複雑すぎて、Soa のビルドおりしていない必要があるために、このモデルでのアプリケーションを設計多く: アプリが拡張されるまでです。</span><span class="sxs-lookup"><span data-stu-id="cf74c-125">Many designed their applications in this model because the tools and infrastructure were too difficult to build SOAs, and they didn't see the need—until the app grew.</span></span>

<span data-ttu-id="cf74c-126">インフラストラクチャの観点からは、各サーバーは、同じホスト内で多くのアプリケーションを実行し、図 4-2 に示すように、リソース使用率を効率よく行う許容の比率があります。</span><span class="sxs-lookup"><span data-stu-id="cf74c-126">From an infrastructure perspective, each server can run many applications within the same host and have an acceptable ratio of efficiency in your resources usage, as shown in Figure 4-2.</span></span>

![](./media/image2.png)

<span data-ttu-id="cf74c-127">図 4-2: 複数のアプリ/コンテナーを実行するホスト</span><span class="sxs-lookup"><span data-stu-id="cf74c-127">Figure 4-2: A host running multiple apps/containers</span></span>

<span data-ttu-id="cf74c-128">Azure での単体のアプリケーションを展開するには、インスタンスごとに専用の Vm を使用します。</span><span class="sxs-lookup"><span data-stu-id="cf74c-128">You can deploy monolithic applications in Azure by using dedicated VMs for each instance.</span></span> <span data-ttu-id="cf74c-129">使用して[Azure VM スケール セット](https://docs.microsoft.com/azure/virtual-machine-scale-sets/)Vm を簡単に拡張することができます。</span><span class="sxs-lookup"><span data-stu-id="cf74c-129">Using [Azure VM Scale Sets](https://docs.microsoft.com/azure/virtual-machine-scale-sets/), you can scale the VMs easily.</span></span> <span data-ttu-id="cf74c-130">[Azure App Service](https://azure.microsoft.com/en-us/services/app-service/) では、VM の管理を必要とせずに、モノリシック アプリケーションを実行し、インスタンスを簡単にスケーリングすることができます。</span><span class="sxs-lookup"><span data-stu-id="cf74c-130">[Azure App Services](https://azure.microsoft.com/en-us/services/app-service/) can run monolithic applications and easily scale instances without having to manage the VMs.</span></span> <span data-ttu-id="cf74c-131">2016 年以降、Azure アプリ サービスは、特定の展開の簡素化、同様に、Docker コンテナーの 1 つのインスタンスを実行できます。</span><span class="sxs-lookup"><span data-stu-id="cf74c-131">Since 2016, Azure App Services can run single instances of Docker containers, as well, simplifying the deployment.</span></span> <span data-ttu-id="cf74c-132">Docker を使用して、Docker ホストと 1 つの VM を展開して実行する複数のインスタンス。</span><span class="sxs-lookup"><span data-stu-id="cf74c-132">And, using Docker, you can deploy a single VM as a Docker host and run multiple instances.</span></span> <span data-ttu-id="cf74c-133">図 4-3 に示すように、Azure の負荷分散装置を使用して、スケールを管理できます。</span><span class="sxs-lookup"><span data-stu-id="cf74c-133">Using the Azure balancer, as illustrated in the Figure 4-3, you can manage scaling.</span></span>

![](./media/image3.png)

<span data-ttu-id="cf74c-134">図 4-3: 複数のホスト Docker アプリケーション アプリ/コンテナーが 1 つをスケール アウト</span><span class="sxs-lookup"><span data-stu-id="cf74c-134">Figure 4-3: Multiple hosts scaling-out a single Docker application apps/containers</span></span>

<span data-ttu-id="cf74c-135">従来の展開方法を使用してさまざまなホストに展開を管理することができます。</span><span class="sxs-lookup"><span data-stu-id="cf74c-135">You can manage the deployment to the various hosts via traditional deployment techniques.</span></span> <span data-ttu-id="cf74c-136">Docker ホストを管理するにはのようなコマンドを使用して`docker run`継続的な配信 (CD) パイプラインは、後でこの電子書籍の説明などのオートメーションによって手動でします。</span><span class="sxs-lookup"><span data-stu-id="cf74c-136">You can manage Docker hosts by using commands like `docker run` manually, through automation such as Continuous Delivery (CD) pipelines, which we explain later in this e-book.</span></span>

## <a name="monolithic-application-deployed-as-a-container"></a><span data-ttu-id="cf74c-137">コンテナーとして展開するモノリシック アプリケーション</span><span class="sxs-lookup"><span data-stu-id="cf74c-137">Monolithic application deployed as a container</span></span>

<span data-ttu-id="cf74c-138">モノリシックな展開を管理するコンテナーを使用する利点があります。</span><span class="sxs-lookup"><span data-stu-id="cf74c-138">There are benefits to using containers to manage monolithic deployments.</span></span> <span data-ttu-id="cf74c-139">コンテナーのインスタンスをスケーリングする処理は、追加の VM を展開するよりもはるかに高速で簡単です。</span><span class="sxs-lookup"><span data-stu-id="cf74c-139">Scaling the instances of containers is far faster and easier than deploying additional VMs.</span></span> <span data-ttu-id="cf74c-140">VM スケール セットが必要な Docker コンテナーをホストする Vm をスケーリングする優れた機能しますが、セットアップに時間がかかります。</span><span class="sxs-lookup"><span data-stu-id="cf74c-140">Although VM Scale Sets are a great feature to scale VMs, which are required to host your Docker containers, they take time to set up.</span></span> <span data-ttu-id="cf74c-141">アプリのインスタンスとして展開する場合、アプリの構成は VM の一部として管理されます。</span><span class="sxs-lookup"><span data-stu-id="cf74c-141">When deployed as app instances, the configuration of the app is managed as part of the VM.</span></span>

<span data-ttu-id="cf74c-142">更新プログラムを Docker イメージとして展開する方がはるかに高速で、ネットワークの効率が高くなります。</span><span class="sxs-lookup"><span data-stu-id="cf74c-142">Deploying updates as Docker images is far faster and network efficient.</span></span> <span data-ttu-id="cf74c-143">Vn インスタンスは、追加の Vm による追加コストを排除すること、バーチャル ネットワーク 1 インスタンスと同じホストで設定できます。</span><span class="sxs-lookup"><span data-stu-id="cf74c-143">The Vn instances can be set up on the same hosts as your Vn-1 instances, eliminating added costs resulting from additional VMs.</span></span> <span data-ttu-id="cf74c-144">Docker のイメージは、通常 (秒単位) の展開の高速で起動します。</span><span class="sxs-lookup"><span data-stu-id="cf74c-144">Docker images typically start in seconds, speeding rollouts.</span></span> <span data-ttu-id="cf74c-145">呼び出しと同じくらい簡単には、Docker インスタンス設定解除を行う、`docker stop`コマンド、通常の 1 秒未満で完了します。</span><span class="sxs-lookup"><span data-stu-id="cf74c-145">Tearing down a Docker instance is as easy as invoking the `docker stop` command, typically completing in less than a second.</span></span>

<span data-ttu-id="cf74c-146">コンテナーは、本質的に変更可能な設計では、ため決して更新スクリプトをいくつかの特定の構成またはファイルがディスク上の残りのアカウントを忘れたために、破損している Vm について心配する必要があります。</span><span class="sxs-lookup"><span data-stu-id="cf74c-146">Because containers are inherently immutable, by design, you never need to worry about corrupted VMs because an update script forgot to account for some specific configuration or file left on disk.</span></span>

<span data-ttu-id="cf74c-147">モノリシックなアプリは、Docker で利用できるがおするいると接触している利点ヒントのみにします。</span><span class="sxs-lookup"><span data-stu-id="cf74c-147">Although monolithic apps can benefit from Docker, we're touching on only the tips of the benefits.</span></span> <span data-ttu-id="cf74c-148">コンテナーを管理するためのより大きな利点は、さまざまなインスタンスと各コンテナー インスタンスのライフ サイクル管理コンテナー orchestrators による展開から取得されます。</span><span class="sxs-lookup"><span data-stu-id="cf74c-148">The larger benefits of managing containers comes from deploying with container orchestrators that manage the various instances and life cycle of each container instance.</span></span> <span data-ttu-id="cf74c-149">モノリシック アプリケーションを、スケーリング、開発、および展開を個別に実行できるサブシステムに分割することが、マイクロサービスの領域への入り口になります。</span><span class="sxs-lookup"><span data-stu-id="cf74c-149">Breaking up the monolithic application into subsystems that can be scaled, developed, and deployed individually is your entry point into the realm of microservices.</span></span>

## <a name="publishing-a-single-docker-container-app-to-azure-app-service"></a><span data-ttu-id="cf74c-150">1 つの Docker コンテナー アプリを Azure App Service に発行</span><span class="sxs-lookup"><span data-stu-id="cf74c-150">Publishing a single Docker container app to Azure App Service</span></span>

<span data-ttu-id="cf74c-151">か、またはアプリが Azure にデプロイされたコンテナーのクイック検証を取得するためだけで、単一のコンテナーにアプリを Azure アプリのサービスは、単一コンテナーのスケーラブルなサービスを提供する優れた方法を提供します。</span><span class="sxs-lookup"><span data-stu-id="cf74c-151">Either because you want to get a quick validation of a container deployed to Azure or because the app is simply a single-container app, Azure App Services provides a great way to provide scalable single-container services.</span></span>

<span data-ttu-id="cf74c-152">直感的な Azure App Service の使用取得できますおよび優れた Git を提供するため、迅速に実行されている統合、コードを実行する、Microsoft Visual Studio でビルドおよび直接 Azure にデプロイします。</span><span class="sxs-lookup"><span data-stu-id="cf74c-152">Using Azure App Service is intuitive and you can get up and running quickly because it provides great Git integration to take your code, build it in Microsoft Visual Studio, and directly deploy it to Azure.</span></span> <span data-ttu-id="cf74c-153">従来 (Docker を使用したなし)、他の機能、フレームワーク、またはアプリ サービスでサポートされていない依存関係が必要な場合、Azure チームは、App Service でそれらの依存関係を更新するまで待機するために必要かなどの他のサービスに切り替えられますが、Service Fabric、クラウド サービス、またはでもプレーンの Vm をさらに制御して、アプリケーションの必要なコンポーネントまたはフレームワークをインストールできます。</span><span class="sxs-lookup"><span data-stu-id="cf74c-153">But, traditionally (with no Docker), if you needed other capabilities, frameworks, or dependencies that aren't supported in App Services, you needed to wait for it until the Azure team updates those dependencies in App Service or switched to other services like Service Fabric, Cloud Services, or even plain VMs, for which you have further control and can install a required component or framework for your application.</span></span>

<span data-ttu-id="cf74c-154">これで、ただし、(2016 年 11 月に Microsoft 接続 2016年で発表された) Visual Studio 2017 を使用する場合に、図 4‑4 に示すように、Azure App Service でのコンテナーのサポートができるアプリの環境に自由に含めるとします。</span><span class="sxs-lookup"><span data-stu-id="cf74c-154">Now, however, (announced at Microsoft Connect 2016 in November 2016) and as shown in Figure 4‑4, when using Visual Studio 2017, container support in Azure App Service gives you the ability to include whatever you want in your app environment.</span></span> <span data-ttu-id="cf74c-155">コンテナーで実行しているため、アプリに依存関係を追加した場合は、Dockerfile または Docker イメージにこれらの依存関係をなどの機能を取得します。</span><span class="sxs-lookup"><span data-stu-id="cf74c-155">If you added a dependency to your app, because you are running it in a container, you get the capability of including those dependencies in your Dockerfile or Docker image.</span></span>

![](./media/image4.png)

<span data-ttu-id="cf74c-156">図 4-4: Azure App Service に Visual Studio アプリ/コンテナーからコンテナーを公開します。</span><span class="sxs-lookup"><span data-stu-id="cf74c-156">Figure 4-4: Publishing a container to Azure App Service from Visual Studio apps/containers</span></span>

<span data-ttu-id="cf74c-157">図 4-4 も発行フローが Azure コンテナー レジストリ (レジストリで、Azure でデプロイに近いし、Azure Active Directory グループとアカウントによって保護された) 可能性があるコンテナー レジストリまたはその他の任意の Docker レジストリを介してイメージをプッシュすることを示していますDocker Hub または内部設置型のレジストリのように</span><span class="sxs-lookup"><span data-stu-id="cf74c-157">Figure 4-4 also shows that the publish flow pushes an image through a Container Registry, which can be the Azure Container Registry (a registry near to your deployments in Azure and secured by Azure Active Directory groups and accounts) or any other Docker Registry like Docker Hub or on-premises registries.</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="cf74c-158">[前] (共通のコンテナーのデザインの principles.md) [次へ] (state-and-data-in-docker-applications.md)</span><span class="sxs-lookup"><span data-stu-id="cf74c-158">[Previous] (common-container-design-principles.md) [Next] (state-and-data-in-docker-applications.md)</span></span>
