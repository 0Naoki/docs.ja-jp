---
title: モノリシック アプリケーション
description: モノリシック アプリケーションをコンテナー化の主要な概念を理解します。
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 02/15/2019
ms.openlocfilehash: eff764472b4a9fc5b699545fc9629cc12d0186ca
ms.sourcegitcommit: 8f95d3a37e591963ebbb9af6e90686fd5f3b8707
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/23/2019
ms.locfileid: "56747263"
---
# <a name="monolithic-applications"></a>モノリシック アプリケーション

このシナリオでは、1 つのモノリシックな web アプリケーションまたはサービスを構築、コンテナーとして展開します。 アプリケーション内で、構造体できない可能性がありますモノリシック;いくつかのライブラリ、コンポーネント、またはさらにはレイヤー (アプリケーション層、ドメイン層、データ アクセス層など) を構成する場合があります。 外部で 1 つのプロセス、単一の web アプリケーション、または 1 つのサービスのように、1 つのコンテナーになります。

このモデルを管理するには、アプリケーションを表す単一のコンテナーを展開します。 これを拡大するには、ロード バランサーを前面に配置してコピーをいくつか追加します。 わかりやすくするため、1 つのコンテナーまたは仮想マシン (VM) で 1 つの展開の管理に由来します。

次のコンテナーがのみ、この操作を 1 つと、1 つのプロセスでは、プリンシパル、モノリシック パターンが競合します。 図 4-1 に示すように、複数のコンポーネント/ライブラリ、または内部レイヤーを各コンテナーを含めることができます。

![モノリシック アプリが、ほとんどすべての単一のプロセスまたはコンテナー内でその機能と内部レイヤーやライブラリで、コンポーネント化されました。](./media/image1.png)

**図 4-1** モノリシック アプリケーションのアーキテクチャの例

このアプローチの欠点は、またはアプリケーションを拡張、スケーリングする必要な場合は取得されます。 アプリケーション全体がスケーリングすれば、実際には問題ではありません。 ただし、ほとんどの場合、アプリケーションのいくつかの部分はチョーク ポイントをスケーリングするには、必要とするその他のコンポーネントを使用する小さい。

一般的な e コマースの例を使用して、可能性の高いが必要な製品情報のコンポーネントをスケーリングします。 製品を購入するユーザーよりも多くのユーザーが製品を参照します。 より多くの顧客が、支払いパイプラインではなくバスケットを使用します。 コメントを追加したり、購入履歴を表示したりする顧客はそれほどいません。 ごく少数のコンテンツとマーケティング キャンペーンを管理する必要がある 1 つのリージョン内の従業員がある可能性があります。 モノリシックな設計をスケールすることによって複数回のコードをすべて配置されます。

ほかに、"スケール-すべての"アプリケーション全体とすべてのインスタンスの完全に再展開を完全に再テストの問題、1 つのコンポーネントへの変更を必要とします。

モノリシック アプローチは一般的であり、多くの組織はこのアーキテクチャのメソッドを使用して開発します。 多くは利用制限が発生する他のユーザーが、十分な結果では良いです。 ツールとインフラストラクチャが複雑すぎて、Soa を構築し、必要性が表示していないために、このモデルでアプリケーションを設計多く — まで、アプリが成長しました。

インフラストラクチャの観点からは、各サーバーは、同じホスト内で多くのアプリケーションを実行し、図 4-2 に示すように、リソース使用量に効率の許容の比率があります。

![1 つのホストは、個別のコンテナーで複数のアプリを実行できます。](./media/image2.png)

**図 4-2** 複数のアプリ/コンテナーを実行しているホスト

最後に、可用性の観点からモノリシック アプリケーション展開する必要が; 全体つまり、必要な場合に*を停止および開始*、すべての機能とすべてのユーザーに展開時間枠中に影響は。 特定の状況では、Azure とコンテナーの使用はこのような状況を最小限に抑えるし、図 4-3 をご覧のように、アプリケーションのダウンタイムの可能性を軽減します。

インスタンスごとに専用の Vm を使用して、Azure のモノリシック アプリケーションをデプロイできます。 使用して[Azure VM Scale Sets](https://docs.microsoft.com/azure/virtual-machine-scale-sets/)Vm を簡単にスケールすることができます。

使用することも[Azure App Services](https://azure.microsoft.com/services/app-service/)モノリシック アプリケーションを実行し、Vm を管理しなくてもインスタンスを簡単にスケールします。 Azure App Services は、展開を簡素化も、Docker コンテナーの単一インスタンスを実行できます。

Docker ホストとして複数の Vm をデプロイして、任意の数の VM あたりのコンテナーを実行できます。 次に、Azure Load Balancer を使用すると、図 4-3 に示すようにスケーリングを管理できます。

![モノリシック アプリできますスケール アウトするのには、それぞれが実行されているアプリのコンテナーで別のホスト。](./media/image3.png)

**図 4-3** Docker アプリケーションのアプリ/コンテナーが 1 つをスケール アウトの複数のホスト

従来の展開手法を使用して、ホスト自体の展開を管理することができます。

ようなコマンドを使用して、コマンドラインから Docker コンテナーを管理する`docker run`と`docker-compose up`も継続的デリバリー (CD) パイプラインを自動化することを Azure DevOps サービスからのインスタンスを Docker ホストに展開できます。

## <a name="monolithic-application-deployed-as-a-container"></a>コンテナーとして展開するモノリシック アプリケーション

モノリシック展開を管理するコンテナーを使用する利点があります。 コンテナーのインスタンスをスケーリングする処理は、追加の VM を展開するよりもはるかに高速で簡単です。

更新プログラムを Docker イメージとして展開する方がはるかに高速で、ネットワークの効率が高くなります。 Docker コンテナーは、通常の展開を高速化、秒単位で開始します。 呼び出しと同じくらい簡単では、Docker コンテナーの破棄、`docker stop`コマンドは、通常は 1 秒未満で完了します。

コンテナーが本質的に、設計上不変なので、決して更新スクリプトをいくつかの特定の構成またはファイルがディスク上の残りのアカウントを忘れたために、Vm の破損について心配する必要があります。

モノリシック アプリケーションは Docker の恩恵がメリットのヒントのみ面しています。 コンテナーの管理の大きな利点は、さまざまなインスタンスと各コンテナー インスタンスのライフ サイクルを管理するコンテナー オーケストレーターに展開するから取得されます。 モノリシック アプリケーションを、スケーリング、開発、および展開を個別に実行できるサブシステムに分割することが、マイクロサービスの領域への入り口になります。

コンテナーでモノリシック アプリケーションを「リフト アンド シフト」し、アプリケーションを最新化する方法する方法の詳細については、この追加の Microsoft のガイドを参照して[Azure クラウドおよび Windows コンテナーで既存の .NET アプリケーションを近代化](https://docs.microsoft.com/dotnet/standard/modernize-with-azure-and-containers/)から PDF としてダウンロードすることもできます。 を<https://aka.ms/LiftAndShiftWithContainersEbook>します。

## <a name="publish-a-single-docker-container-app-to-azure-app-service"></a>Azure App Service への 1 つの Docker コンテナー アプリを発行します。

いずれかを Azure にデプロイされたコンテナーのクイック検証を取得するか、アプリ、単に単一のコンテナー アプリを Azure App Services は、スケーラブルな単一のコンテナー サービスを提供する優れた方法を提供します。

直感的に Azure App Service を使用してとさせることができ、優れた Git を提供するため、迅速に実行されているコードへの統合は Microsoft Visual studio でビルドし、直接 Azure にデプロイします。 従来 (Docker を使用しない) 必要があるその他の機能、フレームワーク、または依存関係では、App Services でサポートされていない場合、Azure チームは、App Service でこれらの依存関係を更新するまで待機するために必要かなどの他のサービスに切り替えることが、Service Fabric、Cloud Services、またはプレーン Vm、対象のコントロールをさらがあるし、アプリケーションの必要なコンポーネントやフレームワークをインストールできます。

図 4-4 に示すように、今すぐ Visual Studio 2017 を使用して Azure App Service でコンテナー サポートが得られます app 環境内で何でもを含むことのできます。 コンテナーで実行しているため、アプリに依存関係を追加した場合、ファイルまたは Docker イメージでこれらの依存関係をなどの機能を取得します。

![コンテナー レジストリのセレクターを強調表示、Azure app service に発行する Visual Studio のウィザードのビュー。](./media/image4.png)

**図 4-4** Visual Studio のアプリ/コンテナーから Azure App Service にコンテナーを発行する.

図 4-4 も発行フローが Azure Container Registry (レジストリを Azure 内の展開に近く、および Azure Active Directory グループとアカウントによって保護された) は、コンテナー レジストリをまたはその他の任意の Docker レジストリを介してイメージをプッシュすることを示していますDocker Hub やオンプレミス レジストリなど。

>[!div class="step-by-step"]
>[前へ](common-container-design-principles.md)
>[次へ](state-and-data-in-docker-applications.md)
