---
title: "アーキテクチャの原則"
description: "ASP.NET Core と Azure での最新の Web アプリケーションを設計 |アーキテクチャの原則"
author: ardalis
ms.author: wiwagn
ms.date: 10/06/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: bdb215d64253fb7d22ae2c5648030336850006b5
ms.sourcegitcommit: f28752eab00d2bd97e971542c0f49ce63cfbc239
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/29/2018
---
# <a name="architectural-principles"></a><span data-ttu-id="3eb34-103">アーキテクチャの原則</span><span class="sxs-lookup"><span data-stu-id="3eb34-103">Architectural Principles</span></span>

> <span data-ttu-id="3eb34-104">"ビルダー建物をビルドする場合は方法プログラマは、プログラムを記述しに付属している最初の woodpecker は文明を破棄します。"</span><span class="sxs-lookup"><span data-stu-id="3eb34-104">"If builders built buildings the way programmers wrote programs, then the first woodpecker that came along would destroy civilization."</span></span>  
> <span data-ttu-id="3eb34-105">_\- ジェラルド Weinberg_</span><span class="sxs-lookup"><span data-stu-id="3eb34-105">_\- Gerald Weinberg_</span></span>

## <a name="summary"></a><span data-ttu-id="3eb34-106">まとめ</span><span class="sxs-lookup"><span data-stu-id="3eb34-106">Summary</span></span>

<span data-ttu-id="3eb34-107">設計し、保守容易性を念頭にソフトウェア ソリューションを設計する必要があります。</span><span class="sxs-lookup"><span data-stu-id="3eb34-107">You should architect and design software solutions with maintainability in mind.</span></span> <span data-ttu-id="3eb34-108">このセクションで説明した原則進めることができます、クリーンで保守性の高いアプリケーションの原因となるアーキテクチャ上の決定に向けたです。</span><span class="sxs-lookup"><span data-stu-id="3eb34-108">The principles outlined in this section can help guide you toward architectural decisions that will result in clean, maintainable applications.</span></span> <span data-ttu-id="3eb34-109">一般に、これらの原則に従って、アプリケーションの他の部分に密結合されていないが、明示的なインターフェイス経由で通信ではなく、独立したコンポーネントからアプリケーションを構築またはメッセージング システムの方向。</span><span class="sxs-lookup"><span data-stu-id="3eb34-109">Generally, these principles will guide you toward building applications out of discrete components that are not tightly coupled to other parts of your application, but rather communicate through explicit interfaces or messaging systems.</span></span>

## <a name="common-design-principles"></a><span data-ttu-id="3eb34-110">一般的なデザインの原則</span><span class="sxs-lookup"><span data-stu-id="3eb34-110">Common design principles</span></span>

### <a name="separation-of-concerns"></a><span data-ttu-id="3eb34-111">関心の分離</span><span class="sxs-lookup"><span data-stu-id="3eb34-111">Separation of Concerns</span></span>

<span data-ttu-id="3eb34-112">開発するときの基本原則が**関心の分離**です。</span><span class="sxs-lookup"><span data-stu-id="3eb34-112">A guiding principle when developing is **Separation of Concerns**.</span></span> <span data-ttu-id="3eb34-113">この原則をアサート ソフトウェアを区切る必要がありますで実行される処理の種類に基づいてします。</span><span class="sxs-lookup"><span data-stu-id="3eb34-113">This principle asserts that software should be separated based on the kinds of work it performs.</span></span> <span data-ttu-id="3eb34-114">たとえば、アプリケーション、ユーザーに表示する項目が注目すべきことを識別するためのロジックが含まれているとする形式などのアイテムでよりわかるように、特定の方法を検討してください。</span><span class="sxs-lookup"><span data-stu-id="3eb34-114">For instance, consider an application that includes logic for identifying noteworthy items to display to the user, and which formats such items in a particular way to make them more noticeable.</span></span> <span data-ttu-id="3eb34-115">これらが互いに関連するのみ偶然にも別の問題であるため、アイテムの書式設定を担当する動作とは別の書式を設定する項目の選択を担当の動作を注意してください。</span><span class="sxs-lookup"><span data-stu-id="3eb34-115">The behavior responsible for choosing which items to format should be kept separate from the behavior responsible for formatting the items, since these are separate concerns that are only coincidentally related to one another.</span></span>

<span data-ttu-id="3eb34-116">アーキテクチャ上、インフラストラクチャとユーザー インターフェイス ロジックをコア ビジネスの動作を区切ることによってこの原則に従うアプリケーションを論理的に構築できます。</span><span class="sxs-lookup"><span data-stu-id="3eb34-116">Architecturally, applications can be logically built to follow this principle by separating core business behavior from infrastructure and user interface logic.</span></span> <span data-ttu-id="3eb34-117">理想的には、ビジネス ルールとロジックは、アプリケーションの他のプロジェクトに依存しないように、独立したプロジェクトに存在する必要があります。</span><span class="sxs-lookup"><span data-stu-id="3eb34-117">Ideally, business rules and logic should reside in a separate project, which should not depend on other projects in the application.</span></span> <span data-ttu-id="3eb34-118">これにより、ビジネス モデルを簡単にテストし、低レベルの実装の詳細に密結合されているせずに改善できます。</span><span class="sxs-lookup"><span data-stu-id="3eb34-118">This helps ensure that the business model is easy to test and can evolve without being tightly coupled to low-level implementation details.</span></span> <span data-ttu-id="3eb34-119">関心の分離は、アプリケーション アーキテクチャ内のレイヤーの使用の背後にある主な考慮事項です。</span><span class="sxs-lookup"><span data-stu-id="3eb34-119">Separation of concerns is a key consideration behind the use of layers in application architectures.</span></span>

### <a name="encapsulation"></a><span data-ttu-id="3eb34-120">カプセル化</span><span class="sxs-lookup"><span data-stu-id="3eb34-120">Encapsulation</span></span>

<span data-ttu-id="3eb34-121">アプリケーションのさまざまな部分を使用する必要があります**カプセル化**アプリケーションの他の部分から分離します。</span><span class="sxs-lookup"><span data-stu-id="3eb34-121">Different parts of an application should use **encapsulation** to insulate them from other parts of the application.</span></span> <span data-ttu-id="3eb34-122">アプリケーション コンポーネントとレイヤーは外部の契約に違反しない限り、共同作業者を分断することがなく、内部の実装を調整できる必要があります。</span><span class="sxs-lookup"><span data-stu-id="3eb34-122">Application components and layers should be able to adjust their internal implementation without breaking their collaborators as long as external contracts are not violated.</span></span> <span data-ttu-id="3eb34-123">カプセル化の適切な使用により、同じインターフェイスが保持されるよう、オブジェクトおよびパッケージを別の実装に置き換えられますできるために、疎結合と、アプリケーション デザインのモジュール性を実現できます。</span><span class="sxs-lookup"><span data-stu-id="3eb34-123">Proper use of encapsulation helps achieve loose coupling and modularity in application designs, since objects and packages can be replaced with alternative implementations so long as the same interface is maintained.</span></span>

<span data-ttu-id="3eb34-124">クラスでは、カプセル化は、クラスの内部状態へのアクセスの外部に制限することによって実現されます。</span><span class="sxs-lookup"><span data-stu-id="3eb34-124">In classes, encapsulation is achieved by limiting outside access to the class's internal state.</span></span> <span data-ttu-id="3eb34-125">外部アクターは、オブジェクトの状態を操作する場合、その要求を実行、適切に定義された関数 (またはプロパティ set アクセス操作子) で、オブジェクトのプライベート状態への直接アクセスではなくです。</span><span class="sxs-lookup"><span data-stu-id="3eb34-125">If an outside actor wants to manipulate the state of the object, it should do so through a well-defined function (or property setter), rather than having direct access to the private state of the object.</span></span> <span data-ttu-id="3eb34-126">同様に、アプリケーション コンポーネントとアプリケーション自体によって、適切に定義されたインターフェイスを直接変更する、状態を許可するのではなく、使用、共同作業者が公開する必要があります。</span><span class="sxs-lookup"><span data-stu-id="3eb34-126">Likewise, application components and applications themselves should expose well-defined interfaces for their collaborators to use, rather than allowing their state to be modified directly.</span></span> <span data-ttu-id="3eb34-127">これにより、心配する必要を行うのため中断されますの共同作業者のパブリック コントラクトが保持される限り、時間の経過と共に変化するアプリケーションの内部設計が解放されます。</span><span class="sxs-lookup"><span data-stu-id="3eb34-127">This frees the application's internal design to evolve over time without worrying that doing so will break collaborators, so long as the public contracts are maintained.</span></span>

### <a name="dependency-inversion"></a><span data-ttu-id="3eb34-128">依存関係の反転</span><span class="sxs-lookup"><span data-stu-id="3eb34-128">Dependency Inversion</span></span>

<span data-ttu-id="3eb34-129">アプリケーション内の依存関係の方向は、抽象化、いないの実装の詳細の方向にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="3eb34-129">The direction of dependency within the application should be in the direction of abstraction, not implementation details.</span></span> <span data-ttu-id="3eb34-130">ほとんどのアプリケーションは、コンパイル時の依存関係がランタイムの実行の方向にフローするように書き込まれます。</span><span class="sxs-lookup"><span data-stu-id="3eb34-130">Most applications are written such that compile-time dependency flows in the direction of runtime execution.</span></span> <span data-ttu-id="3eb34-131">これには、直接の依存関係グラフが生成されます。</span><span class="sxs-lookup"><span data-stu-id="3eb34-131">This produces a direct dependency graph.</span></span> <span data-ttu-id="3eb34-132">つまり、モジュール、C でし、コンパイル時間 A が関数を呼び出す B、モジュールの関数の呼び出しをモジュール A が図 4-1 に示すようには、C に依存している B に依存かどうか。</span><span class="sxs-lookup"><span data-stu-id="3eb34-132">That is, if module A calls a function in module B, which calls a function in module C, then at compile time A will depend on B which will depend on C, as shown in Figure 4-1.</span></span>

![](./media/image4-1.png)

<span data-ttu-id="3eb34-133">**図 4-1**</span><span class="sxs-lookup"><span data-stu-id="3eb34-133">**Figure 4-1.**</span></span> <span data-ttu-id="3eb34-134">直接の依存関係グラフ。</span><span class="sxs-lookup"><span data-stu-id="3eb34-134">Direct dependency graph.</span></span>

<span data-ttu-id="3eb34-135">依存関係の逆転原則を適用する許可できるようにする A に B を呼び出し、実行時に、B を実装する抽象型でメソッドを呼び出す A が b をインターフェイスに依存するによって制御 A コンパイル時に (つまり、*反転*一般的なコンパイル時の依存関係)。</span><span class="sxs-lookup"><span data-stu-id="3eb34-135">Applying the dependency inversion principle allows A to call methods on an abstraction that B implements, making it possible for A to call B at runtime, but for B to depend on an interface controlled by A at compile time (thus, *inverting* the typical compile-time dependency).</span></span> <span data-ttu-id="3eb34-136">実行時に、プログラムの実行フローが変更されないが、インターフェイスの概要では、これらのインターフェイスのさまざまな実装簡単に接続することを意味します。</span><span class="sxs-lookup"><span data-stu-id="3eb34-136">At run time, the flow of program execution remains unchanged, but the introduction of interfaces means that different implementations of these interfaces can easily be plugged in.</span></span>

![](./media/image4-2.png)

<span data-ttu-id="3eb34-137">**図 4-2 です。**</span><span class="sxs-lookup"><span data-stu-id="3eb34-137">**Figure 4-2.**</span></span> <span data-ttu-id="3eb34-138">反転された依存関係グラフ。</span><span class="sxs-lookup"><span data-stu-id="3eb34-138">Inverted dependency graph.</span></span>

<span data-ttu-id="3eb34-139">**依存関係の逆転**疎結合アプリケーションの構築に依存し、その逆ではなくより高いレベルの抽象化を実装する実装の詳細を書き込むための重要な部分です。</span><span class="sxs-lookup"><span data-stu-id="3eb34-139">**Dependency inversion** is a key part of building loosely-coupled applications, since implementation details can be written to depend on and implement higher level abstractions, rather than the other way around.</span></span> <span data-ttu-id="3eb34-140">結果として得られるアプリケーションは、その結果、テスト可能で、モジュール、保守も容易です。</span><span class="sxs-lookup"><span data-stu-id="3eb34-140">The resulting applications are more testable, modular, and maintainable as a result.</span></span> <span data-ttu-id="3eb34-141">推奨事項*依存性の注入*依存関係の逆転という原則に従って、によって可能になりますがします。</span><span class="sxs-lookup"><span data-stu-id="3eb34-141">The practice of *dependency injection* is made possible by following the dependency inversion principle.</span></span>

### <a name="explicit-dependencies"></a><span data-ttu-id="3eb34-142">明示的な依存関係</span><span class="sxs-lookup"><span data-stu-id="3eb34-142">Explicit Dependencies</span></span>

<span data-ttu-id="3eb34-143">**メソッドとクラスは、明示的に正しく機能するために必要なすべての共同作業オブジェクトを要求します。**</span><span class="sxs-lookup"><span data-stu-id="3eb34-143">**Methods and classes should explicitly require any collaborating objects they need in order to function correctly.**</span></span> <span data-ttu-id="3eb34-144">クラスのコンス トラクターは、クラスと適切に機能する有効な状態にするために必要であることを確認する機会を提供します。</span><span class="sxs-lookup"><span data-stu-id="3eb34-144">Class constructors provide an opportunity for classes to identify the things they need in order to be in a valid state and to function properly.</span></span> <span data-ttu-id="3eb34-145">これらのクラスがされている場合、これはのみ正しく機能が設定されている特定のグローバルまたはインフラストラクチャのコンポーネントを構築されと呼ばれることができますが、クラスを定義すると、*悪意を持つ*クライアントとします。</span><span class="sxs-lookup"><span data-stu-id="3eb34-145">If you define classes that can be constructed and called, but which will only function properly if certain global or infrastructure components are in place, these classes are being *dishonest* with their clients.</span></span> <span data-ttu-id="3eb34-146">コンス トラクターのコントラクトを認証するには、クライアントにのみ必要な (可能性のある場合、何もクラスは既定のコンス トラクターだけを使用して)、指定されたものですが、結局のところ、オブジェクトの実行時に実際に必要でした別のものです。</span><span class="sxs-lookup"><span data-stu-id="3eb34-146">The constructor contract is telling the client that it only needs the things specified (possibly nothing if the class is just using a default constructor), but then at runtime it turns out the object really did need something else.</span></span>

<span data-ttu-id="3eb34-147">明示的な依存関係の原則では、クラスとメソッドはされている正直でも機能するために必要な情報については、そのクライアント。</span><span class="sxs-lookup"><span data-stu-id="3eb34-147">By following the explicit dependencies principle, your classes and methods are being honest with their clients about what they need in order to function.</span></span> <span data-ttu-id="3eb34-148">これにより、コードの詳細を自己文書化し、コーディング コントラクトよりわかりやすいユーザーがメソッドの形式で必要なものを提供する限りを信頼するようになるまたはコンス トラクターのパラメーターを使用するオブジェクトの動作正しく実行時にします。</span><span class="sxs-lookup"><span data-stu-id="3eb34-148">This makes your code more self-documenting and your coding contracts more user-friendly, since users will come to trust that as long as they provide what's required in the form of method or constructor parameters, the objects they're working with will behave correctly at runtime.</span></span>

### <a name="single-responsibility"></a><span data-ttu-id="3eb34-149">1 つの責任</span><span class="sxs-lookup"><span data-stu-id="3eb34-149">Single Responsibility</span></span>

<span data-ttu-id="3eb34-150">1 つの責任の原則は、オブジェクト指向デザインに適用されますが、関心の分離と同様のアーキテクチャ原則とも考えられます。</span><span class="sxs-lookup"><span data-stu-id="3eb34-150">The single responsibility principle applies to object-oriented design, but can also be considered as an architectural principle similar to separation of concerns.</span></span> <span data-ttu-id="3eb34-151">オブジェクトは 1 つだけの責任である必要がありする必要がありますを変更する 1 つだけの理由を示します。</span><span class="sxs-lookup"><span data-stu-id="3eb34-151">It states that objects should have only one responsibility and that they should have only one reason to change.</span></span> <span data-ttu-id="3eb34-152">具体的には、その 1 つの役割を実行する方法を更新する必要がありますが、オブジェクトが変更する必要がありますのみ状況です。</span><span class="sxs-lookup"><span data-stu-id="3eb34-152">Specifically, the only situation in which the object should change is if the manner in which it performs its one responsibility must be updated.</span></span> <span data-ttu-id="3eb34-153">この原則に続いて複数生成するために役立ちます疎結合し、モジュール式のシステムでは、さまざまな種類の新しい動作以降を実装する既存のクラスに追加の役割を追加することによってではなく、新しいクラスとして。</span><span class="sxs-lookup"><span data-stu-id="3eb34-153">Following this principle helps to produce more loosely-coupled and modular systems, since many kinds of new behavior can be implemented as new classes, rather than by adding additional responsibility to existing classes.</span></span> <span data-ttu-id="3eb34-154">新しいクラスを追加するコードがないため、既存のクラスを変更するよりも安全では常にまだ、新しいクラスに依存します。</span><span class="sxs-lookup"><span data-stu-id="3eb34-154">Adding new classes is always safer than changing existing classes, since no code yet depends on the new classes.</span></span>

<span data-ttu-id="3eb34-155">モノリシックなアプリケーションでは、アプリケーション内のレイヤーに高レベルで 1 つの責任の原則を適用おできます。</span><span class="sxs-lookup"><span data-stu-id="3eb34-155">In a monolithic application, we can apply the single responsibility principle at a high level to the layers in the application.</span></span> <span data-ttu-id="3eb34-156">プレゼンテーション責任 UI プロジェクトのままにする、責任をインフラストラクチャ プロジェクト内で保持するかデータにアクセスします。</span><span class="sxs-lookup"><span data-stu-id="3eb34-156">Presentation responsibility should remain in the UI project, while data access responsibility should be kept within an infrastructure project.</span></span> <span data-ttu-id="3eb34-157">ビジネス ロジックは、ここで簡単にテストすることができ、その他の役割から個別に展開できるアプリケーション コア プロジェクトでは注意してください。</span><span class="sxs-lookup"><span data-stu-id="3eb34-157">Business logic should be kept in the application core project, where it can be easily tested and can evolve independently from other responsibilities.</span></span>

<span data-ttu-id="3eb34-158">この原則はアプリケーションのアーキテクチャに適用され、その論理エンドポイントに要した、microservices を取得します。</span><span class="sxs-lookup"><span data-stu-id="3eb34-158">When this principle is applied to application architecture, and taken to its logical endpoint, you get microservices.</span></span> <span data-ttu-id="3eb34-159">指定されたマイクロ サービスは、単一の役割が必要です。</span><span class="sxs-lookup"><span data-stu-id="3eb34-159">A given microservice should have a single responsibility.</span></span> <span data-ttu-id="3eb34-160">システムの動作を拡張する必要がある場合は、既存の責任を追加することによってではなく、追加の microservices を追加することによって行う通常お勧めします。</span><span class="sxs-lookup"><span data-stu-id="3eb34-160">If you need to extend the behavior of a system, it's usually better to do it by adding additional microservices, rather than by adding responsibility to an existing one.</span></span>

[<span data-ttu-id="3eb34-161">Microservices アーキテクチャの詳細を表示します</span><span class="sxs-lookup"><span data-stu-id="3eb34-161">Learn more about microservices architecture</span></span>](http://aka.ms/MicroservicesEbook)

### <a name="dont-repeat-yourself-dry"></a><span data-ttu-id="3eb34-162">自分で (ドライ) 繰り返さない</span><span class="sxs-lookup"><span data-stu-id="3eb34-162">Don't Repeat Yourself (DRY)</span></span>

<span data-ttu-id="3eb34-163">アプリケーションでは、これは、頻繁にエラーの原因としては、複数の場所で特定の概念に関連する動作を指定することを避ける必要があります。</span><span class="sxs-lookup"><span data-stu-id="3eb34-163">The application should avoid specifying behavior related to a particular concept in multiple places as this is a frequent source of errors.</span></span> <span data-ttu-id="3eb34-164">ある時点で、要件の変更が必要になりますこの問題および可能性の変更を更新するに少なくとも 1 つの動作のインスタンスは失敗のシステム一貫性のない動作が発生します。</span><span class="sxs-lookup"><span data-stu-id="3eb34-164">At some point, a change in requirements will require changing this behavior and the likelihood that at least one instance of the behavior will fail to be updated will result in inconsistent behavior of the system.</span></span>

<span data-ttu-id="3eb34-165">ロジックを複製するのではなくプログラミング構成要素でこれをカプセル化します。</span><span class="sxs-lookup"><span data-stu-id="3eb34-165">Rather than duplicating logic, encapsulate it in a programming construct.</span></span> <span data-ttu-id="3eb34-166">この動作を 1 つの権限を構築し、この動作は、新しいコンス トラクターを使用してを必要とするアプリケーションの他の部分があるようにされます。</span><span class="sxs-lookup"><span data-stu-id="3eb34-166">Make this construct the single authority over this behavior, and have any other part of the application that requires this behavior use the new construct.</span></span>

> [!NOTE]
> <span data-ttu-id="3eb34-167">バインディングは、偶然にも繰り返しのみ動作では一緒にしないでください。</span><span class="sxs-lookup"><span data-stu-id="3eb34-167">Avoid binding together behavior that is only coincidentally repetitive.</span></span> <span data-ttu-id="3eb34-168">たとえば、両方が 2 つの異なる定数は、同じ値を持つからといってことを意味して 1 つだけの定数を持つ必要があります概念的には、さまざまなを参照する場合。</span><span class="sxs-lookup"><span data-stu-id="3eb34-168">For example, just because two different constants both have the same value, that doesn't mean you should have only one constant, if conceptually they're referring to different things.</span></span>

### <a name="persistence-ignorance"></a><span data-ttu-id="3eb34-169">永続性の無視</span><span class="sxs-lookup"><span data-stu-id="3eb34-169">Persistence Ignorance</span></span>

<span data-ttu-id="3eb34-170">**持続性の無視が適用**(PI) を指す型永続化する必要があるが、そのコードが永続化テクノロジの選択による影響はありません。</span><span class="sxs-lookup"><span data-stu-id="3eb34-170">**Persistence ignorance** (PI) refers to types that need to be persisted, but whose code is unaffected by the choice of persistence technology.</span></span> <span data-ttu-id="3eb34-171">.NET では、このような型とも呼ば Plain Old CLR Object (した poco から)、特定の基本クラスを継承または特定のインターフェイスを実装する必要がないためです。</span><span class="sxs-lookup"><span data-stu-id="3eb34-171">Such types in .NET are sometimes referred to as Plain Old CLR Objects (POCOs), because they do not need to inherit from a particular base class or implement a particular interface.</span></span> <span data-ttu-id="3eb34-172">持続性の無視が適用は、同じビジネス モデルをアプリケーションにさらに高い柔軟性を提供する複数の方法で永続化できるため重要です。</span><span class="sxs-lookup"><span data-stu-id="3eb34-172">Persistence ignorance is valuable because it allows the same business model to be persisted in multiple ways, offering additional flexibility to the application.</span></span> <span data-ttu-id="3eb34-173">永続化の選択肢が、別の 1 つのデータベース テクノロジからの時間の経過と共に変更可能性がありますまたは永続化の追加フォームが任意のアプリケーションの開始だけでなく必要な可能性があります (たとえば、Redis キャッシュまたはに加え、Azure DocumentDb を使用して、リレーショナル データベース)。</span><span class="sxs-lookup"><span data-stu-id="3eb34-173">Persistence choices might change over time, from one database technology to another, or additional forms of persistence might be required in addition to whatever the application started with (for example, using a Redis cache or Azure DocumentDb in addition to a relational database).</span></span>

<span data-ttu-id="3eb34-174">この原則に反したのいくつかの例は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="3eb34-174">Some examples of violations of this principle include:</span></span>

-   <span data-ttu-id="3eb34-175">必要な基本クラス</span><span class="sxs-lookup"><span data-stu-id="3eb34-175">A required base class</span></span>

-   <span data-ttu-id="3eb34-176">必要なインターフェイスの実装</span><span class="sxs-lookup"><span data-stu-id="3eb34-176">A required interface implementation</span></span>

-   <span data-ttu-id="3eb34-177">自体 (有効なレコードのパターン) などの保存を担当するクラス</span><span class="sxs-lookup"><span data-stu-id="3eb34-177">Classes responsible for saving themselves (such as the Active Record pattern)</span></span>

-   <span data-ttu-id="3eb34-178">必要な既定のコンス トラクター</span><span class="sxs-lookup"><span data-stu-id="3eb34-178">Required default constructor</span></span>

-   <span data-ttu-id="3eb34-179">Virtual キーワードを必要とするプロパティ</span><span class="sxs-lookup"><span data-stu-id="3eb34-179">Properties requiring virtual keyword</span></span>

-   <span data-ttu-id="3eb34-180">永続化に固有の必要な属性</span><span class="sxs-lookup"><span data-stu-id="3eb34-180">Persistence-specific required attributes</span></span>

<span data-ttu-id="3eb34-181">クラスがある上記の機能や動作のいずれかの要件は、永続化するために、型や、選択した後で新しいデータ アクセス方法を採用することが難しくなります、永続化テクノロジ間の結合を追加します。</span><span class="sxs-lookup"><span data-stu-id="3eb34-181">The requirement that classes have any of the above features or behaviors adds coupling between the types to be persisted and the choice of persistence technology, making it more difficult to adopt new data access strategies in the future.</span></span>

### <a name="bounded-contexts"></a><span data-ttu-id="3eb34-182">範囲指定されたコンテキスト</span><span class="sxs-lookup"><span data-stu-id="3eb34-182">Bounded Contexts</span></span>

<span data-ttu-id="3eb34-183">**コンテキストの境界を付けられた**ドメイン デザインから中央、パターンには、します。</span><span class="sxs-lookup"><span data-stu-id="3eb34-183">**Bounded contexts** are a central pattern in Domain-Driven Design.</span></span> <span data-ttu-id="3eb34-184">概念の個別のモジュールに分割する、大規模なアプリケーションや組織にへの対応の複雑さの機能を提供します。</span><span class="sxs-lookup"><span data-stu-id="3eb34-184">They provide a way of tackling complexity in large applications or organizations by breaking it up into separate conceptual modules.</span></span> <span data-ttu-id="3eb34-185">各概念モジュールが、他のコンテキストから分離されているコンテキストを表します (このため、制限される)、し、個別に展開できます。</span><span class="sxs-lookup"><span data-stu-id="3eb34-185">Each conceptual module then represents a context which is separated from other contexts (hence, bounded), and can evolve independently.</span></span> <span data-ttu-id="3eb34-186">各境界のあるコンテキストでは、空き、内の概念に関する独自の名前を選択することが理想的で、独自の永続化ストアに排他アクセス権限が必要です。</span><span class="sxs-lookup"><span data-stu-id="3eb34-186">Each bounded context should ideally be free to choose its own names for concepts within it, and should have exclusive access to its own persistence store.</span></span>

<span data-ttu-id="3eb34-187">少なくとも、個々 の web アプリケーションは必要があるデータベースを共有する他のアプリケーションとのではなく、そのビジネス モデルの独自の永続化ストアで、独自の境界のあるコンテキストに努めています。</span><span class="sxs-lookup"><span data-stu-id="3eb34-187">At a minimum, individual web applications should strive to be their own bounded context, with their own persistence store for their business model, rather than sharing a database with other applications.</span></span> <span data-ttu-id="3eb34-188">これにより、ビジネス ロジックの共有データベースではなくプログラム インターフェイスは、使用に範囲指定されたコンテキスト間の通信が発生しをイベントが行われる変更に合わせて配置します。</span><span class="sxs-lookup"><span data-stu-id="3eb34-188">Communication between bounded contexts occurs through programmatic interfaces, rather than through a shared database, which allows for business logic and events to take place in response to changes that take place.</span></span> <span data-ttu-id="3eb34-189">また、独自の個々 の境界のあるコンテキストとして実装されることをお勧め microservices にコンテキストのマップを密接に制限されます。</span><span class="sxs-lookup"><span data-stu-id="3eb34-189">Bounded contexts map closely to microservices, which also are ideally implemented as their own individual bounded contexts.</span></span>

> ### <a name="references--modern-web-applications"></a><span data-ttu-id="3eb34-190">参照: 最新の Web アプリケーション</span><span class="sxs-lookup"><span data-stu-id="3eb34-190">References – Modern Web Applications</span></span>
> - <span data-ttu-id="3eb34-191">関心の分離</span><span class="sxs-lookup"><span data-stu-id="3eb34-191">**Separation of Concerns**</span></span>  
> <span data-ttu-id="3eb34-192"><http://deviq.com/separation-of-concerns/></span><span class="sxs-lookup"><span data-stu-id="3eb34-192"><http://deviq.com/separation-of-concerns/></span></span>
> - <span data-ttu-id="3eb34-193">**Encapsulation** <http://deviq.com/encapsulation/></span><span class="sxs-lookup"><span data-stu-id="3eb34-193">**Encapsulation** <http://deviq.com/encapsulation/></span></span>
> - <span data-ttu-id="3eb34-194">**依存関係の逆転原則**</span><span class="sxs-lookup"><span data-stu-id="3eb34-194">**Dependency Inversion Principle**</span></span>  
> <span data-ttu-id="3eb34-195"><http://deviq.com/dependency-inversion-principle/></span><span class="sxs-lookup"><span data-stu-id="3eb34-195"><http://deviq.com/dependency-inversion-principle/></span></span>
> - <span data-ttu-id="3eb34-196">**明示的な依存関係の原則**</span><span class="sxs-lookup"><span data-stu-id="3eb34-196">**Explicit Dependencies Principle**</span></span>  
> <span data-ttu-id="3eb34-197"><http://deviq.com/explicit-dependencies-principle/></span><span class="sxs-lookup"><span data-stu-id="3eb34-197"><http://deviq.com/explicit-dependencies-principle/></span></span>
> - <span data-ttu-id="3eb34-198">**自分で繰り返さない**</span><span class="sxs-lookup"><span data-stu-id="3eb34-198">**Don't Repeat Yourself**</span></span>  
> <span data-ttu-id="3eb34-199"><http://deviq.com/don-t-repeat-yourself/></span><span class="sxs-lookup"><span data-stu-id="3eb34-199"><http://deviq.com/don-t-repeat-yourself/></span></span>
> - <span data-ttu-id="3eb34-200">永続性の無視</span><span class="sxs-lookup"><span data-stu-id="3eb34-200">**Persistence Ignorance**</span></span>  
> <span data-ttu-id="3eb34-201"><http://deviq.com/persistence-ignorance/></span><span class="sxs-lookup"><span data-stu-id="3eb34-201"><http://deviq.com/persistence-ignorance/></span></span>
> - <span data-ttu-id="3eb34-202">**範囲指定されたコンテキスト**</span><span class="sxs-lookup"><span data-stu-id="3eb34-202">**Bounded Context**</span></span>  
> <span data-ttu-id="3eb34-203"><https://martinfowler.com/bliki/BoundedContext.html></span><span class="sxs-lookup"><span data-stu-id="3eb34-203"><https://martinfowler.com/bliki/BoundedContext.html></span></span>

> [!div class="step-by-step"]
<span data-ttu-id="3eb34-204">[前](choose-between-traditional-web-and-single-page-apps.md) [次へ] (共通-web-アプリケーション-architectures.md)</span><span class="sxs-lookup"><span data-stu-id="3eb34-204">[Previous] (choose-between-traditional-web-and-single-page-apps.md) [Next] (common-web-application-architectures.md)</span></span>
