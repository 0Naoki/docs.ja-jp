---
title: "一般的な web アプリケーションのアーキテクチャ"
description: "ASP.NET Core と Microsoft Azure での最新の web アプリケーションを設計 |一般的な web アプリケーションのアーキテクチャ"
author: ardalis
ms.author: wiwagn
ms.date: 10/06/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.openlocfilehash: b6236cfab290211f930d6a1987075abeade4fd6d
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/21/2017
---
#<a name="common-web-application-architectures"></a><span data-ttu-id="75fc1-103">一般的な Web アプリケーションのアーキテクチャ</span><span class="sxs-lookup"><span data-stu-id="75fc1-103">Common Web Application Architectures</span></span>

> <span data-ttu-id="75fc1-104">「アーキテクチャは、高価な良いと思う場合、不適切なアーキテクチャを再試行してください。」</span><span class="sxs-lookup"><span data-stu-id="75fc1-104">"If you think good architecture is expensive, try bad architecture."</span></span>  
> <span data-ttu-id="75fc1-105">_-Brian Foote とジョセフで_</span><span class="sxs-lookup"><span data-stu-id="75fc1-105">_- Brian Foote and Joseph Yoder_</span></span>

## <a name="summary"></a><span data-ttu-id="75fc1-106">概要</span><span class="sxs-lookup"><span data-stu-id="75fc1-106">Summary</span></span>

<span data-ttu-id="75fc1-107">従来のほとんどの .NET アプリケーションは、実行可能ファイルまたは 1 つの IIS appdomain 内で実行される単一の web アプリケーションに対応する 1 つの単位として配置されます。</span><span class="sxs-lookup"><span data-stu-id="75fc1-107">Most traditional .NET applications are deployed as single units corresponding to an executable or a single web application running within a single IIS appdomain.</span></span> <span data-ttu-id="75fc1-108">これは最も簡単な展開モデルであり、多くの内部およびより小さな公開アプリケーションをあまり機能です。</span><span class="sxs-lookup"><span data-stu-id="75fc1-108">This is the simplest deployment model and serves many internal and smaller public applications very well.</span></span> <span data-ttu-id="75fc1-109">ただし、この展開の 1 つの単位も指定すると、最も重要なビジネス アプリケーションを享受によって複数のレイヤーに論理的な分離できます。</span><span class="sxs-lookup"><span data-stu-id="75fc1-109">However, even given this single unit of deployment, most non-trivial business applications benefit from some logical separation into several layers.</span></span>

## <a name="what-is-a-monolithic-application"></a><span data-ttu-id="75fc1-110">モノリシックなアプリケーションとは何ですか。</span><span class="sxs-lookup"><span data-stu-id="75fc1-110">What is a monolithic application?</span></span>

<span data-ttu-id="75fc1-111">モノリシックなアプリケーションとは、完全に独立、その動作の観点からです。</span><span class="sxs-lookup"><span data-stu-id="75fc1-111">A monolithic application is one that is entirely self-contained, in terms of its behavior.</span></span> <span data-ttu-id="75fc1-112">これは、可能性があります、その操作を実行中の他のサービスまたはデータ ストアがその動作のコアが、独自のプロセス内で実行し、対話アプリケーション全体、1 つの単位として一般的な展開します。</span><span class="sxs-lookup"><span data-stu-id="75fc1-112">It may interact with other services or data stores in the course of performing its operations, but the core of its behavior runs within its own process and the entire application is typically deployed as a single unit.</span></span> <span data-ttu-id="75fc1-113">このようなアプリケーションは、水平方向にスケーリングする必要があります、通常アプリケーション全体は複数のサーバーや仮想マシン間で複製します。</span><span class="sxs-lookup"><span data-stu-id="75fc1-113">If such an application needs to scale horizontally, typically the entire application is duplicated across multiple servers or virtual machines.</span></span>

## <a name="all-in-one-applications"></a><span data-ttu-id="75fc1-114">1 つのすべてのアプリケーション</span><span class="sxs-lookup"><span data-stu-id="75fc1-114">All-in-One applications</span></span>

<span data-ttu-id="75fc1-115">アプリケーションのアーキテクチャ用のプロジェクトの最小数は、1 つです。</span><span class="sxs-lookup"><span data-stu-id="75fc1-115">The smallest possible number of projects for an application architecture is one.</span></span> <span data-ttu-id="75fc1-116">このアーキテクチャでは、アプリケーションのロジック全体が 1 つのプロジェクトに含まれている、1 つのアセンブリにコンパイルおよび 1 つの単位としてデプロイされています。</span><span class="sxs-lookup"><span data-stu-id="75fc1-116">In this architecture, the entire logic of the application is contained in a single project, compiled to a single assembly, and deployed as a single unit.</span></span>

<span data-ttu-id="75fc1-117">新規の ASP.NET Core プロジェクトまたはコマンドラインから Visual Studio で作成したかどうかを起点に単純な「オールインワン」- 一枚岩です。</span><span class="sxs-lookup"><span data-stu-id="75fc1-117">A new ASP.NET Core project, whether created in Visual Studio or from the command line, starts out as a simple "all-in-one" monolith.</span></span> <span data-ttu-id="75fc1-118">すべてのプレゼンテーション、ビジネス、およびデータ アクセス ロジックを含む、アプリケーションの動作が含まれています。</span><span class="sxs-lookup"><span data-stu-id="75fc1-118">It contains all of the behavior of the application, including presentation, business, and data access logic.</span></span> <span data-ttu-id="75fc1-119">図 5-1 は、単一のプロジェクトのアプリのファイル構造を示しています。</span><span class="sxs-lookup"><span data-stu-id="75fc1-119">Figure 5-1 shows the file structure of a single-project app.</span></span>

<span data-ttu-id="75fc1-120">**図 5-1。**</span><span class="sxs-lookup"><span data-stu-id="75fc1-120">**Figure 5-1.**</span></span> <span data-ttu-id="75fc1-121">ASP.NET Core アプリケーションの単一のプロジェクト</span><span class="sxs-lookup"><span data-stu-id="75fc1-121">A single project ASP.NET Core app</span></span>

![](./media/image5-1.png)

<span data-ttu-id="75fc1-122">1 つのプロジェクトのシナリオでは、フォルダーを使用して、関心の分離が実現されます。</span><span class="sxs-lookup"><span data-stu-id="75fc1-122">In a single project scenario, separation of concerns is achieved through the use of folders.</span></span> <span data-ttu-id="75fc1-123">既定のテンプレートには、データおよびサービス用のモデル、ビュー、およびコント ローラーの MVC パターン責任の個別のフォルダーおよびその他のフォルダーが含まれています。</span><span class="sxs-lookup"><span data-stu-id="75fc1-123">The default template includes separate folders for MVC pattern responsibilities of Models, Views, and Controllers, as well as additional folders for Data and Services.</span></span> <span data-ttu-id="75fc1-124">この配置では、プレゼンテーションの詳細をできるだけ、Views フォルダーに制限する必要がありますので、データ アクセスの実装の詳細は、データ フォルダー内に保持するクラスに限定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="75fc1-124">In this arrangement, presentation details should be limited as much as possible to the Views folder, and data access implementation details should be limited to classes kept in the Data folder.</span></span> <span data-ttu-id="75fc1-125">ビジネス ロジックは、サービスとモデル フォルダー内のクラス内に存在する必要があります。</span><span class="sxs-lookup"><span data-stu-id="75fc1-125">Business logic should reside in services and classes within the Models folder.</span></span>

<span data-ttu-id="75fc1-126">、にシンプルですが、単一のプロジェクト モノリシック ソリューションには、いくつかの欠点が含まれて。</span><span class="sxs-lookup"><span data-stu-id="75fc1-126">Although simple, the single-project monolithic solution has some disadvantages.</span></span> <span data-ttu-id="75fc1-127">プロジェクトの規模と複雑さが増大すると、ファイルとフォルダーの数は、拡張も続行されます。</span><span class="sxs-lookup"><span data-stu-id="75fc1-127">As the project's size and complexity grows, the number of files and folders will continue to grow as well.</span></span> <span data-ttu-id="75fc1-128">UI の懸念事項 (モデル、ビュー、コント ローラー) は、グループ分けされていない一緒にアルファベット順に複数のフォルダー内に存在します。</span><span class="sxs-lookup"><span data-stu-id="75fc1-128">UI concerns (models, views, controllers) reside in multiple folders, which are not grouped together alphabetically.</span></span> <span data-ttu-id="75fc1-129">この問題は、フィルターまたは ModelBinders などの他の UI レベル構造が、独自のフォルダーに追加された場合にのみ、悪化を取得します。</span><span class="sxs-lookup"><span data-stu-id="75fc1-129">This issue only gets worse when additional UI-level constructs, such as Filters or ModelBinders, are added in their own folders.</span></span> <span data-ttu-id="75fc1-130">ビジネス ロジックが、モデルとサービスのフォルダー間で分散しているし、がありますがはっきりしないうち先となるフォルダー内のクラスがどの他のユーザーに依存する必要があります。</span><span class="sxs-lookup"><span data-stu-id="75fc1-130">Business logic is scattered between the Models and Services folders, and there is no clear indication of which classes in which folders should depend on which others.</span></span> <span data-ttu-id="75fc1-131">このが不足しているプロジェクト レベルの組織が頻繁につながります[整然としたプログラム](http://deviq.com/spaghetti-code/)です。</span><span class="sxs-lookup"><span data-stu-id="75fc1-131">This lack of organization at the project level frequently leads to [spaghetti code](http://deviq.com/spaghetti-code/).</span></span>

<span data-ttu-id="75fc1-132">これらの問題に対処するために多くの場合にアプリケーションが拡張を特定の配置の各プロジェクトと見なされます、マルチ プロジェクト ソリューション*レイヤー*アプリケーションです。</span><span class="sxs-lookup"><span data-stu-id="75fc1-132">In order to address these issues, applications often evolve into multi-project solutions, where each project is considered to reside in a particular *layer* of the application.</span></span>

## <a name="what-are-layers"></a><span data-ttu-id="75fc1-133">レイヤーとは</span><span class="sxs-lookup"><span data-stu-id="75fc1-133">What are layers?</span></span>

<span data-ttu-id="75fc1-134">アプリケーションが複雑になるにつれて、その複雑さを管理する方法の 1 つでは、その責任や懸念事項に従って、アプリケーションを分割します。</span><span class="sxs-lookup"><span data-stu-id="75fc1-134">As applications grow in complexity, one way to manage that complexity is to break the application up according to its responsibilities or concerns.</span></span> <span data-ttu-id="75fc1-135">これにより、懸念原則の分離に依存して整理されるので、開発者は、特定の機能が実装されている簡単に見つけることが増大するコードベースに保つことができます。</span><span class="sxs-lookup"><span data-stu-id="75fc1-135">This follows the separation of concerns principle, and can help keep a growing codebase organized so that developers can easily find where certain functionality is implemented.</span></span> <span data-ttu-id="75fc1-136">複数層アーキテクチャがいくつかのコード組織だけ以外の利点を得られます。</span><span class="sxs-lookup"><span data-stu-id="75fc1-136">Layered architecture offers a number of advantages beyond just code organization, though.</span></span>

<span data-ttu-id="75fc1-137">コードをレイヤーに編成、下位の共通の機能をアプリケーション全体で再利用できます。</span><span class="sxs-lookup"><span data-stu-id="75fc1-137">By organizing code into layers, common low-level functionality can be reused throughout the application.</span></span> <span data-ttu-id="75fc1-138">ドライという原則に従って、1 つの実装を標準化するアプリケーションを許可することができますが、少ないコードを記述する必要がありますので、この再利用の使用をお勧めします。</span><span class="sxs-lookup"><span data-stu-id="75fc1-138">This reuse is beneficial because it means less code needs to be written and because it can allow the application to standardize on a single implementation, following the DRY principle.</span></span>

<span data-ttu-id="75fc1-139">複数層のアーキテクチャを持つアプリケーションは、他のレイヤーと通信できるレイヤーを制限を適用できます。</span><span class="sxs-lookup"><span data-stu-id="75fc1-139">With a layered architecture, applications can enforce restrictions on which layers can communicate with other layers.</span></span> <span data-ttu-id="75fc1-140">これにより、カプセル化を実現するためにします。</span><span class="sxs-lookup"><span data-stu-id="75fc1-140">This helps to achieve encapsulation.</span></span> <span data-ttu-id="75fc1-141">レイヤーを変更または置換すると場合、を使用するレイヤーだけが影響する必要があります。</span><span class="sxs-lookup"><span data-stu-id="75fc1-141">When a layer is changed or replaced, only those layers that work with it should be impacted.</span></span> <span data-ttu-id="75fc1-142">これを制限することによっては、レイヤーは、アプリケーション全体が 1 つの変更の影響を受けるようにする他のレイヤーでは、変更の影響を軽減することができますを依存します。</span><span class="sxs-lookup"><span data-stu-id="75fc1-142">By limiting which layers depend on which other layers, the impact of changes can be mitigated so that a single change doesn't impact the entire application.</span></span>

<span data-ttu-id="75fc1-143">レイヤー (および encapsulation) をアプリケーション内の機能を置き換えるはるかに簡単にください。</span><span class="sxs-lookup"><span data-stu-id="75fc1-143">Layers (and encapsulation) make it much easier to replace functionality within the application.</span></span> <span data-ttu-id="75fc1-144">たとえば、アプリケーションでは、永続化ストアの独自の SQL Server データベースを使用して最初に可能性がありますが、後で、クラウド ベースの永続性戦略または web API の背後にある 1 つを使用するように選択。</span><span class="sxs-lookup"><span data-stu-id="75fc1-144">For example, an application might initially use its own SQL Server database for persistence, but later could choose to use a cloud-based persistence strategy, or one behind a web API.</span></span> <span data-ttu-id="75fc1-145">アプリケーションは、論理層内の永続性の実装をカプセル化正しくは、その SQL Server の特定のレイヤーはでした同じパブリック インターフェイスを実装する新しい 1 置き換え。</span><span class="sxs-lookup"><span data-stu-id="75fc1-145">If the application has properly encapsulated its persistence implementation within a logical layer, that SQL Server specific layer could be replaced by a new one implementing the same public interface.</span></span>

<span data-ttu-id="75fc1-146">実装要件の将来の変更に応答を交換する可能性がある、だけでなくアプリケーション レイヤーも易くなりますをスワップ アウト テスト目的で実装します。</span><span class="sxs-lookup"><span data-stu-id="75fc1-146">In addition to the potential of swapping out implementations in response to future changes in requirements, application layers can also make it easier to swap out implementations for testing purposes.</span></span> <span data-ttu-id="75fc1-147">実際のデータ層またはアプリケーションの UI レイヤーに対して動作するテストを記述する代わりでは、要求を正常に応答する偽の実装と、テスト時に、これらのレイヤーを置き換えられます。</span><span class="sxs-lookup"><span data-stu-id="75fc1-147">Instead of having to write tests that operate against the real data layer or UI layer of the application, these layers can be replaced at test time with fake implementations that provide known responses to requests.</span></span> <span data-ttu-id="75fc1-148">これは、通常ためテストの記述をはるかに簡単と非常に速くもう一度アプリケーションの実際のインフラストラクチャのテストを実行中に比較した場合に実行します。</span><span class="sxs-lookup"><span data-stu-id="75fc1-148">This typically makes tests much easier to write and much faster to run when compared to running tests again the application's real infrastructure.</span></span>

<span data-ttu-id="75fc1-149">論理の重ね順は、組織のエンタープライズ ソフトウェア アプリケーションで、コードを改善するための一般的な手法といくつかの方法でコードをレイヤーに編成できるようにします。</span><span class="sxs-lookup"><span data-stu-id="75fc1-149">Logical layering is a common technique for improving the organization of code in enterprise software applications, and there are several ways in which code can be organized into layers.</span></span>

> [!NOTE]
> <span data-ttu-id="75fc1-150">*レイヤー*アプリケーション内で論理的な分離を表します。</span><span class="sxs-lookup"><span data-stu-id="75fc1-150">*Layers* represent logical separation within the application.</span></span> <span data-ttu-id="75fc1-151">アプリケーション ロジックは、サーバーまたはプロセスを分離する物理的に分散している別の物理的な配置ターゲットをいいます*階層*です。</span><span class="sxs-lookup"><span data-stu-id="75fc1-151">In the event that application logic is physically distributed to separate servers or processes, these separate physical deployment targets are referred to as *tiers*.</span></span> <span data-ttu-id="75fc1-152">可能であればとに 1 つの層に展開されている N 層アプリケーション、非常に一般的であります。</span><span class="sxs-lookup"><span data-stu-id="75fc1-152">It's possible, and quite common, to have an N-Layer application that is deployed to a single tier.</span></span>

## <a name="traditional-n-layer-architecture-applications"></a><span data-ttu-id="75fc1-153">従来の「N 層」アーキテクチャ アプリケーション</span><span class="sxs-lookup"><span data-stu-id="75fc1-153">Traditional "N-Layer" architecture applications</span></span>

<span data-ttu-id="75fc1-154">アプリケーション ロジックの最も一般的な組織をレイヤー図 5-2 に示すことです。</span><span class="sxs-lookup"><span data-stu-id="75fc1-154">The most common organization of application logic into layers it shown in Figure 5-2.</span></span>

<span data-ttu-id="75fc1-155">**図 5-2 です。**</span><span class="sxs-lookup"><span data-stu-id="75fc1-155">**Figure 5-2.**</span></span> <span data-ttu-id="75fc1-156">通常、アプリケーション レイヤーです。</span><span class="sxs-lookup"><span data-stu-id="75fc1-156">Typical application layers.</span></span>

![](./media/image5-2.png)

<span data-ttu-id="75fc1-157">これらのレイヤーは UI として略称 BLL (ビジネス ロジック層) と DAL (データ アクセス層)。</span><span class="sxs-lookup"><span data-stu-id="75fc1-157">These layers are frequently abbreviated as UI, BLL (Business Logic Layer), and DAL (Data Access Layer).</span></span> <span data-ttu-id="75fc1-158">このアーキテクチャを使用して、ユーザーは、BLL とだけ通信する UI レイヤーを通じて要求を行います。</span><span class="sxs-lookup"><span data-stu-id="75fc1-158">Using this architecture, users make requests through the UI layer, which interacts only with the BLL.</span></span> <span data-ttu-id="75fc1-159">さらに、BLL は、データ アクセスの要求に対して、DAL を呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="75fc1-159">The BLL, in turn, can call the DAL for data access requests.</span></span> <span data-ttu-id="75fc1-160">UI レイヤーをしないようにすべての要求、DAL を直接も、他の手段で直接永続化と通信する必要があります。</span><span class="sxs-lookup"><span data-stu-id="75fc1-160">The UI layer should not make any requests to the DAL directly, nor should it interact with persistence directly through other means.</span></span> <span data-ttu-id="75fc1-161">同様に、BLL は、DAL を使用する永続化とやり取りのみ必要があります。</span><span class="sxs-lookup"><span data-stu-id="75fc1-161">Likewise, the BLL should only interact with persistence by going through the DAL.</span></span> <span data-ttu-id="75fc1-162">この方法では、各レイヤーは、独自のよく知られた責任を持ちます。</span><span class="sxs-lookup"><span data-stu-id="75fc1-162">In this way, each layer has its own well-known responsibility.</span></span>

<span data-ttu-id="75fc1-163">この従来のレイヤーのアプローチの欠点の 1 つでは、コンパイル時の依存関係が最下位に達して上部から実行します。</span><span class="sxs-lookup"><span data-stu-id="75fc1-163">One disadvantage of this traditional layering approach is that compile-time dependencies run from the top to the bottom.</span></span> <span data-ttu-id="75fc1-164">つまり、UI レイヤーは、DAL に依存する BLL によって異なります。</span><span class="sxs-lookup"><span data-stu-id="75fc1-164">That is, the UI layer depends on the BLL, which depends on the DAL.</span></span> <span data-ttu-id="75fc1-165">つまり、BLL は、通常、アプリケーションで最も重要なロジックを保持して、データ アクセスの実装の詳細に (および多くの場合に、データベースの存在に関する) に依存します。</span><span class="sxs-lookup"><span data-stu-id="75fc1-165">This means that the BLL, which usually holds the most important logic in the application, is dependent on data access implementation details (and often on the existence of a database).</span></span> <span data-ttu-id="75fc1-166">アーキテクチャではこのようなビジネス ロジックをテストすることは困難ですが、テスト データベースを必要とするがよくあります。</span><span class="sxs-lookup"><span data-stu-id="75fc1-166">Testing business logic in such an architecture is often difficult, requiring a test database.</span></span> <span data-ttu-id="75fc1-167">次のセクションで後ほど、この問題に対処依存関係の逆転原則を使用できます。</span><span class="sxs-lookup"><span data-stu-id="75fc1-167">The dependency inversion principle can be used to address this issue, as you'll see in the next section.</span></span>

<span data-ttu-id="75fc1-168">図 5-3 は、責任 (またはレイヤー) によって、3 つのプロジェクトにアプリケーションを分割する例ソリューションを示しています。</span><span class="sxs-lookup"><span data-stu-id="75fc1-168">Figure 5-3 shows an example solution, breaking the application into three projects by responsibility (or layer).</span></span>

<span data-ttu-id="75fc1-169">**図 5-3。**</span><span class="sxs-lookup"><span data-stu-id="75fc1-169">**Figure 5-3.**</span></span> <span data-ttu-id="75fc1-170">3 つのプロジェクトでの単純なモノリシック アプリケーション。</span><span class="sxs-lookup"><span data-stu-id="75fc1-170">A simple monolithic application with three projects.</span></span>

![](./media/image5-3.png)

<span data-ttu-id="75fc1-171">このアプリケーションは、組織のためのいくつかのプロジェクトを使用して、単一ユニットとして展開されている、そのクライアントが操作を 1 つの web アプリとして。</span><span class="sxs-lookup"><span data-stu-id="75fc1-171">Although this application uses several projects for organizational purposes, it is still deployed as a single unit and its clients will interact with it as a single web app.</span></span> <span data-ttu-id="75fc1-172">これにより、非常に単純な展開プロセスです。</span><span class="sxs-lookup"><span data-stu-id="75fc1-172">This allows for very simple deployment process.</span></span> <span data-ttu-id="75fc1-173">図 5-4 は、このようなアプリでどのようにされている可能性がありますを示しています。 Windows Azure を使用してホストされています。</span><span class="sxs-lookup"><span data-stu-id="75fc1-173">Figure 5-4 shows how such an app might be hosted using Windows Azure.</span></span>

![](./media/image5-4.png)

<span data-ttu-id="75fc1-174">**図 5-4 です。**</span><span class="sxs-lookup"><span data-stu-id="75fc1-174">**Figure 5-4.**</span></span> <span data-ttu-id="75fc1-175">Azure Web アプリの単純な展開</span><span class="sxs-lookup"><span data-stu-id="75fc1-175">Simple deployment of Azure Web App</span></span>

<span data-ttu-id="75fc1-176">アプリケーション ニーズの拡大に合わせてより複雑で強力な展開ソリューションが必要な場合があります。</span><span class="sxs-lookup"><span data-stu-id="75fc1-176">As application needs grow, more complex and robust deployment solutions may be required.</span></span> <span data-ttu-id="75fc1-177">図 5-5 は、その他の機能をサポートするより複雑な配置計画の例を示します。</span><span class="sxs-lookup"><span data-stu-id="75fc1-177">Figure 5-5 shows an example of a more complex deployment plan that supports additional capabilities.</span></span>

![](./media/image5-5.png)

<span data-ttu-id="75fc1-178">**図 5-5 です。**</span><span class="sxs-lookup"><span data-stu-id="75fc1-178">**Figure 5-5.**</span></span> <span data-ttu-id="75fc1-179">Azure App Service に web アプリを展開します。</span><span class="sxs-lookup"><span data-stu-id="75fc1-179">Deploying a web app to an Azure App Service</span></span>

<span data-ttu-id="75fc1-180">内部的には、役割に基づいた複数のプロジェクトにこのプロジェクトの組織では、アプリケーションの保守容易性が向上します。</span><span class="sxs-lookup"><span data-stu-id="75fc1-180">Internally, this project's organization into multiple projects based on responsibility improves the maintainability of the application.</span></span>

<span data-ttu-id="75fc1-181">この単位は、クラウド ベースのオンデマンドの拡張性を活用するためにアップまたはアウト スケールことができます。</span><span class="sxs-lookup"><span data-stu-id="75fc1-181">This unit can be scaled up or out to take advantage of cloud-based on-demand scalability.</span></span> <span data-ttu-id="75fc1-182">スケール アップには、アプリをホストしているサーバーに CPU がさらに、メモリ、ディスク領域、またはその他のリソースを追加することを意味します。</span><span class="sxs-lookup"><span data-stu-id="75fc1-182">Scaling up means adding additional CPU, memory, disk space, or other resources to the server(s) hosting your app.</span></span> <span data-ttu-id="75fc1-183">スケール アウトはこのようなサーバーの追加インスタンスを追加するこれらは、物理サーバーまたは仮想マシンかどうか。</span><span class="sxs-lookup"><span data-stu-id="75fc1-183">Scaling out means adding additional instances of such servers, whether these are physical servers or virtual machines.</span></span> <span data-ttu-id="75fc1-184">アプリが複数のインスタンスでホストされている場合、ロード バランサーを使用して個々 のアプリのインスタンスに要求を割り当てます。</span><span class="sxs-lookup"><span data-stu-id="75fc1-184">When your app is hosted across multiple instances, a load balancer is used to assign requests to individual app instances.</span></span>

<span data-ttu-id="75fc1-185">Azure で web アプリケーションをスケーリングする最も簡単な方法では、アプリケーションの App Service プランでのスケーリングを手動で構成します。</span><span class="sxs-lookup"><span data-stu-id="75fc1-185">The simplest approach to scaling a web application in Azure is to configure scaling manually in the application's App Service Plan.</span></span> <span data-ttu-id="75fc1-186">図 5-6 では、アプリを提供するインスタンスの数を構成する適切な Azure ダッシュ ボード画面を表示します。</span><span class="sxs-lookup"><span data-stu-id="75fc1-186">Figure 5-6 show the appropriate Azure dashboard screen to configure how many instances are serving an app.</span></span>

![](./media/image5-6.png)

<span data-ttu-id="75fc1-187">**図 5 ~ 6 です。**</span><span class="sxs-lookup"><span data-stu-id="75fc1-187">**Figure 5-6.**</span></span> <span data-ttu-id="75fc1-188">App Service プランが Azure でのスケーリングします。</span><span class="sxs-lookup"><span data-stu-id="75fc1-188">App Service Plan scaling in Azure.</span></span>

## <a name="clean-architecture"></a><span data-ttu-id="75fc1-189">クリーン アーキテクチャ</span><span class="sxs-lookup"><span data-stu-id="75fc1-189">Clean architecture</span></span>

<span data-ttu-id="75fc1-190">依存関係の逆転原則とドメイン デザイン (DDD) の原則に従います。 アプリケーションは、同様のアーキテクチャに到着する傾向があります。</span><span class="sxs-lookup"><span data-stu-id="75fc1-190">Applications that follow the Dependency Inversion Principle as well as Domain-Driven Design (DDD) principles tend to arrive at a similar architecture.</span></span> <span data-ttu-id="75fc1-191">このアーキテクチャを長年にわたってさまざまな名称消えます。</span><span class="sxs-lookup"><span data-stu-id="75fc1-191">This architecture has gone by many names over the years.</span></span> <span data-ttu-id="75fc1-192">名前の 1 つはでした六角アーキテクチャでは、ポートのアダプタを続けてです。</span><span class="sxs-lookup"><span data-stu-id="75fc1-192">One of the first names was Hexagonal Architecture, followed by Ports-and-Adapters.</span></span> <span data-ttu-id="75fc1-193">最近では、これは引用したとして、[タマネギ アーキテクチャ](http://jeffreypalermo.com/blog/the-onion-architecture-part-1/)または[クリーン アーキテクチャ](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html)です。</span><span class="sxs-lookup"><span data-stu-id="75fc1-193">More recently, it's been cited as the [Onion Architecture](http://jeffreypalermo.com/blog/the-onion-architecture-part-1/) or [Clean Architecture](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html).</span></span> <span data-ttu-id="75fc1-194">この最後の名前、クリーンのアーキテクチャがあり、この電子ブックでアーキテクチャを記述するための基礎として使用されているです。</span><span class="sxs-lookup"><span data-stu-id="75fc1-194">It is this last name, Clean Architecture, that is used as the basis for describing the architecture in this e-book.</span></span>

> [!NOTE]
> <span data-ttu-id="75fc1-195">という用語はクリーンなアーキテクチャを DDD を使用して組み込まれていないものについて DDD 原則もを使用して構築されたアプリケーションに適用できます。</span><span class="sxs-lookup"><span data-stu-id="75fc1-195">The term Clean Architecture can be applied to applications that are built using DDD Principles as well as to those that are not built using DDD.</span></span> <span data-ttu-id="75fc1-196">前者の場合はこの組み合わせ可能性がありますと呼ばれます「クリーン DDD アーキテクチャ」です。</span><span class="sxs-lookup"><span data-stu-id="75fc1-196">In the case of the former, this combination may be referred to as "Clean DDD Architecture".</span></span>

<span data-ttu-id="75fc1-197">クリーンなアーキテクチャは、アプリケーションの中心にビジネス ロジックとアプリケーションのモデルを配置します。</span><span class="sxs-lookup"><span data-stu-id="75fc1-197">Clean architecture puts the business logic and application model at the center of the application.</span></span> <span data-ttu-id="75fc1-198">データ アクセスやその他のインフラストラクチャ上の問題に依存するビジネス ロジックはなく、この依存関係は、反転: インフラストラクチャと実装の詳細は、アプリケーションのコアに依存します。</span><span class="sxs-lookup"><span data-stu-id="75fc1-198">Instead of having business logic depend on data access or other infrastructure concerns, this dependency is inverted: infrastructure and implementation details depend on the Application Core.</span></span> <span data-ttu-id="75fc1-199">これは、インフラストラクチャ レイヤーで定義された型を実装する、アプリケーションのコアに抽象化、またはインターフェイスを定義することによって実現されます。</span><span class="sxs-lookup"><span data-stu-id="75fc1-199">This is achieved by defining abstractions, or interfaces, in the Application Core, which are then implemented by types defined in the Infrastructure layer.</span></span> <span data-ttu-id="75fc1-200">このアーキテクチャを視覚化する一般的な方法では、一連の同心円、重のようなを使用します。</span><span class="sxs-lookup"><span data-stu-id="75fc1-200">A common way of visualizing this architecture is to use a series of concentric circles, similar to an onion.</span></span> <span data-ttu-id="75fc1-201">図 5 X は、このスタイルのアーキテクチャの表現の例を示します。</span><span class="sxs-lookup"><span data-stu-id="75fc1-201">Figure 5-X shows an example of this style of architectural representation.</span></span>

![](./media/image5-7.png)

<span data-ttu-id="75fc1-202">**図 5-7 です。**</span><span class="sxs-lookup"><span data-stu-id="75fc1-202">**Figure 5-7.**</span></span> <span data-ttu-id="75fc1-203">クリーン アーキテクチャです。タマネギ ビュー</span><span class="sxs-lookup"><span data-stu-id="75fc1-203">Clean Architecture; onion view</span></span>

<span data-ttu-id="75fc1-204">この図では、依存関係は、最も内側の円に向けたフローです。</span><span class="sxs-lookup"><span data-stu-id="75fc1-204">In this diagram, dependencies flow toward the innermost circle.</span></span> <span data-ttu-id="75fc1-205">したがって、ことはその名前をこのダイアグラムのコアでの位置から) アプリケーションの主要な依存関係を持たない他のアプリケーション レイヤーでを表示できます。</span><span class="sxs-lookup"><span data-stu-id="75fc1-205">Thus, you can see that the Application Core (which takes its name from its position at the core of this diagram) has no dependencies on other application layers.</span></span> <span data-ttu-id="75fc1-206">非常に中心では、アプリケーションのエンティティとのインターフェイスです。</span><span class="sxs-lookup"><span data-stu-id="75fc1-206">At the very center are the application's entities and interfaces.</span></span> <span data-ttu-id="75fc1-207">すぐ外側は、アプリケーションのコアの中では、通常内部円で定義されているインターフェイスを実装しているドメイン サービスです。</span><span class="sxs-lookup"><span data-stu-id="75fc1-207">Just outside, but still in the Application Core, are domain services, which typically implement interfaces defined in the inner circle.</span></span> <span data-ttu-id="75fc1-208">アプリケーション コアの外部で、ユーザー インターフェイスとインフラストラクチャ レイヤーの両方依存アプリケーション Core ではなく相互 (とは限りません)。</span><span class="sxs-lookup"><span data-stu-id="75fc1-208">Outside of the Application Core, both the User Interface and the Infrastructure layers depend on the Application Core, but not on one another (necessarily).</span></span>

<span data-ttu-id="75fc1-209">図 5 X には、UI およびその他のレイヤー間の依存関係をより正確に反映される従来の水平方向のレイヤー図が示しています。</span><span class="sxs-lookup"><span data-stu-id="75fc1-209">Figure 5-X shows a more traditional horizontal layer diagram that better reflects the dependency between the UI and other layers.</span></span>

![](./media/image5-8.png)

<span data-ttu-id="75fc1-210">**図 5-8 です。**</span><span class="sxs-lookup"><span data-stu-id="75fc1-210">**Figure 5-8.**</span></span> <span data-ttu-id="75fc1-211">クリーン アーキテクチャです。水平方向のレイヤーの表示</span><span class="sxs-lookup"><span data-stu-id="75fc1-211">Clean Architecture; horizontal layer view</span></span>

<span data-ttu-id="75fc1-212">破線の矢印は、実行時専用の依存関係を表すに対し、実線の矢印がコンパイル時の依存関係を表すことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="75fc1-212">Note that the solid arrows represent compile-time dependencies, while the dashed arrow represents a runtime-only dependency.</span></span> <span data-ttu-id="75fc1-213">クリーンなアーキテクチャを使用して、コンパイル時に、アプリケーションのコアに定義されているインターフェイスによる UI レイヤーと理想的には必要がありますが実装の種類の知識定義されていないインフラストラクチャ レイヤーでします。</span><span class="sxs-lookup"><span data-stu-id="75fc1-213">Using the clean architecture, the UI layer works with interfaces defined in the Application Core at compile time, and ideally should not have any knowledge of the implementation types defined in the Infrastructure layer.</span></span> <span data-ttu-id="75fc1-214">実行時に、ただし、これらの実装型必要になりますを実行する、アプリのため、存在し、依存関係の挿入を使用してアプリケーションのコア インターフェイスまでワイヤード (有線) である必要があります。</span><span class="sxs-lookup"><span data-stu-id="75fc1-214">At runtime, however, these implementation types will be required for the app to execute, so they will need to be present and wired up to the Application Core interfaces via dependency injection.</span></span>

<span data-ttu-id="75fc1-215">図 5 ~ 9 では、これらの推奨事項に従って構築されたときに、ASP.NET Core アプリケーションのアーキテクチャの詳細なビューを示します。</span><span class="sxs-lookup"><span data-stu-id="75fc1-215">Figure 5-9 shows a more detailed view of an ASP.NET Core application's architecture when built following these recommendations.</span></span>

![ASPNET コア アーキテクチャ](./media/image5-9.png)

<span data-ttu-id="75fc1-217">**図 5 ~ 9 です。**</span><span class="sxs-lookup"><span data-stu-id="75fc1-217">**Figure 5-9.**</span></span> <span data-ttu-id="75fc1-218">ASP.NET Core アーキテクチャの図は次のクリーンなアーキテクチャ。</span><span class="sxs-lookup"><span data-stu-id="75fc1-218">ASP.NET Core architecture diagram following Clean Architecture.</span></span>

<span data-ttu-id="75fc1-219">アプリケーションのコアは、インフラストラクチャに依存しないために、非常に簡単に自動化された単体テストをこのレイヤーの書き込みです。</span><span class="sxs-lookup"><span data-stu-id="75fc1-219">Because the Application Core doesn't depend on Infrastructure, it is very easy to write automated unit tests for this layer.</span></span> <span data-ttu-id="75fc1-220">図 5 ~ 10 と 11 5 は、テストをこのアーキテクチャに適合する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="75fc1-220">Figures 5-10 and 5-11 show how tests fit into this architecture.</span></span>

![UnitTestCore](./media/image5-10.png)

<span data-ttu-id="75fc1-222">**図 5 ~ 10 です。**</span><span class="sxs-lookup"><span data-stu-id="75fc1-222">**Figure 5-10.**</span></span> <span data-ttu-id="75fc1-223">単体テスト アプリケーション Core 分離します。</span><span class="sxs-lookup"><span data-stu-id="75fc1-223">Unit testing Application Core in isolation.</span></span>

![IntegrationTests](./media/image5-11.png)

<span data-ttu-id="75fc1-225">**図 5-11。**</span><span class="sxs-lookup"><span data-stu-id="75fc1-225">**Figure 5-11.**</span></span> <span data-ttu-id="75fc1-226">統合インフラストラクチャの導入と外部依存関係をテストします。</span><span class="sxs-lookup"><span data-stu-id="75fc1-226">Integration testing Infrastructure implementations with external dependencies.</span></span>

<span data-ttu-id="75fc1-227">UI レイヤーにインフラストラクチャ プロジェクトで定義された型の直接的な依存関係があるないために、非常に簡単にテストを容易にするか、実装、またはアプリケーション要件の変更に応答スワップも同様にします。</span><span class="sxs-lookup"><span data-stu-id="75fc1-227">Since the UI layer doesn't have any direct dependency on types defined in the Infrastructure project, it is likewise very easy to swap out implementations, either to facilitate testing or in response to changing application requirements.</span></span> <span data-ttu-id="75fc1-228">ASP.NET Core の組み込みの使用と依存関係の挿入のサポートを使用するこのアーキテクチャ構造体の非自明モノリシックなアプリケーションに最適な方法です。</span><span class="sxs-lookup"><span data-stu-id="75fc1-228">ASP.NET Core's built-in use of and support for dependency injection makes this architecture the most appropriate way to structure non-trivial monolithic applications.</span></span>

<span data-ttu-id="75fc1-229">モノリシック アプリケーション アプリケーション Core、インフラストラクチャ、およびユーザー インターフェイスのプロジェクトはすべてとして実行する 1 つのアプリケーションです。</span><span class="sxs-lookup"><span data-stu-id="75fc1-229">For monolithic applications the Application Core, Infrastructure, and User Interface projects are all run as a single application.</span></span> <span data-ttu-id="75fc1-230">ランタイム アプリケーションのアーキテクチャは、図 5-12 のようなものになります。</span><span class="sxs-lookup"><span data-stu-id="75fc1-230">The runtime application architecture might look something like Figure 5-12.</span></span>

![ASPNET コア アーキテクチャ 2](./media/image5-12.png)

<span data-ttu-id="75fc1-232">**図 5-12 です。**</span><span class="sxs-lookup"><span data-stu-id="75fc1-232">**Figure 5-12.**</span></span> <span data-ttu-id="75fc1-233">サンプル ASP.NET Core アプリケーションのランタイム アーキテクチャです。</span><span class="sxs-lookup"><span data-stu-id="75fc1-233">A sample ASP.NET Core app's runtime architecture.</span></span>

### <a name="organizing-code-in-clean-architecture"></a><span data-ttu-id="75fc1-234">クリーン アーキテクチャ内のコードの整理</span><span class="sxs-lookup"><span data-stu-id="75fc1-234">Organizing Code in Clean Architecture</span></span>

<span data-ttu-id="75fc1-235">ソリューションでは、クリーンなアーキテクチャ、各プロジェクトには責任を明確です。</span><span class="sxs-lookup"><span data-stu-id="75fc1-235">In a Clean Architecture solution, each project has clear responsibilities.</span></span> <span data-ttu-id="75fc1-236">そのため、プロジェクトごとに特定の型が属するし、適切なプロジェクトでこれらの型に対応するフォルダーがよくあります。</span><span class="sxs-lookup"><span data-stu-id="75fc1-236">As such, certain types will belong in each project and you'll frequently find folders corresponding to these types in the appropriate project.</span></span>

<span data-ttu-id="75fc1-237">アプリケーションのコアでは、エンティティ、サービス、およびインターフェイスが含まれるビジネス モデルを保持します。</span><span class="sxs-lookup"><span data-stu-id="75fc1-237">The Application Core holds the business model, which includes entities, services, and interfaces.</span></span> <span data-ttu-id="75fc1-238">これらのインターフェイスには、データ アクセス、ファイル システムへのアクセス、ネットワークの呼び出しなどのインフラストラクチャを使用して実行される操作のための抽象化が含まれます。場合がありますサービスまたはこのレイヤーで定義されているインターフェイスは、UI またはインフラストラクチャへの依存関係を持たない非エンティティ型を処理する必要があります。</span><span class="sxs-lookup"><span data-stu-id="75fc1-238">These interfaces include abstractions for operations that will be performed using Infrastructure, such as data access, file system access, network calls, etc. Sometimes services or interfaces defined at this layer will need to work with non-entity types that have no dependencies on UI or Infrastructure.</span></span> <span data-ttu-id="75fc1-239">これらは、単純なのデータ転送オブジェクト (Dto) として定義することができます。</span><span class="sxs-lookup"><span data-stu-id="75fc1-239">These can be defined as simple Data Transfer Objects (DTOs).</span></span>

> ### <a name="application-core-types"></a><span data-ttu-id="75fc1-240">コアのアプリケーションの種類</span><span class="sxs-lookup"><span data-stu-id="75fc1-240">Application Core Types</span></span>
> -   <span data-ttu-id="75fc1-241">エンティティ (ビジネス モデル クラスは、永続化)</span><span class="sxs-lookup"><span data-stu-id="75fc1-241">Entities (business model classes that are persisted)</span></span>
> -   <span data-ttu-id="75fc1-242">インターフェイス</span><span class="sxs-lookup"><span data-stu-id="75fc1-242">Interfaces</span></span>
> -   <span data-ttu-id="75fc1-243">サービス</span><span class="sxs-lookup"><span data-stu-id="75fc1-243">Services</span></span>
> -   <span data-ttu-id="75fc1-244">Dtos の使用</span><span class="sxs-lookup"><span data-stu-id="75fc1-244">DTOs</span></span>

<span data-ttu-id="75fc1-245">通常、インフラストラクチャ プロジェクトにはデータ アクセスの実装が含まれます。</span><span class="sxs-lookup"><span data-stu-id="75fc1-245">The Infrastructure project will typically include data access implementations.</span></span> <span data-ttu-id="75fc1-246">通常の ASP.NET Core web アプリケーションに Entity Framework DbContext、定義されている任意の EF コア移行およびデータ アクセスの実装のクラスを含めます。</span><span class="sxs-lookup"><span data-stu-id="75fc1-246">In a typical ASP.NET Core web application, this will include the Entity Framework DbContext, any EF Core Migrations that have been defined, and data access implementation classes.</span></span> <span data-ttu-id="75fc1-247">データ アクセスの実装コードを抽象化する最も一般的な方法を使用すると、[リポジトリ デザイン パターン](http://deviq.com/repository-pattern/)です。</span><span class="sxs-lookup"><span data-stu-id="75fc1-247">The most common way to abstract data access implementation code is through the use of the [Repository design pattern](http://deviq.com/repository-pattern/).</span></span>

<span data-ttu-id="75fc1-248">データ アクセスの実装に加えてインフラストラクチャ プロジェクトは、インフラストラクチャの問題と対話する必要がありますサービスの実装を含める必要があります。</span><span class="sxs-lookup"><span data-stu-id="75fc1-248">In addition to data access implementations, the Infrastructure project should contain implementations of services that must interact with infrastructure concerns.</span></span> <span data-ttu-id="75fc1-249">これらのサービスがアプリケーションでは、定義されているインターフェイスを実装する必要があります。 そのためインフラストラクチャ必要がありますが、アプリケーションの主要なプロジェクトへの参照。</span><span class="sxs-lookup"><span data-stu-id="75fc1-249">These services should implement interfaces defined in the Application Core, and so Infrastructure should have a reference to the Application Core project.</span></span>

> ### <a name="infrastructure-types"></a><span data-ttu-id="75fc1-250">インフラストラクチャの型</span><span class="sxs-lookup"><span data-stu-id="75fc1-250">Infrastructure Types</span></span>
> -   <span data-ttu-id="75fc1-251">EF 主要な型 (DbContext、移行)</span><span class="sxs-lookup"><span data-stu-id="75fc1-251">EF Core types (DbContext, Migrations)</span></span>
> -   <span data-ttu-id="75fc1-252">データ アクセスの実装の種類 (リポジトリ)</span><span class="sxs-lookup"><span data-stu-id="75fc1-252">Data access implementation types (Repositories)</span></span>
> -   <span data-ttu-id="75fc1-253">インフラストラクチャに固有のサービス (FileLogger、SmtpNotifier など)</span><span class="sxs-lookup"><span data-stu-id="75fc1-253">Infrastructure-specific services (FileLogger, SmtpNotifier, etc.)</span></span>

<span data-ttu-id="75fc1-254">ASP.NET Core MVC アプリケーションのユーザー インターフェイス レイヤーは、アプリケーションのエントリ ポイントとなるし、ASP.NET Core MVC プロジェクトになります。</span><span class="sxs-lookup"><span data-stu-id="75fc1-254">The user interface layer in an ASP.NET Core MVC application will be the entry point for the application, and will be an ASP.NET Core MVC project.</span></span> <span data-ttu-id="75fc1-255">このプロジェクトは、アプリケーションの主要なプロジェクトを参照する必要があり、その型が厳密にアプリケーションのコアで定義されているインターフェイスを使用するインフラストラクチャと対話する必要があります。</span><span class="sxs-lookup"><span data-stu-id="75fc1-255">This project should reference the Application Core project, and its types should interact with infrastructure strictly through interfaces defined in Application Core.</span></span> <span data-ttu-id="75fc1-256">なし、直接インスタンス化 (または静的の呼び出し)、UI 層インフラストラクチャ レイヤーの種類を許可する必要があります。</span><span class="sxs-lookup"><span data-stu-id="75fc1-256">No direct instantiation of (or static calls to) Infrastructure layer types should be permitted in the UI layer.</span></span>

> ### <a name="ui-layer-types"></a><span data-ttu-id="75fc1-257">UI レイヤーの種類</span><span class="sxs-lookup"><span data-stu-id="75fc1-257">UI Layer Types</span></span>
> -   <span data-ttu-id="75fc1-258">コント ローラー</span><span class="sxs-lookup"><span data-stu-id="75fc1-258">Controllers</span></span>
> -   <span data-ttu-id="75fc1-259">フィルター</span><span class="sxs-lookup"><span data-stu-id="75fc1-259">Filters</span></span>
> -   <span data-ttu-id="75fc1-260">ビュー</span><span class="sxs-lookup"><span data-stu-id="75fc1-260">Views</span></span>
> -   <span data-ttu-id="75fc1-261">ViewModels</span><span class="sxs-lookup"><span data-stu-id="75fc1-261">ViewModels</span></span>
> -   <span data-ttu-id="75fc1-262">スタートアップ</span><span class="sxs-lookup"><span data-stu-id="75fc1-262">Startup</span></span>

<span data-ttu-id="75fc1-263">スタートアップ クラスは、アプリケーションの構成と実装の種類を組み立てる実行時に適切に機能する依存関係の挿入を許可するインターフェイスにします。</span><span class="sxs-lookup"><span data-stu-id="75fc1-263">The Startup class is responsible for configuring the application, and for wiring up implementation types to interfaces, allowing dependency injection to work properly at run time.</span></span>

> [!NOTE]
> <span data-ttu-id="75fc1-264">UI プロジェクトの ConfigureServices Startup.cs ファイル内の依存関係の挿入をネットワーク上で、するために、プロジェクトは、インフラストラクチャ プロジェクトを参照する必要があります。</span><span class="sxs-lookup"><span data-stu-id="75fc1-264">In order to wire up dependency injection in ConfigureServices in the Startup.cs file of the UI project, the project may need to reference the Infrastructure project.</span></span> <span data-ttu-id="75fc1-265">この依存関係を排除できる、最も簡単にカスタム DI コンテナーを使用しています。</span><span class="sxs-lookup"><span data-stu-id="75fc1-265">This dependency can be eliminated, most easily by using a custom DI container.</span></span> <span data-ttu-id="75fc1-266">このサンプルの目的で、UI プロジェクトのインフラストラクチャ プロジェクト参照を許可するは最も簡単な方法です。</span><span class="sxs-lookup"><span data-stu-id="75fc1-266">For the purposes of this sample, the simplest approach is to allow the UI project to reference the Infrastructure project.</span></span>

## <a name="monolithic-applications-and-containers"></a><span data-ttu-id="75fc1-267">モノリシックなアプリケーションとコンテナー</span><span class="sxs-lookup"><span data-stu-id="75fc1-267">Monolithic Applications and Containers</span></span> 

<span data-ttu-id="75fc1-268">単一引用符と展開モノリシック ベースの Web アプリケーションまたはサービスをビルドし、コンテナーとして展開できます。</span><span class="sxs-lookup"><span data-stu-id="75fc1-268">You can build a single and monolithic-deployment based Web Application or Service and deploy it as a container.</span></span> <span data-ttu-id="75fc1-269">アプリケーション内で場合がありますモノリシックがいくつかのライブラリ、コンポーネント、またはレイヤーに整理します。</span><span class="sxs-lookup"><span data-stu-id="75fc1-269">Within the application, it might not be monolithic but organized into several libraries, components or layers.</span></span> <span data-ttu-id="75fc1-270">外部から 1 つのプロセス、1 つの web アプリケーションまたは 1 つのサービスと同様に 1 つのコンテナーであります。</span><span class="sxs-lookup"><span data-stu-id="75fc1-270">Externally it is a single container like a single process, single web application or single service.</span></span>

<span data-ttu-id="75fc1-271">このモデルを管理するには、アプリケーションを表すための 1 つのコンテナーを展開します。</span><span class="sxs-lookup"><span data-stu-id="75fc1-271">To manage this model, you deploy a single container to represent the application.</span></span> <span data-ttu-id="75fc1-272">前に、ロード バランサーに追加のコピーを追加するだけで、スケールを設定します。</span><span class="sxs-lookup"><span data-stu-id="75fc1-272">To scale, just add additional copies with a load balancer in front.</span></span> <span data-ttu-id="75fc1-273">簡単な 1 つのコンテナーまたは VM で単一の展開の管理に由来します。</span><span class="sxs-lookup"><span data-stu-id="75fc1-273">The simplicity comes from managing a single deployment in a single container or VM.</span></span>

![](./media/image5-13.png)

<span data-ttu-id="75fc1-274">5 X の図に示すように、複数のコンポーネント/ライブラリまたは各コンテナー内の内部のレイヤーを含めることができます。</span><span class="sxs-lookup"><span data-stu-id="75fc1-274">You can include multiple components/libraries or internal layers within each container, as illustrated in Figure 5-X.</span></span> <span data-ttu-id="75fc1-275">しかし、次のコンテナーのプリンシパル*"コンテナーは、1 つと、1 つのプロセスでは*"、モノリシックなパターンは競合する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="75fc1-275">But, following the container principal of *"a container does one thing, and does it in one process*", the monolithic pattern might be a conflict.</span></span>

<span data-ttu-id="75fc1-276">この方法の欠点は、アプリケーションが大きくなっても、拡張を必要とする場合、/は取得されます。</span><span class="sxs-lookup"><span data-stu-id="75fc1-276">The downside of this approach comes if/when the application grows, requiring it to scale.</span></span> <span data-ttu-id="75fc1-277">アプリケーション全体がスケールの場合は本当に問題</span><span class="sxs-lookup"><span data-stu-id="75fc1-277">If the entire application scaled, it's not really a problem.</span></span> <span data-ttu-id="75fc1-278">ただし、ほとんどの場合、アプリケーションのいくつかの部分はスケーリングを必要とするその他のコンポーネントですがチョーク ポイントは、以下を使用します。</span><span class="sxs-lookup"><span data-stu-id="75fc1-278">However, in most cases, a few parts of the application are the choke points requiring scaling, while other components are used less.</span></span>

<span data-ttu-id="75fc1-279">一般的な e コマース例; を使用します。場合に必要なものをスケールは、製品情報コンポーネントです。</span><span class="sxs-lookup"><span data-stu-id="75fc1-279">Using the typical eCommerce example; what you likely need to scale is the product information component.</span></span> <span data-ttu-id="75fc1-280">多くのユーザーは、購入するよりも、製品を参照します。</span><span class="sxs-lookup"><span data-stu-id="75fc1-280">Many more customers browse products than purchase them.</span></span> <span data-ttu-id="75fc1-281">支払パイプラインを使用するより多くの顧客は、バスケットを使用します。</span><span class="sxs-lookup"><span data-stu-id="75fc1-281">More customers use their basket than use the payment pipeline.</span></span> <span data-ttu-id="75fc1-282">少ない顧客は、コメントを追加または、購入履歴を表示します。</span><span class="sxs-lookup"><span data-stu-id="75fc1-282">Fewer customers add comments or view their purchase history.</span></span> <span data-ttu-id="75fc1-283">使用して可能性がありますのみ、コンテンツやマーケティング キャンペーンを管理する必要がある 1 つの領域内の従業員のほんの一部です。</span><span class="sxs-lookup"><span data-stu-id="75fc1-283">And you likely only have a handful of employees, in a single region, that need to manage the content and marketing campaigns.</span></span> <span data-ttu-id="75fc1-284">モノリシックな設計をスケーリングしてすべてのコードを複数回展開します。</span><span class="sxs-lookup"><span data-stu-id="75fc1-284">By scaling the monolithic design, all the code is deployed multiple times.</span></span>

<span data-ttu-id="75fc1-285">小数点以下桁数だけでなくすべての問題が発生しました、1 つのコンポーネントへの変更が必要、アプリケーション全体とすべてのインスタンスの再配置の完了の完全な再テストです。</span><span class="sxs-lookup"><span data-stu-id="75fc1-285">In addition to the scale everything problem, changes to a single component require complete retesting of the entire application, and a complete redeployment of all the instances.</span></span>

<span data-ttu-id="75fc1-286">モノリシックなアプローチは一般的では、多くの組織は、このアーキテクチャ アプローチで開発する.</span><span class="sxs-lookup"><span data-stu-id="75fc1-286">The monolithic approach is common, and many organizations are developing with this architectural approach.</span></span> <span data-ttu-id="75fc1-287">多くがある良い十分な結果の制限をヒット他のユーザー間です。</span><span class="sxs-lookup"><span data-stu-id="75fc1-287">Many are having good enough results, while others are hitting limits.</span></span> <span data-ttu-id="75fc1-288">多くすると、ツールとインフラストラクチャが複雑すぎてサービス指向アーキテクチャ (SOA) をビルドし、アプリが拡張されるまでの必要性が表示しなかったために、このモデルでのアプリケーションが設計されています。</span><span class="sxs-lookup"><span data-stu-id="75fc1-288">Many designed their applications in this model, because the tools and infrastructure were too difficult to build service oriented architectures (SOA), and they didn't see the need - until the app grew.</span></span> <span data-ttu-id="75fc1-289">モノリシックなアプローチの制限が発生する場合は、有効にするコンテナーと microservices をさらに活用することをアプリに分割することと、次の論理手順可能性があります。</span><span class="sxs-lookup"><span data-stu-id="75fc1-289">If you find you're hitting the limits of the monolithic approach, breaking the app up to enable it to better leverage containers and microservices may be the next logical step.</span></span>

![](./media/image5-14.png)

<span data-ttu-id="75fc1-290">Microsoft Azure でモノリシックなアプリケーションの配置を実現できますインスタンスごとに専用の Vm を使用します。</span><span class="sxs-lookup"><span data-stu-id="75fc1-290">Deploying monolithic applications in Microsoft Azure can be achieved using dedicated VMs for each instance.</span></span> <span data-ttu-id="75fc1-291">使用して[Azure VM スケール セット](https://docs.microsoft.com/azure/virtual-machine-scale-sets/)Vm を簡単に拡張することができます。</span><span class="sxs-lookup"><span data-stu-id="75fc1-291">Using [Azure VM Scale Sets](https://docs.microsoft.com/azure/virtual-machine-scale-sets/), you can easily scale the VMs.</span></span> <span data-ttu-id="75fc1-292">[アプリの azure サービス](https://azure.microsoft.com/services/app-service/)モノリシックなアプリケーションを実行し、Vm を管理しなくてもインスタンスを簡単にスケールことができます。</span><span class="sxs-lookup"><span data-stu-id="75fc1-292">[Azure App Services](https://azure.microsoft.com/services/app-service/) can run monolithic applications and easily scale instances without having to manage the VMs.</span></span> <span data-ttu-id="75fc1-293">アプリの azure サービスは、展開を簡略化することも、Docker のコンテナーの単一のインスタンスを実行できます。</span><span class="sxs-lookup"><span data-stu-id="75fc1-293">Azure App Services can run single instances of Docker containers as well, simplifying the deployment.</span></span> <span data-ttu-id="75fc1-294">Docker を使用して、1 つの VM は Docker ホストを配置して、複数のインスタンスを実行できます。</span><span class="sxs-lookup"><span data-stu-id="75fc1-294">Using Docker, you can deploy a single VM as a Docker host, and run multiple instances.</span></span> <span data-ttu-id="75fc1-295">図 5-14 に示すように、Azure の負荷分散装置を使用して、スケールを管理できます。</span><span class="sxs-lookup"><span data-stu-id="75fc1-295">Using the Azure balancer, as shown in the Figure 5-14, you can manage scaling.</span></span>

<span data-ttu-id="75fc1-296">従来の展開方法でさまざまなホストに展開を管理できます。</span><span class="sxs-lookup"><span data-stu-id="75fc1-296">The deployment to the various hosts can be managed with traditional deployment techniques.</span></span> <span data-ttu-id="75fc1-297">などのコマンドで Docker ホストを管理できる**実行 docker**パイプラインを継続的な配信 (CD) などに、手動、またはのオートメーションによってを実行します。</span><span class="sxs-lookup"><span data-stu-id="75fc1-297">The Docker hosts can be managed with commands like **docker run** performed manually, or through automation such as Continuous Delivery (CD) pipelines.</span></span>

### <a name="monolithic-application-deployed-as-a-container"></a><span data-ttu-id="75fc1-298">モノリシックなアプリケーションのコンテナーとして展開</span><span class="sxs-lookup"><span data-stu-id="75fc1-298">Monolithic application deployed as a container</span></span>

<span data-ttu-id="75fc1-299">コンテナーを使用して、単体のアプリケーション展開を管理する利点があります。</span><span class="sxs-lookup"><span data-stu-id="75fc1-299">There are benefits of using containers to manage monolithic application deployments.</span></span> <span data-ttu-id="75fc1-300">コンテナーのインスタンスをスケール、はるかに高速化およびその他の Vm をデプロイするよりも簡単です。</span><span class="sxs-lookup"><span data-stu-id="75fc1-300">Scaling the instances of containers is far faster and easier than deploying additional VMs.</span></span> <span data-ttu-id="75fc1-301">VM スケール セット Vm の拡張を使用している場合でもインスタンスに、時間がかかります。</span><span class="sxs-lookup"><span data-stu-id="75fc1-301">Even when using VM Scale Sets to scale VMs, they take time to instance.</span></span> <span data-ttu-id="75fc1-302">アプリのインスタンスとして展開されると、アプリの構成は、VM の一部として管理します。</span><span class="sxs-lookup"><span data-stu-id="75fc1-302">When deployed as app instances, the configuration of the app is managed as part of the VM.</span></span>

<span data-ttu-id="75fc1-303">Docker images がはるかに高速更新の展開とネットワーク効率的です。</span><span class="sxs-lookup"><span data-stu-id="75fc1-303">Deploying updates as Docker images is far faster and network efficient.</span></span> <span data-ttu-id="75fc1-304">Docker イメージは、通常 (秒単位) の展開の高速で起動します。</span><span class="sxs-lookup"><span data-stu-id="75fc1-304">Docker Images typically start in seconds, speeding rollouts.</span></span> <span data-ttu-id="75fc1-305">発行元と同じくらい簡単設定解除を行う Docker インスタンスは、 **docker stop**コマンド、通常は 1 秒未満で完了します。</span><span class="sxs-lookup"><span data-stu-id="75fc1-305">Tearing down a Docker instance is as easy as issuing a **docker stop** command, typically completing in less than a second.</span></span>

<span data-ttu-id="75fc1-306">コンテナーは、本質的にデザインを変更可能なは、することはありませんで済む破損している仮想マシンについて心配する更新スクリプトをディスク上のいくつかの特定の構成またはファイルの残りのアカウントを忘れた可能性があります。</span><span class="sxs-lookup"><span data-stu-id="75fc1-306">As containers are inherently immutable by design, you never need to worry about corrupted VMs, whereas update scripts might forget to account for some specific configuration or file left on disk.</span></span>

<span data-ttu-id="75fc1-307">モノリシック アプリケーションにとって有益な Docker、モノリシック アプリケーションをスケールできる sub システムに分割することは、開発し、個別に展開されている可能性があります microservices の領域へのエントリ ポイントします。</span><span class="sxs-lookup"><span data-stu-id="75fc1-307">While monolithic apps can benefit from Docker, breaking up the monolithic application into sub systems which can be scaled, developed and deployed individually may be your entry point into the realm of microservices.</span></span>

> ### <a name="references--common-web-architectures"></a><span data-ttu-id="75fc1-308">参照: 一般的な Web アーキテクチャ</span><span class="sxs-lookup"><span data-stu-id="75fc1-308">References – Common Web Architectures</span></span>
> - <span data-ttu-id="75fc1-309">**クリーン アーキテクチャ**</span><span class="sxs-lookup"><span data-stu-id="75fc1-309">**The Clean Architecture**</span></span>  
> <span data-ttu-id="75fc1-310"><https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html></span><span class="sxs-lookup"><span data-stu-id="75fc1-310"><https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html></span></span>
> - <span data-ttu-id="75fc1-311">**タマネギ アーキテクチャ**</span><span class="sxs-lookup"><span data-stu-id="75fc1-311">**The Onion Architecture**</span></span>  
> <span data-ttu-id="75fc1-312"><http://jeffreypalermo.com/blog/the-onion-architecture-part-1/></span><span class="sxs-lookup"><span data-stu-id="75fc1-312"><http://jeffreypalermo.com/blog/the-onion-architecture-part-1/></span></span>
> - <span data-ttu-id="75fc1-313">**リポジトリ パターン**</span><span class="sxs-lookup"><span data-stu-id="75fc1-313">**The Repository Pattern**</span></span>  
> <span data-ttu-id="75fc1-314"><http://deviq.com/repository-pattern/></span><span class="sxs-lookup"><span data-stu-id="75fc1-314"><http://deviq.com/repository-pattern/></span></span>
> - <span data-ttu-id="75fc1-315">**クリーン アーキテクチャ ソリューションのサンプル**</span><span class="sxs-lookup"><span data-stu-id="75fc1-315">**Clean Architecture Solution Sample**</span></span>  
> <span data-ttu-id="75fc1-316"><https://github.com/ardalis/cleanarchitecture></span><span class="sxs-lookup"><span data-stu-id="75fc1-316"><https://github.com/ardalis/cleanarchitecture></span></span>
> - <span data-ttu-id="75fc1-317">**Microservices 電子書籍を設計** <http://aka.ms/MicroservicesEbook></span><span class="sxs-lookup"><span data-stu-id="75fc1-317">**Architecting Microservices e-book** <http://aka.ms/MicroservicesEbook></span></span>

>[!div class="step-by-step"]
<span data-ttu-id="75fc1-318">[前](アーキテクチャ-principles.md) [次へ] (一般的なのクライアント-側-web-technologies.md)</span><span class="sxs-lookup"><span data-stu-id="75fc1-318">[Previous] (architectural-principles.md) [Next] (common-client-side-web-technologies.md)</span></span>
