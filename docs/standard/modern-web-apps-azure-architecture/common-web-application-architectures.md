---
title: 一般的な Web アプリケーション アーキテクチャ
description: ASP.NET Core および Azure での最新の Web アプリケーションの設計 | 一般的な Web アプリケーション アーキテクチャの探索
author: ardalis
ms.author: wiwagn
ms.date: 01/30/2019
ms.openlocfilehash: 05d696f5cbceaedb35e3e4e97f8c4e89124d43dc
ms.sourcegitcommit: 3500c4845f96a91a438a02ef2c6b4eef45a5e2af
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/07/2019
ms.locfileid: "55826734"
---
# <a name="common-web-application-architectures"></a><span data-ttu-id="aede2-103">一般的な Web アプリケーション アーキテクチャ</span><span class="sxs-lookup"><span data-stu-id="aede2-103">Common web application architectures</span></span>

> <span data-ttu-id="aede2-104">"優れたアーキテクチャが高価であると思うならば、不完全なアーキテクチャを試してみてください。"</span><span class="sxs-lookup"><span data-stu-id="aede2-104">"If you think good architecture is expensive, try bad architecture."</span></span>  
> <span data-ttu-id="aede2-105">_- Brian Foote および Joseph Yoder_</span><span class="sxs-lookup"><span data-stu-id="aede2-105">_- Brian Foote and Joseph Yoder_</span></span>

<span data-ttu-id="aede2-106">従来の .NET アプリケーションのほとんどは、実行可能ファイルに対応する単一のユニットとして、または 1 つの IIS appdomain 内で実行される単一の Web アプリケーションとして展開されます。</span><span class="sxs-lookup"><span data-stu-id="aede2-106">Most traditional .NET applications are deployed as single units corresponding to an executable or a single web application running within a single IIS appdomain.</span></span> <span data-ttu-id="aede2-107">これは最も簡単な展開モデルであり、多くの内部的アプリケーションおよび小さなパブリック アプリケーションに適切に対応します。</span><span class="sxs-lookup"><span data-stu-id="aede2-107">This is the simplest deployment model and serves many internal and smaller public applications very well.</span></span> <span data-ttu-id="aede2-108">ただし、このように単位ユニットとして展開されても、重要なビジネス アプリケーションの大部分は複数のレイヤーへの論理的な分離から恩恵を受けます。</span><span class="sxs-lookup"><span data-stu-id="aede2-108">However, even given this single unit of deployment, most non-trivial business applications benefit from some logical separation into several layers.</span></span>

## <a name="what-is-a-monolithic-application"></a><span data-ttu-id="aede2-109">モノリシック アプリケーションとは?</span><span class="sxs-lookup"><span data-stu-id="aede2-109">What is a monolithic application?</span></span>

<span data-ttu-id="aede2-110">モノリシック アプリケーションは、そのビヘイビアーの観点から見ると、完全な自己独立型のアプリケーションです。</span><span class="sxs-lookup"><span data-stu-id="aede2-110">A monolithic application is one that is entirely self-contained, in terms of its behavior.</span></span> <span data-ttu-id="aede2-111">このアプリケーションは、操作の実行中に他のサービスまたはデータ ストアとやり取りすることがありますが、アプリケーションのビヘイビアーの中核を成す部分は独自のプロセス内で実行され、通常はアプリケーション全体が単一ユニットとして展開されます。</span><span class="sxs-lookup"><span data-stu-id="aede2-111">It may interact with other services or data stores in the course of performing its operations, but the core of its behavior runs within its own process and the entire application is typically deployed as a single unit.</span></span> <span data-ttu-id="aede2-112">このようなアプリケーションを水平方向にスケーリングする必要がある場合、通常は、アプリケーション全体を複数のサーバーまたは仮想マシンに複製します。</span><span class="sxs-lookup"><span data-stu-id="aede2-112">If such an application needs to scale horizontally, typically the entire application is duplicated across multiple servers or virtual machines.</span></span>

## <a name="all-in-one-applications"></a><span data-ttu-id="aede2-113">オールインワン アプリケーション</span><span class="sxs-lookup"><span data-stu-id="aede2-113">All-in-one applications</span></span>

<span data-ttu-id="aede2-114">アプリケーション アーキテクチャ用の最小限のプロジェクト数は 1 となります。</span><span class="sxs-lookup"><span data-stu-id="aede2-114">The smallest possible number of projects for an application architecture is one.</span></span> <span data-ttu-id="aede2-115">このアーキテクチャでは、アプリケーションのロジック全体が単一のプロジェクトに含められ、単一のアセンブリにコンパイルされ、単一ユニットとして展開されます。</span><span class="sxs-lookup"><span data-stu-id="aede2-115">In this architecture, the entire logic of the application is contained in a single project, compiled to a single assembly, and deployed as a single unit.</span></span>

<span data-ttu-id="aede2-116">新しい ASP.NET Core プロジェクトは、Visual Studio またはコマンド ラインのいずれで作成されたかに関係なく、簡単な "オールインワン" モノシリックとして開始されます。</span><span class="sxs-lookup"><span data-stu-id="aede2-116">A new ASP.NET Core project, whether created in Visual Studio or from the command line, starts out as a simple "all-in-one" monolith.</span></span> <span data-ttu-id="aede2-117">これには、プレゼンテーション、ビジネス、データ アクセス ロジックなど、アプリケーションのあらゆるビヘイビアーが含まれています。</span><span class="sxs-lookup"><span data-stu-id="aede2-117">It contains all of the behavior of the application, including presentation, business, and data access logic.</span></span> <span data-ttu-id="aede2-118">図 5-1 に、単一プロジェクト アプリのファイル構造を示します。</span><span class="sxs-lookup"><span data-stu-id="aede2-118">Figure 5-1 shows the file structure of a single-project app.</span></span>

![](./media/image5-1.png)

<span data-ttu-id="aede2-119">**図 5-1**</span><span class="sxs-lookup"><span data-stu-id="aede2-119">**Figure 5-1.**</span></span> <span data-ttu-id="aede2-120">単一プロジェクトの ASP.NET Core アプリ。</span><span class="sxs-lookup"><span data-stu-id="aede2-120">A single project ASP.NET Core app.</span></span>

<span data-ttu-id="aede2-121">単一プロジェクトのシナリオでは、フォルダーを使用して懸念事項の分離が実現されます。</span><span class="sxs-lookup"><span data-stu-id="aede2-121">In a single project scenario, separation of concerns is achieved through the use of folders.</span></span> <span data-ttu-id="aede2-122">既定のテンプレートには、Models、Views、および Controllers の MVC パターン責任用の分離フォルダーに加えて、Data および Services 用の追加のフォルダーが含まれています。</span><span class="sxs-lookup"><span data-stu-id="aede2-122">The default template includes separate folders for MVC pattern responsibilities of Models, Views, and Controllers, as well as additional folders for Data and Services.</span></span> <span data-ttu-id="aede2-123">この配置では、プレゼンテーションの詳細は可能な限り Views フォルダーに限定する必要があり、データ アクセス実装の詳細は Data フォルダー内に保持されるクラスに限定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="aede2-123">In this arrangement, presentation details should be limited as much as possible to the Views folder, and data access implementation details should be limited to classes kept in the Data folder.</span></span> <span data-ttu-id="aede2-124">ビジネス ロジックは、Models フォルダーにあるサービスとモデル内に配置する必要があります。</span><span class="sxs-lookup"><span data-stu-id="aede2-124">Business logic should reside in services and classes within the Models folder.</span></span>

<span data-ttu-id="aede2-125">単一プロジェクトのモノリシック ソリューションは簡単なのですが、いくつかの欠点があります。</span><span class="sxs-lookup"><span data-stu-id="aede2-125">Although simple, the single-project monolithic solution has some disadvantages.</span></span> <span data-ttu-id="aede2-126">プロジェクトの規模と複雑さが増大するに従い、ファイルとフォルダーの数も増加し続けます。</span><span class="sxs-lookup"><span data-stu-id="aede2-126">As the project's size and complexity grows, the number of files and folders will continue to grow as well.</span></span> <span data-ttu-id="aede2-127">アルファベット順にグループ化されていない複数のフォルダーには、ユーザー インターフェイス (UI) の懸念事項 (モデル、ビュー、コントローラー) が存在します。</span><span class="sxs-lookup"><span data-stu-id="aede2-127">User interface (UI) concerns (models, views, controllers) reside in multiple folders, which aren't grouped together alphabetically.</span></span> <span data-ttu-id="aede2-128">この問題は、Filters や ModelBinders などの UI レベル構造が独自のフォルダーに追加される場合にのみ深刻になります。</span><span class="sxs-lookup"><span data-stu-id="aede2-128">This issue only gets worse when additional UI-level constructs, such as Filters or ModelBinders, are added in their own folders.</span></span> <span data-ttu-id="aede2-129">ビジネス ロジックは Models フォルダーと Services フォルダーに分散され、どのフォルダーのどのクラスが他のどれに依存すべきかは明示されません。</span><span class="sxs-lookup"><span data-stu-id="aede2-129">Business logic is scattered between the Models and Services folders, and there's no clear indication of which classes in which folders should depend on which others.</span></span> <span data-ttu-id="aede2-130">プロジェクト レベルでのこの編成不足は、[スパゲティ コード](https://deviq.com/spaghetti-code/)の原因となることがよくあります。</span><span class="sxs-lookup"><span data-stu-id="aede2-130">This lack of organization at the project level frequently leads to [spaghetti code](https://deviq.com/spaghetti-code/).</span></span>

<span data-ttu-id="aede2-131">これらの問題に対処するために、アプリケーションは多くの場合、マルチ プロジェクト ソリューションに展開されます。ここで、各プロジェクトは、アプリケーションの特定の_レイヤー_ に配置されているとみなされます。</span><span class="sxs-lookup"><span data-stu-id="aede2-131">To address these issues, applications often evolve into multi-project solutions, where each project is considered to reside in a particular _layer_ of the application.</span></span>

## <a name="what-are-layers"></a><span data-ttu-id="aede2-132">レイヤーとは?</span><span class="sxs-lookup"><span data-stu-id="aede2-132">What are layers?</span></span>

<span data-ttu-id="aede2-133">アプリケーションの複雑さが増すにつれて、その複雑さを管理することが必要です。その方法の 1 つが、アプリケーションをその責任や懸念事項に従って分割するというものです。</span><span class="sxs-lookup"><span data-stu-id="aede2-133">As applications grow in complexity, one way to manage that complexity is to break up the application according to its responsibilities or concerns.</span></span> <span data-ttu-id="aede2-134">この方法は懸念事項の分離の原則に従って実施されます。また、この方法を使用すれば、特定の機能が実装されている場所を開発者が容易に見つけられるように、増大するコードベースを常に整理された状態に維持することができます。</span><span class="sxs-lookup"><span data-stu-id="aede2-134">This follows the separation of concerns principle, and can help keep a growing codebase organized so that developers can easily find where certain functionality is implemented.</span></span> <span data-ttu-id="aede2-135">ただし、レイヤー化されたアーキテクチャには、単なるコード編成に勝る利点が複数あります。</span><span class="sxs-lookup"><span data-stu-id="aede2-135">Layered architecture offers a number of advantages beyond just code organization, though.</span></span>

<span data-ttu-id="aede2-136">コードをレイヤーに編成することにより、よく使われる下位機能をアプリケーション全体で再利用できるようになります。</span><span class="sxs-lookup"><span data-stu-id="aede2-136">By organizing code into layers, common low-level functionality can be reused throughout the application.</span></span> <span data-ttu-id="aede2-137">この再利用を行うと、コードをほとんど記述する必要がなくなり、[DRY (don't repeat yourself) 原則](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself)に従って単一の実装でアプリケーションを標準化できるようになるので、便利です。</span><span class="sxs-lookup"><span data-stu-id="aede2-137">This reuse is beneficial because it means less code needs to be written and because it can allow the application to standardize on a single implementation, following the [don't repeat yourself (DRY)](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) principle.</span></span>

<span data-ttu-id="aede2-138">レイヤー化されたアーキテクチャの場合、アプリケーションではレイヤー間のやり取りに対して制限を加えることができます。</span><span class="sxs-lookup"><span data-stu-id="aede2-138">With a layered architecture, applications can enforce restrictions on which layers can communicate with other layers.</span></span> <span data-ttu-id="aede2-139">この制限を利用することで、カプセル化を容易に実現できます。</span><span class="sxs-lookup"><span data-stu-id="aede2-139">This helps to achieve encapsulation.</span></span> <span data-ttu-id="aede2-140">レイヤーを変更または置換した場合、そのレイヤーと連携しているその他のレイヤーのみが影響を受けます。</span><span class="sxs-lookup"><span data-stu-id="aede2-140">When a layer is changed or replaced, only those layers that work with it should be impacted.</span></span> <span data-ttu-id="aede2-141">レイヤー同士の依存関係を制限することにより、1 つの変更がアプリケーション全体に影響しないように変更の及ぼす影響を軽減することができます。</span><span class="sxs-lookup"><span data-stu-id="aede2-141">By limiting which layers depend on which other layers, the impact of changes can be mitigated so that a single change doesn't impact the entire application.</span></span>

<span data-ttu-id="aede2-142">レイヤー (およびカプセル化) により、アプリケーション内で機能を容易に置換できるようになります。</span><span class="sxs-lookup"><span data-stu-id="aede2-142">Layers (and encapsulation) make it much easier to replace functionality within the application.</span></span> <span data-ttu-id="aede2-143">たとえば、アプリケーションで最初は永続化のために独自の SQL Server データベースが使用されている場合でも、後でクラウド ベースの永続化の方法または Web API の背後での永続化の方法を使用するように選択することが可能です。</span><span class="sxs-lookup"><span data-stu-id="aede2-143">For example, an application might initially use its own SQL Server database for persistence, but later could choose to use a cloud-based persistence strategy, or one behind a web API.</span></span> <span data-ttu-id="aede2-144">論理層内でアプリケーションによって永続化の実装が適切にカプセル化されている場合、その SQL Server に固有のレイヤーを、同じパブリック インターフェイスを実装する新しいレイヤーに置き換えることが可能です。</span><span class="sxs-lookup"><span data-stu-id="aede2-144">If the application has properly encapsulated its persistence implementation within a logical layer, that SQL Server specific layer could be replaced by a new one implementing the same public interface.</span></span>

<span data-ttu-id="aede2-145">将来的な要件の変更に合わせて実装を交換できることに加えて、アプリケーション レイヤーではテスト目的で実装を容易に交換することもできます。</span><span class="sxs-lookup"><span data-stu-id="aede2-145">In addition to the potential of swapping out implementations in response to future changes in requirements, application layers can also make it easier to swap out implementations for testing purposes.</span></span> <span data-ttu-id="aede2-146">アプリケーションの実際のデータ レイヤーまたは UI レイヤーに対して動作するテストを記述しなくても、これらのレイヤーをテスト時に、要求に対して既知の応答を提供するフェイク実装に置き換えることができます。</span><span class="sxs-lookup"><span data-stu-id="aede2-146">Instead of having to write tests that operate against the real data layer or UI layer of the application, these layers can be replaced at test time with fake implementations that provide known responses to requests.</span></span> <span data-ttu-id="aede2-147">この方法は、アプリケーションの実際のインフラストラクチャに対してテストを実行する場合と比較して、一般的にテストの記述が簡単であり、テストをより迅速に実行することができます。</span><span class="sxs-lookup"><span data-stu-id="aede2-147">This typically makes tests much easier to write and much faster to run when compared to running tests again the application's real infrastructure.</span></span>

<span data-ttu-id="aede2-148">論理的なレイヤー化は、エンタープライズ ソフトウェア アプリケーションでのコード編成を改善するための一般的な手法です。コードをレイヤーに編成する方法には複数あります。</span><span class="sxs-lookup"><span data-stu-id="aede2-148">Logical layering is a common technique for improving the organization of code in enterprise software applications, and there are several ways in which code can be organized into layers.</span></span>

> [!NOTE]
 > <span data-ttu-id="aede2-149">"_レイヤー_" とは、アプリケーション内での論理的な分離を表します。</span><span class="sxs-lookup"><span data-stu-id="aede2-149">_Layers_ represent logical separation within the application.</span></span> <span data-ttu-id="aede2-150">アプリケーション ロジックを個々のサーバーまたはプロセスに物理的に分散するイベントでは、このような個々の物理的展開ターゲットを "_階層_" と呼んでいます。</span><span class="sxs-lookup"><span data-stu-id="aede2-150">In the event that application logic is physically distributed to separate servers or processes, these separate physical deployment targets are referred to as _tiers_.</span></span> <span data-ttu-id="aede2-151">N レイヤー アプリケーションを単一の階層に展開することは可能であり、これは非常に一般的な方法です。</span><span class="sxs-lookup"><span data-stu-id="aede2-151">It's possible, and quite common, to have an N-Layer application that is deployed to a single tier.</span></span>

## <a name="traditional-n-layer-architecture-applications"></a><span data-ttu-id="aede2-152">従来の "N レイヤー" アーキテクチャ アプリケーション</span><span class="sxs-lookup"><span data-stu-id="aede2-152">Traditional "N-Layer" architecture applications</span></span>

<span data-ttu-id="aede2-153">図 5-2 に、レイヤーへのアプリケーション ロジックの最も一般的な編成を示します。</span><span class="sxs-lookup"><span data-stu-id="aede2-153">The most common organization of application logic into layers is shown in Figure 5-2.</span></span>

![](./media/image5-2.png)

<span data-ttu-id="aede2-154">**図 5-2**</span><span class="sxs-lookup"><span data-stu-id="aede2-154">**Figure 5-2.**</span></span> <span data-ttu-id="aede2-155">代表的なアプリケーション レイヤー。</span><span class="sxs-lookup"><span data-stu-id="aede2-155">Typical application layers.</span></span>

<span data-ttu-id="aede2-156">これらのレイヤーは多くの場合、UI、BLL (ビジネス ロジック層)、DAL (データ アクセス層) と略称で表現されます。</span><span class="sxs-lookup"><span data-stu-id="aede2-156">These layers are frequently abbreviated as UI, BLL (Business Logic Layer), and DAL (Data Access Layer).</span></span> <span data-ttu-id="aede2-157">このアーキテクチャを使用する場合、ユーザーは UI レイヤーを介して要求を行います。UI レイヤーは BLL とのみやり取りします。</span><span class="sxs-lookup"><span data-stu-id="aede2-157">Using this architecture, users make requests through the UI layer, which interacts only with the BLL.</span></span> <span data-ttu-id="aede2-158">次に BLL は、データ アクセス要求のために DAL を呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="aede2-158">The BLL, in turn, can call the DAL for data access requests.</span></span> <span data-ttu-id="aede2-159">UI レイヤーは DAL に要求を直接出すことも、他の手段によって永続化と直接やり取りすることもありません。</span><span class="sxs-lookup"><span data-stu-id="aede2-159">The UI layer shouldn't make any requests to the DAL directly, nor should it interact with persistence directly through other means.</span></span> <span data-ttu-id="aede2-160">同様に、BLL は DAL を経由して永続化とやり取りするだけです。</span><span class="sxs-lookup"><span data-stu-id="aede2-160">Likewise, the BLL should only interact with persistence by going through the DAL.</span></span> <span data-ttu-id="aede2-161">この方法では、各レイヤーには独自の既知の責任があります。</span><span class="sxs-lookup"><span data-stu-id="aede2-161">In this way, each layer has its own well-known responsibility.</span></span>

<span data-ttu-id="aede2-162">この従来のレイヤー化アプローチの欠点の 1 つは、コンパイル時の依存関係が上位から下位に向かって適用されるということです。</span><span class="sxs-lookup"><span data-stu-id="aede2-162">One disadvantage of this traditional layering approach is that compile-time dependencies run from the top to the bottom.</span></span> <span data-ttu-id="aede2-163">つまり、UI レイヤーは BLL に依存し、BLL は DAL に依存するということです。</span><span class="sxs-lookup"><span data-stu-id="aede2-163">That is, the UI layer depends on the BLL, which depends on the DAL.</span></span> <span data-ttu-id="aede2-164">このことは、アプリケーション内で、通常、最も重要なロジックを保持する BLL が、データ アクセスの実装の詳細 (およびしばしばデータベースの存在) に依存することを意味します。</span><span class="sxs-lookup"><span data-stu-id="aede2-164">This means that the BLL, which usually holds the most important logic in the application, is dependent on data access implementation details (and often on the existence of a database).</span></span> <span data-ttu-id="aede2-165">このようなアーキテクチャでビジネス ロジックをテストするのは困難なことが多く、テスト データベースが必要となります。</span><span class="sxs-lookup"><span data-stu-id="aede2-165">Testing business logic in such an architecture is often difficult, requiring a test database.</span></span> <span data-ttu-id="aede2-166">次のセクションで示すように、依存関係逆転の原則 (Dependency Inversion principle) を使用すれば、この問題に対処できます。</span><span class="sxs-lookup"><span data-stu-id="aede2-166">The dependency inversion principle can be used to address this issue, as you'll see in the next section.</span></span>

<span data-ttu-id="aede2-167">図 5-3 に、責任 (またはレイヤー) ごとに 3 つのプロジェクトにアプリケーションを分割するソリューションの例を示します。</span><span class="sxs-lookup"><span data-stu-id="aede2-167">Figure 5-3 shows an example solution, breaking the application into three projects by responsibility (or layer).</span></span>

![](./media/image5-3.png)

<span data-ttu-id="aede2-168">**図 5-3**</span><span class="sxs-lookup"><span data-stu-id="aede2-168">**Figure 5-3.**</span></span> <span data-ttu-id="aede2-169">3 つのプロジェクトによる単純なモノリシック アプリケーション。</span><span class="sxs-lookup"><span data-stu-id="aede2-169">A simple monolithic application with three projects.</span></span>

<span data-ttu-id="aede2-170">このアプリケーションでは編成上の目的で複数のプロジェクトを使用していますが、アプリケーションは引き続き単一ユニットとして展開され、そのクライアントは単一の Web アプリとしてこのアプリケーションとやり取りします。</span><span class="sxs-lookup"><span data-stu-id="aede2-170">Although this application uses several projects for organizational purposes, it's still deployed as a single unit and its clients will interact with it as a single web app.</span></span> <span data-ttu-id="aede2-171">これにより、展開プロセスが非常に簡単になります。</span><span class="sxs-lookup"><span data-stu-id="aede2-171">This allows for very simple deployment process.</span></span> <span data-ttu-id="aede2-172">図 5-4 に、そのようなアプリを Azure を使用してホストする場合の方法を示します。</span><span class="sxs-lookup"><span data-stu-id="aede2-172">Figure 5-4 shows how such an app might be hosted using Azure.</span></span>

![](./media/image5-4.png)

<span data-ttu-id="aede2-173">**図 5-4**</span><span class="sxs-lookup"><span data-stu-id="aede2-173">**Figure 5-4.**</span></span> <span data-ttu-id="aede2-174">Azure Web アプリの単純な展開</span><span class="sxs-lookup"><span data-stu-id="aede2-174">Simple deployment of Azure Web App</span></span>

<span data-ttu-id="aede2-175">アプリケーション ニーズの拡大に合わせて、より複雑で堅牢な展開ソリューションが必要な場合があります。</span><span class="sxs-lookup"><span data-stu-id="aede2-175">As application needs grow, more complex and robust deployment solutions may be required.</span></span> <span data-ttu-id="aede2-176">図 5-5 に、追加の機能をサポートするより複雑な展開計画の例を示します。</span><span class="sxs-lookup"><span data-stu-id="aede2-176">Figure 5-5 shows an example of a more complex deployment plan that supports additional capabilities.</span></span>

![](./media/image5-5.png)

<span data-ttu-id="aede2-177">**図 5-5**</span><span class="sxs-lookup"><span data-stu-id="aede2-177">**Figure 5-5.**</span></span> <span data-ttu-id="aede2-178">Azure App Service への Web アプリの公開</span><span class="sxs-lookup"><span data-stu-id="aede2-178">Deploying a web app to an Azure App Service</span></span>

<span data-ttu-id="aede2-179">内部的には、このプロジェクトを責任に基づいて複数のプロジェクトに編成することにより、アプリケーションの保守容易性が向上します。</span><span class="sxs-lookup"><span data-stu-id="aede2-179">Internally, this project's organization into multiple projects based on responsibility improves the maintainability of the application.</span></span>

<span data-ttu-id="aede2-180">このユニットをスケール アップまたはスケール アウトすることで、クラウド ベースのオンデマンドのスケーラビリティを活用することができます。</span><span class="sxs-lookup"><span data-stu-id="aede2-180">This unit can be scaled up or out to take advantage of cloud-based on-demand scalability.</span></span> <span data-ttu-id="aede2-181">スケール アップとは、アプリをホストしているサーバーに CPU、メモリ、ディスク領域などのリソースを追加することを意味します。</span><span class="sxs-lookup"><span data-stu-id="aede2-181">Scaling up means adding additional CPU, memory, disk space, or other resources to the server(s) hosting your app.</span></span> <span data-ttu-id="aede2-182">スケール アウトとは、そのようなサーバーが物理サーバーか、仮想マシンか、コンテナーかに関係なく、サーバーのインスタンスを追加することを意味します。</span><span class="sxs-lookup"><span data-stu-id="aede2-182">Scaling out means adding additional instances of such servers, whether these are physical servers, virtual machines, or containers.</span></span> <span data-ttu-id="aede2-183">アプリが複数のインスタンスでホストされている場合は、ロード バランサーを使用して個々のアプリ インスタンスに要求が割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="aede2-183">When your app is hosted across multiple instances, a load balancer is used to assign requests to individual app instances.</span></span>

<span data-ttu-id="aede2-184">Azure 内で Web アプリケーションをスケーリングする最も簡単な方法は、アプリケーションの App Service プランでスケーリングを手動で構成するというものです。</span><span class="sxs-lookup"><span data-stu-id="aede2-184">The simplest approach to scaling a web application in Azure is to configure scaling manually in the application's App Service Plan.</span></span> <span data-ttu-id="aede2-185">図 5-6 に、アプリを提供しているインスタンスの数を構成する適切な Azure ダッシュボード画面を示します。</span><span class="sxs-lookup"><span data-stu-id="aede2-185">Figure 5-6 shows the appropriate Azure dashboard screen to configure how many instances are serving an app.</span></span>

![](./media/image5-6.png)

<span data-ttu-id="aede2-186">**図 5-6**</span><span class="sxs-lookup"><span data-stu-id="aede2-186">**Figure 5-6.**</span></span> <span data-ttu-id="aede2-187">App での App Service プランによるスケーリング。</span><span class="sxs-lookup"><span data-stu-id="aede2-187">App Service Plan scaling in Azure.</span></span>

## <a name="clean-architecture"></a><span data-ttu-id="aede2-188">クリーン アーキテクチャ</span><span class="sxs-lookup"><span data-stu-id="aede2-188">Clean architecture</span></span>

<span data-ttu-id="aede2-189">依存関係逆転の原則ならびにドメイン駆動設計 (DDD) の原則に従うアプリケーションは、同様のアーキテクチャに到達する傾向があります。</span><span class="sxs-lookup"><span data-stu-id="aede2-189">Applications that follow the Dependency Inversion Principle as well as the Domain-Driven Design (DDD) principles tend to arrive at a similar architecture.</span></span> <span data-ttu-id="aede2-190">このアーキテクチャには長年にわたってさまざまな名称が付けられてきました。</span><span class="sxs-lookup"><span data-stu-id="aede2-190">This architecture has gone by many names over the years.</span></span> <span data-ttu-id="aede2-191">最初の名前の 1 つがヘキサゴナル アーキテクチャ (Hexagonal Architecture) でした。その後に使用された名前がポート アンド アダプター (Ports-and-Adapters) でした。</span><span class="sxs-lookup"><span data-stu-id="aede2-191">One of the first names was Hexagonal Architecture, followed by Ports-and-Adapters.</span></span> <span data-ttu-id="aede2-192">最近では、このアーキテクチャは[オニオン アーキテクチャ](https://jeffreypalermo.com/blog/the-onion-architecture-part-1/)または[クリーン アーキテクチャ](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html)として引用されています。</span><span class="sxs-lookup"><span data-stu-id="aede2-192">More recently, it's been cited as the [Onion Architecture](https://jeffreypalermo.com/blog/the-onion-architecture-part-1/) or [Clean Architecture](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html).</span></span> <span data-ttu-id="aede2-193">後者のクリーン アーキテクチャは、この電子書籍でアーキテクチャの名前として使用されています。</span><span class="sxs-lookup"><span data-stu-id="aede2-193">The latter name, Clean Architecture, is used as the name for this architecture in this e-book.</span></span>

> [!NOTE]
> <span data-ttu-id="aede2-194">クリーン アーキテクチャという用語は、DDD 原則を使用して構築されたアプリケーションにも、DDD 原則を使用して構築されていないアプリケーションにも適用できます。</span><span class="sxs-lookup"><span data-stu-id="aede2-194">The term Clean Architecture can be applied to applications that are built using DDD Principles as well as to those that are not built using DDD.</span></span> <span data-ttu-id="aede2-195">前者の場合、この組み合わせを "クリーン DDD アーキテクチャ" と呼ぶことがあります。</span><span class="sxs-lookup"><span data-stu-id="aede2-195">In the case of the former, this combination may be referred to as "Clean DDD Architecture".</span></span>

<span data-ttu-id="aede2-196">クリーン アーキテクチャでは、ビジネス ロジックとアプリケーション モデルをアプリケーションの中心に配置します。</span><span class="sxs-lookup"><span data-stu-id="aede2-196">Clean architecture puts the business logic and application model at the center of the application.</span></span> <span data-ttu-id="aede2-197">ビジネス ロジックはデータ アクセスまたはその他のインフラストラクチャの懸念事項に依存するのでなく、この依存関係は逆転されます。つまり、インフラストラクチャおよび実装の詳細はアプリケーション コアに依存します。</span><span class="sxs-lookup"><span data-stu-id="aede2-197">Instead of having business logic depend on data access or other infrastructure concerns, this dependency is inverted: infrastructure and implementation details depend on the Application Core.</span></span> <span data-ttu-id="aede2-198">これを達成するには、アプリケーション コア内で抽象化またはインターフェイスを定義し、それらをインフラストラクチャ レイヤーで定義された型によって実装します。</span><span class="sxs-lookup"><span data-stu-id="aede2-198">This is achieved by defining abstractions, or interfaces, in the Application Core, which are then implemented by types defined in the Infrastructure layer.</span></span> <span data-ttu-id="aede2-199">このアーキテクチャを視覚化するための一般的な方法としては、オニオンに似た一連の同心円を使用します。</span><span class="sxs-lookup"><span data-stu-id="aede2-199">A common way of visualizing this architecture is to use a series of concentric circles, similar to an onion.</span></span> <span data-ttu-id="aede2-200">図 5-7 に、このスタイルのアーキテクチャを表現した例を示します。</span><span class="sxs-lookup"><span data-stu-id="aede2-200">Figure 5-7 shows an example of this style of architectural representation.</span></span>

![](./media/image5-7.png)

<span data-ttu-id="aede2-201">**図 5-7**</span><span class="sxs-lookup"><span data-stu-id="aede2-201">**Figure 5-7.**</span></span> <span data-ttu-id="aede2-202">クリーン アーキテクチャ。オニオン ビュー</span><span class="sxs-lookup"><span data-stu-id="aede2-202">Clean Architecture; onion view</span></span>

<span data-ttu-id="aede2-203">この図では、依存関係が最も内側の円に向かっています。</span><span class="sxs-lookup"><span data-stu-id="aede2-203">In this diagram, dependencies flow toward the innermost circle.</span></span> <span data-ttu-id="aede2-204">アプリケーション コアという名前は、この図の中心に位置するところから取ったものです。</span><span class="sxs-lookup"><span data-stu-id="aede2-204">The Application Core takes its name from its position at the core of this diagram.</span></span> <span data-ttu-id="aede2-205">この図から、アプリケーション コアが他のアプリケーション レイヤーに依存していないことがわかります。</span><span class="sxs-lookup"><span data-stu-id="aede2-205">And you can see on the diagram that the Application Core has no dependencies on other application layers.</span></span> <span data-ttu-id="aede2-206">アプリケーションのエンティティとインターフェイスは真中にあります。</span><span class="sxs-lookup"><span data-stu-id="aede2-206">The application's entities and interfaces are at the very center.</span></span> <span data-ttu-id="aede2-207">そのすぐ外側 (まだアプリケーション コア内) は、ドメイン サービスです。ここでは通常、内側の円で定義されたインターフェイスを実装します。</span><span class="sxs-lookup"><span data-stu-id="aede2-207">Just outside, but still in the Application Core, are domain services, which typically implement interfaces defined in the inner circle.</span></span> <span data-ttu-id="aede2-208">アプリケーション コアの外側には、UI レイヤーとインフラストラクチャ レイヤーがあり、これらの両方がアプリケーション コアに依存しますが、相互に依存関係があるとは限りません。</span><span class="sxs-lookup"><span data-stu-id="aede2-208">Outside of the Application Core, both the UI and the Infrastructure layers depend on the Application Core, but not on one another (necessarily).</span></span>

<span data-ttu-id="aede2-209">図 5-8 に、UI とその他のレイヤーの間の依存関係をより正確に反映させた、従来の水平方向レイヤー図を示します。</span><span class="sxs-lookup"><span data-stu-id="aede2-209">Figure 5-8 shows a more traditional horizontal layer diagram that better reflects the dependency between the UI and other layers.</span></span>

![](./media/image5-8.png)

<span data-ttu-id="aede2-210">**図 5-8**</span><span class="sxs-lookup"><span data-stu-id="aede2-210">**Figure 5-8.**</span></span> <span data-ttu-id="aede2-211">クリーン アーキテクチャ。水平方向のレイヤー ビュー</span><span class="sxs-lookup"><span data-stu-id="aede2-211">Clean Architecture; horizontal layer view</span></span>

<span data-ttu-id="aede2-212">破線の矢印はコンパイル時の依存関係を表し、実線の矢印は実行時専用の依存関係を表します。</span><span class="sxs-lookup"><span data-stu-id="aede2-212">Note that the solid arrows represent compile-time dependencies, while the dashed arrow represents a runtime-only dependency.</span></span> <span data-ttu-id="aede2-213">クリーン アーキテクチャを使用する場合、UI レイヤーではコンパイル時にアプリケーション コアで定義されたインターフェイスを操作します。インフラストラクチャ レイヤーで定義された実装型を把握しなくてもよいのが理想的です。</span><span class="sxs-lookup"><span data-stu-id="aede2-213">With the clean architecture, the UI layer works with interfaces defined in the Application Core at compile time, and ideally shouldn't know about the implementation types defined in the Infrastructure layer.</span></span> <span data-ttu-id="aede2-214">ただし、実行時にこれらの実装型は、アプリを実行するために必須となるので、存在する必要があり、また依存関係挿入を介してアプリケーション コアのインターフェイスに接続される必要があります。</span><span class="sxs-lookup"><span data-stu-id="aede2-214">At run time, however, these implementation types are required for the app to execute, so they need to be present and wired up to the Application Core interfaces via dependency injection.</span></span>

<span data-ttu-id="aede2-215">図 5-9 に、これらの推奨事項に従って ASP.NET Core アプリケーションのアーキテクチャを構築した場合の詳細なビューを示します。</span><span class="sxs-lookup"><span data-stu-id="aede2-215">Figure 5-9 shows a more detailed view of an ASP.NET Core application's architecture when built following these recommendations.</span></span>

![ASPNET コア アーキテクチャ](./media/image5-9.png)

<span data-ttu-id="aede2-217">**図 5-9**</span><span class="sxs-lookup"><span data-stu-id="aede2-217">**Figure 5-9.**</span></span> <span data-ttu-id="aede2-218">クリーン アーキテクチャに基づく ASP.NET Core アーキテクチャの図。</span><span class="sxs-lookup"><span data-stu-id="aede2-218">ASP.NET Core architecture diagram following Clean Architecture.</span></span>

<span data-ttu-id="aede2-219">アプリケーション コアはインフラストラクチャに依存していないので、このレイヤーを対象にした自動化された単体テストを記述するのは非常に簡単です。</span><span class="sxs-lookup"><span data-stu-id="aede2-219">Because the Application Core doesn't depend on Infrastructure, it's very easy to write automated unit tests for this layer.</span></span> <span data-ttu-id="aede2-220">図 5-10 と図 5-11 に、このアーキテクチャにテストがどのように適合するのかを示します。</span><span class="sxs-lookup"><span data-stu-id="aede2-220">Figures 5-10 and 5-11 show how tests fit into this architecture.</span></span>

![UnitTestCore](./media/image5-10.png)

<span data-ttu-id="aede2-222">**図 5-10**</span><span class="sxs-lookup"><span data-stu-id="aede2-222">**Figure 5-10.**</span></span> <span data-ttu-id="aede2-223">分離環境でのアプリケーション コアの単体テスト。</span><span class="sxs-lookup"><span data-stu-id="aede2-223">Unit testing Application Core in isolation.</span></span>

![IntegrationTests](./media/image5-11.png)

<span data-ttu-id="aede2-225">**図 5-11**</span><span class="sxs-lookup"><span data-stu-id="aede2-225">**Figure 5-11.**</span></span> <span data-ttu-id="aede2-226">外部依存関係を持つインフラストラクチャ実装の統合テスト。</span><span class="sxs-lookup"><span data-stu-id="aede2-226">Integration testing Infrastructure implementations with external dependencies.</span></span>

<span data-ttu-id="aede2-227">UI レイヤーはインフラストラクチャ プロジェクトで定義された型に対して直接的な依存関係を持たないことから、テストの促進、またはアプリケーション要件の変更への対応を目的として実装を交換することも容易にできます。</span><span class="sxs-lookup"><span data-stu-id="aede2-227">Since the UI layer doesn't have any direct dependency on types defined in the Infrastructure project, it's likewise very easy to swap out implementations, either to facilitate testing or in response to changing application requirements.</span></span> <span data-ttu-id="aede2-228">ASP.NET Core には依存関係挿入の使用とサポートが組み込まれているので、このアーキテクチャは重要なモノリシック アプリケーションを構築する方法として最適です。</span><span class="sxs-lookup"><span data-stu-id="aede2-228">ASP.NET Core's built-in use of and support for dependency injection makes this architecture the most appropriate way to structure non-trivial monolithic applications.</span></span>

<span data-ttu-id="aede2-229">モノリシック アプリケーションの場合、アプリケーション コア、インフラストラクチャ、UI の各プロジェクトはいずれも単一のアプリケーションとして実行されます。</span><span class="sxs-lookup"><span data-stu-id="aede2-229">For monolithic applications the Application Core, Infrastructure, and UI projects are all run as a single application.</span></span> <span data-ttu-id="aede2-230">ランタイム アプリケーションのアーキテクチャは、図 5-12 のようなものになります。</span><span class="sxs-lookup"><span data-stu-id="aede2-230">The runtime application architecture might look something like Figure 5-12.</span></span>

![ASP.NET Core アーキテクチャ 2](./media/image5-12.png)

<span data-ttu-id="aede2-232">**図 5-12**</span><span class="sxs-lookup"><span data-stu-id="aede2-232">**Figure 5-12.**</span></span> <span data-ttu-id="aede2-233">ASP.NET Core アプリのランタイム アーキテクチャの例。</span><span class="sxs-lookup"><span data-stu-id="aede2-233">A sample ASP.NET Core app's runtime architecture.</span></span>

### <a name="organizing-code-in-clean-architecture"></a><span data-ttu-id="aede2-234">クリーン アーキテクチャ内でのコードの整理</span><span class="sxs-lookup"><span data-stu-id="aede2-234">Organizing code in Clean Architecture</span></span>

<span data-ttu-id="aede2-235">クリーン アーキテクチャでは、各プロジェクトが明確な責任を担っています。</span><span class="sxs-lookup"><span data-stu-id="aede2-235">In a Clean Architecture solution, each project has clear responsibilities.</span></span> <span data-ttu-id="aede2-236">そのため、各プロジェクトにはそれぞれ特定の型が属しており、該当するプロジェクトではこれらの型に対応するフォルダーを頻繁に確認できます。</span><span class="sxs-lookup"><span data-stu-id="aede2-236">As such, certain types belong in each project and you'll frequently find folders corresponding to these types in the appropriate project.</span></span>

<span data-ttu-id="aede2-237">アプリケーション コアでは、エンティティ、サービス、およびインターフェイスが含まれるビジネス モデルを保持します。</span><span class="sxs-lookup"><span data-stu-id="aede2-237">The Application Core holds the business model, which includes entities, services, and interfaces.</span></span> <span data-ttu-id="aede2-238">これらのインターフェイスには、データ アクセス、ファイル システム アクセス、ネットワーク呼び出しなどのインフラストラクチャを使用して実行される操作のための抽象化が含まれます。このレイヤーで定義されたサービスまたはインターフェイスは場合によって、UI またはインフラストラクチャに対して依存関係を持たない非エンティティ型を操作する必要があります。</span><span class="sxs-lookup"><span data-stu-id="aede2-238">These interfaces include abstractions for operations that will be performed using Infrastructure, such as data access, file system access, network calls, etc. Sometimes services or interfaces defined at this layer will need to work with non-entity types that have no dependencies on UI or Infrastructure.</span></span> <span data-ttu-id="aede2-239">これらは単純なデータ転送オブジェクト (DTO) として定義することができます。</span><span class="sxs-lookup"><span data-stu-id="aede2-239">These can be defined as simple Data Transfer Objects (DTOs).</span></span>

### <a name="application-core-types"></a><span data-ttu-id="aede2-240">アプリケーション コアの種類</span><span class="sxs-lookup"><span data-stu-id="aede2-240">Application Core types</span></span>

- <span data-ttu-id="aede2-241">エンティティ (永続化されたビジネス モデル クラス)</span><span class="sxs-lookup"><span data-stu-id="aede2-241">Entities (business model classes that are persisted)</span></span>
- <span data-ttu-id="aede2-242">インターフェイス</span><span class="sxs-lookup"><span data-stu-id="aede2-242">Interfaces</span></span>
- <span data-ttu-id="aede2-243">Services</span><span class="sxs-lookup"><span data-stu-id="aede2-243">Services</span></span>
- <span data-ttu-id="aede2-244">DTO</span><span class="sxs-lookup"><span data-stu-id="aede2-244">DTOs</span></span>

<span data-ttu-id="aede2-245">インフラストラクチャ プロジェクトには、通常、データ アクセス実装が含まれます。</span><span class="sxs-lookup"><span data-stu-id="aede2-245">The Infrastructure project typically includes data access implementations.</span></span> <span data-ttu-id="aede2-246">代表的な ASP.NET Core Web アプリケーションの場合、これらの実装には Entity Framework (EF) DbContext、定義済みの任意の EF Core `Migration` オブジェクト、およびデータ アクセス実装クラスが含まれます。</span><span class="sxs-lookup"><span data-stu-id="aede2-246">In a typical ASP.NET Core web application, these implementations include the Entity Framework (EF) DbContext, any EF Core `Migration` objects that have been defined, and data access implementation classes.</span></span> <span data-ttu-id="aede2-247">データ アクセス実装コードを抽象化するには、[リポジトリ デザイン パターン](https://deviq.com/repository-pattern/)を使用するのが最も一般的な方法です。</span><span class="sxs-lookup"><span data-stu-id="aede2-247">The most common way to abstract data access implementation code is through the use of the [Repository design pattern](https://deviq.com/repository-pattern/).</span></span>

<span data-ttu-id="aede2-248">データ アクセス実装に加えて、インフラストラクチャ プロジェクトにはインフラストラクチャの懸念事項とやり取りする必要があるサービスの実装を含める必要があります。</span><span class="sxs-lookup"><span data-stu-id="aede2-248">In addition to data access implementations, the Infrastructure project should contain implementations of services that must interact with infrastructure concerns.</span></span> <span data-ttu-id="aede2-249">これらのサービスではアプリケーション コアで定義されているインターフェイスを実装する必要があります。そのため、インフラストラクチャにはアプリケーション コア プロジェクトへの参照を含める必要があります。</span><span class="sxs-lookup"><span data-stu-id="aede2-249">These services should implement interfaces defined in the Application Core, and so Infrastructure should have a reference to the Application Core project.</span></span>

### <a name="infrastructure-types"></a><span data-ttu-id="aede2-250">インフラストラクチャの種類</span><span class="sxs-lookup"><span data-stu-id="aede2-250">Infrastructure types</span></span>

- <span data-ttu-id="aede2-251">EF Core 型 (`DbContext`、`Migration`)</span><span class="sxs-lookup"><span data-stu-id="aede2-251">EF Core types (`DbContext`, `Migration`)</span></span>
- <span data-ttu-id="aede2-252">データ アクセス実装型 (リポジトリ)</span><span class="sxs-lookup"><span data-stu-id="aede2-252">Data access implementation types (Repositories)</span></span>
- <span data-ttu-id="aede2-253">インフラストラクチャに固有のサービス (`FileLogger` や `SmtpNotifier` など)</span><span class="sxs-lookup"><span data-stu-id="aede2-253">Infrastructure-specific services (for example, `FileLogger` or `SmtpNotifier`)</span></span>

<span data-ttu-id="aede2-254">ASP.NET Core MVC アプリケーション内のユーザー インターフェイス レイヤーは、アプリケーションのエントリ ポイントです。</span><span class="sxs-lookup"><span data-stu-id="aede2-254">The user interface layer in an ASP.NET Core MVC application is the entry point for the application.</span></span> <span data-ttu-id="aede2-255">このプロジェクトはアプリケーション コア プロジェクトを参照する必要があり、その型はアプリケーション コアで定義されているインターフェイスを介してインフラストラクチャと厳密にやり取りする必要があります。</span><span class="sxs-lookup"><span data-stu-id="aede2-255">This project should reference the Application Core project, and its types should interact with infrastructure strictly through interfaces defined in Application Core.</span></span> <span data-ttu-id="aede2-256">UI レイヤーでは、インフラストラクチャ レイヤー型の直接的なインスタンス化や静的呼び出しを許可すべきではありません。</span><span class="sxs-lookup"><span data-stu-id="aede2-256">No direct instantiation of or static calls to the Infrastructure layer types should be allowed in the UI layer.</span></span>

### <a name="ui-layer-types"></a><span data-ttu-id="aede2-257">UI レイヤーの種類</span><span class="sxs-lookup"><span data-stu-id="aede2-257">UI layer types</span></span>

- <span data-ttu-id="aede2-258">Controllers</span><span class="sxs-lookup"><span data-stu-id="aede2-258">Controllers</span></span>
- <span data-ttu-id="aede2-259">フィルター</span><span class="sxs-lookup"><span data-stu-id="aede2-259">Filters</span></span>
- <span data-ttu-id="aede2-260">Views</span><span class="sxs-lookup"><span data-stu-id="aede2-260">Views</span></span>
- <span data-ttu-id="aede2-261">ViewModels</span><span class="sxs-lookup"><span data-stu-id="aede2-261">ViewModels</span></span>
- <span data-ttu-id="aede2-262">スタートアップ</span><span class="sxs-lookup"><span data-stu-id="aede2-262">Startup</span></span>

<span data-ttu-id="aede2-263">スタートアップ クラスはアプリケーションの構成と、インターフェイスへの実装型の接続とを担当します。これにより、依存関係挿入は実行時に適切に機能します。</span><span class="sxs-lookup"><span data-stu-id="aede2-263">The Startup class is responsible for configuring the application, and for wiring up implementation types to interfaces, allowing dependency injection to work properly at run time.</span></span>

> [!NOTE]
> <span data-ttu-id="aede2-264">UI プロジェクトの Startup.cs ファイル内の ConfigureServices で依存関係挿入を接続するために、プロジェクトはインフラストラクチャ プロジェクトを参照することが必要な場合があります。</span><span class="sxs-lookup"><span data-stu-id="aede2-264">In order to wire up dependency injection in ConfigureServices in the Startup.cs file of the UI project, the project may need to reference the Infrastructure project.</span></span> <span data-ttu-id="aede2-265">この依存関係を排除するには、カスタム DI コンテナーを使用するのが最も簡単な方法です。</span><span class="sxs-lookup"><span data-stu-id="aede2-265">This dependency can be eliminated, most easily by using a custom DI container.</span></span> <span data-ttu-id="aede2-266">このサンプルの目的を考慮すると、UI プロジェクトでインフラストラクチャ プロジェクトを参照できるようにするのが最も簡単な方法です。</span><span class="sxs-lookup"><span data-stu-id="aede2-266">For the purposes of this sample, the simplest approach is to allow the UI project to reference the Infrastructure project.</span></span>

## <a name="monolithic-applications-and-containers"></a><span data-ttu-id="aede2-267">モノリシック アプリケーションとコンテナー</span><span class="sxs-lookup"><span data-stu-id="aede2-267">Monolithic applications and containers</span></span>

<span data-ttu-id="aede2-268">モノリシックに展開された単一の Web アプリケーションまたはサービスを構築し、それをコンテナーとして展開することができます。</span><span class="sxs-lookup"><span data-stu-id="aede2-268">You can build a single and monolithic-deployment based Web Application or Service and deploy it as a container.</span></span> <span data-ttu-id="aede2-269">アプリケーション内では、それはモノリシックとはならずにいくつかのライブラリ、コンポーネント、またはレイヤーに編成される場合があります。</span><span class="sxs-lookup"><span data-stu-id="aede2-269">Within the application, it might not be monolithic but organized into several libraries, components, or layers.</span></span> <span data-ttu-id="aede2-270">外部的には、単一のプロセス、単一の Web アプリケーション、または単一のサービスのような単一のコンテナーです。</span><span class="sxs-lookup"><span data-stu-id="aede2-270">Externally, it's a single container like a single process, single web application, or single service.</span></span>

<span data-ttu-id="aede2-271">このモデルを管理するには、アプリケーションを表す単一のコンテナーを展開します。</span><span class="sxs-lookup"><span data-stu-id="aede2-271">To manage this model, you deploy a single container to represent the application.</span></span> <span data-ttu-id="aede2-272">ロード バランサーを前面に配置してコピーを追加するだけで、スケーリングできます。</span><span class="sxs-lookup"><span data-stu-id="aede2-272">To scale, just add additional copies with a load balancer in front.</span></span> <span data-ttu-id="aede2-273">単一のコンテナーまたは VM で単一の展開を管理することで、このように簡単になります。</span><span class="sxs-lookup"><span data-stu-id="aede2-273">The simplicity comes from managing a single deployment in a single container or VM.</span></span>

![](./media/image5-13.png)

<span data-ttu-id="aede2-274">図 5-13 に示すように、複数のコンポーネント/ライブラリ、または内部レイヤーを各コンテナーに含めることができます。</span><span class="sxs-lookup"><span data-stu-id="aede2-274">You can include multiple components/libraries or internal layers within each container, as illustrated in Figure 5-13.</span></span> <span data-ttu-id="aede2-275">しかし、"_コンテナーは 1 つのことを実行し、それを 1 つのプロセスで実行する_" というコンテナーの原則に従えば、このモノリシック パターンは矛盾する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="aede2-275">But, following the container principle of _"a container does one thing, and does it in one process_", the monolithic pattern might be a conflict.</span></span>

<span data-ttu-id="aede2-276">このアプローチの欠点は、アプリケーションが大きくなり、スケーリングする必要が出てきた場合に顕著になります。</span><span class="sxs-lookup"><span data-stu-id="aede2-276">The downside of this approach comes if/when the application grows, requiring it to scale.</span></span> <span data-ttu-id="aede2-277">アプリケーション全体がスケーリングすれば、実際には問題ではありません。</span><span class="sxs-lookup"><span data-stu-id="aede2-277">If the entire application scales, it's not really a problem.</span></span> <span data-ttu-id="aede2-278">ただし、ほとんどの場合、スケーリングする必要があるネックはアプリケーションの一部であり、他のコンポーネントはそれほど使用されません。</span><span class="sxs-lookup"><span data-stu-id="aede2-278">However, in most cases, a few parts of the application are the choke points requiring scaling, while other components are used less.</span></span>

<span data-ttu-id="aede2-279">一般的な E コマースを例にとると、スケーリングする必要が生じるのは多くの場合、製品情報のコンポーネントです。</span><span class="sxs-lookup"><span data-stu-id="aede2-279">Using the typical eCommerce example, what you likely need to scale is the product information component.</span></span> <span data-ttu-id="aede2-280">製品を購入するユーザーよりも多くのユーザーが製品を参照します。</span><span class="sxs-lookup"><span data-stu-id="aede2-280">Many more customers browse products than purchase them.</span></span> <span data-ttu-id="aede2-281">より多くの顧客が、支払いパイプラインではなくバスケットを使用します。</span><span class="sxs-lookup"><span data-stu-id="aede2-281">More customers use their basket than use the payment pipeline.</span></span> <span data-ttu-id="aede2-282">コメントを追加したり、購入履歴を表示したりする顧客はそれほどいません。</span><span class="sxs-lookup"><span data-stu-id="aede2-282">Fewer customers add comments or view their purchase history.</span></span> <span data-ttu-id="aede2-283">また、単一のリージョンで、コンテンツとマーケティング キャンペーンを管理する必要がある従業員数は多分、ほんの一握りです。</span><span class="sxs-lookup"><span data-stu-id="aede2-283">And you likely only have a handful of employees, in a single region, that need to manage the content and marketing campaigns.</span></span> <span data-ttu-id="aede2-284">モノリシック デザインのスケーリングにより、コード全体は複数回展開されます。</span><span class="sxs-lookup"><span data-stu-id="aede2-284">By scaling the monolithic design, all the code is deployed multiple times.</span></span>

<span data-ttu-id="aede2-285">"すべてをスケーリングする" 問題に加えて、単一のコンポーネントを変更するには、アプリケーション全体を完全に再テストし、すべてのインスタンスを完全に再展開する必要があります。</span><span class="sxs-lookup"><span data-stu-id="aede2-285">In addition to the "scale everything" problem, changes to a single component require complete retesting of the entire application, and a complete redeployment of all the instances.</span></span>

<span data-ttu-id="aede2-286">モノリシック アプローチは一般的であり、多くの組織が、このアーキテクチャ アプローチによって開発を行っています。</span><span class="sxs-lookup"><span data-stu-id="aede2-286">The monolithic approach is common, and many organizations are developing with this architectural approach.</span></span> <span data-ttu-id="aede2-287">多くの組織が十分に良好な結果を収めている一方で、限界に達している組織もあります。</span><span class="sxs-lookup"><span data-stu-id="aede2-287">Many are having good enough results, while others are hitting limits.</span></span> <span data-ttu-id="aede2-288">多くの組織は、このモデルでアプリケーションを設計していました。これは、ツールとインフラストラクチャのせいでサービス指向アーキテクチャ (SOA) の構築が非常に困難だったためと、アプリケーションが大きくなるまで SOA の必要性がわからなかったためです。</span><span class="sxs-lookup"><span data-stu-id="aede2-288">Many designed their applications in this model, because the tools and infrastructure were too difficult to build service-oriented architectures (SOA), and they didn't see the need until the app grew.</span></span> <span data-ttu-id="aede2-289">モノリシック アプローチの限界に達しているとわかった場合は、コンテナーとマイクロサービスを有効活用できるようにアプリを分割することを次の論理的な手順とすることができます。</span><span class="sxs-lookup"><span data-stu-id="aede2-289">If you find you're hitting the limits of the monolithic approach, breaking up the app to enable it to better leverage containers and microservices may be the next logical step.</span></span>

![](./media/image5-14.png)

<span data-ttu-id="aede2-290">Microsoft Azure のモノリシック アプリケーションは、各インスタンスに専用の VM を使用して展開できます。</span><span class="sxs-lookup"><span data-stu-id="aede2-290">Deploying monolithic applications in Microsoft Azure can be achieved using dedicated VMs for each instance.</span></span> <span data-ttu-id="aede2-291">[Azure Virtual Machine Scale Sets](https://docs.microsoft.com/azure/virtual-machine-scale-sets/) を使用すると、VM のスケーリングを簡単に行うことができます。</span><span class="sxs-lookup"><span data-stu-id="aede2-291">Using [Azure Virtual Machine Scale Sets](https://docs.microsoft.com/azure/virtual-machine-scale-sets/), you can easily scale the VMs.</span></span> <span data-ttu-id="aede2-292">[Azure App Service](https://azure.microsoft.com/services/app-service/) では、VM の管理を必要とせずに、モノリシック アプリケーションを実行し、インスタンスを簡単にスケーリングすることができます。</span><span class="sxs-lookup"><span data-stu-id="aede2-292">[Azure App Services](https://azure.microsoft.com/services/app-service/) can run monolithic applications and easily scale instances without having to manage the VMs.</span></span> <span data-ttu-id="aede2-293">Azure App Services では、Docker コンテナーの単一インスタンスも実行できるため、展開が簡単になります。</span><span class="sxs-lookup"><span data-stu-id="aede2-293">Azure App Services can run single instances of Docker containers as well, simplifying the deployment.</span></span> <span data-ttu-id="aede2-294">Docker を使用すれば、1 つの VM を Docker ホストとして展開し、複数のインスタンスを実行できます。</span><span class="sxs-lookup"><span data-stu-id="aede2-294">Using Docker, you can deploy a single VM as a Docker host, and run multiple instances.</span></span> <span data-ttu-id="aede2-295">図 5-14 に示すように、Azure バランサーを使用してスケーリングを管理できます。</span><span class="sxs-lookup"><span data-stu-id="aede2-295">Using the Azure balancer, as shown in the Figure 5-14, you can manage scaling.</span></span>

<span data-ttu-id="aede2-296">さまざまなホストへの展開は、従来の展開手法で管理できます。</span><span class="sxs-lookup"><span data-stu-id="aede2-296">The deployment to the various hosts can be managed with traditional deployment techniques.</span></span> <span data-ttu-id="aede2-297">Docker ホストは、**docker run** などのコマンドを使用して手動で管理するか、継続的デリバリー (CD) パイプラインなどのオートメーションによって管理できます。</span><span class="sxs-lookup"><span data-stu-id="aede2-297">The Docker hosts can be managed with commands like **docker run** performed manually, or through automation such as Continuous Delivery (CD) pipelines.</span></span>

### <a name="monolithic-application-deployed-as-a-container"></a><span data-ttu-id="aede2-298">コンテナーとして展開するモノリシック アプリケーション</span><span class="sxs-lookup"><span data-stu-id="aede2-298">Monolithic application deployed as a container</span></span>

<span data-ttu-id="aede2-299">コンテナーを使用してモノリシック アプリケーションの展開を管理することには利点があります。</span><span class="sxs-lookup"><span data-stu-id="aede2-299">There are benefits of using containers to manage monolithic application deployments.</span></span> <span data-ttu-id="aede2-300">コンテナーのインスタンスをスケーリングする処理は、追加の VM を展開するよりもはるかに高速で簡単です。</span><span class="sxs-lookup"><span data-stu-id="aede2-300">Scaling the instances of containers is far faster and easier than deploying additional VMs.</span></span> <span data-ttu-id="aede2-301">仮想マシン スケール セットを使用して VM をスケーリングする場合も、インスタンス化には時間がかかります。</span><span class="sxs-lookup"><span data-stu-id="aede2-301">Even when using virtual machine scale sets to scale VMs, they take time to instance.</span></span> <span data-ttu-id="aede2-302">アプリのインスタンスとして展開する場合、アプリの構成は VM の一部として管理されます。</span><span class="sxs-lookup"><span data-stu-id="aede2-302">When deployed as app instances, the configuration of the app is managed as part of the VM.</span></span>

<span data-ttu-id="aede2-303">更新プログラムを Docker イメージとして展開する方がはるかに高速で、ネットワークの効率が高くなります。</span><span class="sxs-lookup"><span data-stu-id="aede2-303">Deploying updates as Docker images is far faster and network efficient.</span></span> <span data-ttu-id="aede2-304">通常、Docker イメージは秒単位で起動するので、ロールアウトが高速になります。</span><span class="sxs-lookup"><span data-stu-id="aede2-304">Docker Images typically start in seconds, speeding rollouts.</span></span> <span data-ttu-id="aede2-305">Docker インスタンスの破棄は、`docker stop` コマンドの発行と同じくらい簡単で、通常は 1 秒未満で完了します。</span><span class="sxs-lookup"><span data-stu-id="aede2-305">Tearing down a Docker instance is as easy as issuing a `docker stop` command, typically completing in less than a second.</span></span>

<span data-ttu-id="aede2-306">コンテナーは本質的に設計上、変更不可であるため、VM の破損について心配する必要はありません。一方、更新スクリプトではディスク上に残された特定の構成またはファイルが考慮されない場合があります。</span><span class="sxs-lookup"><span data-stu-id="aede2-306">As containers are inherently immutable by design, you never need to worry about corrupted VMs, whereas update scripts might forget to account for some specific configuration or file left on disk.</span></span>

<span data-ttu-id="aede2-307">Docker コンテナーは、単純な Web アプリケーションのモノリシックな展開に使用できます。</span><span class="sxs-lookup"><span data-stu-id="aede2-307">You can use Docker containers for monolithic deployment of simpler web applications.</span></span> <span data-ttu-id="aede2-308">これにより継続的な統合と継続的な展開のパイプラインが向上し、展開から実稼働を成功に導くのために役立ちます。</span><span class="sxs-lookup"><span data-stu-id="aede2-308">This improves continuous integration and continuous deployment pipelines and helps achieve deployment-to-production success.</span></span> <span data-ttu-id="aede2-309">"自分のコンピューターでは動作するのに実稼働環境では動作しないのはなぜ" と悩むことがなくなります。</span><span class="sxs-lookup"><span data-stu-id="aede2-309">No more “It works in my machine, why does it not work in production?”</span></span>

<span data-ttu-id="aede2-310">マイクロサービスベースのアーキテクチャには、多くの利点がありますが、それらの利点のために複雑さが増加します。</span><span class="sxs-lookup"><span data-stu-id="aede2-310">A microservices-based architecture has many benefits, but those benefits come at a cost of increased complexity.</span></span> <span data-ttu-id="aede2-311">場合によっては、コストが利点を上回り、1 つのコンテナーまたは少数のコンテナーで実行されているモノリシック展開アプリケーションの方が有効なことがあります。</span><span class="sxs-lookup"><span data-stu-id="aede2-311">In some cases, the costs outweigh the benefits, so a monolithic deployment application running in a single container or in just a few containers is a better option.</span></span>

<span data-ttu-id="aede2-312">モノリシック アプリケーションを適切に区切られたマイクロサービスに簡単に分解できない場合があります。</span><span class="sxs-lookup"><span data-stu-id="aede2-312">A monolithic application might not be easily decomposable into well-separated microservices.</span></span> <span data-ttu-id="aede2-313">マイクロサービスは相互に独立して起動することで、より回復力のあるアプリケーションを提供します。</span><span class="sxs-lookup"><span data-stu-id="aede2-313">Microservices should work independently of each other to provide a more resilient application.</span></span> <span data-ttu-id="aede2-314">アプリケーションの独立した機能のスライスを提供できない場合、分割しても複雑さが増すだけです。</span><span class="sxs-lookup"><span data-stu-id="aede2-314">If you can't deliver independent feature slices of the application, separating it only adds complexity.</span></span>

<span data-ttu-id="aede2-315">場合によっては、アプリケーションを機能に依存せずに拡張できる必要があります</span><span class="sxs-lookup"><span data-stu-id="aede2-315">An application might not yet need to scale features independently.</span></span> <span data-ttu-id="aede2-316">多くのアプリケーションでは、単一のインスタンスの範囲を超えてスケーリングする必要がある場合、そのインスタンス全体を複製する比較的シンプルなプロセスで行うことができます。</span><span class="sxs-lookup"><span data-stu-id="aede2-316">Many applications, when they need to scale beyond a single instance, can do so through the relatively simple process of cloning that entire instance.</span></span> <span data-ttu-id="aede2-317">アプリケーションを個別のサービスに分割する追加の作業では、アプリケーションのすべてのインスタンスをスケーリングするのがシンプルかつコスト効率に優れている場合、最小限のメリットしか得られません。</span><span class="sxs-lookup"><span data-stu-id="aede2-317">The additional work to separate the application into discrete services provides minimal benefit when scaling full instances of the application is simple and cost-effective.</span></span>

<span data-ttu-id="aede2-318">アプリケーション開発の早い段階では、自然の機能的な境界を明確に把握できないことがあります。</span><span class="sxs-lookup"><span data-stu-id="aede2-318">Early in the development of an application, you might not have a clear idea where the natural functional boundaries are.</span></span> <span data-ttu-id="aede2-319">最小の実行可能な製品を開発したときには、自然な境界がまだ明らかにならないことがあります。</span><span class="sxs-lookup"><span data-stu-id="aede2-319">As you develop a minimum viable product, the natural separation might not yet have emerged.</span></span> <span data-ttu-id="aede2-320">これらの条件の一部は、一時的な可能性があります。</span><span class="sxs-lookup"><span data-stu-id="aede2-320">Some of these conditions might be temporary.</span></span> <span data-ttu-id="aede2-321">最初にモノリシック アプリケーションを作成し、後で一部の個別の機能を開発して、マイクロサービスとして展開する場合があります。</span><span class="sxs-lookup"><span data-stu-id="aede2-321">You might start by creating a monolithic application, and later separate some features to be developed and deployed as microservices.</span></span> <span data-ttu-id="aede2-322">その他の条件はアプリケーションの問題の領域に不可欠な場合があります。つまり、アプリケーションを複数マイクロサービスに分割しない場合があります。</span><span class="sxs-lookup"><span data-stu-id="aede2-322">Other conditions might be essential to the application’s problem space, meaning that the application might never be broken into multiple microservices.</span></span>

<span data-ttu-id="aede2-323">多くの個別のプロセスにアプリケーションを分割すると、オーバーヘッドも発生します。</span><span class="sxs-lookup"><span data-stu-id="aede2-323">Separating an application into many discrete processes also introduces overhead.</span></span> <span data-ttu-id="aede2-324">別のプロセスに機能を分離することで、複雑さが増します。</span><span class="sxs-lookup"><span data-stu-id="aede2-324">There's more complexity in separating features into different processes.</span></span> <span data-ttu-id="aede2-325">通信プロトコルはより複雑になります。</span><span class="sxs-lookup"><span data-stu-id="aede2-325">The communication protocols become more complex.</span></span> <span data-ttu-id="aede2-326">メソッドの呼び出しではなく、サービス間の非同期通信を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="aede2-326">Instead of method calls, you must use asynchronous communications between services.</span></span> <span data-ttu-id="aede2-327">マイクロサービス アーキテクチャに移動するきには、eShopOnContainers アプリケーションのマイクロサービス バージョンに実装される多くの構築ブロックを追加する必要があります。つまり、イベント バスの処理、メッセージの回復性と再試行、最終的な整合性などです。</span><span class="sxs-lookup"><span data-stu-id="aede2-327">As you move to a microservices architecture, you need to add many of the building blocks implemented in the microservices version of the eShopOnContainers application: event bus handling, message resiliency and retries, eventual consistency, and more.</span></span>

<span data-ttu-id="aede2-328">よりシンプルな [eShopOnWeb 参照アプリケーション](https://github.com/dotnet-architecture/eShopOnWeb)では、単一コンテナーのモノリシック コンテナーの使用がサポートされます。</span><span class="sxs-lookup"><span data-stu-id="aede2-328">The much simpler [eShopOnWeb reference application](https://github.com/dotnet-architecture/eShopOnWeb) supports single-container monolithic container usage.</span></span> <span data-ttu-id="aede2-329">このアプリケーションには、従来の MVC ビュー、Web API、Razor Pages が含まれる Web アプリケーションが 1 つ含まれます。</span><span class="sxs-lookup"><span data-stu-id="aede2-329">The application includes one web application that includes traditional MVC views, web APIs, and Razor Pages.</span></span> <span data-ttu-id="aede2-330">`docker-compose build` コマンドと `docker-compose up` コマンドを使用し、ソリューション ルートからこのアプリケーションを起動できます。</span><span class="sxs-lookup"><span data-stu-id="aede2-330">This application can be launched from the solution root using the `docker-compose build` and `docker-compose up` commands.</span></span> <span data-ttu-id="aede2-331">このコマンドでは、Web プロジェクトのルートで検出された `Dockerfile` を使用し、Web インスタンスのコンテナーを構成し、コンテナーを指定のポートで実行します。</span><span class="sxs-lookup"><span data-stu-id="aede2-331">This command configures a container for the web instance, using the `Dockerfile` found in the web project's root, and runs the container on a specified port.</span></span> <span data-ttu-id="aede2-332">GitHub からこのアプリケーションのソースをダウンロードして、ローカルで実行できます。</span><span class="sxs-lookup"><span data-stu-id="aede2-332">You can download the source for this application from GitHub and run it locally.</span></span> <span data-ttu-id="aede2-333">このモノリシック アプリケーションは、コンテナー環境で展開すると有益です。</span><span class="sxs-lookup"><span data-stu-id="aede2-333">Even this monolithic application benefits from being deployed in a container environment.</span></span>

<span data-ttu-id="aede2-334">1 つは、コンテナー化した展開は、アプリケーションのすべてのインスタンスが同じ環境で実行されることを意味します。</span><span class="sxs-lookup"><span data-stu-id="aede2-334">For one, the containerized deployment means that every instance of the application runs in the same environment.</span></span> <span data-ttu-id="aede2-335">これには、初期のテストと開発を行う開発者環境が含まれます。</span><span class="sxs-lookup"><span data-stu-id="aede2-335">This includes the developer environment where early testing and development take place.</span></span> <span data-ttu-id="aede2-336">開発チームは、実稼働環境に一致するコンテナー化した環境でアプリケーションを実行できます。</span><span class="sxs-lookup"><span data-stu-id="aede2-336">The development team can run the application in a containerized environment that matches the production environment.</span></span>

<span data-ttu-id="aede2-337">さらに、コンテナー化アプリケーションは低コストでスケールアウトされます。</span><span class="sxs-lookup"><span data-stu-id="aede2-337">In addition, containerized applications scale out at lower cost.</span></span> <span data-ttu-id="aede2-338">コンテナー環境を使用することで、従来の VM 環境よりも多くのリソースを共有できます。</span><span class="sxs-lookup"><span data-stu-id="aede2-338">Using a container environment enables greater resource sharing than traditional VM environments.</span></span>

<span data-ttu-id="aede2-339">最後に、アプリケーションのコンテナー化は、強制的にビジネス ロジックと記憶域サーバーの間を分離します。</span><span class="sxs-lookup"><span data-stu-id="aede2-339">Finally, containerizing the application forces a separation between the business logic and the storage server.</span></span> <span data-ttu-id="aede2-340">アプリケーションのスケール アウト時には、複数のコンテナーはすべて単一の物理記憶域メディアに移動します。</span><span class="sxs-lookup"><span data-stu-id="aede2-340">As the application scales out, the multiple containers will all rely on a single physical storage medium.</span></span> <span data-ttu-id="aede2-341">通常、この記憶域メディアが SQL Server データベースを実行している高可用性サーバーになります。</span><span class="sxs-lookup"><span data-stu-id="aede2-341">This storage medium would typically be a high-availability server running a SQL Server database.</span></span>

## <a name="docker-support"></a><span data-ttu-id="aede2-342">Docker のサポート</span><span class="sxs-lookup"><span data-stu-id="aede2-342">Docker support</span></span>

<span data-ttu-id="aede2-343">`eShopOnWeb` プロジェクトは、.NET Core で実行されます。</span><span class="sxs-lookup"><span data-stu-id="aede2-343">The `eShopOnWeb` project runs on .NET Core.</span></span> <span data-ttu-id="aede2-344">そのため、Windows ベースまたは Linux ベースのコンテナーで実行できます。</span><span class="sxs-lookup"><span data-stu-id="aede2-344">Therefore, it can run in either Linux-based or Windows-based containers.</span></span> <span data-ttu-id="aede2-345">Docker の展開の場合、SQL Server に同じホストの種類を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="aede2-345">Note that for Docker deployment, you want to use the same host type for SQL Server.</span></span> <span data-ttu-id="aede2-346">Linux ベースのコンテナーは、小さなフット プリントが可能なので優先されます。</span><span class="sxs-lookup"><span data-stu-id="aede2-346">Linux-based containers allow a smaller footprint and are preferred.</span></span>

<span data-ttu-id="aede2-347">Visual Studio 2017 以降を使用すれば、Docker サポートを既存のアプリケーションに追加することができます。その場合、**ソリューション エクスプローラー**でプロジェクトを右クリックし、**[追加]**、**[Docker サポート]** の順に選択します。</span><span class="sxs-lookup"><span data-stu-id="aede2-347">You can use Visual Studio 2017 or later to add Docker support to an existing application by right-clicking on a project in **Solution Explorer** and choosing **Add** > **Docker Support**.</span></span> <span data-ttu-id="aede2-348">これで、必要なファイルが追加され、そのファイルを使用するようにプロジェクトが変更されます。</span><span class="sxs-lookup"><span data-stu-id="aede2-348">This adds the files required and modifies the project to use them.</span></span> <span data-ttu-id="aede2-349">現在の `eShopOnWeb` サンプルには既にこれらのファイルが用意されています。</span><span class="sxs-lookup"><span data-stu-id="aede2-349">The current `eShopOnWeb` sample already has these files in place.</span></span>

<span data-ttu-id="aede2-350">ソリューション レベルの `docker-compose.yml` ファイルには、どのようなイメージをビルドしてどのようなコンテナーを起動するかに関する情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="aede2-350">The solution-level `docker-compose.yml` file contains information about what images to build and what containers to launch.</span></span> <span data-ttu-id="aede2-351">このファイルでは、`docker-compose` コマンドを使用し、複数のアプリケーションを同時に起動できます。</span><span class="sxs-lookup"><span data-stu-id="aede2-351">The file allows you to use the `docker-compose` command to launch multiple applications at the same time.</span></span> <span data-ttu-id="aede2-352">この場合、Web プロジェクトのみが起動されます。</span><span class="sxs-lookup"><span data-stu-id="aede2-352">In this case, it is only launching the Web project.</span></span> <span data-ttu-id="aede2-353">別のデータベース コンテナーなど、依存関係を構成する場合にも使用できます。</span><span class="sxs-lookup"><span data-stu-id="aede2-353">You can also use it to configure dependencies, such as a separate database container.</span></span>

```yml
version: '3'

services:
  eshopwebmvc:
    image: eshopwebmvc
    build:
      context: .
      dockerfile: src/Web/Dockerfile
    environment:
      - ASPNETCORE_ENVIRONMENT=Development
    ports:
      - "5106:5106"

networks:
  default:
    external:
      name: nat
```

<span data-ttu-id="aede2-354">`docker-compose.yml` ファイルは `Web` プロジェクトで `Dockerfile` を参照します。</span><span class="sxs-lookup"><span data-stu-id="aede2-354">The `docker-compose.yml` file references the `Dockerfile` in the `Web` project.</span></span> <span data-ttu-id="aede2-355">`Dockerfile` は、使用される基本コンテナーと、その基本コンテナーでのアプリケーションの構成方法を指定する場合に使います。</span><span class="sxs-lookup"><span data-stu-id="aede2-355">The `Dockerfile` is used to specify which base container will be used and how the application will be configured on it.</span></span> <span data-ttu-id="aede2-356">`Web` の `Dockerfile` は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="aede2-356">The `Web`' `Dockerfile`:</span></span>

```
FROM microsoft/dotnet:2.2-sdk AS build
WORKDIR /app

COPY *.sln .
COPY . .
WORKDIR /app/src/Web
RUN dotnet restore

RUN dotnet publish -c Release -o out

FROM microsoft/dotnet:2.2-aspnetcore-runtime AS runtime
WORKDIR /app
COPY --from=build /app/src/Web/out ./

# Optional: Set this here if not setting it from docker-compose.yml
# ENV ASPNETCORE_ENVIRONMENT Development

ENTRYPOINT ["dotnet", "Web.dll"]
```

### <a name="troubleshooting-docker-problems"></a><span data-ttu-id="aede2-357">Docker に関する問題のトラブルシューティング</span><span class="sxs-lookup"><span data-stu-id="aede2-357">Troubleshooting Docker problems</span></span>

<span data-ttu-id="aede2-358">コンテナー化アプリケーションを実行すると、それを停止するまで実行し続けます。</span><span class="sxs-lookup"><span data-stu-id="aede2-358">Once you run the containerized application, it continues to run until you stop it.</span></span> <span data-ttu-id="aede2-359">`docker ps` コマンドで実行されているコンテナーを表示することができます。</span><span class="sxs-lookup"><span data-stu-id="aede2-359">You can view which containers are running with the `docker ps` command.</span></span> <span data-ttu-id="aede2-360">`docker stop` コマンドを使用して、コンテナー ID を指定すれば、実行中のコンテナーを停止することができます。</span><span class="sxs-lookup"><span data-stu-id="aede2-360">You can stop a running container by using the `docker stop` command and specifying the container ID.</span></span>

<span data-ttu-id="aede2-361">実行中の Docker コンテナーは、開発環境では別の目的で使用を試みる可能性のあるポートにバインドされる場合があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="aede2-361">Note that running Docker containers may be bound to ports you might otherwise try to use in your development environment.</span></span> <span data-ttu-id="aede2-362">実行中の Docker コンテナーと同じポートを使用して、アプリケーションの実行やデバッグを試みると、サーバーがそのポートにバインドできないことを示すエラーが表示されます。</span><span class="sxs-lookup"><span data-stu-id="aede2-362">If you try to run or debug an application using the same port as a running Docker container, you'll get an error stating that the server can't bind to that port.</span></span> <span data-ttu-id="aede2-363">繰り返しになりますが、コンテナーを停止すると、問題は解決します。</span><span class="sxs-lookup"><span data-stu-id="aede2-363">Once again, stopping the container should resolve the issue.</span></span>

<span data-ttu-id="aede2-364">Visual Studio を使用して、ご利用のアプリケーションに Docker サポートを追加する場合は、その際に Docker Desktop が実行されていることを確認してください。</span><span class="sxs-lookup"><span data-stu-id="aede2-364">If you want to add Docker support to your application using Visual Studio, make sure Docker Desktop is running when you do so.</span></span> <span data-ttu-id="aede2-365">ウィザードを起動するときに、Docker Desktop が実行されていない場合、ウィザードは正しく実行されません。</span><span class="sxs-lookup"><span data-stu-id="aede2-365">The wizard won't run correctly if Docker Desktop isn't running when you start the wizard.</span></span> <span data-ttu-id="aede2-366">さらに、ウィザードでは、正しい Docker のサポートを追加するためにコンテナーの現在の選択について説明します。</span><span class="sxs-lookup"><span data-stu-id="aede2-366">In addition, the wizard examines your current container choice to add the correct Docker support.</span></span> <span data-ttu-id="aede2-367">Windows コンテナーのサポートを追加する場合は、Windows コンテナーが構成された状態で Docker Desktop が実行されているときに、ウィザードを実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="aede2-367">If you want to add support for Windows Containers, you need to run the wizard while you have Docker Desktop running with Windows Containers configured.</span></span> <span data-ttu-id="aede2-368">Linux コンテナーのサポートを追加する場合は、Linux コンテナーが構成された状態で Docker が実行されているときに、ウィザードを実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="aede2-368">If you want to add support for Linux containers, run the wizard while you have Docker running with Linux containers configured.</span></span>

### <a name="references--common-web-architectures"></a><span data-ttu-id="aede2-369">参照 – 一般的な Web アーキテクチャ</span><span class="sxs-lookup"><span data-stu-id="aede2-369">References – Common web architectures</span></span>
> - <span data-ttu-id="aede2-370">**クリーン アーキテクチャ**</span><span class="sxs-lookup"><span data-stu-id="aede2-370">**The Clean Architecture**</span></span>  
>   <https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html>
> - <span data-ttu-id="aede2-371">**オニオン アーキテクチャ**</span><span class="sxs-lookup"><span data-stu-id="aede2-371">**The Onion Architecture**</span></span>  
>   <https://jeffreypalermo.com/blog/the-onion-architecture-part-1/>
> - <span data-ttu-id="aede2-372">**リポジトリ パターン**</span><span class="sxs-lookup"><span data-stu-id="aede2-372">**The Repository Pattern**</span></span>  
>   <https://deviq.com/repository-pattern/>
> - <span data-ttu-id="aede2-373">**クリーン アーキテクチャ ソリューションのサンプル**</span><span class="sxs-lookup"><span data-stu-id="aede2-373">**Clean Architecture Solution Sample**</span></span>  
>   <https://github.com/ardalis/cleanarchitecture>
> - <span data-ttu-id="aede2-374">**マイクロサービス電子書籍の設計**</span><span class="sxs-lookup"><span data-stu-id="aede2-374">**Architecting Microservices e-book**</span></span>  
>   <https://aka.ms/MicroservicesEbook>

>[!div class="step-by-step"]
><span data-ttu-id="aede2-375">[前へ](architectural-principles.md)
>[次へ](common-client-side-web-technologies.md)</span><span class="sxs-lookup"><span data-stu-id="aede2-375">[Previous](architectural-principles.md)
[Next](common-client-side-web-technologies.md)</span></span>
