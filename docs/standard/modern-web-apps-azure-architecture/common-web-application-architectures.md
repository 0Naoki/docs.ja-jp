---
title: "一般的な web アプリケーションのアーキテクチャ"
description: "ASP.NET Core と Microsoft Azure での最新の web アプリケーションを設計 |一般的な web アプリケーションのアーキテクチャ"
author: ardalis
ms.author: wiwagn
ms.date: 10/06/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.openlocfilehash: b6236cfab290211f930d6a1987075abeade4fd6d
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/21/2017
---
#<a name="common-web-application-architectures"></a>一般的な Web アプリケーションのアーキテクチャ

> 「アーキテクチャは、高価な良いと思う場合、不適切なアーキテクチャを再試行してください。」  
> _-Brian Foote とジョセフで_

## <a name="summary"></a>概要

従来のほとんどの .NET アプリケーションは、実行可能ファイルまたは 1 つの IIS appdomain 内で実行される単一の web アプリケーションに対応する 1 つの単位として配置されます。 これは最も簡単な展開モデルであり、多くの内部およびより小さな公開アプリケーションをあまり機能です。 ただし、この展開の 1 つの単位も指定すると、最も重要なビジネス アプリケーションを享受によって複数のレイヤーに論理的な分離できます。

## <a name="what-is-a-monolithic-application"></a>モノリシックなアプリケーションとは何ですか。

モノリシックなアプリケーションとは、完全に独立、その動作の観点からです。 これは、可能性があります、その操作を実行中の他のサービスまたはデータ ストアがその動作のコアが、独自のプロセス内で実行し、対話アプリケーション全体、1 つの単位として一般的な展開します。 このようなアプリケーションは、水平方向にスケーリングする必要があります、通常アプリケーション全体は複数のサーバーや仮想マシン間で複製します。

## <a name="all-in-one-applications"></a>1 つのすべてのアプリケーション

アプリケーションのアーキテクチャ用のプロジェクトの最小数は、1 つです。 このアーキテクチャでは、アプリケーションのロジック全体が 1 つのプロジェクトに含まれている、1 つのアセンブリにコンパイルおよび 1 つの単位としてデプロイされています。

新規の ASP.NET Core プロジェクトまたはコマンドラインから Visual Studio で作成したかどうかを起点に単純な「オールインワン」- 一枚岩です。 すべてのプレゼンテーション、ビジネス、およびデータ アクセス ロジックを含む、アプリケーションの動作が含まれています。 図 5-1 は、単一のプロジェクトのアプリのファイル構造を示しています。

**図 5-1。** ASP.NET Core アプリケーションの単一のプロジェクト

![](./media/image5-1.png)

1 つのプロジェクトのシナリオでは、フォルダーを使用して、関心の分離が実現されます。 既定のテンプレートには、データおよびサービス用のモデル、ビュー、およびコント ローラーの MVC パターン責任の個別のフォルダーおよびその他のフォルダーが含まれています。 この配置では、プレゼンテーションの詳細をできるだけ、Views フォルダーに制限する必要がありますので、データ アクセスの実装の詳細は、データ フォルダー内に保持するクラスに限定する必要があります。 ビジネス ロジックは、サービスとモデル フォルダー内のクラス内に存在する必要があります。

、にシンプルですが、単一のプロジェクト モノリシック ソリューションには、いくつかの欠点が含まれて。 プロジェクトの規模と複雑さが増大すると、ファイルとフォルダーの数は、拡張も続行されます。 UI の懸念事項 (モデル、ビュー、コント ローラー) は、グループ分けされていない一緒にアルファベット順に複数のフォルダー内に存在します。 この問題は、フィルターまたは ModelBinders などの他の UI レベル構造が、独自のフォルダーに追加された場合にのみ、悪化を取得します。 ビジネス ロジックが、モデルとサービスのフォルダー間で分散しているし、がありますがはっきりしないうち先となるフォルダー内のクラスがどの他のユーザーに依存する必要があります。 このが不足しているプロジェクト レベルの組織が頻繁につながります[整然としたプログラム](http://deviq.com/spaghetti-code/)です。

これらの問題に対処するために多くの場合にアプリケーションが拡張を特定の配置の各プロジェクトと見なされます、マルチ プロジェクト ソリューション*レイヤー*アプリケーションです。

## <a name="what-are-layers"></a>レイヤーとは

アプリケーションが複雑になるにつれて、その複雑さを管理する方法の 1 つでは、その責任や懸念事項に従って、アプリケーションを分割します。 これにより、懸念原則の分離に依存して整理されるので、開発者は、特定の機能が実装されている簡単に見つけることが増大するコードベースに保つことができます。 複数層アーキテクチャがいくつかのコード組織だけ以外の利点を得られます。

コードをレイヤーに編成、下位の共通の機能をアプリケーション全体で再利用できます。 ドライという原則に従って、1 つの実装を標準化するアプリケーションを許可することができますが、少ないコードを記述する必要がありますので、この再利用の使用をお勧めします。

複数層のアーキテクチャを持つアプリケーションは、他のレイヤーと通信できるレイヤーを制限を適用できます。 これにより、カプセル化を実現するためにします。 レイヤーを変更または置換すると場合、を使用するレイヤーだけが影響する必要があります。 これを制限することによっては、レイヤーは、アプリケーション全体が 1 つの変更の影響を受けるようにする他のレイヤーでは、変更の影響を軽減することができますを依存します。

レイヤー (および encapsulation) をアプリケーション内の機能を置き換えるはるかに簡単にください。 たとえば、アプリケーションでは、永続化ストアの独自の SQL Server データベースを使用して最初に可能性がありますが、後で、クラウド ベースの永続性戦略または web API の背後にある 1 つを使用するように選択。 アプリケーションは、論理層内の永続性の実装をカプセル化正しくは、その SQL Server の特定のレイヤーはでした同じパブリック インターフェイスを実装する新しい 1 置き換え。

実装要件の将来の変更に応答を交換する可能性がある、だけでなくアプリケーション レイヤーも易くなりますをスワップ アウト テスト目的で実装します。 実際のデータ層またはアプリケーションの UI レイヤーに対して動作するテストを記述する代わりでは、要求を正常に応答する偽の実装と、テスト時に、これらのレイヤーを置き換えられます。 これは、通常ためテストの記述をはるかに簡単と非常に速くもう一度アプリケーションの実際のインフラストラクチャのテストを実行中に比較した場合に実行します。

論理の重ね順は、組織のエンタープライズ ソフトウェア アプリケーションで、コードを改善するための一般的な手法といくつかの方法でコードをレイヤーに編成できるようにします。

> [!NOTE]
> *レイヤー*アプリケーション内で論理的な分離を表します。 アプリケーション ロジックは、サーバーまたはプロセスを分離する物理的に分散している別の物理的な配置ターゲットをいいます*階層*です。 可能であればとに 1 つの層に展開されている N 層アプリケーション、非常に一般的であります。

## <a name="traditional-n-layer-architecture-applications"></a>従来の「N 層」アーキテクチャ アプリケーション

アプリケーション ロジックの最も一般的な組織をレイヤー図 5-2 に示すことです。

**図 5-2 です。** 通常、アプリケーション レイヤーです。

![](./media/image5-2.png)

これらのレイヤーは UI として略称 BLL (ビジネス ロジック層) と DAL (データ アクセス層)。 このアーキテクチャを使用して、ユーザーは、BLL とだけ通信する UI レイヤーを通じて要求を行います。 さらに、BLL は、データ アクセスの要求に対して、DAL を呼び出すことができます。 UI レイヤーをしないようにすべての要求、DAL を直接も、他の手段で直接永続化と通信する必要があります。 同様に、BLL は、DAL を使用する永続化とやり取りのみ必要があります。 この方法では、各レイヤーは、独自のよく知られた責任を持ちます。

この従来のレイヤーのアプローチの欠点の 1 つでは、コンパイル時の依存関係が最下位に達して上部から実行します。 つまり、UI レイヤーは、DAL に依存する BLL によって異なります。 つまり、BLL は、通常、アプリケーションで最も重要なロジックを保持して、データ アクセスの実装の詳細に (および多くの場合に、データベースの存在に関する) に依存します。 アーキテクチャではこのようなビジネス ロジックをテストすることは困難ですが、テスト データベースを必要とするがよくあります。 次のセクションで後ほど、この問題に対処依存関係の逆転原則を使用できます。

図 5-3 は、責任 (またはレイヤー) によって、3 つのプロジェクトにアプリケーションを分割する例ソリューションを示しています。

**図 5-3。** 3 つのプロジェクトでの単純なモノリシック アプリケーション。

![](./media/image5-3.png)

このアプリケーションは、組織のためのいくつかのプロジェクトを使用して、単一ユニットとして展開されている、そのクライアントが操作を 1 つの web アプリとして。 これにより、非常に単純な展開プロセスです。 図 5-4 は、このようなアプリでどのようにされている可能性がありますを示しています。 Windows Azure を使用してホストされています。

![](./media/image5-4.png)

**図 5-4 です。** Azure Web アプリの単純な展開

アプリケーション ニーズの拡大に合わせてより複雑で強力な展開ソリューションが必要な場合があります。 図 5-5 は、その他の機能をサポートするより複雑な配置計画の例を示します。

![](./media/image5-5.png)

**図 5-5 です。** Azure App Service に web アプリを展開します。

内部的には、役割に基づいた複数のプロジェクトにこのプロジェクトの組織では、アプリケーションの保守容易性が向上します。

この単位は、クラウド ベースのオンデマンドの拡張性を活用するためにアップまたはアウト スケールことができます。 スケール アップには、アプリをホストしているサーバーに CPU がさらに、メモリ、ディスク領域、またはその他のリソースを追加することを意味します。 スケール アウトはこのようなサーバーの追加インスタンスを追加するこれらは、物理サーバーまたは仮想マシンかどうか。 アプリが複数のインスタンスでホストされている場合、ロード バランサーを使用して個々 のアプリのインスタンスに要求を割り当てます。

Azure で web アプリケーションをスケーリングする最も簡単な方法では、アプリケーションの App Service プランでのスケーリングを手動で構成します。 図 5-6 では、アプリを提供するインスタンスの数を構成する適切な Azure ダッシュ ボード画面を表示します。

![](./media/image5-6.png)

**図 5 ~ 6 です。** App Service プランが Azure でのスケーリングします。

## <a name="clean-architecture"></a>クリーン アーキテクチャ

依存関係の逆転原則とドメイン デザイン (DDD) の原則に従います。 アプリケーションは、同様のアーキテクチャに到着する傾向があります。 このアーキテクチャを長年にわたってさまざまな名称消えます。 名前の 1 つはでした六角アーキテクチャでは、ポートのアダプタを続けてです。 最近では、これは引用したとして、[タマネギ アーキテクチャ](http://jeffreypalermo.com/blog/the-onion-architecture-part-1/)または[クリーン アーキテクチャ](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html)です。 この最後の名前、クリーンのアーキテクチャがあり、この電子ブックでアーキテクチャを記述するための基礎として使用されているです。

> [!NOTE]
> という用語はクリーンなアーキテクチャを DDD を使用して組み込まれていないものについて DDD 原則もを使用して構築されたアプリケーションに適用できます。 前者の場合はこの組み合わせ可能性がありますと呼ばれます「クリーン DDD アーキテクチャ」です。

クリーンなアーキテクチャは、アプリケーションの中心にビジネス ロジックとアプリケーションのモデルを配置します。 データ アクセスやその他のインフラストラクチャ上の問題に依存するビジネス ロジックはなく、この依存関係は、反転: インフラストラクチャと実装の詳細は、アプリケーションのコアに依存します。 これは、インフラストラクチャ レイヤーで定義された型を実装する、アプリケーションのコアに抽象化、またはインターフェイスを定義することによって実現されます。 このアーキテクチャを視覚化する一般的な方法では、一連の同心円、重のようなを使用します。 図 5 X は、このスタイルのアーキテクチャの表現の例を示します。

![](./media/image5-7.png)

**図 5-7 です。** クリーン アーキテクチャです。タマネギ ビュー

この図では、依存関係は、最も内側の円に向けたフローです。 したがって、ことはその名前をこのダイアグラムのコアでの位置から) アプリケーションの主要な依存関係を持たない他のアプリケーション レイヤーでを表示できます。 非常に中心では、アプリケーションのエンティティとのインターフェイスです。 すぐ外側は、アプリケーションのコアの中では、通常内部円で定義されているインターフェイスを実装しているドメイン サービスです。 アプリケーション コアの外部で、ユーザー インターフェイスとインフラストラクチャ レイヤーの両方依存アプリケーション Core ではなく相互 (とは限りません)。

図 5 X には、UI およびその他のレイヤー間の依存関係をより正確に反映される従来の水平方向のレイヤー図が示しています。

![](./media/image5-8.png)

**図 5-8 です。** クリーン アーキテクチャです。水平方向のレイヤーの表示

破線の矢印は、実行時専用の依存関係を表すに対し、実線の矢印がコンパイル時の依存関係を表すことに注意してください。 クリーンなアーキテクチャを使用して、コンパイル時に、アプリケーションのコアに定義されているインターフェイスによる UI レイヤーと理想的には必要がありますが実装の種類の知識定義されていないインフラストラクチャ レイヤーでします。 実行時に、ただし、これらの実装型必要になりますを実行する、アプリのため、存在し、依存関係の挿入を使用してアプリケーションのコア インターフェイスまでワイヤード (有線) である必要があります。

図 5 ~ 9 では、これらの推奨事項に従って構築されたときに、ASP.NET Core アプリケーションのアーキテクチャの詳細なビューを示します。

![ASPNET コア アーキテクチャ](./media/image5-9.png)

**図 5 ~ 9 です。** ASP.NET Core アーキテクチャの図は次のクリーンなアーキテクチャ。

アプリケーションのコアは、インフラストラクチャに依存しないために、非常に簡単に自動化された単体テストをこのレイヤーの書き込みです。 図 5 ~ 10 と 11 5 は、テストをこのアーキテクチャに適合する方法を示しています。

![UnitTestCore](./media/image5-10.png)

**図 5 ~ 10 です。** 単体テスト アプリケーション Core 分離します。

![IntegrationTests](./media/image5-11.png)

**図 5-11。** 統合インフラストラクチャの導入と外部依存関係をテストします。

UI レイヤーにインフラストラクチャ プロジェクトで定義された型の直接的な依存関係があるないために、非常に簡単にテストを容易にするか、実装、またはアプリケーション要件の変更に応答スワップも同様にします。 ASP.NET Core の組み込みの使用と依存関係の挿入のサポートを使用するこのアーキテクチャ構造体の非自明モノリシックなアプリケーションに最適な方法です。

モノリシック アプリケーション アプリケーション Core、インフラストラクチャ、およびユーザー インターフェイスのプロジェクトはすべてとして実行する 1 つのアプリケーションです。 ランタイム アプリケーションのアーキテクチャは、図 5-12 のようなものになります。

![ASPNET コア アーキテクチャ 2](./media/image5-12.png)

**図 5-12 です。** サンプル ASP.NET Core アプリケーションのランタイム アーキテクチャです。

### <a name="organizing-code-in-clean-architecture"></a>クリーン アーキテクチャ内のコードの整理

ソリューションでは、クリーンなアーキテクチャ、各プロジェクトには責任を明確です。 そのため、プロジェクトごとに特定の型が属するし、適切なプロジェクトでこれらの型に対応するフォルダーがよくあります。

アプリケーションのコアでは、エンティティ、サービス、およびインターフェイスが含まれるビジネス モデルを保持します。 これらのインターフェイスには、データ アクセス、ファイル システムへのアクセス、ネットワークの呼び出しなどのインフラストラクチャを使用して実行される操作のための抽象化が含まれます。場合がありますサービスまたはこのレイヤーで定義されているインターフェイスは、UI またはインフラストラクチャへの依存関係を持たない非エンティティ型を処理する必要があります。 これらは、単純なのデータ転送オブジェクト (Dto) として定義することができます。

> ### <a name="application-core-types"></a>コアのアプリケーションの種類
> -   エンティティ (ビジネス モデル クラスは、永続化)
> -   インターフェイス
> -   サービス
> -   Dtos の使用

通常、インフラストラクチャ プロジェクトにはデータ アクセスの実装が含まれます。 通常の ASP.NET Core web アプリケーションに Entity Framework DbContext、定義されている任意の EF コア移行およびデータ アクセスの実装のクラスを含めます。 データ アクセスの実装コードを抽象化する最も一般的な方法を使用すると、[リポジトリ デザイン パターン](http://deviq.com/repository-pattern/)です。

データ アクセスの実装に加えてインフラストラクチャ プロジェクトは、インフラストラクチャの問題と対話する必要がありますサービスの実装を含める必要があります。 これらのサービスがアプリケーションでは、定義されているインターフェイスを実装する必要があります。 そのためインフラストラクチャ必要がありますが、アプリケーションの主要なプロジェクトへの参照。

> ### <a name="infrastructure-types"></a>インフラストラクチャの型
> -   EF 主要な型 (DbContext、移行)
> -   データ アクセスの実装の種類 (リポジトリ)
> -   インフラストラクチャに固有のサービス (FileLogger、SmtpNotifier など)

ASP.NET Core MVC アプリケーションのユーザー インターフェイス レイヤーは、アプリケーションのエントリ ポイントとなるし、ASP.NET Core MVC プロジェクトになります。 このプロジェクトは、アプリケーションの主要なプロジェクトを参照する必要があり、その型が厳密にアプリケーションのコアで定義されているインターフェイスを使用するインフラストラクチャと対話する必要があります。 なし、直接インスタンス化 (または静的の呼び出し)、UI 層インフラストラクチャ レイヤーの種類を許可する必要があります。

> ### <a name="ui-layer-types"></a>UI レイヤーの種類
> -   コント ローラー
> -   フィルター
> -   ビュー
> -   ViewModels
> -   スタートアップ

スタートアップ クラスは、アプリケーションの構成と実装の種類を組み立てる実行時に適切に機能する依存関係の挿入を許可するインターフェイスにします。

> [!NOTE]
> UI プロジェクトの ConfigureServices Startup.cs ファイル内の依存関係の挿入をネットワーク上で、するために、プロジェクトは、インフラストラクチャ プロジェクトを参照する必要があります。 この依存関係を排除できる、最も簡単にカスタム DI コンテナーを使用しています。 このサンプルの目的で、UI プロジェクトのインフラストラクチャ プロジェクト参照を許可するは最も簡単な方法です。

## <a name="monolithic-applications-and-containers"></a>モノリシックなアプリケーションとコンテナー 

単一引用符と展開モノリシック ベースの Web アプリケーションまたはサービスをビルドし、コンテナーとして展開できます。 アプリケーション内で場合がありますモノリシックがいくつかのライブラリ、コンポーネント、またはレイヤーに整理します。 外部から 1 つのプロセス、1 つの web アプリケーションまたは 1 つのサービスと同様に 1 つのコンテナーであります。

このモデルを管理するには、アプリケーションを表すための 1 つのコンテナーを展開します。 前に、ロード バランサーに追加のコピーを追加するだけで、スケールを設定します。 簡単な 1 つのコンテナーまたは VM で単一の展開の管理に由来します。

![](./media/image5-13.png)

5 X の図に示すように、複数のコンポーネント/ライブラリまたは各コンテナー内の内部のレイヤーを含めることができます。 しかし、次のコンテナーのプリンシパル*"コンテナーは、1 つと、1 つのプロセスでは*"、モノリシックなパターンは競合する可能性があります。

この方法の欠点は、アプリケーションが大きくなっても、拡張を必要とする場合、/は取得されます。 アプリケーション全体がスケールの場合は本当に問題 ただし、ほとんどの場合、アプリケーションのいくつかの部分はスケーリングを必要とするその他のコンポーネントですがチョーク ポイントは、以下を使用します。

一般的な e コマース例; を使用します。場合に必要なものをスケールは、製品情報コンポーネントです。 多くのユーザーは、購入するよりも、製品を参照します。 支払パイプラインを使用するより多くの顧客は、バスケットを使用します。 少ない顧客は、コメントを追加または、購入履歴を表示します。 使用して可能性がありますのみ、コンテンツやマーケティング キャンペーンを管理する必要がある 1 つの領域内の従業員のほんの一部です。 モノリシックな設計をスケーリングしてすべてのコードを複数回展開します。

小数点以下桁数だけでなくすべての問題が発生しました、1 つのコンポーネントへの変更が必要、アプリケーション全体とすべてのインスタンスの再配置の完了の完全な再テストです。

モノリシックなアプローチは一般的では、多くの組織は、このアーキテクチャ アプローチで開発する. 多くがある良い十分な結果の制限をヒット他のユーザー間です。 多くすると、ツールとインフラストラクチャが複雑すぎてサービス指向アーキテクチャ (SOA) をビルドし、アプリが拡張されるまでの必要性が表示しなかったために、このモデルでのアプリケーションが設計されています。 モノリシックなアプローチの制限が発生する場合は、有効にするコンテナーと microservices をさらに活用することをアプリに分割することと、次の論理手順可能性があります。

![](./media/image5-14.png)

Microsoft Azure でモノリシックなアプリケーションの配置を実現できますインスタンスごとに専用の Vm を使用します。 使用して[Azure VM スケール セット](https://docs.microsoft.com/azure/virtual-machine-scale-sets/)Vm を簡単に拡張することができます。 [アプリの azure サービス](https://azure.microsoft.com/services/app-service/)モノリシックなアプリケーションを実行し、Vm を管理しなくてもインスタンスを簡単にスケールことができます。 アプリの azure サービスは、展開を簡略化することも、Docker のコンテナーの単一のインスタンスを実行できます。 Docker を使用して、1 つの VM は Docker ホストを配置して、複数のインスタンスを実行できます。 図 5-14 に示すように、Azure の負荷分散装置を使用して、スケールを管理できます。

従来の展開方法でさまざまなホストに展開を管理できます。 などのコマンドで Docker ホストを管理できる**実行 docker**パイプラインを継続的な配信 (CD) などに、手動、またはのオートメーションによってを実行します。

### <a name="monolithic-application-deployed-as-a-container"></a>モノリシックなアプリケーションのコンテナーとして展開

コンテナーを使用して、単体のアプリケーション展開を管理する利点があります。 コンテナーのインスタンスをスケール、はるかに高速化およびその他の Vm をデプロイするよりも簡単です。 VM スケール セット Vm の拡張を使用している場合でもインスタンスに、時間がかかります。 アプリのインスタンスとして展開されると、アプリの構成は、VM の一部として管理します。

Docker images がはるかに高速更新の展開とネットワーク効率的です。 Docker イメージは、通常 (秒単位) の展開の高速で起動します。 発行元と同じくらい簡単設定解除を行う Docker インスタンスは、 **docker stop**コマンド、通常は 1 秒未満で完了します。

コンテナーは、本質的にデザインを変更可能なは、することはありませんで済む破損している仮想マシンについて心配する更新スクリプトをディスク上のいくつかの特定の構成またはファイルの残りのアカウントを忘れた可能性があります。

モノリシック アプリケーションにとって有益な Docker、モノリシック アプリケーションをスケールできる sub システムに分割することは、開発し、個別に展開されている可能性があります microservices の領域へのエントリ ポイントします。

> ### <a name="references--common-web-architectures"></a>参照: 一般的な Web アーキテクチャ
> - **クリーン アーキテクチャ**  
> <https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html>
> - **タマネギ アーキテクチャ**  
> <http://jeffreypalermo.com/blog/the-onion-architecture-part-1/>
> - **リポジトリ パターン**  
> <http://deviq.com/repository-pattern/>
> - **クリーン アーキテクチャ ソリューションのサンプル**  
> <https://github.com/ardalis/cleanarchitecture>
> - **Microservices 電子書籍を設計** <http://aka.ms/MicroservicesEbook>

>[!div class="step-by-step"]
[前](アーキテクチャ-principles.md) [次へ] (一般的なのクライアント-側-web-technologies.md)
