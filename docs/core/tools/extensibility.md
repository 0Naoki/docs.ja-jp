---
title: ".NET Core CLI の拡張モデル"
description: ".NET Core CLI の拡張モデル"
keywords: "CLI, 拡張, カスタム コマンド, .NET Core"
author: blackdwarf
ms.author: mairaw
ms.date: 06/20/2016
ms.topic: article
ms.prod: .net-core
ms.technology: dotnet-cli
ms.devlang: dotnet
ms.assetid: 1bebd25a-120f-48d3-8c25-c89965afcbcd
translationtype: Human Translation
ms.sourcegitcommit: aeb199a9aeb1584570ad2a2942e2f22c75a59616
ms.openlocfilehash: 4223f296224c9b62c88b72f0f643c8b8b6fc9f6b

---

# <a name="net-core-cli-extensibility-model"></a>.NET Core CLI の拡張モデル 

## <a name="overview"></a>概要
このドキュメントは、CLI ツールを拡張する主な方法と、それぞれのツールを動作させるシナリオについて説明します。 ここでは、ツールの利用方法を概説するだけでなく、両方の種類のツールをビルドする方法の簡単なメモを提供します。 

## <a name="how-to-extend-cli-tools"></a>CLI ツールを拡張する方法
CLI ツールは、主に次の 2 つの方法で拡張できます。

1. プロジェクトごとに NuGet パッケージを使用
2. システムのパスを使用

上記で説明した 2 つの拡張メカニズムは、排他的ではありません。両方または一方のみを使用することができます。 どちらを選択するかは、拡張機能で実現しようとしている目標によって大きく異なります。

## <a name="per-project-based-extensibility"></a>各プロジェクト ベースの拡張機能
各プロジェクトのツールは、NuGet パッケージとして配布される[ポータブル コンソール アプリケーション](../deploying/index.md)です。 ツールは、ツールを参照および復元するプロジェクトのコンテキスト内でのみ使用できます。プロジェクトのコンテキストの外部 (たとえば、プロジェクトが含まれているディレクトリの外) での起動は、コマンドを見つけることができないために失敗します。

`project.json` の外部は必要ないため、これらのツールはビルド サーバーにも最適です。 ビルド処理では、ビルドを行うプロジェクトの復元が実行され、ツールが利用可能になります。 F# などの言語プロジェクトも、このカテゴリに入ります。結局、各プロジェクトは 1 つの特定の言語でのみ記述できます。 

最後に、この拡張モデルは、プロジェクトのビルド出力へのアクセス権が必要なツールの作成をサポートします。 たとえば、[ASP.NET](https://www.asp.net/) MVC アプリケーションのさまざまな Razor ビュー ツールが、このカテゴリに分類されます。 

### <a name="consuming-per-project-tools"></a>各プロジェクト ツールの利用
これらのツールを利用するには、`tools` ノードを自分の `project.json` に追加する必要があります。 `tools` ノード内で、ツールが存在するパッケージを参照します。 `dotnet restore` を実行した後、ツールとその依存関係が復元されます。 

実行するためにプロジェクトのビルド出力を読み込む必要があるツールの場合、通常、別の依存関係がプロジェクト ファイル内の標準の依存関係に一覧されています。 つまり、プロジェクトのコードを読み込むツールには、次の 2 つのコンポーネントがあるということです。 

1. "tools" の主な起動元
2. 作業するロジックを含む、さまざまなその他のツール 

なぜ 2 つあるのでしょう。 プロジェクトのビルド出力を読み込む必要があるツールは、動作しているプロジェクトと統合された依存関係グラフを持っている必要があります。 依存関係ビットを追加して、統合されたグラフとしてこれらの依存関係を解決する NuGet を有効にします。 起動元は、場所だけでなく、依存関係ツールのフレームワークについて判断する必要があるために存在しています。 この起動元は、ユーザーが依存関係ツールを指定および検索する、すべてのリダイレクト引数 (`-c``-o`、`-b`) を許可できます。また、複数の依存関係ツールが複数のフレームワーク向けに存在する場合 (すべてを実行、1 つだけを実行など)、任意のポリシーを実装することもできます。一般に、ロジックは必要に応じて 2 つツール間で共有できます。 

単純なツールだけのツールを単純なプロジェクトに追加する例を確認してみましょう。 指定された API の NuGet パッケージを使用して検索できる `dotnet-api-search` というコマンドの例を仮定すると、そのツールを使用するコンソール アプリケーションの `project.json` ファイルは、次のようになります。

```json
{
    "version": "1.0.0",
    "compilationOptions": {
        "emitEntryPoint": true
    },
    "dependencies": {
        "Microsoft.NETCore.App": {
            "type": "platform",
            "version": "1.0.0"
        }
    },
    "tools": {
        "dotnet-api-search": {
            "version": "1.0.0",
            "imports": ["dnxcore50"]
        }
    },
    "frameworks": {
        "netcoreapp1.0": {}
    }
}
```

`tools` ノードは、`dependencies` ノードと同様の方法で構造化されます。 少なくともツールとそのバージョンを含む、パッケージのパッケージ ID が必要です。 上述の例では、`imports` というもう 1 つのステートメントがあることがわかります。 このステートメントは、ツールの復元処理に影響し、ツールが所有しているターゲットのフレームワークだけでなく、`dnxcore50` ターゲットとも互換性があることを示します。 詳細については、「[project.json 参照](project-json.md)」を参照してください。

### <a name="building-tools"></a>ツールのビルド
前述のように、ツールは、単なるポータブル コンソール アプリケーションです。 お客様はコンソール アプリケーションをビルドするように、ツールをビルドします。 ビルドした後、[`dotnet pack`](dotnet-pack.md) コマンドを使用して、コード、その依存関係に関する情報などを含む NuGet パッケージ (nupkg) を作成します。 パッケージ名は、作成者が必要な内容であることがありますが、アプリケーション内 (実際のツール バイナリ) は、`dotnet` がそれを起動できるように、`dotnet-<command>` の規則に準拠している必要があります。 

ツールはポータブル アプリケーションであるため、ツールを利用しているユーザーは、ツールを実行するためにツールをビルドするバージョンの .NET Core ライブラリを所有している必要があります。 ツールを使用し、.NET Core ライブラリ内に含まれない任意のその他の依存関係は、NuGet キャッシュに復元および配置されます。 そのため、ツール全体が、.NET Core ライブラリからのアセンブリ、および NuGet キャッシュからのアセンブリを使用して実行されます。 

このようなツールには、それらのツールを使用するプロジェクトの依存関係グラフから完全に切り離された依存関係グラフがあります。 復元処理では、最初にプロジェクトの依存関係を復元し、その後、各ツールとその依存関係を復元します。 

豊富な例やさまざまな組み合わせを [.NET Core CLI リポジトリ](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestProjects) で見つけることができます。 また、同じリポジトリで[使用されたツールの実装](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestPackages)を確認することもできます。 

実行するためにプロジェクトのビルド出力を読み込むツールのビルドは、少し異なります。 前述したように、これらのツールには、次の 2 つのコンポーネントがあります。

1. ユーザーが起動するディスパッチャー ツール
2. ビルド出力を検索する方法と、操作する内容のロジックを含むフレームワーク固有の依存関係

[Entity Framework (EF)](https://github.com/aspnet/EntityFramework) コマンドおよび [`dotnet test`](dotnet-test.md) コマンドが、この主な例です。 どちらの場合も、`project.json` の `tools` ノードで参照されるツールがあります。このツールが主要なディスパッチャーです。 ユーザーは、コマンドラインでこのツールを起動します。 2 つ目のピースは、プロジェクトの主要な依存関係 (root の依存関係またはフレームワーク固有の依存関係) で指定される依存関係です。 このパッケージには、ツールの実際のロジックが含まれます。 このパッケージは標準の依存関係であるため、プロジェクトの復元処理の一部として復元されます。 

以前の種類のツールとは異なり、これらのツールは、実際にツールを利用するプロジェクトのグラフの一部です。 これは、プロジェクトのコードおよび可能性があるすべてのその依存関係へのアクセス権が必要であるためです。 たとえば、EF ツールは、ツールが必要なコードを検索するアセンブリ (移行など) をスキャンする必要があるため、このアクセス権が必要です。  

この 2 つに分かれたソリューションが存在するもう 1 つの理由は、より洗練された呼び出しモデルを可能にするためです。 ディスク上の特定の成果物を削除する CLI コマンドのほとんど (`dotnet build`、`dotnet publish` など) で、ユーザーが `--output` 引数、`--build-base-path` 引数、または `--configuration` 引数を使用して、別のパスに出力をリダイレクトできるようにします。 たとえば、EF ツールの場合、プロジェクトのビルド出力を検索できるようにするには、`dotnet` ドライバーと `ef` コマンドの*両方*に同じ値の同じ引数を指定する必要があります。 呼び出しモデルでは、ユーザーは任意の引数をディスパッチャー ツールに渡します。これにより、出力ディレクトリでロジックを含む必要なバイナリを検索するために使用できます。 

この手法の例を次の [.NET Core CLI リポジトリ](https://github.com/dotnet/cli)で確認することができます。

* [project.json ファイルの例](https://github.com/dotnet/cli/blob/rel/1.0.0-preview2/TestAssets/DesktopTestProjects/AppWithDirectDependencyDesktopAndPortable/project.json)
* [ディスパッチャーの実装](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestPackages/dotnet-dependency-tool-invoker)
* [フレームワーク固有の依存関係の実装](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestPackages/dotnet-desktop-and-portable)


### <a name="path-based-extensibility"></a>パス ベースの拡張機能
通常、パス ベースの拡張機能は、概念的に複数のプロジェクトに対応するツールが必要な開発用コンピューターに使用されます。 この拡張機能のメカニズムの主なデメリットは、ツールが存在するマシンに関連付けられていることです。 別のコンピューターで拡張機能が必要な場合は、それを展開する必要があります。

このパターンの CLI ツールセットの拡張は、非常に単純です。 [.NET Core CLI の概要](index.md)に関するページにあるように、`dotnet` ドライバーは、`dotnet-<command>` 規則にふさわしい名前が付けられた任意のコマンドを実行することができます。 この既定の解決ロジックは、最初にいくつかの場所をプローブし、最後にシステム パスに取りかかります。 要求されたコマンドがシステム パスに存在し、起動することができるバイナリである場合、`dotnet` ドライバーでそれを起動します。 

オペレーティング システムが実行できるほぼすべてがバイナリです。 Unix システムでは、`chmod +x` によって実行ビット セットがあるすべてを意味します。 Windows では、Windows が実行方法を理解しているすべてのことです。 

例として、`dotnet clean` コマンドの単純な実装を見てみましょう。 このコマンドを実装するには、`bash` を使用します。 このコマンドは、単純に現在のディレクトリ内の `bin/` と `obj/` ディレクトリを削除します。 `--lock` 引数が渡された場合、これは `project.lock.json` ファイルも削除します。 コマンドの全体は次のとおりです。 

```bash
#!/bin/bash

# Delete the bin and obj dirs
rm -rf bin/ obj/

LOCK_FILE=$1
if [[ "$LOCK_FILE" = "--lock" ]]; then
    rm project.lock.json
fi


echo "Cleaning complete..."
```

macOS では、このスクリプトを `dotnet-clean` として保存し、その実行可能ビットを `chmod +x dotnet-clean` に設定します。 これで、コマンド `ln -s dotnet-clean /usr/local/bin/` を使用して、`/usr/local/bin` でこのスクリプトへのシンボリック リンクを作成できます。 これにより、`dotnet clean` 構文を使用して、クリーン コマンドを起動できるようになります。 アプリを作成し、そのアプリで `dotnet build` を実行して、`dotnet clean` を実行し、これをテストできます。 

## <a name="conclusion"></a>まとめ
.NET Core CLI ツールでは、2 つの主な拡張ポイントを許可します。 各プロジェクトのツールはプロジェクトのコンテキスト内に含まれますが、復元によって簡単にインストールできます。 パス ベースのツールは、一般的に単一のコンピューターで使用できるプロジェクト間のツールに適しています。 



<!--HONumber=Nov16_HO3-->


