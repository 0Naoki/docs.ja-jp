---
title: C# の式 - C# 言語のツアー
description: 式、オペランド、および演算子は、C# 言語の構成要素です
ms.date: 11/06/2016
ms.assetid: 20d5eb10-7381-47b9-ad90-f1cc895aa27e
ms.openlocfilehash: 8fa1c5d0464644b26eb457bca8ecaf007c288f42
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/04/2018
ms.locfileid: "33352302"
---
# <a name="expressions"></a>式

*式*は、*オペランド*と*演算子*で構成されます。 式の演算子は、オペランドに適用する演算を表します。 演算子の例として、`+`、`-`、`*`、`/`、および `new` などがあります。 オペランドの例としては、リテラル、フィールド、ローカル変数、式などがあります。

複数の演算子を含む式の場合、演算子の*優先順位*によって各々の演算子が評価される順序が決定されます。 たとえば、式 `x + y * z` の評価は `x + (y * z)` ですが、これは `*` 演算子が `+` 演算子より高い優先順位だからです。

1 つのオペランドが同じ優先順位を持つ 2 つの演算子の間で発生した場合、演算子の*結合性*によって演算が実行される順序が決定されます。

*   代入演算子を除くすべてのバイナリ演算子は、*左からの結合*、つまり演算は左から右に実行されます。 たとえば、`x + y + z` は `(x + y) + z` と評価されます。
*   代入演算子と条件演算子 (`?:`) は*右からの結合*、つまり演算は右から左に実行されます。 たとえば、`x = y = z` は `x = (y = z)` と評価されます。

優先順位と結合性は、かっこを使用して制御することができます。 たとえば、`x + y * z` は最初に `y` と `z` を掛け、そして結果を `x` に足しますが、`(x + y) * z` では最初に `x` と `y` を足してから `z` を掛けます。

ほとんどの演算子は*オーバーロード*できます。 演算子をオーバーロードすると、ユーザー定義演算子の実装を、1 つまたは両方のオペランドがユーザー定義のクラスまたは構造体型である演算子に指定することができます。

以下は C# の演算子をまとめたもので、演算子のカテゴリを優先順位の高い順に記載してあります。 同じカテゴリの演算子は、同じ優先順位を持ちます。 各カテゴリには、そのカテゴリの式の一覧を、その式型の説明と共に示しています。

* 1 次式
    - `x.m`: メンバー アクセス
    - `x(...)`: メソッドおよびデリゲートの呼び出し
    - `x[...]`: 配列アクセスおよびインデクサー アクセス
    - `x++`: 後置インクリメント
    - `x--`: 後置デクリメント
    - `new T(...)`: オブジェクトおよびデリゲートの作成
    - `new T(...){...}`: 初期化子を使用したオブジェクトの作成
    - `new {...}`:  匿名オブジェクト初期化子
    - `new T[...]`: 配列の作成
    - `typeof(T)`: `T` の <xref:System.Type> オブジェクトの取得
    - `checked(x)`: チェック済みコンテキストで式を評価する
    - `unchecked(x)`: 未チェックのコンテキストで式を評価する
    - `default(T)`: `T` 型の既定値の取得
    - `delegate {...}`: 匿名関数 (匿名メソッド)
* 単項
    - `+x`: ID
    - `-x`: 否定
    - `!x`: 論理否定
    - `~x`: ビットごとの否定
    - `++x`: 前置インクリメント
    - `--x`: 前置デクリメント
    - `(T)x`: `x` を明示的に `T` 型に変換
    - `await x`: `x` が完了するのを非同期的に待つ
* 乗法
    - `x * y`: 乗算
    - `x / y`: 除算
    - `x % y`: 剰余
* 加法
    - `x + y`: 加算、文字列の連結、デリゲートの組み合わせ
    - `x – y`: 減算、デリゲートの削除
* シフト
    - `x << y`: 左シフト
    - `x >> y`: 右シフト
* 関係式と型検査
    - `x < y`: より小さい
    - `x > y`: より大きい
    - `x <= y`: 以下
    - `x >= y`: 以上
    - `x is T`: `x` が `T` であれば `true`、そうでなければ `false` を返す
    - `x as T`: `T` として指定された `x` を返すか、`x` が `T` でない場合は `null` を返す
* 等価比較
    - `x == y`: 等しい
    - `x != y`: 等しくない
* 論理 AND
    - `x & y`: 整数のビットごとの AND、ブール型の論理 AND
* 論理 XOR
    - `x ^ y`: 整数のビットごとの XOR、ブール型の論理 XOR
* 論理 OR
    - `x | y`: 整数のビットごとの OR、ブール型の論理 OR
* 条件 AND
    - `x && y`: `x` が `false` でない場合にのみ `y` を評価する
* 条件 OR
    - `x || y`: `x` が `true` でない場合にのみ `y` を評価する
* Null 合体演算子
    - `x ?? y`: `x` が null の場合に `y` に評価、そうでない場合は `x` に評価する
* 条件
    - `x ? y : z`: `x` が `true` の場合は `y` を評価、`x` が `false` の場合は `z` を評価する
* 代入または匿名関数
    - `x = y`: 代入
    - `x op= y`: 複合代入。サポートされる演算子は以下の通り。
        - `*=`   `/=`   `%=`   `+=`   `-=`   `<<=`   `>>=`   `&=`  `^=`  `|=`
    - `(T x) => y`: 匿名関数 (ラムダ式)

>[!div class="step-by-step"]
[前へ](types-and-variables.md)
[次へ](statements.md)
