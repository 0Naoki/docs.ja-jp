---
title: 値の型による参照セマンティクス
description: 構造のコピーを安全に最小限に抑える言語機能を理解する
ms.date: 11/10/2017
ms.custom: mvc
ms.openlocfilehash: f241219994d7a03192a4aea69b912bf1ac5ed29c
ms.sourcegitcommit: 4b6490b2529707627ad77c3a43fbe64120397175
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 09/10/2018
ms.locfileid: "44272905"
---
# <a name="reference-semantics-with-value-types"></a><span data-ttu-id="505ed-103">値の型による参照セマンティクス</span><span class="sxs-lookup"><span data-stu-id="505ed-103">Reference semantics with value types</span></span>

<span data-ttu-id="505ed-104">値の型を利用する利点は、多くの場合にヒープ割り当てが回避されることにあります。</span><span class="sxs-lookup"><span data-stu-id="505ed-104">An advantage to using value types is that they often avoid heap allocations.</span></span>
<span data-ttu-id="505ed-105">欠点は、値でコピーされるということです。</span><span class="sxs-lookup"><span data-stu-id="505ed-105">The disadvantage is that they are copied by value.</span></span> <span data-ttu-id="505ed-106">このトレードオフは、大量のデータを操作するアルゴリズムの最適化を難しくします。</span><span class="sxs-lookup"><span data-stu-id="505ed-106">This tradeoff makes it harder to optimize algorithms that operate on large amounts of data.</span></span> <span data-ttu-id="505ed-107">C# 7.2 の新しい言語機能は、値の型による参照渡しセマンティクスを可能にするメカニズムを提供します。</span><span class="sxs-lookup"><span data-stu-id="505ed-107">New language features in C# 7.2 provide mechanisms that enable pass-by-reference semantics with value types.</span></span> <span data-ttu-id="505ed-108">これらの機能を賢く使って、割り当てとコピー操作の両方を最小限に抑えます。</span><span class="sxs-lookup"><span data-stu-id="505ed-108">Use these features wisely to minimize both allocations and copy operations.</span></span> <span data-ttu-id="505ed-109">この記事では、これらの新しい機能について説明します。</span><span class="sxs-lookup"><span data-stu-id="505ed-109">This article explores those new features.</span></span>

<span data-ttu-id="505ed-110">この記事にあるサンプル コードの多くは、C# 7.2 で追加された機能を示すものです。</span><span class="sxs-lookup"><span data-stu-id="505ed-110">Much of the sample code in this article demonstrates features added in C# 7.2.</span></span> <span data-ttu-id="505ed-111">そのような機能を使用するには、C# 7.2 以降を使用するようにプロジェクトを構成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="505ed-111">In order to use those features, you must configure your project to use C# 7.2 or later.</span></span> <span data-ttu-id="505ed-112">言語バージョンを設定する方法の詳細については、[言語バージョンの構成](language-reference/configure-language-version.md)に関する記事を参照してください。</span><span class="sxs-lookup"><span data-stu-id="505ed-112">For more information on setting the language version see [configure the language version](language-reference/configure-language-version.md).</span></span>

## <a name="passing-arguments-by-readonly-reference"></a><span data-ttu-id="505ed-113">引数の読み取り専用参照渡し</span><span class="sxs-lookup"><span data-stu-id="505ed-113">Passing arguments by readonly reference</span></span>

<span data-ttu-id="505ed-114">C# 7.2 では、引数を参照渡しするために既存の `ref` キーワードと `out` キーワードを補完する `in` キーワードが追加されています。</span><span class="sxs-lookup"><span data-stu-id="505ed-114">C# 7.2 adds the `in` keyword to complement the existing `ref` and `out` keywords to pass arguments by reference.</span></span> <span data-ttu-id="505ed-115">`in` キーワードは、引数を参照で渡すことを指定しますが、呼び出されたメソッドは値を変更しません。</span><span class="sxs-lookup"><span data-stu-id="505ed-115">The `in` keyword specifies passing the argument by reference, but the called method does not modify the value.</span></span> 

<span data-ttu-id="505ed-116">この追加によって、設計の意図を表すためのボキャブラリが完全に与えられます。</span><span class="sxs-lookup"><span data-stu-id="505ed-116">This addition provides a full vocabulary to express your design intent.</span></span> <span data-ttu-id="505ed-117">メソッド シグネチャで次の修飾子のいずれも指定しないのであれば、呼び出されたメソッドに渡されるとき、値の型がコピーされます。</span><span class="sxs-lookup"><span data-stu-id="505ed-117">Value types are copied when passed to a called method when you don't specify any of the following modifiers in the method signature.</span></span> <span data-ttu-id="505ed-118">これらの修飾子のいずれも、値の型が参照で渡され、コピーが回避されます。</span><span class="sxs-lookup"><span data-stu-id="505ed-118">Each of these modifiers specifies that a value type is passed by reference, avoiding the copy.</span></span> <span data-ttu-id="505ed-119">修飾子はそれぞれ、異なる意図を表します。</span><span class="sxs-lookup"><span data-stu-id="505ed-119">Each modifier expresses a different intent:</span></span>

- <span data-ttu-id="505ed-120">`out`: このメソッドは、このパラメーターとして使用される引数の値を設定します。</span><span class="sxs-lookup"><span data-stu-id="505ed-120">`out`: This method sets the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="505ed-121">`ref`: このメソッドは、このパラメーターとして使用される引数の値を設定することがあります。</span><span class="sxs-lookup"><span data-stu-id="505ed-121">`ref`: This method may set the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="505ed-122">`in`: このメソッドは、このパラメーターとして使用される引数の値を変更しません。</span><span class="sxs-lookup"><span data-stu-id="505ed-122">`in`: This method does not modify the value of the argument used as this parameter.</span></span>

<span data-ttu-id="505ed-123">`in` 修飾子を追加し、参照で引数を渡し、参照で引数を渡して不必要なコピーを回避する設計の意図を宣言します。</span><span class="sxs-lookup"><span data-stu-id="505ed-123">Add the `in` modifier to pass an argument by reference and declare your design intent to pass arguments by reference to avoid unnecessary copying.</span></span> <span data-ttu-id="505ed-124">その引数として使用されるオブジェクトの変更は意図しません。</span><span class="sxs-lookup"><span data-stu-id="505ed-124">You do not intend to modify the object used as that argument.</span></span> <span data-ttu-id="505ed-125">次のコードは、3D 空間の 2 点間の距離を計算するメソッドの例です。</span><span class="sxs-lookup"><span data-stu-id="505ed-125">The following code shows an example of a method that calculates the distance between two points in 3D space.</span></span> 

[!code-csharp[InArgument](../../samples/csharp/reference-semantics/Program.cs#InArgument "Specifying an In argument")]

<span data-ttu-id="505ed-126">引数は 2 つの構造で、それぞれに 3 つの倍精度浮動小数点型が含まれます。</span><span class="sxs-lookup"><span data-stu-id="505ed-126">The arguments are two structures that each contain three doubles.</span></span> <span data-ttu-id="505ed-127">倍精度浮動小数点型は 8 バイトです。そのため、各引数は 24 バイトになります。</span><span class="sxs-lookup"><span data-stu-id="505ed-127">A double is 8 bytes, so each argument is 24 bytes.</span></span> <span data-ttu-id="505ed-128">`in` 修飾子を指定することで、コンピューターのアーキテクチャに基づき、4 バイトまたは 8 バイトの参照をそれらの引数に渡します。</span><span class="sxs-lookup"><span data-stu-id="505ed-128">By specifying the `in` modifier, you pass a 4-byte or 8-byte reference to those arguments, depending on the architecture of the machine.</span></span> <span data-ttu-id="505ed-129">サイズの差はわずかですが、アプリケーションにおいて、繰り返しの多いループでさまざまな値でこのメソッドを呼び出すと、すぐに差が膨れ上がります。</span><span class="sxs-lookup"><span data-stu-id="505ed-129">The difference in size is small, but it can quickly add up when your application calls this method in a tight loop using many different values.</span></span>
 
<span data-ttu-id="505ed-130">`in` 修飾子は、その他の面でも `out` と `ref` を補完します。</span><span class="sxs-lookup"><span data-stu-id="505ed-130">The `in` modifier complements `out` and `ref` in other ways as well.</span></span> <span data-ttu-id="505ed-131">`in`、`out`、または `ref` の存在のみが異なるメソッドのオーバーロードは作成できません。</span><span class="sxs-lookup"><span data-stu-id="505ed-131">You cannot create overloads of a method that differ only in the presence of `in`, `out`, or `ref`.</span></span> <span data-ttu-id="505ed-132">これらの新しいルールは、`out` パラメーターと `ref` パラメーターに常に定義されていた同じ動作を拡張します。</span><span class="sxs-lookup"><span data-stu-id="505ed-132">These new rules extend the same behavior that had always been defined for `out` and `ref` parameters.</span></span>

<span data-ttu-id="505ed-133">`in` 修飾子は、メソッド、デリケート、ラムダ、ローカル関数、インデクサー、演算子など、パラメーターを受け取るあらゆるメンバーに適用されることがあります。</span><span class="sxs-lookup"><span data-stu-id="505ed-133">The `in` modifier may be applied to any member that takes parameters: methods, delegates, lambdas, local functions, indexers, operators.</span></span>

<span data-ttu-id="505ed-134">`ref` 引数や `out` 引数とは異なり、`in` パラメーターの引数にリテラル値か定数を使用できます。</span><span class="sxs-lookup"><span data-stu-id="505ed-134">Unlike `ref` and `out` arguments, you may use literal values or constants for the argument to an `in` parameter.</span></span> <span data-ttu-id="505ed-135">また、`ref` パラメーターや `out` パラメーターとは異なり、呼び出しサイトで `in` 修飾子を適用する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="505ed-135">Also, unlike a `ref` or `out` parameter, you don't need to apply the `in` modifier at the call site.</span></span> <span data-ttu-id="505ed-136">次のコードは、`CalculateDistance` メソッドを呼び出す 2 つの例です。</span><span class="sxs-lookup"><span data-stu-id="505ed-136">The following code shows you two examples of calling the `CalculateDistance` method.</span></span> <span data-ttu-id="505ed-137">最初のメソッドでは、参照で渡される 2 つのローカル変数が使用されます。</span><span class="sxs-lookup"><span data-stu-id="505ed-137">The first uses two local variables passed by reference.</span></span> <span data-ttu-id="505ed-138">2 つ目のメソッドには、メソッド呼び出しの一部として作成される一時的な変数が含まれます。</span><span class="sxs-lookup"><span data-stu-id="505ed-138">The second includes a temporary variable created as part of the method call.</span></span> 

[!code-csharp[UseInArgument](../../samples/csharp/reference-semantics/Program.cs#UseInArgument "Specifying an In argument")]

<span data-ttu-id="505ed-139">コンパイラにおいて、`in` 引数の読み取り専用の性質を強制する方法がいくつかあります。</span><span class="sxs-lookup"><span data-stu-id="505ed-139">There are several ways in which the compiler ensures that the read-only nature of an `in` argument is enforced.</span></span>  <span data-ttu-id="505ed-140">まず、呼び出されたメソッドは `in` パラメーターに直接割り当てできません。</span><span class="sxs-lookup"><span data-stu-id="505ed-140">First of all, the called method can't directly assign to an `in` parameter.</span></span> <span data-ttu-id="505ed-141">値が `struct` 型の場合、`in` パラメーターのどのフィールドにも直接割り当てできません。</span><span class="sxs-lookup"><span data-stu-id="505ed-141">It can't directly assign to any field of an `in` parameter when that value is a `struct` type.</span></span> <span data-ttu-id="505ed-142">また、`ref` または `out` 修飾子を使用するメソッドに `in` パラメーターを渡すことができません。</span><span class="sxs-lookup"><span data-stu-id="505ed-142">In addition, you cannot pass an `in` parameter to any method using the `ref` or `out` modifier.</span></span>
<span data-ttu-id="505ed-143">これらの規則は、`in` パラメーターのすべてのフィールドに適用されます (ただし、フィールドが `struct` 型でパラメーターも `struct` 型の場合)。</span><span class="sxs-lookup"><span data-stu-id="505ed-143">These rules apply to any field of an `in` parameter, provided the field is a `struct` type and the parameter is also a `struct` type.</span></span> <span data-ttu-id="505ed-144">実際、これらの規則は、メンバー アクセスのすべてのレベルで型が `structs` であれば、複数層のメンバー アクセスに適用されます。</span><span class="sxs-lookup"><span data-stu-id="505ed-144">In fact, these rules apply for multiple layers of member access provided the types at all levels of member access are `structs`.</span></span> <span data-ttu-id="505ed-145">コンパイラは `struct` 型を `in` 引数として渡し、その `struct` メンバーが他のメソッドへの引数として使用される場合は読み取り専用変数になるよう強制します。</span><span class="sxs-lookup"><span data-stu-id="505ed-145">The compiler enforces that `struct` types passed as  `in` arguments and their `struct` members are read-only variables when used as arguments to other methods.</span></span>

<span data-ttu-id="505ed-146">`in` パラメーターを使用することで、コピーを作成することの潜在的なパフォーマンス コストを回避できます。</span><span class="sxs-lookup"><span data-stu-id="505ed-146">The use of `in` parameters avoids the potential performance costs of making copies.</span></span> <span data-ttu-id="505ed-147">メソッド呼び出しのセマンティクスは変更されません。</span><span class="sxs-lookup"><span data-stu-id="505ed-147">It does not change the semantics of any method call.</span></span> <span data-ttu-id="505ed-148">そのため、呼び出しサイトで `in` 修飾子を指定する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="505ed-148">Therefore, you do not need to specify the `in` modifier at the call site.</span></span> <span data-ttu-id="505ed-149">ただし、呼び出しサイトで `in` 修飾子を省略すると、次の理由で、引数のコピーを作成することが許可されていることがコンパイラに通知されます。</span><span class="sxs-lookup"><span data-stu-id="505ed-149">However, omitting the `in` modifier at the call site informs the compiler that it is allowed to make a copy of the argument for the following reasons:</span></span>

- <span data-ttu-id="505ed-150">暗黙的な変換はあるが、引数の型からパラメーターの型への ID 変換がない。</span><span class="sxs-lookup"><span data-stu-id="505ed-150">There is an implicit conversion but not an identity conversion from the argument type to the parameter type.</span></span>
- <span data-ttu-id="505ed-151">引数は式だが、既知のストレージ変数がない。</span><span class="sxs-lookup"><span data-stu-id="505ed-151">The argument is an expression but does not have a known storage variable.</span></span>
- <span data-ttu-id="505ed-152">`in` の有無によって異なるオーバーロードが存在する。</span><span class="sxs-lookup"><span data-stu-id="505ed-152">An overload exists that differs by the presence or absence of `in`.</span></span> <span data-ttu-id="505ed-153">この場合は、値渡しオーバーロードの方がより適しています。</span><span class="sxs-lookup"><span data-stu-id="505ed-153">In that case, the by value overload is a better match.</span></span>

<span data-ttu-id="505ed-154">これらの規則は、既存のコードを読み取り専用の参照引数を使用するように更新するときに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="505ed-154">These rules are useful as you update existing code to use read-only reference arguments.</span></span> <span data-ttu-id="505ed-155">呼び出されるメソッド内で、値渡しパラメーターを使用する任意のインスタンス メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="505ed-155">Inside the called method, you can call any instance method that uses by value parameters.</span></span> <span data-ttu-id="505ed-156">それらのインスタンスで、`in` パラメーターのコピーが作成されます。</span><span class="sxs-lookup"><span data-stu-id="505ed-156">In those instances, a copy of the `in` parameter is created.</span></span> <span data-ttu-id="505ed-157">コンパイラは `in` パラメーターに一時的な変数を作成できるため、`in` パラメーターに既定値を指定することもできます。</span><span class="sxs-lookup"><span data-stu-id="505ed-157">Because the compiler can create a temporary variable for any `in` parameter, you can also specify default values for any `in` parameter.</span></span> <span data-ttu-id="505ed-158">次のコードでは、2 つ目の点の既定値として原点 (点 0,0) を指定します。</span><span class="sxs-lookup"><span data-stu-id="505ed-158">The following code specifies the origin (point 0,0) as the default value for the second point:</span></span>

[!code-csharp[InArgumentDefault](../../samples/csharp/reference-semantics/Program.cs#InArgumentDefault "Specifying defaults for an in parameter")]

<span data-ttu-id="505ed-159">コンパイラに読み取り専用引数の参照渡しを強制するには、次のコードに示すように、呼び出しサイトで引数に `in` 修飾子を指定します。</span><span class="sxs-lookup"><span data-stu-id="505ed-159">To force the compiler to pass read only arguments by reference, specify the `in` modifer on the arguments at the call site, as shown in the following code:</span></span>

[!code-csharp[UseInArgument](../../samples/csharp/reference-semantics/Program.cs#ExplicitInArgument "Specifying an In argument")]

<span data-ttu-id="505ed-160">この動作により、パフォーマンスの向上が可能な大規模なコードベースで、徐々に `in` パラメーターを採用しやすくなります。</span><span class="sxs-lookup"><span data-stu-id="505ed-160">This behavior makes it easier to adopt `in` parameters over time in large codebases where performance gains are possible.</span></span> <span data-ttu-id="505ed-161">最初に、メソッド シグネチャに `in` 修飾子を追加します。</span><span class="sxs-lookup"><span data-stu-id="505ed-161">You add the `in` modifier to method signatures first.</span></span> <span data-ttu-id="505ed-162">その後、呼び出しサイトで `in` 修飾子を追加し、`readonly struct` 型を作成して、コンパイラに他の場所で `in` パラメーターの防御用コピーを作成しないようにすることができます。</span><span class="sxs-lookup"><span data-stu-id="505ed-162">Then, you can add the `in` modifier at callsites and create `readonly struct` types to enable the compiler to avoid creating defensive copies of `in` parameters in more locations.</span></span>

<span data-ttu-id="505ed-163">`in` パラメーターの指定は、参照型または数値と併用することもできます。</span><span class="sxs-lookup"><span data-stu-id="505ed-163">The `in` parameter designation can also be used with reference types or numeric values.</span></span> <span data-ttu-id="505ed-164">ただし、いずれの場合も、利点があるとしてもわずかです。</span><span class="sxs-lookup"><span data-stu-id="505ed-164">However, the benefits in both cases are minimal, if any.</span></span>

## <a name="ref-readonly-returns"></a><span data-ttu-id="505ed-165">`ref readonly` 戻り値</span><span class="sxs-lookup"><span data-stu-id="505ed-165">`ref readonly` returns</span></span>

<span data-ttu-id="505ed-166">参照で値の型を返すが、呼び出し元にはその値の変更を禁止する場合もあります。</span><span class="sxs-lookup"><span data-stu-id="505ed-166">You may also want to return a value type by reference, but disallow the caller from modifying that value.</span></span> <span data-ttu-id="505ed-167">`ref readonly` 修飾子を使用し、その設計の意図を表します。</span><span class="sxs-lookup"><span data-stu-id="505ed-167">Use the `ref readonly` modifier to express that design intent.</span></span> <span data-ttu-id="505ed-168">既存のデータへの参照を返すが、変更を許可しないことを閲覧者に通知します。</span><span class="sxs-lookup"><span data-stu-id="505ed-168">It notifies readers that you are returning a reference to existing data, but not allowing modification.</span></span> 

<span data-ttu-id="505ed-169">コンパイラは、呼び出し元は参照を変更できないことを強制します。</span><span class="sxs-lookup"><span data-stu-id="505ed-169">The compiler enforces that the caller cannot modify the reference.</span></span> <span data-ttu-id="505ed-170">値を直接割り当てようとすると、コンパイル時エラーが生成されます。</span><span class="sxs-lookup"><span data-stu-id="505ed-170">Attempts to assign the value directly generate a compile-time error.</span></span> <span data-ttu-id="505ed-171">ただし、メンバー メソッドによって構造体の状態が変更されるか、コンパイラは認識できません。</span><span class="sxs-lookup"><span data-stu-id="505ed-171">However, the compiler cannot know if any member method modifies the state of the struct.</span></span>
<span data-ttu-id="505ed-172">オブジェクトが変更されないように、コンパイラはコピーを作成し、そのコピーを利用してメンバー参照を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="505ed-172">To ensure that the object is not modified, the compiler creates a copy and calls member references using that copy.</span></span> <span data-ttu-id="505ed-173">変更されるとすれば、その防御用のコピーに行われます。</span><span class="sxs-lookup"><span data-stu-id="505ed-173">Any modifications are to that defensive copy.</span></span> 

<span data-ttu-id="505ed-174">`Point3D` を使用するライブラリは、多くの場合、コード全体で原点を使用する可能性が高いです。</span><span class="sxs-lookup"><span data-stu-id="505ed-174">It's likely that the library using `Point3D` would often use the origin throughout the code.</span></span> <span data-ttu-id="505ed-175">インスタンスごとに、スタックに新しいオブジェクトが作成されます。</span><span class="sxs-lookup"><span data-stu-id="505ed-175">Every instance creates a new object on the stack.</span></span> <span data-ttu-id="505ed-176">定数を作成し、それを参照で返すことには利点がある場合があります。</span><span class="sxs-lookup"><span data-stu-id="505ed-176">It may be advantageous to create a constant and return it by reference.</span></span> <span data-ttu-id="505ed-177">ただし、内部の記憶域に参照を返す場合、参照される記憶域を呼び出し元が変更できないように強制することが勧められます。</span><span class="sxs-lookup"><span data-stu-id="505ed-177">But, if you return a reference to internal storage, you may want to enforce that the caller cannot modify the referenced storage.</span></span> <span data-ttu-id="505ed-178">次のコードでは、原点を指定する `Point3D` に `readonly ref` を返す読み取り専用プロパティが定義されます。</span><span class="sxs-lookup"><span data-stu-id="505ed-178">The following code defines a read-only property that returns a `readonly ref` to a `Point3D` that specifies the origin.</span></span>

[!code-csharp[OriginReference](../../samples/csharp/reference-semantics/Point3D.cs#OriginReference "Creating a readonly Origin reference")]

<span data-ttu-id="505ed-179">参照読み取り専用戻り値のコピーの作成は簡単です。`ref readonly` 修飾子で宣言されない変数にそれを割り当てるだけです。</span><span class="sxs-lookup"><span data-stu-id="505ed-179">Creating a copy of a ref readonly return is easy: Just assign it to a variable not declared with the `ref readonly` modifier.</span></span> <span data-ttu-id="505ed-180">割り当ての一環としてオブジェクトをコピーするコードがコンパイラによって生成されます。</span><span class="sxs-lookup"><span data-stu-id="505ed-180">The compiler generates code to copy the object as part of the assignment.</span></span> 

<span data-ttu-id="505ed-181">変数を `ref readonly return` に割り当てるとき、`ref readonly` 変数か、読み取り専用参照の値渡しコピーを指定できます。</span><span class="sxs-lookup"><span data-stu-id="505ed-181">When you assign a variable to a `ref readonly return`, you can specify either a `ref readonly` variable, or a by-value copy of the read-only reference:</span></span>

[!code-csharp[AssignRefReadonly](../../samples/csharp/reference-semantics/Program.cs#AssignRefReadonly "Assigning a ref readonly")]

<span data-ttu-id="505ed-182">先のコードの最初の割り当てでは、`Origin` 定数のコピーが作成され、そのコピーが割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="505ed-182">The first assignment in the preceding code makes a copy of the `Origin` constant and assigns that copy.</span></span> <span data-ttu-id="505ed-183">2 つ目は参照を割り当てます。</span><span class="sxs-lookup"><span data-stu-id="505ed-183">The second assigns a reference.</span></span> <span data-ttu-id="505ed-184">`readonly` 修飾子は変数の宣言の一部にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="505ed-184">Notice that the `readonly` modifier must be part of the declaration of the variable.</span></span> <span data-ttu-id="505ed-185">それが参照するものは変更できません。</span><span class="sxs-lookup"><span data-stu-id="505ed-185">The reference to which it refers can't be modified.</span></span> <span data-ttu-id="505ed-186">変更を試みると、コンパイル時エラーが発生します。</span><span class="sxs-lookup"><span data-stu-id="505ed-186">Attempts to do so result in a compile-time error.</span></span>

## <a name="readonly-struct-type"></a><span data-ttu-id="505ed-187">`readonly struct` 型</span><span class="sxs-lookup"><span data-stu-id="505ed-187">`readonly struct` type</span></span>

<span data-ttu-id="505ed-188">構造体の高トラフィック利用に `ref readonly` を適用する方法で十分な場合があります。</span><span class="sxs-lookup"><span data-stu-id="505ed-188">Applying `ref readonly` to high-traffic uses of a struct may be sufficient.</span></span>
<span data-ttu-id="505ed-189">不変構造体の作成が勧められる場合もあります。</span><span class="sxs-lookup"><span data-stu-id="505ed-189">Other times, you may want to create an immutable struct.</span></span> <span data-ttu-id="505ed-190">その後、常に読み取り専用参照で渡すことができます。</span><span class="sxs-lookup"><span data-stu-id="505ed-190">Then you can always pass by read-only reference.</span></span> <span data-ttu-id="505ed-191">この方法では、`in` パラメーターとして使用される構造のメソッドにアクセスするときに発生する防御用のコピーが取り除かれます。</span><span class="sxs-lookup"><span data-stu-id="505ed-191">That practice removes the defensive copies that take place when you access methods of a struct used as an `in` parameter.</span></span>

<span data-ttu-id="505ed-192">これは `readonly struct` 型を作成することで実行できます。</span><span class="sxs-lookup"><span data-stu-id="505ed-192">You can do that by creating a `readonly struct` type.</span></span> <span data-ttu-id="505ed-193">構造体宣言に `readonly` 修飾子を追加できます。</span><span class="sxs-lookup"><span data-stu-id="505ed-193">You can add the `readonly` modifier to a struct declaration.</span></span> <span data-ttu-id="505ed-194">その構造体のすべてのインスタンス メンバーが `readonly` になるようにコンパイラは強制します。`struct` は変更不可能でなければなりません。</span><span class="sxs-lookup"><span data-stu-id="505ed-194">The compiler enforces that all instance members of the struct are `readonly`; the `struct` must be immutable.</span></span>

<span data-ttu-id="505ed-195">`readonly struct` は最適化が他にもあります。</span><span class="sxs-lookup"><span data-stu-id="505ed-195">There are other optimizations for a `readonly struct`.</span></span> <span data-ttu-id="505ed-196">`in` が引数となるあらゆる場所で `readonly struct` 修飾子を使用できます。</span><span class="sxs-lookup"><span data-stu-id="505ed-196">You can use the `in` modifier at every location where a `readonly struct` is an argument.</span></span> <span data-ttu-id="505ed-197">また、有効期間がオブジェクトを返すメソッドの範囲を超えるオブジェクトを返すとき、`ref return` として `readonly struct` を返すことができます。</span><span class="sxs-lookup"><span data-stu-id="505ed-197">In addition, you can return a `readonly struct` as a `ref return` when you are returning an object whose lifetime extends beyond the scope of the method returning the object.</span></span>

<span data-ttu-id="505ed-198">最後に、`readonly struct` のメンバーを呼びだすと、コンパイラは一層効率的なコードを生成します。レシーバーのコピーではなく、`this` 参照が常に、メンバー メソッドに参照で渡される `in` パラメーターになります。</span><span class="sxs-lookup"><span data-stu-id="505ed-198">Finally, the compiler generates more efficient code when you call members of a `readonly struct`: The `this` reference, instead of a copy of the receiver, is always an `in` parameter passed by reference to the member method.</span></span> <span data-ttu-id="505ed-199">この最適化によって、`readonly struct` の利用時、省略されるコピーが多くなります。</span><span class="sxs-lookup"><span data-stu-id="505ed-199">This optimization saves more copying when you use a `readonly struct`.</span></span> <span data-ttu-id="505ed-200">この変更の対象として `Point3D` が勧められます。</span><span class="sxs-lookup"><span data-stu-id="505ed-200">The `Point3D` is a great candidate for this change.</span></span> <span data-ttu-id="505ed-201">次のコードは、更新後の `ReadonlyPoint3D` 構造体を示します。</span><span class="sxs-lookup"><span data-stu-id="505ed-201">The following code shows an updated `ReadonlyPoint3D` structure:</span></span>

[!code-csharp[ReadonlyOnlyPoint3D](../../samples/csharp/reference-semantics/Point3D.cs#ReadonlyOnlyPoint3D "Defining an immutable structure")]

## <a name="ref-struct-type"></a><span data-ttu-id="505ed-202">`ref struct` 型</span><span class="sxs-lookup"><span data-stu-id="505ed-202">`ref struct` type</span></span>

<span data-ttu-id="505ed-203">関連するもう 1 つの言語機能は、スタック割り当てにする必要がある値型を宣言する機能です。</span><span class="sxs-lookup"><span data-stu-id="505ed-203">Another related language feature is the ability to declare a value type that must be stack allocated.</span></span> <span data-ttu-id="505ed-204">言い換えると、このような型を別のクラスのメンバーとしてヒープ上で作成することはできません。</span><span class="sxs-lookup"><span data-stu-id="505ed-204">In other words, these types can never be created on the heap as a member of another class.</span></span> <span data-ttu-id="505ed-205">この機能の第一の動機は <xref:System.Span%601> と関連構造でした。</span><span class="sxs-lookup"><span data-stu-id="505ed-205">The primary motivation for this feature was <xref:System.Span%601> and related structures.</span></span> <span data-ttu-id="505ed-206"><xref:System.Span%601> には、そのメンバーの 1 つとしてマネージド ポインターが含まれます。他方はスパンの長さです。</span><span class="sxs-lookup"><span data-stu-id="505ed-206"><xref:System.Span%601> may contain a managed pointer as one of its members, the other being the length of the span.</span></span> <span data-ttu-id="505ed-207">実装は少し異なります。C# の場合、安全ではないコンテキストの外では、マネージド メモリのポインターがサポートされていないためです。</span><span class="sxs-lookup"><span data-stu-id="505ed-207">It's implemented a bit differently because C# doesn't support pointers to managed memory outside of an unsafe context.</span></span> <span data-ttu-id="505ed-208">ポインターや長さを変更する記述はアトミックではありません。</span><span class="sxs-lookup"><span data-stu-id="505ed-208">Any write that changes the pointer and the length is not atomic.</span></span> <span data-ttu-id="505ed-209">つまり、単一のスタック フレームに制約されない場合、<xref:System.Span%601> は範囲外エラーか、その他のタイプ セーフ違反になります。</span><span class="sxs-lookup"><span data-stu-id="505ed-209">That means a <xref:System.Span%601> would be subject to out of range errors or other type safety violations were it not constrained to a single stack frame.</span></span> <span data-ttu-id="505ed-210">また、GC ヒープ上にマネージド ポインターを置くと、通常、JIT 時にクラッシュします。</span><span class="sxs-lookup"><span data-stu-id="505ed-210">In addition, putting a managed pointer on the GC heap typically crashes at JIT time.</span></span>

<span data-ttu-id="505ed-211">[`stackalloc`](language-reference/keywords/stackalloc.md) で作成したメモリを使用するとき、あるいは相互運用 API からメモリを使用するとき、同様の要件が求められる場合があります。</span><span class="sxs-lookup"><span data-stu-id="505ed-211">You may have similar requirements working with memory created using [`stackalloc`](language-reference/keywords/stackalloc.md) or when using memory from interop APIs.</span></span> <span data-ttu-id="505ed-212">そのようなニーズには独自の `ref struct` 型を定義できます。</span><span class="sxs-lookup"><span data-stu-id="505ed-212">You can define your own `ref struct` types for those needs.</span></span> <span data-ttu-id="505ed-213">この記事の例では `Span<T>` を利用し、わかりやすくしています。</span><span class="sxs-lookup"><span data-stu-id="505ed-213">In this article, you see examples using `Span<T>` for simplicity.</span></span>

<span data-ttu-id="505ed-214">`ref struct` 宣言によって、この型の構造体はスタック上に置かなければならないことが宣言されます。</span><span class="sxs-lookup"><span data-stu-id="505ed-214">The `ref struct` declaration declares a struct of this type must be on the stack.</span></span> <span data-ttu-id="505ed-215">言語規則により、この型が安全に使用されます。</span><span class="sxs-lookup"><span data-stu-id="505ed-215">The language rules ensure the safe use of these types.</span></span> <span data-ttu-id="505ed-216">`ref struct` として宣言されるその他の型には <xref:System.ReadOnlySpan%601> があります。</span><span class="sxs-lookup"><span data-stu-id="505ed-216">Other types declared as `ref struct` include <xref:System.ReadOnlySpan%601>.</span></span> 

<span data-ttu-id="505ed-217">スタック割り当て変数として `ref struct` 型を維持する目的の下、すべての `ref struct` 型にコンパイラが適用する規則がいくつか導入されます。</span><span class="sxs-lookup"><span data-stu-id="505ed-217">The goal of keeping a `ref struct` type as a stack-allocated variable introduces several rules that the compiler enforces for all `ref struct` types.</span></span>

- <span data-ttu-id="505ed-218">`ref struct` はボックス化できません。</span><span class="sxs-lookup"><span data-stu-id="505ed-218">You can't box a `ref struct`.</span></span> <span data-ttu-id="505ed-219">`object` 型、`dynamic` 型、またはあらゆるインターフェイス型の変数には、`ref struct` 型を割り当てることができません。</span><span class="sxs-lookup"><span data-stu-id="505ed-219">You cannot assign a `ref struct` type to a variable of type `object`, `dynamic`, or any interface type.</span></span>
- <span data-ttu-id="505ed-220">クラスまたは通常構造体のメンバーとして `ref struct` を宣言することはできません。</span><span class="sxs-lookup"><span data-stu-id="505ed-220">You can't declare a `ref struct` as a member of a class or a normal struct.</span></span>
- <span data-ttu-id="505ed-221">非同期メソッドでは、`ref struct` 型のローカル変数を宣言できません。</span><span class="sxs-lookup"><span data-stu-id="505ed-221">You cannot declare local variables that are `ref struct` types in async methods.</span></span> <span data-ttu-id="505ed-222">`Task`、`Task<T>`、あるいは Task のような型を返す同期メソッドで宣言できます。</span><span class="sxs-lookup"><span data-stu-id="505ed-222">You can declare them in synchronous methods that return `Task`, `Task<T>` or Task-like types.</span></span>
- <span data-ttu-id="505ed-223">反復子で `ref struct` ローカル変数を宣言することはできません。</span><span class="sxs-lookup"><span data-stu-id="505ed-223">You cannot declare `ref struct` local variables in iterators.</span></span>
- <span data-ttu-id="505ed-224">ラムダ式またはローカル関数で `ref struct` 変数をキャプチャすることはできません。</span><span class="sxs-lookup"><span data-stu-id="505ed-224">You cannot capture `ref struct` variables in lambda expressions or local functions.</span></span>

<span data-ttu-id="505ed-225">これらの制約によって、誤って、マネージド ヒープに昇格させるようなやり方で `ref struct` を使用することがなくなります。</span><span class="sxs-lookup"><span data-stu-id="505ed-225">These restrictions ensure you do not accidentally use a `ref struct` in a manner that could promote it to the managed heap.</span></span>

## <a name="readonly-ref-struct-type"></a><span data-ttu-id="505ed-226">`readonly ref struct` 型</span><span class="sxs-lookup"><span data-stu-id="505ed-226">`readonly ref struct` type</span></span>

<span data-ttu-id="505ed-227">構造体を `readonly ref` として宣言すると、`ref struct` と `readonly struct` の制限の利点と制限が組み合わされます。</span><span class="sxs-lookup"><span data-stu-id="505ed-227">Declaring a struct as `readonly ref` combines the benefits and restrictions of `ref struct` and `readonly struct` declarations.</span></span> 

<span data-ttu-id="505ed-228">次の例は、`readonly ref struct` の宣言を示しています。</span><span class="sxs-lookup"><span data-stu-id="505ed-228">The following example demonstrates the declaration of `readonly ref struct`.</span></span>

```csharp
readonly ref struct ReadOnlyRefPoint2D
{
    public int X { get; }
    public int Y { get; }
    
    public ReadOnlyRefPoint2D(int x, int y) => (X, Y) = (x, y);
}
```

## <a name="conclusions"></a><span data-ttu-id="505ed-229">まとめ</span><span class="sxs-lookup"><span data-stu-id="505ed-229">Conclusions</span></span>

<span data-ttu-id="505ed-230">C# 言語の以上の拡張機能は、必要なパフォーマンスの達成にメモリ割り当てが重要となる、パフォーマンス クリティカルなアルゴリズムのために設計されています。</span><span class="sxs-lookup"><span data-stu-id="505ed-230">These enhancements to the C# language are designed for performance critical algorithms where memory allocations can be critical to achieving the necessary performance.</span></span> <span data-ttu-id="505ed-231">自分が記述するコードではこれらの機能を頻繁に使用することがないかもしれません。</span><span class="sxs-lookup"><span data-stu-id="505ed-231">You may find that you don't often use these features in the code you write.</span></span> <span data-ttu-id="505ed-232">しかしながら、以上の拡張機能は、.NET Framework では、さまざまな場所で採用されています。</span><span class="sxs-lookup"><span data-stu-id="505ed-232">However, these enhancements have been adopted in many locations in the .NET Framework.</span></span> <span data-ttu-id="505ed-233">これらの機能を利用する API が増えれば、自分で作るアプリケーションのパフォーマンスが改善するでしょう。</span><span class="sxs-lookup"><span data-stu-id="505ed-233">As more and more APIs make use of these features, you'll see the performance of your own applications improve.</span></span>
