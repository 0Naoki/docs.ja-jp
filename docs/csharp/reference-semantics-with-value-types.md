---
title: "値の型による参照セマンティクス"
description: "構造のコピーを安全に最小限に抑える言語機能を理解する"
author: billwagner
ms.author: wiwagn
ms.date: 11/10/2017
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.custom: mvc
ms.openlocfilehash: 0c6e44a3e1a1458f4211b66b6d1ef5b4b30cd7c1
ms.sourcegitcommit: 5177d6ae2e9baf026f07ee0631556700a5a193f7
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/28/2017
---
# <a name="reference-semantics-with-value-types"></a><span data-ttu-id="e04dd-103">値の型による参照セマンティクス</span><span class="sxs-lookup"><span data-stu-id="e04dd-103">Reference semantics with value types</span></span>

<span data-ttu-id="e04dd-104">値の型を利用する利点は、多くの場合にヒープ割り当てが回避されることにあります。</span><span class="sxs-lookup"><span data-stu-id="e04dd-104">An advantage to using value types is that they often avoid heap allocations.</span></span>
<span data-ttu-id="e04dd-105">それに付随する欠点が、値でコピーされるということです。</span><span class="sxs-lookup"><span data-stu-id="e04dd-105">The corresponding disadvantage is that they are copied by value.</span></span> <span data-ttu-id="e04dd-106">このトレードオフは、大量のデータを操作するアルゴリズムの最適化を難しくします。</span><span class="sxs-lookup"><span data-stu-id="e04dd-106">This tradeoff makes it harder to optimize algorithms that operate on large amounts of data.</span></span> <span data-ttu-id="e04dd-107">C# 7.2 の新しい言語機能は、値の型による参照渡しセマンティクスを可能にするメカニズムを提供します。</span><span class="sxs-lookup"><span data-stu-id="e04dd-107">New language features in C# 7.2 provide mechanisms that enable pass-by-reference semantics with value types.</span></span> <span data-ttu-id="e04dd-108">これらの機能を賢く使えば、割り当てとコピー操作の両方を最小限に抑えることができます。</span><span class="sxs-lookup"><span data-stu-id="e04dd-108">If you use these features wisely you can minimize both allocations and copy operations.</span></span> <span data-ttu-id="e04dd-109">この記事では、これらの新しい機能について説明します。</span><span class="sxs-lookup"><span data-stu-id="e04dd-109">This article explores those new features.</span></span>

<span data-ttu-id="e04dd-110">この記事にあるサンプル コードの多くは、C# 7.2 で追加された機能を示すものです。</span><span class="sxs-lookup"><span data-stu-id="e04dd-110">Much of the sample code in this article demonstrates features added in C# 7.2.</span></span> <span data-ttu-id="e04dd-111">そのような機能を使用するには、プロジェクトで C# 7.2 以降を使用するようにプロジェクトを構成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="e04dd-111">In order to use those features, you have to configure your project to use C# 7.2 or later in your project.</span></span> <span data-ttu-id="e04dd-112">Visual Studio を使用してそれを選択できます。</span><span class="sxs-lookup"><span data-stu-id="e04dd-112">You can use Visual Studio to select it.</span></span> <span data-ttu-id="e04dd-113">プロジェクトごとに、メニューから **[プロジェクト]** を選択し、次に **[プロパティ]** を選択します。</span><span class="sxs-lookup"><span data-stu-id="e04dd-113">For each project, select **Project** from the menu, then **Properties**.</span></span> <span data-ttu-id="e04dd-114">**[ビルド]** タブを選択してから **[詳細設定]** をクリックします。</span><span class="sxs-lookup"><span data-stu-id="e04dd-114">Select the **Build** tab and click **Advanced**.</span></span> <span data-ttu-id="e04dd-115">そこから、言語バージョンを構成できます。</span><span class="sxs-lookup"><span data-stu-id="e04dd-115">From there, you can configure the language version.</span></span> <span data-ttu-id="e04dd-116">"7.2" または "latest" を選択します。</span><span class="sxs-lookup"><span data-stu-id="e04dd-116">Choose either "7.2", or "latest".</span></span>  <span data-ttu-id="e04dd-117">あるいは、*csproj* ファイルを編集し、次のノードを追加できます。</span><span class="sxs-lookup"><span data-stu-id="e04dd-117">Or you can edit the *csproj* file and add the following node:</span></span>

```XML
  <PropertyGroup>
    <LangVersion>7.2</LangVersion>
  </PropertyGroup>
```

<span data-ttu-id="e04dd-118">値には "7.2" または "latest" を使用できます。</span><span class="sxs-lookup"><span data-stu-id="e04dd-118">You can use either "7.2" or "latest" for the value.</span></span>

## <a name="specifying-in-parameters"></a><span data-ttu-id="e04dd-119">`in` パラメーターを指定する</span><span class="sxs-lookup"><span data-stu-id="e04dd-119">Specifying `in` parameters</span></span>

<span data-ttu-id="e04dd-120">C# 7.2 では、参照で引数を渡すメソッドを記述するときに既存の `ref` キーワードと `out` キーワードを補完する `in` キーワードが追加されています。</span><span class="sxs-lookup"><span data-stu-id="e04dd-120">C# 7.2 adds the `in` keyword to complement the existing `ref` and `out` keywords when you write a method that passes arguments by reference.</span></span> <span data-ttu-id="e04dd-121">`in` キーワードは、参照でパラメーターを渡していること、呼び出されたメソッドはそれに渡された値を変更しないことを指定します。</span><span class="sxs-lookup"><span data-stu-id="e04dd-121">The `in` keyword specifies that you are passing the parameter by reference and the called method does not modify the value passed to it.</span></span> 

<span data-ttu-id="e04dd-122">この追加によって、設計の意図を表すためのボキャブラリが完全に与えられます。</span><span class="sxs-lookup"><span data-stu-id="e04dd-122">This addition provides a full vocabulary to express your design intent.</span></span> <span data-ttu-id="e04dd-123">次の修飾子のいずれも指定しないのであれば、呼び出されたメソッドに渡されるとき、値の型がコピーされます。</span><span class="sxs-lookup"><span data-stu-id="e04dd-123">Value types are copied when passed to a called method when you do not specify any of the following modifiers.</span></span> <span data-ttu-id="e04dd-124">これらの修飾子のいずれも、値の型が参照で渡され、コピーが回避されます。</span><span class="sxs-lookup"><span data-stu-id="e04dd-124">Each of these modifiers specify that a value type is passed by reference, avoiding the copy.</span></span> <span data-ttu-id="e04dd-125">修飾子はそれぞれ、異なる意図を表します。</span><span class="sxs-lookup"><span data-stu-id="e04dd-125">Each modifier expresses a different intent:</span></span>

- <span data-ttu-id="e04dd-126">`out`: このメソッドは、このパラメーターとして使用される引数の値を設定します。</span><span class="sxs-lookup"><span data-stu-id="e04dd-126">`out`: This method sets the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="e04dd-127">`ref`: このメソッドは、このパラメーターとして使用される引数の値を設定することがあります。</span><span class="sxs-lookup"><span data-stu-id="e04dd-127">`ref`: This method may set the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="e04dd-128">`in`: このメソッドは、このパラメーターとして使用される引数の値を変更しません。</span><span class="sxs-lookup"><span data-stu-id="e04dd-128">`in`: This method does not modify the value of the argument used as this parameter.</span></span>

<span data-ttu-id="e04dd-129">`in` 修飾子を追加し、参照で引数を渡すとき、不必要なコピーを回避するために、設計の意図が参照で引数を渡すことであることを宣言します。</span><span class="sxs-lookup"><span data-stu-id="e04dd-129">When you add the `in` modifier to pass an argument by reference, you declare your design intent is to pass arguments by reference to avoid unnecessary copying.</span></span> <span data-ttu-id="e04dd-130">その引数として使用されるオブジェクトの変更は意図しません。</span><span class="sxs-lookup"><span data-stu-id="e04dd-130">You do not intend to modify the object used as that argument.</span></span> <span data-ttu-id="e04dd-131">次のコードは、3D 空間の 2 点間の距離を計算するメソッドの例です。</span><span class="sxs-lookup"><span data-stu-id="e04dd-131">The following code shows an example of a method that calculates the distance between two points in 3D space.</span></span> 

[!code-csharp[InArgument](../../samples/csharp/reference-semantics/Program.cs#InArgument "Specifying an In argument")]

<span data-ttu-id="e04dd-132">引数は 2 つの構造で、それぞれに 3 つの倍精度浮動小数点型が含まれます。</span><span class="sxs-lookup"><span data-stu-id="e04dd-132">The arguments are two structures that each contain three doubles.</span></span> <span data-ttu-id="e04dd-133">倍精度浮動小数点型は 8 バイトです。そのため、各引数は 24 バイトになります。</span><span class="sxs-lookup"><span data-stu-id="e04dd-133">A double is 8 bytes, so each argument is 24 bytes.</span></span> <span data-ttu-id="e04dd-134">`in` 修飾子を指定することで、コンピューターのアーキテクチャに基づき、4 バイトまたは 8 バイトの参照をそれらの引数に渡します。</span><span class="sxs-lookup"><span data-stu-id="e04dd-134">By specifying the `in` modifier, you pass 4-byte or 8-byte reference to those arguments, depending on the architecture of the machine.</span></span> <span data-ttu-id="e04dd-135">サイズの差はわずかですが、アプリケーションにおいて、繰り返しの多いループでさまざまな値でこのメソッドを呼び出すと、すぐに差が膨れ上がります。</span><span class="sxs-lookup"><span data-stu-id="e04dd-135">The difference in size is small, but it can quickly add up when your application calls this method in a tight loop using many different values.</span></span>
 
<span data-ttu-id="e04dd-136">`in` 修飾子は、その他の面でも `out` と `ref` を補完します。</span><span class="sxs-lookup"><span data-stu-id="e04dd-136">The `in` modifier complements `out` and `ref` in other ways as well.</span></span> <span data-ttu-id="e04dd-137">`in`、`out`、または `ref` の存在でのみ異なるメソッドのオーバーロードは作成できません。</span><span class="sxs-lookup"><span data-stu-id="e04dd-137">You cannot create overloads of a method that differ only in the presence of `in`, `out` or `ref`.</span></span> <span data-ttu-id="e04dd-138">これらの新しいルールは、`out` パラメーターと `ref` パラメーターに常に定義されていた同じ動作を拡張します。</span><span class="sxs-lookup"><span data-stu-id="e04dd-138">These new rules extend the same behavior that had always been defined for `out` and `ref` parameters.</span></span>

<span data-ttu-id="e04dd-139">`in` 修飾子は、メソッド、デリケート、ラムダ、ローカル関数、インデクサー、演算子など、パラメーターを受け取るあらゆるメンバーに適用されることがあります。</span><span class="sxs-lookup"><span data-stu-id="e04dd-139">The `in` modifier may be applied to any member that takes parameters: methods, delegates, lambdas, local functions, indexers, operators.</span></span>

<span data-ttu-id="e04dd-140">`ref` 引数や `out` 引数とは異なり、`in` パラメーターの引数にリテラル値か定数を使用できます。</span><span class="sxs-lookup"><span data-stu-id="e04dd-140">Unlike `ref` and `out` arguments, you may use literal values or constants for the argument to an `in` parameter.</span></span> <span data-ttu-id="e04dd-141">また、`ref` パラメーターや `out` パラメーターとは異なり、呼び出しサイトで `in` 修飾子を適用する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="e04dd-141">Also, unlike a `ref` or `out` parameter, you don't need to apply the `in` modifier at the call site.</span></span> <span data-ttu-id="e04dd-142">次のコードは、`CalculateDistance` メソッドを呼び出す 2 つの例です。</span><span class="sxs-lookup"><span data-stu-id="e04dd-142">The following code shows you two examples of calling the `CalculateDistance` method.</span></span> <span data-ttu-id="e04dd-143">最初のメソッドでは、参照で渡される 2 つのローカル変数が使用されます。</span><span class="sxs-lookup"><span data-stu-id="e04dd-143">The first uses two local variables passed by reference.</span></span> <span data-ttu-id="e04dd-144">2 つ目のメソッドには、メソッド呼び出しの一部として作成される一時的な変数が含まれます。</span><span class="sxs-lookup"><span data-stu-id="e04dd-144">The second includes a temporary variable created as part of the method call.</span></span> 

[!code-csharp[UseInArgument](../../samples/csharp/reference-semantics/Program.cs#UseInArgument "Specifying an In argument")]

<span data-ttu-id="e04dd-145">コンパイラにおいて、`in` 引数の読み取り専用の性質を強制する方法がいくつかあります。</span><span class="sxs-lookup"><span data-stu-id="e04dd-145">There are several ways in which the compiler ensures that the read-only nature of an `in` argument is enforced.</span></span>  <span data-ttu-id="e04dd-146">まず、呼び出されたメソッドは `in` パラメーターに直接割り当てできません。</span><span class="sxs-lookup"><span data-stu-id="e04dd-146">First of all, the called method can't directly assign to an `in` parameter.</span></span> <span data-ttu-id="e04dd-147">`in` パラメーターのどのフィールドにも直接割り当てできません。</span><span class="sxs-lookup"><span data-stu-id="e04dd-147">It can't directly assign to any field of an `in` parameter.</span></span> <span data-ttu-id="e04dd-148">また、`ref` または `out` 修飾子を要求するメソッドに `in` パラメーターを渡すことができません。</span><span class="sxs-lookup"><span data-stu-id="e04dd-148">In addition, you cannot pass an `in` parameter to any method demanding the `ref` or `out` modifier.</span></span>
<span data-ttu-id="e04dd-149">コンパイラは、`in` 引数が読み取り専用変数であることを強制します。</span><span class="sxs-lookup"><span data-stu-id="e04dd-149">The compiler enforces that the `in` argument is a readonly variable.</span></span> <span data-ttu-id="e04dd-150">値渡しセマンティクスを使用するあらゆるインスタンス メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="e04dd-150">You can call any instance method that uses pass-by-value semantics.</span></span> <span data-ttu-id="e04dd-151">それらのインスタンスで、`in` パラメーターのコピーが作成されます。</span><span class="sxs-lookup"><span data-stu-id="e04dd-151">In those instances, a copy of the `in` parameter is created.</span></span> <span data-ttu-id="e04dd-152">コンパイラは `in` パラメーターに一時的な変数を作成できるため、`in` パラメーターに既定値を指定することもできます。</span><span class="sxs-lookup"><span data-stu-id="e04dd-152">Because the compiler can create a temporary variable for any `in` parameter, you can also specify default values for any `in` parameter.</span></span> <span data-ttu-id="e04dd-153">次のコードでは、2 つ目の点の既定値として原点 (点 0,0) を指定するためにそれが利用されています。</span><span class="sxs-lookup"><span data-stu-id="e04dd-153">The follow code uses that to specify the origin (point 0,0) as the default value for the second point:</span></span>

[!code-csharp[InArgumentDefault](../../samples/csharp/reference-semantics/Program.cs#InArgumentDefault "Specifying defaults for an in parameter")]

<span data-ttu-id="e04dd-154">`in` パラメーターの指定は、参照型または組み込み数値と併用することもできます。</span><span class="sxs-lookup"><span data-stu-id="e04dd-154">The `in` parameter designation can also be used with reference types or built in numeric values.</span></span> <span data-ttu-id="e04dd-155">ただし、いずれの場合も、利点があるとしてもわずかです。</span><span class="sxs-lookup"><span data-stu-id="e04dd-155">However, the benefits in both cases are minimal, if any.</span></span>

## <a name="ref-readonly-returns"></a><span data-ttu-id="e04dd-156">`ref readonly` 戻り値</span><span class="sxs-lookup"><span data-stu-id="e04dd-156">`ref readonly` returns</span></span>

<span data-ttu-id="e04dd-157">参照で値の型を返すが、呼び出し元にはその値の変更を禁止する場合もあります。</span><span class="sxs-lookup"><span data-stu-id="e04dd-157">You may also want to return a value type by reference, but disallow the caller from modifying that value.</span></span> <span data-ttu-id="e04dd-158">`ref readonly` 修飾子を使用し、その設計の意図を表します。</span><span class="sxs-lookup"><span data-stu-id="e04dd-158">Use the `ref readonly` modifier to express that design intent.</span></span> <span data-ttu-id="e04dd-159">既存のデータへの参照を返すが、変更を許可しないことを閲覧者に通知します。</span><span class="sxs-lookup"><span data-stu-id="e04dd-159">It notifies readers that you are returning a reference to existing data, but not allowing modification.</span></span> 

<span data-ttu-id="e04dd-160">コンパイラは、呼び出し元は参照を変更できないことを強制します。</span><span class="sxs-lookup"><span data-stu-id="e04dd-160">The compiler enforces that the caller cannot modify the reference.</span></span> <span data-ttu-id="e04dd-161">値に直接割り当てようとすると、コンパイル時エラーが生成されます。</span><span class="sxs-lookup"><span data-stu-id="e04dd-161">Attempts to assign to the value directly generate a compile-time error.</span></span> <span data-ttu-id="e04dd-162">ただし、メンバー メソッドによって構造体の状態が変更されるか、コンパイラは認識できません。</span><span class="sxs-lookup"><span data-stu-id="e04dd-162">However, the compiler cannot know if any member method modifies the state of the struct.</span></span>
<span data-ttu-id="e04dd-163">オブジェクトが変更されないように、コンパイラはコピーを作成し、そのコピーを利用してメンバー参照を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="e04dd-163">To ensure that the object is not modified, the compiler creates a copy and calls member references using that copy.</span></span> <span data-ttu-id="e04dd-164">変更されるとすれば、その防御用のコピーに行われます。</span><span class="sxs-lookup"><span data-stu-id="e04dd-164">Any modifications are to that defensive copy.</span></span> 

<span data-ttu-id="e04dd-165">`Point3D` を使用するライブラリは、多くの場合、コード全体で原点を使用する可能性が高いです。</span><span class="sxs-lookup"><span data-stu-id="e04dd-165">It's likely that the library using `Point3D` would often use the origin throughout the code.</span></span> <span data-ttu-id="e04dd-166">インスタンスごとに、スタックに新しいオブジェクトが作成されます。</span><span class="sxs-lookup"><span data-stu-id="e04dd-166">Every instance creates a new object on the stack.</span></span> <span data-ttu-id="e04dd-167">定数を作成し、それを参照で返すことには利点がある場合があります。</span><span class="sxs-lookup"><span data-stu-id="e04dd-167">It may be advantageous to create a constant and return it by reference.</span></span> <span data-ttu-id="e04dd-168">ただし、内部の記憶域に参照を返す場合、参照される記憶域を呼び出し元が変更できないように強制することが勧められます。</span><span class="sxs-lookup"><span data-stu-id="e04dd-168">But, if you return a reference to internal storage, you may want to enforce that the caller cannot modify the referenced storage.</span></span> <span data-ttu-id="e04dd-169">次のコードでは、原点を指定する `Point3D` に `readonly ref` を返す読み取り専用プロパティが定義されます。</span><span class="sxs-lookup"><span data-stu-id="e04dd-169">The following code defines a read-only property that returns a `readonly ref` to a `Point3D` that specifies the origin.</span></span>

[!code-csharp[OriginReference](../../samples/csharp/reference-semantics/Point3D.cs#OriginReference "Creating a readonly Origin reference")]

<span data-ttu-id="e04dd-170">参照読み取り専用戻り値のコピーの作成は簡単です。`ref readonly` 修飾子で宣言されない変数にそれを割り当てるだけです。</span><span class="sxs-lookup"><span data-stu-id="e04dd-170">Creating a copy of a ref readonly return is easy: Just assign it to a variable not declared with the `ref readonly` modifier.</span></span> <span data-ttu-id="e04dd-171">割り当ての一環としてオブジェクトをコピーするコードがコンパイラによって生成されます。</span><span class="sxs-lookup"><span data-stu-id="e04dd-171">The compiler generates code to copy the object as part of the assignment.</span></span> 

<span data-ttu-id="e04dd-172">変数を `ref readonly return` に割り当てるとき、`ref readonly` 変数か、読み取り専用参照の値渡しコピーを指定できます。</span><span class="sxs-lookup"><span data-stu-id="e04dd-172">When you assign a variable to a `ref readonly return`, you can specify either a `ref readonly` variable, or a by-value copy of the readonly reference:</span></span>

[!code-csharp[AssignRefReadonly](../../samples/csharp/reference-semantics/Program.cs#AssignRefReadonly "Assigning a ref readonly")]

<span data-ttu-id="e04dd-173">先のコードの最初の割り当てでは、`Origin` 定数のコピーが作成され、そのコピーが割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="e04dd-173">The first assignment in the preceding code makes a copy of the `Origin` constant and assigns that copy.</span></span> <span data-ttu-id="e04dd-174">2 つ目は参照を割り当てます。</span><span class="sxs-lookup"><span data-stu-id="e04dd-174">The second assigns a reference.</span></span> <span data-ttu-id="e04dd-175">`readonly` 修飾子は変数の宣言の一部にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="e04dd-175">Notice that the `readonly` modifier must be part of the declaration of the variable.</span></span> <span data-ttu-id="e04dd-176">それが参照するものは変更できません。</span><span class="sxs-lookup"><span data-stu-id="e04dd-176">The reference to which it refers cannot be modified.</span></span> <span data-ttu-id="e04dd-177">変更を試みると、コンパイル時エラーが発生します。</span><span class="sxs-lookup"><span data-stu-id="e04dd-177">Attempts to do so result in a compile-time error.</span></span>

## <a name="readonly-struct-type"></a><span data-ttu-id="e04dd-178">`readonly struct` 型</span><span class="sxs-lookup"><span data-stu-id="e04dd-178">`readonly struct` type</span></span>

<span data-ttu-id="e04dd-179">構造体の高トラフィック利用に `ref readonly` を適用する方法で十分な場合があります。</span><span class="sxs-lookup"><span data-stu-id="e04dd-179">Applying `ref readonly` to high-traffic uses of a struct may be sufficient.</span></span>
<span data-ttu-id="e04dd-180">不変構造体の作成が勧められる場合もあります。</span><span class="sxs-lookup"><span data-stu-id="e04dd-180">Other times, you may want to create an immutable struct.</span></span> <span data-ttu-id="e04dd-181">その後、常に読み取り専用参照で渡すことができます。</span><span class="sxs-lookup"><span data-stu-id="e04dd-181">Then you can always pass by readonly reference.</span></span> <span data-ttu-id="e04dd-182">この方法では、`in` パラメーターとして使用される構造のメソッドにアクセスするときに発生する防御用のコピーが取り除かれます。</span><span class="sxs-lookup"><span data-stu-id="e04dd-182">That practice removes the defensive copies that take place when you access methods of a struct used as an `in` parameter.</span></span>

<span data-ttu-id="e04dd-183">これは `readonly struct` 型を作成することで実行できます。</span><span class="sxs-lookup"><span data-stu-id="e04dd-183">You can do that by creating a `readonly struct` type.</span></span> <span data-ttu-id="e04dd-184">構造体宣言に `readonly` 修飾子を追加できます。</span><span class="sxs-lookup"><span data-stu-id="e04dd-184">You can add the `readonly` modifier to a struct declaration.</span></span> <span data-ttu-id="e04dd-185">その構造体のすべてのインスタンス メンバーが `readonly` になるようにコンパイラは強制します。`struct` は変更不可能でなければなりません。</span><span class="sxs-lookup"><span data-stu-id="e04dd-185">The compiler enforces that all instance members of the struct are `readonly`; the `struct` must be immutable.</span></span>

<span data-ttu-id="e04dd-186">`readonly struct` は最適化が他にもあります。</span><span class="sxs-lookup"><span data-stu-id="e04dd-186">There are other optimizations for a `readonly struct`.</span></span> <span data-ttu-id="e04dd-187">`in` が引数となるあらゆる場所で `readonly struct` 修飾子を使用できます。</span><span class="sxs-lookup"><span data-stu-id="e04dd-187">You can use the `in` modifier at every location where a `readonly struct` is an argument.</span></span> <span data-ttu-id="e04dd-188">また、有効期間がオブジェクトを返すメソッドの範囲を超えるオブジェクトを返すとき、`ref return` として `readonly struct` を返すことができます。</span><span class="sxs-lookup"><span data-stu-id="e04dd-188">In addition, you can return a `readonly struct` as a `ref return` when you are returning an object whose lifetime extends beyond the scope of the method returning the object.</span></span>

<span data-ttu-id="e04dd-189">最後に、`readonly struct` のメンバーを呼びだすと、コンパイラは一層効率的なコードを生成します。レシーバーのコピーではなく、`this` 参照が常に、メンバー メソッドに参照で渡される `in` パラメーターになります。</span><span class="sxs-lookup"><span data-stu-id="e04dd-189">Finally, the compiler generates more efficient code when you call members of a `readonly struct`: The `this` reference, instead of a copy of the receiver, is always an `in` parameter passed by reference to the member method.</span></span> <span data-ttu-id="e04dd-190">この最適化によって、`readonly struct` の利用時、省略されるコピーが多くなります。</span><span class="sxs-lookup"><span data-stu-id="e04dd-190">This optimization saves more copying when you use a `readonly struct`.</span></span> <span data-ttu-id="e04dd-191">この変更の対象として `Point3D` が勧められます。</span><span class="sxs-lookup"><span data-stu-id="e04dd-191">The `Point3D` is a great candidate for this change.</span></span> <span data-ttu-id="e04dd-192">次のコードは、更新後の `ReadonlyPoint3D` 構造体を示します。</span><span class="sxs-lookup"><span data-stu-id="e04dd-192">The following code shows an updated `ReadonlyPoint3D` structure:</span></span>

[!code-csharp[ReadonlyOnlyPoint3D](../../samples/csharp/reference-semantics/Point3D.cs#ReadonlyOnlyPoint3D "Defining an immutable structure")]

## <a name="ref-struct-type"></a><span data-ttu-id="e04dd-193">`ref struct` 型</span><span class="sxs-lookup"><span data-stu-id="e04dd-193">`ref struct` type</span></span>

<span data-ttu-id="e04dd-194">関連するもう 1 つの言語機能は、スタック割り当てにする必要がある値型を宣言する機能です。</span><span class="sxs-lookup"><span data-stu-id="e04dd-194">Another related language feature is the ability to declare a value type that must be stack allocated.</span></span> <span data-ttu-id="e04dd-195">言い換えると、このような型を別のクラスのメンバーとしてヒープ上で作成することはできません。</span><span class="sxs-lookup"><span data-stu-id="e04dd-195">In other words, these types can never be created on the heap as a member of another class.</span></span> <span data-ttu-id="e04dd-196">この機能の第一の動機は <xref:System.Span%601> と関連構造でした。</span><span class="sxs-lookup"><span data-stu-id="e04dd-196">The primary motivation for this feature was <xref:System.Span%601> and related structures.</span></span> <span data-ttu-id="e04dd-197"><xref:System.Span%601> には、そのメンバーの 1 つとしてマネージ ポインターが含まれます。他方はスパンの長さです。</span><span class="sxs-lookup"><span data-stu-id="e04dd-197"><xref:System.Span%601> may contain a managed pointer as one of its members, the other being the length of the span.</span></span> <span data-ttu-id="e04dd-198">実際の実装は少し異なります。C# の場合、安全ではないコンテキストの外では、マネージ メモリのポインターがサポートされていないためです。</span><span class="sxs-lookup"><span data-stu-id="e04dd-198">It's actually implemented a bit differently because C# doesn't support pointers to managed memory outside of an unsafe context.</span></span> <span data-ttu-id="e04dd-199">ポインターや長さを変更する記述はアトミックではありません。</span><span class="sxs-lookup"><span data-stu-id="e04dd-199">Any write that changes the pointer and the length is not atomic.</span></span> <span data-ttu-id="e04dd-200">つまり、単一のスタック フレームに制約されない場合、<xref:System.Span%601> は範囲外エラーか、その他のタイプ セーフ違反になります。</span><span class="sxs-lookup"><span data-stu-id="e04dd-200">That means a <xref:System.Span%601> would be subject to out of range errors or other type safety violations were it not constrained to a single stack frame.</span></span> <span data-ttu-id="e04dd-201">また、GC ヒープ上にマネージ ポインターを置くと、通常、JIT 時にクラッシュします。</span><span class="sxs-lookup"><span data-stu-id="e04dd-201">In addition, putting a managed pointer on the GC heap typically crashes at JIT time.</span></span>

<span data-ttu-id="e04dd-202">[`stackalloc`](language-reference/keywords/stackalloc.md) で作成したメモリを使用するとき、あるいは相互運用 API からメモリを使用するとき、同様の要件が求められる場合があります。</span><span class="sxs-lookup"><span data-stu-id="e04dd-202">You may have similar requirements working with memory created using [`stackalloc`](language-reference/keywords/stackalloc.md) or when using memory from interop APIs.</span></span> <span data-ttu-id="e04dd-203">そのようなニーズには独自の `ref struct` 型を定義できます。</span><span class="sxs-lookup"><span data-stu-id="e04dd-203">You can define your own `ref struct` types for those needs.</span></span> <span data-ttu-id="e04dd-204">この記事の例では `Span<T>` を利用し、わかりやすくしています。</span><span class="sxs-lookup"><span data-stu-id="e04dd-204">In this article, you see examples using `Span<T>` for simplicity.</span></span>

<span data-ttu-id="e04dd-205">`ref struct` 宣言によって、この型の構造体はスタック上に置かなければならないことが宣言されます。</span><span class="sxs-lookup"><span data-stu-id="e04dd-205">The `ref struct` declaration declares that a struct of this type must be on the stack.</span></span> <span data-ttu-id="e04dd-206">言語規則により、この型が安全に使用されます。</span><span class="sxs-lookup"><span data-stu-id="e04dd-206">The language rules ensure the safe use of these types.</span></span> <span data-ttu-id="e04dd-207">`ref struct` として宣言されるその他の型には <xref:System.ReadOnlySpan%601> があります。</span><span class="sxs-lookup"><span data-stu-id="e04dd-207">Other types declared as `ref struct` include <xref:System.ReadOnlySpan%601>.</span></span> 

<span data-ttu-id="e04dd-208">スタック割り当て変数として `ref struct` 型を維持する目的の下、すべての `ref struct` 型にコンパイラが適用する規則がいくつか導入されます。</span><span class="sxs-lookup"><span data-stu-id="e04dd-208">The goal of keeping a `ref struct` type as a stack-allocated variable introduces several rules that the compiler enforces for all `ref struct` types.</span></span>

- <span data-ttu-id="e04dd-209">`ref struct` はボックス化できません。</span><span class="sxs-lookup"><span data-stu-id="e04dd-209">You can't box a `ref struct`.</span></span> <span data-ttu-id="e04dd-210">`object` 型、`dynamic` 型、またはあらゆるインターフェイス型の変数には、`ref struct` 型を割り当てることができません。</span><span class="sxs-lookup"><span data-stu-id="e04dd-210">You cannot assign a `ref struct` type to a variable of type `object`, `dynamic`, or any interface type.</span></span>
- <span data-ttu-id="e04dd-211">クラスまたは通常構造体のメンバーとして `ref struct` を宣言することはできません。</span><span class="sxs-lookup"><span data-stu-id="e04dd-211">You can't declare a `ref struct` as a member of a class or a normal struct.</span></span>
- <span data-ttu-id="e04dd-212">非同期メソッドでは、`ref struct` 型のローカル変数を宣言できません。</span><span class="sxs-lookup"><span data-stu-id="e04dd-212">You cannot declare local variables that are `ref struct` types in async methods.</span></span> <span data-ttu-id="e04dd-213">`Task`、`Task<T>`、あるいは Task のような型を返す同期メソッドで宣言できます。</span><span class="sxs-lookup"><span data-stu-id="e04dd-213">You can declare them in synchronous methods that return `Task`, `Task<T>` or Task-like types.</span></span>
- <span data-ttu-id="e04dd-214">反復子で `ref struct` ローカル変数を宣言することはできません。</span><span class="sxs-lookup"><span data-stu-id="e04dd-214">You cannot declare `ref struct` local variables in iterators.</span></span>
- <span data-ttu-id="e04dd-215">ラムダ式またはローカル関数で `ref struct` 変数をキャプチャすることはできません。</span><span class="sxs-lookup"><span data-stu-id="e04dd-215">You cannot capture `ref struct` variables in lambda expressions or local functions.</span></span>

<span data-ttu-id="e04dd-216">これらの制約によって、誤って、マネージ ヒープに昇格させるようなやり方で `ref struct` を使用することがなくなります。</span><span class="sxs-lookup"><span data-stu-id="e04dd-216">These restrictions ensure that you do not accidentally use a `ref struct` in a manner that could promote it to the managed heap.</span></span>

## <a name="conclusions"></a><span data-ttu-id="e04dd-217">まとめ</span><span class="sxs-lookup"><span data-stu-id="e04dd-217">Conclusions</span></span>

<span data-ttu-id="e04dd-218">C# 言語の以上の拡張機能は、必要なパフォーマンスの達成にメモリ割り当てが重要となる、パフォーマンス クリティカルなアルゴリズムのために設計されています。</span><span class="sxs-lookup"><span data-stu-id="e04dd-218">These enhancements to the C# language are designed for performance critical algorithms where memory allocations can be critical to achieving the necessary performance.</span></span> <span data-ttu-id="e04dd-219">自分が記述するコードではこれらの機能を頻繁に使用することがないかもしれません。</span><span class="sxs-lookup"><span data-stu-id="e04dd-219">You may find that you don't often use these features in the code you write.</span></span> <span data-ttu-id="e04dd-220">しかしながら、以上の拡張機能は、.NET Framework では、さまざまな場所で採用されています。</span><span class="sxs-lookup"><span data-stu-id="e04dd-220">However, these enhancements have been adopted in many locations in the .NET Framework.</span></span> <span data-ttu-id="e04dd-221">これらの機能を利用する API が増えれば、自分で作るアプリケーションのパフォーマンスが改善するでしょう。</span><span class="sxs-lookup"><span data-stu-id="e04dd-221">As more and more APIs make use of these features, you'll see the performance of your own applications improve.</span></span>
