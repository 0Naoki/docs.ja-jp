---
title: "値の型と参照セマンティクス"
description: "構造体のコピーを安全に最小限に抑える言語機能を理解します。"
author: billwagner
ms.author: wiwagn
ms.date: 11/10/2017
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.custom: mvc
ms.openlocfilehash: 9eeaf201c1f5a58044db62e356199b609c4c035a
ms.sourcegitcommit: 7e99f66ef09d2903e22c789c67ff5a10aa953b2f
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/18/2017
---
# <a name="reference-semantics-with-value-types"></a><span data-ttu-id="d8670-103">値の型と参照セマンティクス</span><span class="sxs-lookup"><span data-stu-id="d8670-103">Reference semantics with value types</span></span>

<span data-ttu-id="d8670-104">値の型を使用する利点は、通常ヒープ割り当てを回避します。</span><span class="sxs-lookup"><span data-stu-id="d8670-104">An advantage to using value types is that they often avoid heap allocations.</span></span>
<span data-ttu-id="d8670-105">対応する欠点は、値によってコピーされます。</span><span class="sxs-lookup"><span data-stu-id="d8670-105">The corresponding disadvantage is that they are copied by value.</span></span> <span data-ttu-id="d8670-106">このトレードオフが難しく大量のデータを操作するアルゴリズムを最適化するためにします。</span><span class="sxs-lookup"><span data-stu-id="d8670-106">This tradeoff makes it harder to optimize algorithms that operate on large amounts of data.</span></span> <span data-ttu-id="d8670-107">C# 7.2 の新しい言語機能は、値の型と参照渡しセマンティクスを有効にするメカニズムを提供します。</span><span class="sxs-lookup"><span data-stu-id="d8670-107">New language features in C# 7.2 provide mechanisms that enable pass-by-reference semantics with value types.</span></span> <span data-ttu-id="d8670-108">これらの機能を慎重に使用する場合は、両方の割り当てを最小化し、コピー操作できます。</span><span class="sxs-lookup"><span data-stu-id="d8670-108">If you use these features wisely you can minimize both allocations and copy operations.</span></span> <span data-ttu-id="d8670-109">この記事では、これらの新機能について説明します。</span><span class="sxs-lookup"><span data-stu-id="d8670-109">This article explores those new features.</span></span>

<span data-ttu-id="d8670-110">この記事のサンプル コードの多くには、c# 7.2 で追加された機能を示しています。</span><span class="sxs-lookup"><span data-stu-id="d8670-110">Much of the sample code in this article demonstrates features added in C# 7.2.</span></span> <span data-ttu-id="d8670-111">これらの機能を使用するのには、c# を使用して 7.2 またはそれ以降、プロジェクトのプロジェクトを構成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d8670-111">In order to use those features, you have to configure your project to use C# 7.2 or later in your project.</span></span> <span data-ttu-id="d8670-112">Visual Studio を使用すると、それを選択します。</span><span class="sxs-lookup"><span data-stu-id="d8670-112">You can use Visual Studio to select it.</span></span> <span data-ttu-id="d8670-113">プロジェクトごとに、選択**プロジェクト**し、メニューから**プロパティ**です。</span><span class="sxs-lookup"><span data-stu-id="d8670-113">For each project, select **Project** from the menu, then **Properties**.</span></span> <span data-ttu-id="d8670-114">選択、**ビルド** タブでをクリックし、**詳細**です。</span><span class="sxs-lookup"><span data-stu-id="d8670-114">Select the **Build** tab and click **Advanced**.</span></span> <span data-ttu-id="d8670-115">そこから、言語バージョンを構成することができます。</span><span class="sxs-lookup"><span data-stu-id="d8670-115">From there, you can configure the language version.</span></span> <span data-ttu-id="d8670-116">「7.2」または「最新」のいずれかを選択します。</span><span class="sxs-lookup"><span data-stu-id="d8670-116">Choose either "7.2", or "latest".</span></span>  <span data-ttu-id="d8670-117">または編集することができます、 *csproj*ファイルし、次のノードを追加します。</span><span class="sxs-lookup"><span data-stu-id="d8670-117">Or you can edit the *csproj* file and add the following node:</span></span>

```XML
  <PropertyGroup>
    <LangVersion>7.2</LangVersion>
  </PropertyGroup>
```

<span data-ttu-id="d8670-118">値の「7.2」または「最新」を使用することができます。</span><span class="sxs-lookup"><span data-stu-id="d8670-118">You can use either "7.2" or "latest" for the value.</span></span>

## <a name="specifying-in-parameters"></a><span data-ttu-id="d8670-119">指定する`in`パラメーター</span><span class="sxs-lookup"><span data-stu-id="d8670-119">Specifying `in` parameters</span></span>

<span data-ttu-id="d8670-120">C# 7.2 を追加、`in`既存を補完するためにキーワード`ref`と`out`キーワードが参照渡しの引数を渡すメソッドを記述するときにします。</span><span class="sxs-lookup"><span data-stu-id="d8670-120">C# 7.2 adds the `in` keyword to complement the existing `ref` and `out` keywords when you write a method that passes arguments by reference.</span></span> <span data-ttu-id="d8670-121">`in`キーワードは、参照渡しでパラメーターを渡しているし、呼び出されたメソッドが渡された値を変更していないことを指定します。</span><span class="sxs-lookup"><span data-stu-id="d8670-121">The `in` keyword specifies that you are passing the parameter by reference and the called method does not modify the value passed to it.</span></span> 

<span data-ttu-id="d8670-122">この追加は、設計意図の express に完全ボキャブラリを提供します。</span><span class="sxs-lookup"><span data-stu-id="d8670-122">This addition provides a full vocabulary to express your design intent.</span></span> <span data-ttu-id="d8670-123">次の修飾子のいずれかを指定しないときに呼び出されたメソッドに渡される値の型がコピーされます。</span><span class="sxs-lookup"><span data-stu-id="d8670-123">Value types are copied when passed to a called method when you do not specify any of the following modifiers.</span></span> <span data-ttu-id="d8670-124">これらの修飾子のそれぞれは、ある値の型が参照渡しで、コピーの回避を指定します。</span><span class="sxs-lookup"><span data-stu-id="d8670-124">Each of these modifiers specify that a value type is passed by reference, avoiding the copy.</span></span> <span data-ttu-id="d8670-125">各修飾子は、さまざまな目的を表します。</span><span class="sxs-lookup"><span data-stu-id="d8670-125">Each modifier expresses a different intent:</span></span>

- <span data-ttu-id="d8670-126">`out`: このメソッドは、このパラメーターとして使用される引数の値を設定します。</span><span class="sxs-lookup"><span data-stu-id="d8670-126">`out`: This method sets the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="d8670-127">`ref`: このメソッドは、このパラメーターとして使用される引数の値を設定可能性があります。</span><span class="sxs-lookup"><span data-stu-id="d8670-127">`ref`: This method may set the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="d8670-128">`in`: このメソッドは、このパラメーターとして使用される引数の値を変更できません。</span><span class="sxs-lookup"><span data-stu-id="d8670-128">`in`: This method does not modify the value of the argument used as this parameter.</span></span>

<span data-ttu-id="d8670-129">追加すると、`in`修飾子を追加、参照渡しの引数を渡す不必要なコピーを避けるために参照によって引数を渡すには、設計意図を宣言します。</span><span class="sxs-lookup"><span data-stu-id="d8670-129">When you add the `in` modifier to pass an argument by reference, you declare your design intent is to pass arguments by reference to avoid unnecessary copying.</span></span> <span data-ttu-id="d8670-130">その引数として使用するオブジェクトを変更するのにはしません。</span><span class="sxs-lookup"><span data-stu-id="d8670-130">You do not intend to modify the object used as that argument.</span></span> <span data-ttu-id="d8670-131">次のコードでは、3 D 空間内の 2 点間の距離を計算する方法の例を示します。</span><span class="sxs-lookup"><span data-stu-id="d8670-131">The following code shows an example of a method that calculates the distance between two points in 3D space.</span></span> 

[!code-csharp[InArgument](../../samples/csharp/reference-semantics/Program.cs#InArgument "Specifying an In argument")]

<span data-ttu-id="d8670-132">引数は、それぞれ 3 個の double を含む 2 つの構造です。</span><span class="sxs-lookup"><span data-stu-id="d8670-132">The arguments are two structures that each contain three doubles.</span></span> <span data-ttu-id="d8670-133">Double は 8 バイトで、各引数はの 24 バイトです。</span><span class="sxs-lookup"><span data-stu-id="d8670-133">A double is 8 bytes, so each argument is 24 bytes.</span></span> <span data-ttu-id="d8670-134">指定して、`in`修飾子は、4 バイトまたは 8 バイトへ参照を渡すこれらの引数では、コンピューターのアーキテクチャによって異なります。</span><span class="sxs-lookup"><span data-stu-id="d8670-134">By specifying the `in` modifier, you pass 4-byte or 8-byte reference to those arguments, depending on the architecture of the machine.</span></span> <span data-ttu-id="d8670-135">サイズの差が小さくが、アプリケーションは、多数の異なる値を使用してループの中でこのメソッドを呼び出すできます追加すばやく。</span><span class="sxs-lookup"><span data-stu-id="d8670-135">The difference in size is small, but it can quickly add up when your application calls this method in a tight loop using many different values.</span></span>
 
<span data-ttu-id="d8670-136">`in`修飾子補完`out`と`ref`他の方法でも同様にします。</span><span class="sxs-lookup"><span data-stu-id="d8670-136">The `in` modifier complements `out` and `ref` in other ways as well.</span></span> <span data-ttu-id="d8670-137">のみ存在している状態のとは異なるメソッドのオーバー ロードを作成することはできません`in`、`out`または`ref`です。</span><span class="sxs-lookup"><span data-stu-id="d8670-137">You cannot create overloads of a method that differ only in the presence of `in`, `out` or `ref`.</span></span> <span data-ttu-id="d8670-138">これらの新しい規則が常に定義されていた同じ動作を拡張`out`と`ref`パラメーター。</span><span class="sxs-lookup"><span data-stu-id="d8670-138">These new rules extend the same behavior that had always been defined for `out` and `ref` parameters.</span></span>

<span data-ttu-id="d8670-139">`in`修飾子はパラメーターを受け取るすべてのメンバーに適用する: メソッド、デリゲート、ラムダ、ローカル関数、インデクサー、演算子。</span><span class="sxs-lookup"><span data-stu-id="d8670-139">The `in` modifier may be applied to any member that takes parameters: methods, delegates, lambdas, local functions, indexers, operators.</span></span>

<span data-ttu-id="d8670-140">異なり`ref`と`out`引数を使用することがリテラル値または定数の引数、`in`パラメーター。</span><span class="sxs-lookup"><span data-stu-id="d8670-140">Unlike `ref` and `out` arguments, you may use literal values or constants for the argument to an `in` parameter.</span></span> <span data-ttu-id="d8670-141">またとは異なり、`ref`または`out`を適用する必要ありません、パラメーター、`in`呼び出しサイトでの修飾子です。</span><span class="sxs-lookup"><span data-stu-id="d8670-141">Also, unlike a `ref` or `out` parameter, you don't need to apply the `in` modifier at the call site.</span></span> <span data-ttu-id="d8670-142">次のコードは、呼び出し元の 2 つの例を示します、`CalculateDistance`メソッドです。</span><span class="sxs-lookup"><span data-stu-id="d8670-142">The following code shows you two examples of calling the `CalculateDistance` method.</span></span> <span data-ttu-id="d8670-143">1 つ目は、参照によって渡される 2 つのローカル変数を使用します。</span><span class="sxs-lookup"><span data-stu-id="d8670-143">The first uses two local variables passed by reference.</span></span> <span data-ttu-id="d8670-144">2 つ目には、メソッド呼び出しの一部として作成された一時変数が含まれています。</span><span class="sxs-lookup"><span data-stu-id="d8670-144">The second includes a temporary variable created as part of the method call.</span></span> 

[!code-csharp[UseInArgument](../../samples/csharp/reference-semantics/Program.cs#UseInArgument "Specifying an In argument")]

<span data-ttu-id="d8670-145">いくつかの方法をコンパイラは、確認を読み取り専用の性質がある、`in`引数が適用されます。</span><span class="sxs-lookup"><span data-stu-id="d8670-145">There are several ways in which the compiler ensures that the read-only nature of an `in` argument is enforced.</span></span>  <span data-ttu-id="d8670-146">最初に、呼び出されたメソッドに割り当てることはできません直接、`in`パラメーター。</span><span class="sxs-lookup"><span data-stu-id="d8670-146">First of all, the called method can't directly assign to an `in` parameter.</span></span> <span data-ttu-id="d8670-147">すべてのフィールドを直接割り当てることはできませんが、`in`パラメーター。</span><span class="sxs-lookup"><span data-stu-id="d8670-147">It can't directly assign to any field of an `in` parameter.</span></span> <span data-ttu-id="d8670-148">さらに、渡すことはできません、`in`に必要なすべてのメソッド パラメーター、`ref`または`out`修飾子です。</span><span class="sxs-lookup"><span data-stu-id="d8670-148">In addition, you cannot pass an `in` parameter to any method demanding the `ref` or `out` modifier.</span></span>
<span data-ttu-id="d8670-149">コンパイラは、`in`引数は読み取り専用変数です。</span><span class="sxs-lookup"><span data-stu-id="d8670-149">The compiler enforces that the `in` argument is a readonly variable.</span></span> <span data-ttu-id="d8670-150">値渡しのセマンティクスを使用する任意のインスタンス メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="d8670-150">You can call any instance method that uses pass-by-value semantics.</span></span> <span data-ttu-id="d8670-151">これらのインスタンスのコピーで、`in`パラメーターを作成します。</span><span class="sxs-lookup"><span data-stu-id="d8670-151">In those instances, a copy of the `in` parameter is created.</span></span> <span data-ttu-id="d8670-152">コンパイラは、いずれかの一時変数を作成できるので`in`パラメーターのいずれかの既定値を指定することも`in`パラメーター。</span><span class="sxs-lookup"><span data-stu-id="d8670-152">Because the compiler can create a temporary variable for any `in` parameter, you can also specify default values for any `in` parameter.</span></span> <span data-ttu-id="d8670-153">次のコードは、2 番目のポイントの既定値として、原点 (ポイント 0, 0) を指定するのにを使用します。</span><span class="sxs-lookup"><span data-stu-id="d8670-153">The follow code uses that to specify the origin (point 0,0) as the default value for the second point:</span></span>

[!code-csharp[InArgumentDefault](../../samples/csharp/reference-semantics/Program.cs#InArgumentDefault "Specifying defaults for an in parameter")]

<span data-ttu-id="d8670-154">`in`パラメーターの指定も参照型で使用または組み込みの数値を指定します。</span><span class="sxs-lookup"><span data-stu-id="d8670-154">The `in` parameter designation can also be used with reference types or built in numeric values.</span></span> <span data-ttu-id="d8670-155">ただし、どちらの場合も利点は、存在する場合は最小限です。</span><span class="sxs-lookup"><span data-stu-id="d8670-155">However, the benefits in both cases are minimal, if any.</span></span>

## <a name="ref-readonly-returns"></a><span data-ttu-id="d8670-156">`ref readonly`返します。</span><span class="sxs-lookup"><span data-stu-id="d8670-156">`ref readonly` returns</span></span>

<span data-ttu-id="d8670-157">参照によって値型を返しますが、その値を変更するを呼び出し元を許可しないようにすることもできます。</span><span class="sxs-lookup"><span data-stu-id="d8670-157">You may also want to return a value type by reference, but disallow the caller from modifying that value.</span></span> <span data-ttu-id="d8670-158">使用して、`ref readonly`その設計意図を表現する修飾子です。</span><span class="sxs-lookup"><span data-stu-id="d8670-158">Use the `ref readonly` modifier to express that design intent.</span></span> <span data-ttu-id="d8670-159">既存のデータへの参照を返すことが変更を許可していませんが、リーダーを通知します。</span><span class="sxs-lookup"><span data-stu-id="d8670-159">It notifies readers that you are returning a reference to existing data, but not allowing modification.</span></span> 

<span data-ttu-id="d8670-160">コンパイラは、呼び出し元が、参照を変更できないことを強制します。</span><span class="sxs-lookup"><span data-stu-id="d8670-160">The compiler enforces that the caller cannot modify the reference.</span></span> <span data-ttu-id="d8670-161">値に直接割り当てを試行は、コンパイル時のエラーを生成します。</span><span class="sxs-lookup"><span data-stu-id="d8670-161">Attempts to assign to the value directly generate a compile-time error.</span></span> <span data-ttu-id="d8670-162">ただし、コンパイラは、任意のメンバーではメソッドが、構造体の状態を変更するかどうかを知ることはできません。</span><span class="sxs-lookup"><span data-stu-id="d8670-162">However, the compiler cannot know if any member method modifies the state of the struct.</span></span>
<span data-ttu-id="d8670-163">オブジェクトが変更されていないためには、コンパイラは、コピーを作成し、そのコピーを使用して参照メンバーを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="d8670-163">To ensure that the object is not modified, the compiler creates a copy and calls member references using that copy.</span></span> <span data-ttu-id="d8670-164">すべての変更は、その防御的コピーには。</span><span class="sxs-lookup"><span data-stu-id="d8670-164">Any modifications are to that defensive copy.</span></span> 

<span data-ttu-id="d8670-165">可能性がありますするライブラリを使用して、`Point3D`は多くの場合、コード全体で配信元を使用します。</span><span class="sxs-lookup"><span data-stu-id="d8670-165">It's likely that the library using `Point3D` would often use the origin throughout the code.</span></span> <span data-ttu-id="d8670-166">すべてのインスタンスは、スタックを新しいオブジェクトを作成します。</span><span class="sxs-lookup"><span data-stu-id="d8670-166">Every instance creates a new object on the stack.</span></span> <span data-ttu-id="d8670-167">定数を作成し、参照渡しで返すと便利な場合があります。</span><span class="sxs-lookup"><span data-stu-id="d8670-167">It may be advantageous to create a constant and return it by reference.</span></span> <span data-ttu-id="d8670-168">しかし、内部記憶域への参照を返す場合、呼び出し元が参照されている記憶域を変更できないことを強制することがあります。</span><span class="sxs-lookup"><span data-stu-id="d8670-168">But, if you return a reference to internal storage, you may want to enforce that the caller cannot modify the referenced storage.</span></span> <span data-ttu-id="d8670-169">次のコードを返す読み取り専用のプロパティを定義する、`readonly ref`を`Point3D`配信元を指定します。</span><span class="sxs-lookup"><span data-stu-id="d8670-169">The following code defines a read-only property that returns a `readonly ref` to a `Point3D` that specifies the origin.</span></span>

[!code-csharp[OriginReference](../../samples/csharp/reference-semantics/Point3D.cs#OriginReference "Creating a readonly Origin reference")]

<span data-ttu-id="d8670-170">戻り値、ref を読み取り専用のコピーの作成は簡単: で宣言されていない変数に割り当てるだけ、`ref readonly`修飾子です。</span><span class="sxs-lookup"><span data-stu-id="d8670-170">Creating a copy of a ref readonly return is easy: Just assign it to a variable not declared with the `ref readonly` modifier.</span></span> <span data-ttu-id="d8670-171">コンパイラは、割り当ての一部として、オブジェクトをコピーするコードを生成します。</span><span class="sxs-lookup"><span data-stu-id="d8670-171">The compiler generates code to copy the object as part of the assignment.</span></span> 

<span data-ttu-id="d8670-172">変数を割り当てると、 `ref readonly return`、どちらかを指定することができます、`ref readonly`変数、または読み取り専用の参照の値によってコピー。</span><span class="sxs-lookup"><span data-stu-id="d8670-172">When you assign a variable to a `ref readonly return`, you can specify either a `ref readonly` variable, or a by-value copy of the readonly reference:</span></span>

[!code-csharp[AssignRefReadonly](../../samples/csharp/reference-semantics/Program.cs#AssignRefReadonly "Assigning a ref readonly")]

<span data-ttu-id="d8670-173">上記のコードの最初の割り当てのコピーを作成する、`Origin`定数とコピー代入します。</span><span class="sxs-lookup"><span data-stu-id="d8670-173">The first assignment in the preceding code makes a copy of the `Origin` constant and assigns that copy.</span></span> <span data-ttu-id="d8670-174">2 つ目は、参照を割り当てます。</span><span class="sxs-lookup"><span data-stu-id="d8670-174">The second assigns a reference.</span></span> <span data-ttu-id="d8670-175">注意して、`readonly`修飾子は、変数の宣言の一部である必要があります。</span><span class="sxs-lookup"><span data-stu-id="d8670-175">Notice that the `readonly` modifier must be part of the declaration of the variable.</span></span> <span data-ttu-id="d8670-176">これは参照の参照を変更できません。</span><span class="sxs-lookup"><span data-stu-id="d8670-176">The reference to which it refers cannot be modified.</span></span> <span data-ttu-id="d8670-177">これを行うとは、コンパイル時にエラー発生します。</span><span class="sxs-lookup"><span data-stu-id="d8670-177">Attempts to do so result in a compile-time error.</span></span>

## <a name="readonly-struct-type"></a><span data-ttu-id="d8670-178">`readonly struct` 型</span><span class="sxs-lookup"><span data-stu-id="d8670-178">`readonly struct` type</span></span>

<span data-ttu-id="d8670-179">適用する`ref readonly`を構造体のトラフィック量が多い使用するには十分なする可能性があります。</span><span class="sxs-lookup"><span data-stu-id="d8670-179">Applying `ref readonly` to high-traffic uses of a struct may be sufficient.</span></span>
<span data-ttu-id="d8670-180">それ以外の時間を変更できないの構造体を作成できます。</span><span class="sxs-lookup"><span data-stu-id="d8670-180">Other times, you may want to create an immutable struct.</span></span> <span data-ttu-id="d8670-181">常に読み取り専用の参照渡しで渡すことができます。</span><span class="sxs-lookup"><span data-stu-id="d8670-181">Then you can always pass by readonly reference.</span></span> <span data-ttu-id="d8670-182">として使用される構造体のメソッドにアクセスするときに、その行わをコピー実習が守勢を削除する、`in`パラメーター。</span><span class="sxs-lookup"><span data-stu-id="d8670-182">That practice removes the defensive copies that take place when you access methods of a struct used as an `in` parameter.</span></span>

<span data-ttu-id="d8670-183">作成することができます、`readonly struct`型です。</span><span class="sxs-lookup"><span data-stu-id="d8670-183">You can do that by creating a `readonly struct` type.</span></span> <span data-ttu-id="d8670-184">追加することができます、`readonly`構造体の宣言に修飾子です。</span><span class="sxs-lookup"><span data-stu-id="d8670-184">You can add the `readonly` modifier to a struct declaration.</span></span> <span data-ttu-id="d8670-185">コンパイラは構造体のすべてのメンバーによって適用`readonly`;`struct`不変である必要があります。</span><span class="sxs-lookup"><span data-stu-id="d8670-185">The compiler enforces that all members of the struct are `readonly`; the `struct` must be immutable.</span></span>

<span data-ttu-id="d8670-186">その他の最適化がある、`readonly struct`です。</span><span class="sxs-lookup"><span data-stu-id="d8670-186">There are other optimizations for a `readonly struct`.</span></span> <span data-ttu-id="d8670-187">使用することができます、`in`すべての場所に修飾子を`readonly struct`引数です。</span><span class="sxs-lookup"><span data-stu-id="d8670-187">You can use the `in` modifier at every location where a `readonly struct` is an argument.</span></span> <span data-ttu-id="d8670-188">さらに戻ることができます、`readonly struct`として、`ref return`の有効期間が、オブジェクトを返すメソッドのスコープを越えるオブジェクトを取得するときにします。</span><span class="sxs-lookup"><span data-stu-id="d8670-188">In addition, you can return a `readonly struct` as a `ref return` when you are returning an object whose lifetime extends beyond the scope of the method returning the object.</span></span>

<span data-ttu-id="d8670-189">メンバーを呼び出すときに、コンパイラがより効率的なコードを生成する最後に、 `readonly struct`: `this` 、レシーバーのコピーではなく、参照は、常に、`in`メンバー メソッドへの参照で渡されるパラメーター。</span><span class="sxs-lookup"><span data-stu-id="d8670-189">Finally, the compiler generates more efficient code when you call members of a `readonly struct`: The `this` reference, instead of a copy of the receiver, is always an `in` parameter passed by reference to the member method.</span></span> <span data-ttu-id="d8670-190">この最適化が使用すると、詳細コピーを保存、`readonly struct`です。</span><span class="sxs-lookup"><span data-stu-id="d8670-190">This optimization saves more copying when you use a `readonly struct`.</span></span> <span data-ttu-id="d8670-191">`Point3D`は、この変更の最適な候補です。</span><span class="sxs-lookup"><span data-stu-id="d8670-191">The `Point3D` is a great candidate for this change.</span></span> <span data-ttu-id="d8670-192">次のコードは、更新された`ReadonlyPoint3D`構造体。</span><span class="sxs-lookup"><span data-stu-id="d8670-192">The following code shows an updated `ReadonlyPoint3D` structure:</span></span>

[!code-csharp[ReadonlyOnlyPoint3D](../../samples/csharp/reference-semantics/Point3D.cs#ReadonlyOnlyPoint3D "Defining an immutable structure")]

## <a name="ref-struct-type"></a><span data-ttu-id="d8670-193">`ref struct` 型</span><span class="sxs-lookup"><span data-stu-id="d8670-193">`ref struct` type</span></span>

<span data-ttu-id="d8670-194">もう 1 つの関連する言語機能は、割り当てられたスタックをする必要がある値型を宣言する機能です。</span><span class="sxs-lookup"><span data-stu-id="d8670-194">Another related language feature is the ability to declare a value type that must be stack allocated.</span></span> <span data-ttu-id="d8670-195">つまり、これらの型作成できません、ヒープ上の別のクラスのメンバーとして。</span><span class="sxs-lookup"><span data-stu-id="d8670-195">In other words, these types can never be created on the heap as a member of another class.</span></span> <span data-ttu-id="d8670-196">この機能の主要な動機が<xref:System.Span%601>し、関連する構造。</span><span class="sxs-lookup"><span data-stu-id="d8670-196">The primary motivation for this feature was <xref:System.Span%601> and related structures.</span></span> <span data-ttu-id="d8670-197"><xref:System.Span%601>含めることは、マネージ ポインターそのメンバーの 1 つとして、もう一方はスパンの長さ。</span><span class="sxs-lookup"><span data-stu-id="d8670-197"><xref:System.Span%601> may contain a managed pointer as one of its members, the other being the length of the span.</span></span> <span data-ttu-id="d8670-198">実際に実装が若干異なる c# サポートしていないため、unsafe コンテキストの外部で管理されたメモリへのポインター。</span><span class="sxs-lookup"><span data-stu-id="d8670-198">It's actually implemented a bit differently because C# doesn't support pointers to managed memory outside of an unsafe context.</span></span> <span data-ttu-id="d8670-199">ポインターと長さを変更する任意の書き込みがアトミックではないです。</span><span class="sxs-lookup"><span data-stu-id="d8670-199">Any write that changes the pointer and the length is not atomic.</span></span> <span data-ttu-id="d8670-200">つまり、<xref:System.Span%601>不足のエラーの範囲が対象になるか、他の型の安全性違反が 1 つのスタック フレームに制限されません。</span><span class="sxs-lookup"><span data-stu-id="d8670-200">That means a <xref:System.Span%601> would be subject to out of range errors or other type safety violations were it not constrained to a single stack frame.</span></span> <span data-ttu-id="d8670-201">さらに、GC ヒープでマネージ ポインターを配置すると、通常は、JIT 時にクラッシュします。</span><span class="sxs-lookup"><span data-stu-id="d8670-201">In addition, putting a managed pointer on the GC heap typically crashes at JIT time.</span></span>

<span data-ttu-id="d8670-202">同様の要件を使用して作成されたメモリを使用する必要があります[ `stackalloc` ](language-reference/keywords/stackalloc.md)相互運用 Api からメモリを使用する場合またはします。</span><span class="sxs-lookup"><span data-stu-id="d8670-202">You may have similar requirements working with memory created using [`stackalloc`](language-reference/keywords/stackalloc.md) or when using memory from interop APIs.</span></span> <span data-ttu-id="d8670-203">独自に定義することができます`ref struct`ニーズの型。</span><span class="sxs-lookup"><span data-stu-id="d8670-203">You can define your own `ref struct` types for those needs.</span></span> <span data-ttu-id="d8670-204">この記事の使用例が参照してください。`Span<T>`わかりやすくするためです。</span><span class="sxs-lookup"><span data-stu-id="d8670-204">In this article, you see examples using `Span<T>` for simplicity.</span></span>

<span data-ttu-id="d8670-205">`ref struct`宣言ではこの型の構造体は、スタックにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="d8670-205">The `ref struct` declaration declares that a struct of this type must be on the stack.</span></span> <span data-ttu-id="d8670-206">言語の規則では、これらの型の安全な使用を確認します。</span><span class="sxs-lookup"><span data-stu-id="d8670-206">The language rules ensure the safe use of these types.</span></span> <span data-ttu-id="d8670-207">として宣言されているその他の種類`ref struct`含める<xref:System.ReadOnlySpan%601>です。</span><span class="sxs-lookup"><span data-stu-id="d8670-207">Other types declared as `ref struct` include <xref:System.ReadOnlySpan%601>.</span></span> 

<span data-ttu-id="d8670-208">管理の目的、`ref struct`入力スタック割り当て変数には、コンパイラによってすべてに適用されるいくつかのルールが導入されています`ref struct`型です。</span><span class="sxs-lookup"><span data-stu-id="d8670-208">The goal of keeping a `ref struct` type as a stack-allocated variable introduces several rules that the compiler enforces for all `ref struct` types.</span></span>

- <span data-ttu-id="d8670-209">ボックスことはできません、`ref struct`です。</span><span class="sxs-lookup"><span data-stu-id="d8670-209">You can't box a `ref struct`.</span></span> <span data-ttu-id="d8670-210">割り当てることはできません、`ref struct`型の変数に型`object`、 `dynamic`、または任意のインターフェイス型です。</span><span class="sxs-lookup"><span data-stu-id="d8670-210">You cannot assign a `ref struct` type to a variable of type `object`, `dynamic`, or any interface type.</span></span>
- <span data-ttu-id="d8670-211">宣言することはできません、`ref struct`クラスまたは構造体を通常のメンバーとして。</span><span class="sxs-lookup"><span data-stu-id="d8670-211">You can't declare a `ref struct` as a member of a class or a normal struct.</span></span>
- <span data-ttu-id="d8670-212">ローカル変数を宣言することはできません`ref struct`非同期メソッドの型。</span><span class="sxs-lookup"><span data-stu-id="d8670-212">You cannot declare local variables that are `ref struct` types in async methods.</span></span> <span data-ttu-id="d8670-213">返す同期メソッドにそれを宣言することができます`Task`、`Task<T>`またはタスクのような型です。</span><span class="sxs-lookup"><span data-stu-id="d8670-213">You can declare them in synchronous methods that return `Task`, `Task<T>` or Task-like types.</span></span>
- <span data-ttu-id="d8670-214">宣言することはできません`ref struct`反復子のローカル変数。</span><span class="sxs-lookup"><span data-stu-id="d8670-214">You cannot declare `ref struct` local variables in iterators.</span></span>
- <span data-ttu-id="d8670-215">キャプチャすることはできません`ref struct`ラムダ式またはローカル関数内の変数です。</span><span class="sxs-lookup"><span data-stu-id="d8670-215">You cannot capture `ref struct` variables in lambda expressions or local functions.</span></span>

<span data-ttu-id="d8670-216">これらの制限は、誤って使用しないことを確認、`ref struct`でしたが、マネージ ヒープに昇格するようにします。</span><span class="sxs-lookup"><span data-stu-id="d8670-216">These restrictions ensure that you do not accidentally use a `ref struct` in a manner that could promote it to the managed heap.</span></span>

## <a name="conclusions"></a><span data-ttu-id="d8670-217">まとめ</span><span class="sxs-lookup"><span data-stu-id="d8670-217">Conclusions</span></span>

<span data-ttu-id="d8670-218">パフォーマンスの重大なアルゴリズムが、メモリ割り当てが必要なパフォーマンスを実現するために重要になることは、c# 言語にこれらの拡張機能が設計されています。</span><span class="sxs-lookup"><span data-stu-id="d8670-218">These enhancements to the C# language are designed for performance critical algorithms where memory allocations can be critical to achieving the necessary performance.</span></span> <span data-ttu-id="d8670-219">多くの場合、記述するコードでこれらの機能を使用しないことがあります。</span><span class="sxs-lookup"><span data-stu-id="d8670-219">You may find that you don't often use these features in the code you write.</span></span> <span data-ttu-id="d8670-220">ただし、.NET Framework のさまざまな場所では、これらの拡張機能が採用されました。</span><span class="sxs-lookup"><span data-stu-id="d8670-220">However, these enhancements have been adopted in many locations in the .NET Framework.</span></span> <span data-ttu-id="d8670-221">ますます多くの Api でこれらの機能を使用して、独自のアプリケーションのパフォーマンスを向上させるが表示されます。</span><span class="sxs-lookup"><span data-stu-id="d8670-221">As more and more APIs make use of these features, you'll see the performance of your own applications improve.</span></span>
