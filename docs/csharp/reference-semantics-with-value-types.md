---
title: "値の型と参照セマンティクス"
description: "構造体のコピーを安全に最小限に抑える言語機能を理解します。"
author: billwagner
ms.author: wiwagn
ms.date: 11/10/2017
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.custom: mvc
ms.openlocfilehash: 9eeaf201c1f5a58044db62e356199b609c4c035a
ms.sourcegitcommit: 7e99f66ef09d2903e22c789c67ff5a10aa953b2f
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/18/2017
---
# <a name="reference-semantics-with-value-types"></a>値の型と参照セマンティクス

値の型を使用する利点は、通常ヒープ割り当てを回避します。
対応する欠点は、値によってコピーされます。 このトレードオフが難しく大量のデータを操作するアルゴリズムを最適化するためにします。 C# 7.2 の新しい言語機能は、値の型と参照渡しセマンティクスを有効にするメカニズムを提供します。 これらの機能を慎重に使用する場合は、両方の割り当てを最小化し、コピー操作できます。 この記事では、これらの新機能について説明します。

この記事のサンプル コードの多くには、c# 7.2 で追加された機能を示しています。 これらの機能を使用するのには、c# を使用して 7.2 またはそれ以降、プロジェクトのプロジェクトを構成する必要があります。 Visual Studio を使用すると、それを選択します。 プロジェクトごとに、選択**プロジェクト**し、メニューから**プロパティ**です。 選択、**ビルド** タブでをクリックし、**詳細**です。 そこから、言語バージョンを構成することができます。 「7.2」または「最新」のいずれかを選択します。  または編集することができます、 *csproj*ファイルし、次のノードを追加します。

```XML
  <PropertyGroup>
    <LangVersion>7.2</LangVersion>
  </PropertyGroup>
```

値の「7.2」または「最新」を使用することができます。

## <a name="specifying-in-parameters"></a>指定する`in`パラメーター

C# 7.2 を追加、`in`既存を補完するためにキーワード`ref`と`out`キーワードが参照渡しの引数を渡すメソッドを記述するときにします。 `in`キーワードは、参照渡しでパラメーターを渡しているし、呼び出されたメソッドが渡された値を変更していないことを指定します。 

この追加は、設計意図の express に完全ボキャブラリを提供します。 次の修飾子のいずれかを指定しないときに呼び出されたメソッドに渡される値の型がコピーされます。 これらの修飾子のそれぞれは、ある値の型が参照渡しで、コピーの回避を指定します。 各修飾子は、さまざまな目的を表します。

- `out`: このメソッドは、このパラメーターとして使用される引数の値を設定します。
- `ref`: このメソッドは、このパラメーターとして使用される引数の値を設定可能性があります。
- `in`: このメソッドは、このパラメーターとして使用される引数の値を変更できません。

追加すると、`in`修飾子を追加、参照渡しの引数を渡す不必要なコピーを避けるために参照によって引数を渡すには、設計意図を宣言します。 その引数として使用するオブジェクトを変更するのにはしません。 次のコードでは、3 D 空間内の 2 点間の距離を計算する方法の例を示します。 

[!code-csharp[InArgument](../../samples/csharp/reference-semantics/Program.cs#InArgument "Specifying an In argument")]

引数は、それぞれ 3 個の double を含む 2 つの構造です。 Double は 8 バイトで、各引数はの 24 バイトです。 指定して、`in`修飾子は、4 バイトまたは 8 バイトへ参照を渡すこれらの引数では、コンピューターのアーキテクチャによって異なります。 サイズの差が小さくが、アプリケーションは、多数の異なる値を使用してループの中でこのメソッドを呼び出すできます追加すばやく。
 
`in`修飾子補完`out`と`ref`他の方法でも同様にします。 のみ存在している状態のとは異なるメソッドのオーバー ロードを作成することはできません`in`、`out`または`ref`です。 これらの新しい規則が常に定義されていた同じ動作を拡張`out`と`ref`パラメーター。

`in`修飾子はパラメーターを受け取るすべてのメンバーに適用する: メソッド、デリゲート、ラムダ、ローカル関数、インデクサー、演算子。

異なり`ref`と`out`引数を使用することがリテラル値または定数の引数、`in`パラメーター。 またとは異なり、`ref`または`out`を適用する必要ありません、パラメーター、`in`呼び出しサイトでの修飾子です。 次のコードは、呼び出し元の 2 つの例を示します、`CalculateDistance`メソッドです。 1 つ目は、参照によって渡される 2 つのローカル変数を使用します。 2 つ目には、メソッド呼び出しの一部として作成された一時変数が含まれています。 

[!code-csharp[UseInArgument](../../samples/csharp/reference-semantics/Program.cs#UseInArgument "Specifying an In argument")]

いくつかの方法をコンパイラは、確認を読み取り専用の性質がある、`in`引数が適用されます。  最初に、呼び出されたメソッドに割り当てることはできません直接、`in`パラメーター。 すべてのフィールドを直接割り当てることはできませんが、`in`パラメーター。 さらに、渡すことはできません、`in`に必要なすべてのメソッド パラメーター、`ref`または`out`修飾子です。
コンパイラは、`in`引数は読み取り専用変数です。 値渡しのセマンティクスを使用する任意のインスタンス メソッドを呼び出すことができます。 これらのインスタンスのコピーで、`in`パラメーターを作成します。 コンパイラは、いずれかの一時変数を作成できるので`in`パラメーターのいずれかの既定値を指定することも`in`パラメーター。 次のコードは、2 番目のポイントの既定値として、原点 (ポイント 0, 0) を指定するのにを使用します。

[!code-csharp[InArgumentDefault](../../samples/csharp/reference-semantics/Program.cs#InArgumentDefault "Specifying defaults for an in parameter")]

`in`パラメーターの指定も参照型で使用または組み込みの数値を指定します。 ただし、どちらの場合も利点は、存在する場合は最小限です。

## <a name="ref-readonly-returns"></a>`ref readonly`返します。

参照によって値型を返しますが、その値を変更するを呼び出し元を許可しないようにすることもできます。 使用して、`ref readonly`その設計意図を表現する修飾子です。 既存のデータへの参照を返すことが変更を許可していませんが、リーダーを通知します。 

コンパイラは、呼び出し元が、参照を変更できないことを強制します。 値に直接割り当てを試行は、コンパイル時のエラーを生成します。 ただし、コンパイラは、任意のメンバーではメソッドが、構造体の状態を変更するかどうかを知ることはできません。
オブジェクトが変更されていないためには、コンパイラは、コピーを作成し、そのコピーを使用して参照メンバーを呼び出します。 すべての変更は、その防御的コピーには。 

可能性がありますするライブラリを使用して、`Point3D`は多くの場合、コード全体で配信元を使用します。 すべてのインスタンスは、スタックを新しいオブジェクトを作成します。 定数を作成し、参照渡しで返すと便利な場合があります。 しかし、内部記憶域への参照を返す場合、呼び出し元が参照されている記憶域を変更できないことを強制することがあります。 次のコードを返す読み取り専用のプロパティを定義する、`readonly ref`を`Point3D`配信元を指定します。

[!code-csharp[OriginReference](../../samples/csharp/reference-semantics/Point3D.cs#OriginReference "Creating a readonly Origin reference")]

戻り値、ref を読み取り専用のコピーの作成は簡単: で宣言されていない変数に割り当てるだけ、`ref readonly`修飾子です。 コンパイラは、割り当ての一部として、オブジェクトをコピーするコードを生成します。 

変数を割り当てると、 `ref readonly return`、どちらかを指定することができます、`ref readonly`変数、または読み取り専用の参照の値によってコピー。

[!code-csharp[AssignRefReadonly](../../samples/csharp/reference-semantics/Program.cs#AssignRefReadonly "Assigning a ref readonly")]

上記のコードの最初の割り当てのコピーを作成する、`Origin`定数とコピー代入します。 2 つ目は、参照を割り当てます。 注意して、`readonly`修飾子は、変数の宣言の一部である必要があります。 これは参照の参照を変更できません。 これを行うとは、コンパイル時にエラー発生します。

## <a name="readonly-struct-type"></a>`readonly struct` 型

適用する`ref readonly`を構造体のトラフィック量が多い使用するには十分なする可能性があります。
それ以外の時間を変更できないの構造体を作成できます。 常に読み取り専用の参照渡しで渡すことができます。 として使用される構造体のメソッドにアクセスするときに、その行わをコピー実習が守勢を削除する、`in`パラメーター。

作成することができます、`readonly struct`型です。 追加することができます、`readonly`構造体の宣言に修飾子です。 コンパイラは構造体のすべてのメンバーによって適用`readonly`;`struct`不変である必要があります。

その他の最適化がある、`readonly struct`です。 使用することができます、`in`すべての場所に修飾子を`readonly struct`引数です。 さらに戻ることができます、`readonly struct`として、`ref return`の有効期間が、オブジェクトを返すメソッドのスコープを越えるオブジェクトを取得するときにします。

メンバーを呼び出すときに、コンパイラがより効率的なコードを生成する最後に、 `readonly struct`: `this` 、レシーバーのコピーではなく、参照は、常に、`in`メンバー メソッドへの参照で渡されるパラメーター。 この最適化が使用すると、詳細コピーを保存、`readonly struct`です。 `Point3D`は、この変更の最適な候補です。 次のコードは、更新された`ReadonlyPoint3D`構造体。

[!code-csharp[ReadonlyOnlyPoint3D](../../samples/csharp/reference-semantics/Point3D.cs#ReadonlyOnlyPoint3D "Defining an immutable structure")]

## <a name="ref-struct-type"></a>`ref struct` 型

もう 1 つの関連する言語機能は、割り当てられたスタックをする必要がある値型を宣言する機能です。 つまり、これらの型作成できません、ヒープ上の別のクラスのメンバーとして。 この機能の主要な動機が<xref:System.Span%601>し、関連する構造。 <xref:System.Span%601>含めることは、マネージ ポインターそのメンバーの 1 つとして、もう一方はスパンの長さ。 実際に実装が若干異なる c# サポートしていないため、unsafe コンテキストの外部で管理されたメモリへのポインター。 ポインターと長さを変更する任意の書き込みがアトミックではないです。 つまり、<xref:System.Span%601>不足のエラーの範囲が対象になるか、他の型の安全性違反が 1 つのスタック フレームに制限されません。 さらに、GC ヒープでマネージ ポインターを配置すると、通常は、JIT 時にクラッシュします。

同様の要件を使用して作成されたメモリを使用する必要があります[ `stackalloc` ](language-reference/keywords/stackalloc.md)相互運用 Api からメモリを使用する場合またはします。 独自に定義することができます`ref struct`ニーズの型。 この記事の使用例が参照してください。`Span<T>`わかりやすくするためです。

`ref struct`宣言ではこの型の構造体は、スタックにする必要があります。 言語の規則では、これらの型の安全な使用を確認します。 として宣言されているその他の種類`ref struct`含める<xref:System.ReadOnlySpan%601>です。 

管理の目的、`ref struct`入力スタック割り当て変数には、コンパイラによってすべてに適用されるいくつかのルールが導入されています`ref struct`型です。

- ボックスことはできません、`ref struct`です。 割り当てることはできません、`ref struct`型の変数に型`object`、 `dynamic`、または任意のインターフェイス型です。
- 宣言することはできません、`ref struct`クラスまたは構造体を通常のメンバーとして。
- ローカル変数を宣言することはできません`ref struct`非同期メソッドの型。 返す同期メソッドにそれを宣言することができます`Task`、`Task<T>`またはタスクのような型です。
- 宣言することはできません`ref struct`反復子のローカル変数。
- キャプチャすることはできません`ref struct`ラムダ式またはローカル関数内の変数です。

これらの制限は、誤って使用しないことを確認、`ref struct`でしたが、マネージ ヒープに昇格するようにします。

## <a name="conclusions"></a>まとめ

パフォーマンスの重大なアルゴリズムが、メモリ割り当てが必要なパフォーマンスを実現するために重要になることは、c# 言語にこれらの拡張機能が設計されています。 多くの場合、記述するコードでこれらの機能を使用しないことがあります。 ただし、.NET Framework のさまざまな場所では、これらの拡張機能が採用されました。 ますます多くの Api でこれらの機能を使用して、独自のアプリケーションのパフォーマンスを向上させるが表示されます。
