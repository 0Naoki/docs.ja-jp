---
title: "Compiler Error CS0029 | Microsoft Docs"
ms.date: "2015-07-20"
ms.prod: ".net"
ms.technology: 
  - "devlang-csharp"
ms.topic: "error-reference"
f1_keywords: 
  - "CS0029"
dev_langs: 
  - "CSharp"
helpviewer_keywords: 
  - "CS0029"
ms.assetid: 63c3e574-1868-4a9e-923e-dcd9f38bce88
caps.latest.revision: 7
author: "BillWagner"
ms.author: "wiwagn"
caps.handback.revision: 7
---
# Compiler Error CS0029
型 'type' を型 'type' に変換できません。  
  
 コンパイラでは明示的な変換が必要です。  たとえば、左辺値と同じ型になるように右辺値をキャストする必要が生じることがあります。  または、特定の演算子のオーバーロードをサポートする、変換ルーチンを用意する必要があります。  
  
 変換は、ある型の変数を別の型の変数に代入する場合に行われます。  異なる型の変数間で代入を行う場合、コンパイラでは、代入演算子の右側にある型を、代入演算子の左側にある型に変換する必要があります。  次のようなコードがあるとします。  
  
```  
int i = 50;  
long lng = 100;  
i = lng;  
```  
  
 `i = lng;` は代入を行いますが、代入演算子の左右の変数のデータ型が一致しません。  代入を行う前に、コンパイラは変数 `lng` の型を long から int に暗黙に変換します。  この変換を実行するようにコンパイラに明示的に指示するコードがないため、この変換は暗黙に行われます。  このコードの問題点は、この変換が縮小変換であると見なされることです。データを損失する可能性があるため、コンパイラでは暗黙の縮小変換を許可していません。  
  
 変換元のデータ型よりも、変換先のデータ型の方がメモリの記憶領域の占有率が少ない場合に、縮小変換が行われます。  たとえば、long を int に変換することは縮小変換と見なされます。  long はメモリの 8 バイトを占有し、int は 4 バイトを占有します。  データの損失がどのように発生するかを確認するには、次の例を参照してください。  
  
```  
int i = 50;  
long lng = 3147483647;  
i = lng;  
```  
  
 変数 `lng` には、大きすぎて変数 `i` に格納できない値が含まれます。  この値を int 型に変換した場合は、データの一部が損失し、変換された値は変換前の値と同じにはなりません。  
  
 拡大変換は、縮小変換の逆の変換です。  拡大変換では、変換元のデータ型よりも変換先のデータ型の方が、メモリの記憶領域の占有率が多くなります。  拡大変換の例を次に示します。  
  
```  
int i = 50;  
long lng = 100;  
lng = i;  
```  
  
 このコード サンプルと最初のコード サンプルとの違いに注意してください。  このコード サンプルでは、代入の対象となるように、変数 `lng` が代入演算子の左側にあります。  変数の値を代入するためには、コンパイラは int 型の変数 `i` を long. 型に暗黙的に変換する必要があります。  この場合は、記憶領域が 4 バイトの型 \(int\) から、8 バイト \(long\) の型に変換することになるため、拡大変換になります。  データを損失する可能性はないため、暗黙に拡大変換を行うことができます。  int に格納できる値は、long にも格納できます。  
  
 暗黙の縮小変換は許可されないため、このコードをコンパイルするには、データ型を明示的に変換する必要があります。  キャストを使用すると、明示的な変換が行われます。  キャストとは、あるデータ型から別のデータ型への変換を記述する C\# の用語です。  コンパイルするコードを取得するには、次の構文を使用する必要があります。  
  
```  
int i = 50;  
long lng = 100;  
i = (int) lng;   // cast to int  
```  
  
 このコードの 3 行目は、代入を行う前に long 型の変数 `lng` を int に明示的に変換するようにコンパイラに指示します。  縮小変換を使用すると、データを損失する可能性があります。  縮小変換を使用する場合は注意が必要です。コードがコンパイルできても、実行時に予期しない結果になる可能性があります。  
  
 この説明は、値型だけに対するものです。  値型を処理する場合は、変数に格納されているデータを直接処理します。  ただし、.NET Framework にも参照型があります。  参照型を扱う場合は、実際のデータではなく変数への参照を扱います。  参照型の例としては、クラス、インターフェイス、および配列があります。  コンパイラで特定の変換が許可されているか、適切な変換演算子が実装されていない限り、ある参照型から別の参照型への変換は、暗黙にも明示的にも行うことはできません。  
  
 次の例では警告 CS0029 が生成されます。  
  
```  
// CS0029.cs  
public class MyInt  
{  
    private int x = 0;      
  
    // Uncomment this conversion routine to resolve CS0029  
    /*  
    public static implicit operator int(MyInt i)  
    {  
       return i.x;  
    }  
    */  
  
    public static void Main()  
   {  
      MyInt myInt = new MyInt();  
      int i = myInt; // CS0029  
   }  
}  
```  
  
## 参照  
 [変換演算子](../../../csharp/programming-guide/statements-expressions-operators/conversion-operators.md)