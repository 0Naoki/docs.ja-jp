### YamlMime:Tutorial
title: <span data-ttu-id="c92ed-101">C# 7.0 を詳しく学習する - C# に関する対話型チュートリアル</span><span class="sxs-lookup"><span data-stu-id="c92ed-101">Explore C# 7.0 - C# interactive tutorial</span></span>
metadata:
  title: C# 7.0 を詳しく学習する - ブラウザーを使用して、C# 7.0 の新機能を対話形式で試す
  description: このチュートリアルでは、ブラウザーを使用して C# 7.0 を対話形式で詳しく学習します。 C# 7.0 で使用できる、より簡潔で読みやすいコードにすることができる新しい表現方法を詳しく学習します。
  audience: Developer
  level: intermediate
  ms.date: 03/20/2019
  displayType: two-column
  interactive: csharp
  ms.openlocfilehash: 1b1de22769c86f75684f41635287a73558d1d15a
  ms.sourcegitcommit: 2701302a99cafbe0d86d53d540eb0fa7e9b46b36
  ms.translationtype: HT
  ms.contentlocale: ja-JP
  ms.lasthandoff: 04/28/2019
  ms.locfileid: "64750382"
items:
- durationInMinutes: 1
  content: >
    <span data-ttu-id="c92ed-105">このチュートリアルでは C# 7.0 の機能を対話形式で詳しく学習できます。ブラウザーを使用して C# を記述し、コードをコンパイルして実行した結果を確認します。</span><span class="sxs-lookup"><span data-stu-id="c92ed-105">This tutorial lets you explore C# 7.0 features interactively, using your browser to write C# and see the results of compiling and running your code.</span></span> <span data-ttu-id="c92ed-106">これには、より新しく簡潔な C# 7.0 の機能を使用するため、以前の C# プラクティスを変更する一連のレッスンが含まれています。</span><span class="sxs-lookup"><span data-stu-id="c92ed-106">It contains a series of lessons that modify earlier C# practices to use newer, more concise C# 7.0 features.</span></span> <span data-ttu-id="c92ed-107">この記事の残りの部分では、これらの各機能の概要と、各機能をより詳しく学習するためのリンクを提供します。</span><span class="sxs-lookup"><span data-stu-id="c92ed-107">The rest of this article provides an overview of each of these features, with a link to explore each feature.</span></span>
- title: <span data-ttu-id="c92ed-108">割り当て場所での out 変数の宣言</span><span class="sxs-lookup"><span data-stu-id="c92ed-108">Out variable declarations at the assignment location</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"c92ed-109\">`out` パラメーターをサポートする既存の構文は、このバージョンで改良されました。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-109\">The existing syntax that supports `out` parameters has been improved in this version.</span></span> <span data-ttu-id=\"c92ed-110\">このページの下にある *[Enter Focus Mode]\\(フォーカス モードに入る\\)* ボタンをクリックし、対話型ウィンドウで次のコードを試します。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-110\">Click the *Enter Focus Mode* button at the bottom of this page, then try the following code in the interactive window:</span></span> \n\n[!code-csharp[OutVariableOldStyle](~/samples/snippets/csharp/new-in-7/program.cs#OutVariableOldStyle \"classic out variable declaration\")]\n\n<span data-ttu-id=\"c92ed-111\">現在は、別の宣言ステートメントを記述するのではなく、メソッド呼び出しの引数リストで `out` 変数を宣言できるようになりました。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-111\">You can now declare `out` variables in the argument list of a method call, rather than writing a separate declaration statement.</span></span> <span data-ttu-id=\"c92ed-112\">宣言はメソッド呼び出しに移動できます。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-112\">You can move the declaration into the method call.</span></span> <span data-ttu-id=\"c92ed-113\">対話型ウィンドウの下部に次のコードを追加します。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-113\">Add the following code to the bottom of the interactive window:</span></span>\n\n[!code-csharp[OutVariableDeclarations](~/samples/snippets/csharp/new-in-7/program.cs#OutVariableDeclarations \"Out variable declarations\")]\n\n<span data-ttu-id=\"c92ed-114\">`int` 宣言を `var` 宣言に変更できます。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-114\">You can change the `int` declaration to a `var` declaration.</span></span> <span data-ttu-id=\"c92ed-115\">対話型ウィンドウに次のコードを追加します。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-115\">Add the following code to the interactive window:</span></span>\n\n[!code-csharp[OutVarVariableDeclarations](~/samples/snippets/csharp/new-in-7/program.cs#OutVarVariableDeclarations \"Implicitly typed Out variable\")]\n\n<span data-ttu-id=\"c92ed-116\">新しい構文は既存の構文と比べ、2 つの点で重要な優位性があります。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-116\">The new syntax provides two important advantages over the existing syntax:</span></span>\n\n* <span data-ttu-id=\"c92ed-117\">コードが読みやすくなる。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-117\">The code is easier to read.</span></span> \n    - <span data-ttu-id=\"c92ed-118\">out 変数は、使用する場所で宣言します。その場所より上にある別の行で宣言しません。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-118\">You declare the out variable where you use it, not on another line above.</span></span>\n* <span data-ttu-id=\"c92ed-119\">初期値を割り当てる必要がない。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-119\">No need to assign an initial value.</span></span>\n    - <span data-ttu-id=\"c92ed-120\">`out` 変数は、メソッド呼び出し内の使用場所で宣言することにより、割り当てる前に誤って使用することがなくなります。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-120\">By declaring the `out` variable where it is used in a method call, you can't accidentally use it before it is assigned.</span></span>\n\n<span data-ttu-id=\"c92ed-121\">宣言された変数の範囲は、`if` ステートメントを囲む範囲になります。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-121\">The declared variable's scope is the scope enclosing the `if` statement.</span></span> <span data-ttu-id=\"c92ed-122\">これにより、その後はこの変数を使用することができます。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-122\">This allows you to use the variable afterwards.</span></span> <span data-ttu-id=\"c92ed-123\">次のスニペットのように最後の `if` ブロックを変更します。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-123\">Modify the last `if` block as shown in the following snippet.</span></span>\n\n```csharp\nif (!int.TryParse(input, out int result))\n{    \n    return null;\n}\n\nConsole.WriteLine(result);\n```\n"
- title: <span data-ttu-id="c92ed-124">タプルからは軽量のデータ構造が作成されます。</span><span class="sxs-lookup"><span data-stu-id="c92ed-124">Tuples create light-weight data structures</span></span>
  durationInMinutes: 1
  content: "<span data-ttu-id=\"c92ed-125\">タプルとは、データ メンバーを表す複数のフィールドを含む軽量なデータ構造です。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-125\">Tuples are lightweight data structures that contain multiple fields to represent the data members.</span></span> <span data-ttu-id=\"c92ed-126\">フィールドは検証されず、独自のメソッドを定義することはできません。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-126\">The fields are not validated, and you cannot define your own methods.</span></span>\n\n> [!NOTE]\n> <span data-ttu-id=\"c92ed-127\">タプルは C# 7.0 より前で使用できましたが、効率的でなく、言語サポートがありませんでした。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-127\">Tuples were available before C# 7.0, but they were inefficient and had no language support.</span></span> <span data-ttu-id=\"c92ed-128\">これは、タプル要素が `Item1` や `Item2` などとしてのみ参照できることを意味しました。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-128\">This meant that tuple elements could only be referenced as `Item1`, `Item2` and so on.</span></span> <span data-ttu-id=\"c92ed-129\">C# 7.0 では、タプルの言語サポートが導入されたことで、新しい、より効率的なタプル型を使用するフィールドのセマンティック名が有効になります。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-129\">C# 7.0 introduces language support for tuples, which enables semantic names for the fields of a tuple using new more efficient tuple types.</span></span>\n\n<span data-ttu-id=\"c92ed-130\">タプルを作成するには、それぞれの名前付きメンバーに値を割り当てます。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-130\">You can create a tuple by assigning a value to each named member:</span></span>\n\n[!code-csharp[NamedTuple](~/samples/snippets/csharp/new-in-7/program.cs#NamedTuple \"Named tuple\")]\n\n<span data-ttu-id=\"c92ed-131\">`namedLetters` タプルには、`Alpha` と `Beta` と呼ばれるフィールドが含まれています。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-131\">The `namedLetters` tuple contains fields referred to as `Alpha` and `Beta`.</span></span> <span data-ttu-id=\"c92ed-132\">これらの名前は、コンパイル時にのみ存在し、実行時 (リフレクションを使用してタプルを検査するときなど) には保持されません。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-132\">Those names exist only at compile time and are not preserved at runtime (when inspecting the tuple using reflection, for example).</span></span>\n\n<span data-ttu-id=\"c92ed-133\">タプルの割り当てでは、代入の右辺でフィールドの名前を指定することもできます。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-133\">In a tuple assignment, you can also specify the names of the fields on the right-hand side of the assignment:</span></span> \n\n[!code-csharp[ImplicitNamedTuple](~/samples/snippets/csharp/new-in-7/program.cs#ImplicitNamedTuple \"Implicitly named tuple\")]\n\n<span data-ttu-id=\"c92ed-134\">代入の左辺と右辺の両方でフィールドの名前を指定することができますが、右辺の名前は無視されます。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-134\">You can specify names for the fields on both the left and right-hand side of the assignment, but the names on the right side are ignored.</span></span>\n\n<span data-ttu-id=\"c92ed-135\">タプルは、`private` メソッドと `internal` メソッドの戻り値の型として最も有用です。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-135\">Tuples are most useful as return types for `private` and `internal` methods.</span></span> <span data-ttu-id=\"c92ed-136\">タプルは、これらのメソッドで複数の離散値を返すためのシンプルな構文です。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-136\">Tuples provide a simple syntax for those methods to return multiple discrete values.</span></span>\n\n<span data-ttu-id=\"c92ed-137\">タプルの作成は、クラスや構造の作成より効率的かつ生産的です。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-137\">Creating a tuple is more efficient and more productive that creating a class or struct.</span></span> <span data-ttu-id=\"c92ed-138\">タプルは、複数の値を保持するデータ構造を定義するための、よりシンプルで軽量な構文です。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-138\">It has a simpler, lightweight syntax to define a data structure that carries more than one value.</span></span> <span data-ttu-id=\"c92ed-139\">以下の例のメソッドは、整数のシーケンス内で見つかった最小値と最大値を返します。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-139\">The example method below returns the minimum and maximum values found in a sequence of integers.</span></span> <span data-ttu-id=\"c92ed-140\">ブラウザーで次のコードを追加して試してください。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-140\">Add the following code in your browser to try it:</span></span>\n\n[!code-csharp[TupleReturningMethod](~/samples/snippets/csharp/new-in-7/program.cs#TupleReturningMethod \"Tuple returning method\")]\n\n<span data-ttu-id=\"c92ed-141\">状況によっては、メソッドから返されたタプルのメンバーをばらすことが必要になる場合もあります。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-141\">There may be times when you want to unpackage the members of a tuple that were returned from a method.</span></span>  <span data-ttu-id=\"c92ed-142\">そのためには、タプル内のそれぞれの値に対して別個の変数を宣言します。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-142\">You can do that by declaring separate variables for each of the values in the tuple.</span></span> <span data-ttu-id=\"c92ed-143\">この操作は、タプルの*分解*と呼ばれます。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-143\">This is called *deconstructing* the tuple.</span></span> <span data-ttu-id=\"c92ed-144\">ブラウザーで次のコードを追加して試してください。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-144\">Add the following code in your browser to try it:</span></span>\n\n[!code-csharp[CallingWithDeconstructor](~/samples/snippets/csharp/new-in-7/program.cs#CallingWithDeconstructor \"Deconstructing a tuple\")]\n\n<span data-ttu-id=\"c92ed-145\">タプルを使用していると、しばしば、タプルの結果のうち、一部を使用しないことに気付きます。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-145\">As you work with tuples, you'll often find that you don't use all of the members of a tuple result.</span></span> <span data-ttu-id=\"c92ed-146\">そのとき、変数の代わりに `_` を使用することで、返された値を破棄できます。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-146\">When that happens, you can discard one or more of the returned values by using `_` in place of a variable.</span></span> <span data-ttu-id=\"c92ed-147\">ブラウザーで次のコードを追加して試してください。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-147\">Add the following code in your browser to try it:</span></span>\n\n[!code-csharp[DiscardTupleMember](~/samples/snippets/csharp/new-in-7/program.cs#DiscardMember \"Discard a tuple member\")]\n\n<span data-ttu-id=\"c92ed-148\">タプルの詳細については、[タプルに関する記事](../../tuples.md)を参照してください。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-148\">You can learn more in depth about tuples in the [tuples article](../../tuples.md).</span></span>\n<span data-ttu-id=\"c92ed-149\">破棄の詳細については、[破棄に関する記事](../../discards.md)を参照してください。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-149\">You can learn more about discards in the [discards article](../../discards.md).</span></span>\n"
- title: <span data-ttu-id="c92ed-150">is 式と共に型パターンを使用する</span><span class="sxs-lookup"><span data-stu-id="c92ed-150">Use the type pattern with the is expression</span></span>
  durationInMinutes: 2
  content: >
    <span data-ttu-id="c92ed-151">`is` パターン式を使用すると、使い慣れた [`is` 演算子](../../language-reference/keywords/is.md#pattern-matching-with-is)を拡張して、その型を超えてオブジェクトを照会できます。</span><span class="sxs-lookup"><span data-stu-id="c92ed-151">The `is` pattern expression extends the familiar [`is` operator](../../language-reference/keywords/is.md#pattern-matching-with-is) to query an object beyond its type.</span></span>


    <span data-ttu-id="c92ed-152">ブラウザー ウィンドウで次のコードを試してみてください。</span><span class="sxs-lookup"><span data-stu-id="c92ed-152">Try the following code in your browser window:</span></span>


    [!code-csharp[SimpleIs](~/samples/snippets/csharp/new-in-7/patternmatch.cs#SimpleIsPattern "Simple Is pattern")]


    <span data-ttu-id="c92ed-153">代わりに変数宣言を文字列に変更します。</span><span class="sxs-lookup"><span data-stu-id="c92ed-153">Change the variable declaration to a string instead:</span></span>


    ```csharp

    object count = "5";

    ```


    <span data-ttu-id="c92ed-154">これで `is` 式が false になりました。そのため、`else` 分岐が実行されます。</span><span class="sxs-lookup"><span data-stu-id="c92ed-154">Now, the `is` expression is false, so the `else` branch is executed.</span></span> <span data-ttu-id="c92ed-155">else 分岐で `count` を `number` に変更してみます。</span><span class="sxs-lookup"><span data-stu-id="c92ed-155">Try to change `count` to `number` in the else branch:</span></span>


    ```csharp

    Console.WriteLine($"{number} is not an integer");

    ```


    <span data-ttu-id="c92ed-156">上のコードはコンパイルされません。`else` 分岐に `number` が入っていないためです。</span><span class="sxs-lookup"><span data-stu-id="c92ed-156">The above won't compile because `number` isn't assigned in the `else` branch.</span></span> <span data-ttu-id="c92ed-157">`if` ステートメントの `true` 分岐に入っているだけです。</span><span class="sxs-lookup"><span data-stu-id="c92ed-157">It's only assigned in the `true` branch of the `if` statement.</span></span>


    <span data-ttu-id="c92ed-158">`is` 式の型パターンは、テストする型が少ないときにのみ便利です。</span><span class="sxs-lookup"><span data-stu-id="c92ed-158">The `is` expression type pattern is useful when you have a small number of types to test against.</span></span> <span data-ttu-id="c92ed-159">多くの場合、複数の種類をテストする必要があります。</span><span class="sxs-lookup"><span data-stu-id="c92ed-159">Often, you may need to test multiple types.</span></span> <span data-ttu-id="c92ed-160">それには、`switch` ステートメントに一致するパターンが必要です。</span><span class="sxs-lookup"><span data-stu-id="c92ed-160">That requires the pattern matching `switch` statement.</span></span>
- title: <span data-ttu-id="c92ed-161">switch ステートメントのパターン マッチング</span><span class="sxs-lookup"><span data-stu-id="c92ed-161">Pattern matching in the switch statement</span></span>
  durationInMinutes: 2
  content: >
    <span data-ttu-id="c92ed-162">"*一致式*" には、既に C# 言語に含まれている `switch` ステートメントに基づいた、使い慣れた構文があります。</span><span class="sxs-lookup"><span data-stu-id="c92ed-162">The *match expression* has a familiar syntax, based on the `switch` statement already part of the C# language.</span></span> <span data-ttu-id="c92ed-163">前のページで学習した `is` 式の構文に基づく小さなサンプルから始めましょう。</span><span class="sxs-lookup"><span data-stu-id="c92ed-163">Let's start with a small sample based on the `is` expression syntax you explored on the previous page:</span></span>


    [!code-csharp[SimpleSwitch](~/samples/snippets/csharp/new-in-7/patternmatch.cs#SimpleSwitchPattern "simple switch")]


    <span data-ttu-id="c92ed-164">先のコードは `int` または `null` を確認します。</span><span class="sxs-lookup"><span data-stu-id="c92ed-164">The preceding code checks for an `int` or `null`.</span></span> <span data-ttu-id="c92ed-165">その他の型はすべて、既定のケースに達します。</span><span class="sxs-lookup"><span data-stu-id="c92ed-165">Every other type reached the default case.</span></span> <span data-ttu-id="c92ed-166">次の 2 行を追加し、動作を検証します。</span><span class="sxs-lookup"><span data-stu-id="c92ed-166">Add the following two lines to verify the behavior:</span></span>


    [!code-csharp[AddLongCase](~/samples/snippets/csharp/new-in-7/patternmatch.cs#TestLong "Add a case for long")]


    <span data-ttu-id="c92ed-167">`switch` 式は、null 許容型をそれに対応する型に変換します。</span><span class="sxs-lookup"><span data-stu-id="c92ed-167">The `switch` expression will convert a nullable type to its corresponding type.</span></span> <span data-ttu-id="c92ed-168">次のコードを追加して検証します。</span><span class="sxs-lookup"><span data-stu-id="c92ed-168">Add the following to verify:</span></span>


    [!code-csharp[NullableCase](~/samples/snippets/csharp/new-in-7/patternmatch.cs#NullableSwitch "Add a nullable case")]


    <span data-ttu-id="c92ed-169">switch ステートメントには他にもいくつでも型パターン式を追加できます。</span><span class="sxs-lookup"><span data-stu-id="c92ed-169">You can add any number of other type pattern expressions to the switch statements.</span></span> <span data-ttu-id="c92ed-170">`null` ケースの前に以下を追加します。</span><span class="sxs-lookup"><span data-stu-id="c92ed-170">Add these before the `null` case:</span></span>


    [!code-csharp[MoreTypeCases](~/samples/snippets/csharp/new-in-7/patternmatch.cs#MoreCases "Add more type cases")]


    <span data-ttu-id="c92ed-171">次のテストを追加し、コードが動作することを確認してください。</span><span class="sxs-lookup"><span data-stu-id="c92ed-171">Make sure these work by adding the following tests:</span></span>


    [!code-csharp[AddMoreTests](~/samples/snippets/csharp/new-in-7/patternmatch.cs#MoreTests "Add more type tests")]


    <span data-ttu-id="c92ed-172">一致式では定数もサポートされます。</span><span class="sxs-lookup"><span data-stu-id="c92ed-172">The match expressions also support constants.</span></span> <span data-ttu-id="c92ed-173">これにより、単純なケースが取り除かれるため、時間を節約できます。</span><span class="sxs-lookup"><span data-stu-id="c92ed-173">This can save time by factoring out simple cases:</span></span>


    [!code-csharp[ConstantCase](~/samples/snippets/csharp/new-in-7/patternmatch.cs#ConstantCase "Add a constant case")]


    <span data-ttu-id="c92ed-174">先のケースは `case int:` 式の*前*に追加する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c92ed-174">You must add the preceding case *before* the `case int:` expression.</span></span> <span data-ttu-id="c92ed-175">このケースの後に追加した場合、前のケースにより既に処理されているとコンパイラから警告が出ます。</span><span class="sxs-lookup"><span data-stu-id="c92ed-175">If you add it after that case, the compiler warns you that it has already been handled by a previous case.</span></span>


    <span data-ttu-id="c92ed-176">型や定数値以外の条件をテストできるように、あらゆるパターン ケースに `when` 句を追加できます。</span><span class="sxs-lookup"><span data-stu-id="c92ed-176">You can add a `when` clause to any pattern case so that you can test other conditions beyond a type or a constant value.</span></span> <span data-ttu-id="c92ed-177">一般的な `string` ケースの上に次のケースを追加して試してください。</span><span class="sxs-lookup"><span data-stu-id="c92ed-177">Try it by adding the following case above the general `string` case:</span></span>


    [!code-csharp[WhenClause](~/samples/snippets/csharp/new-in-7/patternmatch.cs#WhenClause "Add a when clause")]


    <span data-ttu-id="c92ed-178">次のようなコードでテストします。</span><span class="sxs-lookup"><span data-stu-id="c92ed-178">Test it with something like the following code:</span></span>


    [!code-csharp[TestWhenClause](~/samples/snippets/csharp/new-in-7/patternmatch.cs#TestWhenClause "Test the when clause")]


    <span data-ttu-id="c92ed-179">パターン マッチング式の新しい構文を使用すると、オブジェクトの型やその他のプロパティに基づいたディスパッチ アルゴリズムを、明確かつ簡潔な構文を使用して簡単に作成できます。</span><span class="sxs-lookup"><span data-stu-id="c92ed-179">The new syntax for pattern matching expressions makes it easier to create dispatch algorithms using a clear and concise syntax based on an object's type or other properties.</span></span> <span data-ttu-id="c92ed-180">パターン マッチング式は、継承によって関連付けられていないデータ型に対してこれらのコンストラクトを有効にします。</span><span class="sxs-lookup"><span data-stu-id="c92ed-180">Pattern matching expressions enable these constructs on data types that are unrelated by inheritance.</span></span>


    <span data-ttu-id="c92ed-181">パターン マッチングの詳細については、[C# のパターン マッチング](../../pattern-matching.md)に特化した記事を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c92ed-181">You can learn more about pattern matching in the article dedicated to [pattern matching in C#](../../pattern-matching.md).</span></span>
- title: <span data-ttu-id="c92ed-182">ref ローカル変数と戻り値を使用し、メモリ ストレージを最適化する</span><span class="sxs-lookup"><span data-stu-id="c92ed-182">Optimize memory storage using ref locals and returns</span></span>
  durationInMinutes: 2
  content: >
    <span data-ttu-id="c92ed-183">この機能により、他の場所に定義されている変数への参照を使用したり返したりするアルゴリズムが実現します。</span><span class="sxs-lookup"><span data-stu-id="c92ed-183">This feature enables algorithms that use and return references to variables defined elsewhere.</span></span> <span data-ttu-id="c92ed-184">たとえば、大規模なマトリックスを使用し、特定の特性を持つ 1 つの場所を探します。</span><span class="sxs-lookup"><span data-stu-id="c92ed-184">One example is with large matrices and finding a single location with certain characteristics.</span></span> <span data-ttu-id="c92ed-185">1 つのメソッドでマトリックス内の単一の場所を 2 つのインデックスに返すこともあります。</span><span class="sxs-lookup"><span data-stu-id="c92ed-185">One method would return the two indices a single location in the matrix:</span></span>


    [!code-csharp[EverythingByValue](~/samples/snippets/csharp/new-in-7/MatrixSearch.cs#EverythingByValue "return indices by value")]


    <span data-ttu-id="c92ed-186">このメソッドを次のコードを使用してテストできます。</span><span class="sxs-lookup"><span data-stu-id="c92ed-186">You can test this method using the following code:</span></span>


    [!code-csharp[TestByValue](~/samples/snippets/csharp/new-in-7/MatrixSearch.cs#TestByValue "test code for return indices by value")]



    <span data-ttu-id="c92ed-187">この `Find` メソッドは、マトリックス内の項目にインデックスを返します。</span><span class="sxs-lookup"><span data-stu-id="c92ed-187">This `Find` method returns the indices to the item in the matrix.</span></span> <span data-ttu-id="c92ed-188">そのため、呼び出し元は、これらのインデックスを使用してマトリックスを逆参照し、1 つの要素を変更するコードを記述することになります。</span><span class="sxs-lookup"><span data-stu-id="c92ed-188">That leads callers to write code that uses those indices to dereference the matrix and modify a single element.</span></span> <span data-ttu-id="c92ed-189">それよりも、変更するマトリックス内の要素への "*参照*" を返すメソッドを記述することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c92ed-189">You'd rather write a method that returns a *reference* to the element of the matrix that you want to change.</span></span>


    <span data-ttu-id="c92ed-190">それでは、一連の変更を確認しながら、ref ローカル変数の機能と、内部ストレージへの参照を返すメソッドの作成方法を説明します。</span><span class="sxs-lookup"><span data-stu-id="c92ed-190">Let's walk through a series of changes to demonstrate the ref local feature and show how to create a method that returns a reference to internal storage.</span></span> <span data-ttu-id="c92ed-191">その過程で、ref 戻り値および ref ローカル変数の機能の誤用を防ぐための規則についても説明します。</span><span class="sxs-lookup"><span data-stu-id="c92ed-191">Along the way, you'll learn the rules of the ref return and ref local feature that protect you from accidentally misusing it.</span></span>


    <span data-ttu-id="c92ed-192">まず、タプルの代わりに `ref int` を返すように `Find` メソッドの宣言を変更します。</span><span class="sxs-lookup"><span data-stu-id="c92ed-192">Start by modifying the `Find` method declaration so that it returns a `ref int` instead of a tuple.</span></span>


    ```csharp

    ref int Find(int[,] matrix, Func<int, bool> predicate)

    ```


    <span data-ttu-id="c92ed-193">正しいインデックスで項目を返すように return ステートメントを変更します。</span><span class="sxs-lookup"><span data-stu-id="c92ed-193">Modify the return statement to return the item at the correct indices:</span></span>


    ```csharp

    return matrix[i,j];

    ```


    <span data-ttu-id="c92ed-194">代わりに例外をスローするように最後の return を変更します。</span><span class="sxs-lookup"><span data-stu-id="c92ed-194">Change the final return to throw an exception instead:</span></span>


    ```csharp

    throw new InvalidOperationException("Not found");

    ```


    <span data-ttu-id="c92ed-195">これはコンパイルされないことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="c92ed-195">Note that this won't compile.</span></span> <span data-ttu-id="c92ed-196">このメソッド宣言は `ref` return を示しますが、return ステートメントからは値の戻りが指定されます。</span><span class="sxs-lookup"><span data-stu-id="c92ed-196">The method declaration indicates a `ref` return, but the return statement specifies a value return.</span></span> <span data-ttu-id="c92ed-197">各 return ステートメントに `ref` キーワードを追加する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c92ed-197">You must add the `ref` keyword to each return statement.</span></span> <span data-ttu-id="c92ed-198">これは、参照渡しを示します。これにより、後でコードを読む開発者にも、そのメソッドが参照渡しで返すことがわかります。</span><span class="sxs-lookup"><span data-stu-id="c92ed-198">That indicates return by reference, and helps developers reading the code later remember that the method returns by reference:</span></span>


    ```csharp

    return ref matrix[i,j];

    ```


    <span data-ttu-id="c92ed-199">このメソッドはマトリックス内の整数値への参照を返すため、呼び出し側のコードを修正する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c92ed-199">Now that the method returns a reference to the integer value in the matrix, you need to modify where it's called.</span></span> <span data-ttu-id="c92ed-200">`var` 宣言は、`valItem` がタプルではなく `int` であることを意味します。</span><span class="sxs-lookup"><span data-stu-id="c92ed-200">The `var` declaration means that `valItem` is now an `int` rather than a tuple.</span></span> <span data-ttu-id="c92ed-201">呼び出し元のコードを次のように変更します。</span><span class="sxs-lookup"><span data-stu-id="c92ed-201">Change the calling code to the following:</span></span>


    ```csharp

    var valItem = Find(matrix, (val) => val == 42);

    Console.WriteLine(valItem);

    valItem = 24;

    Console.WriteLine(matrix[4, 2]);

    ```


    <span data-ttu-id="c92ed-202">上記の例の 2 番目の `WriteLine` ステートメントで出力される値は `42` であり、`24` ではありません。</span><span class="sxs-lookup"><span data-stu-id="c92ed-202">The second `WriteLine` statement in the example above prints out the value `42`, not `24`.</span></span> <span data-ttu-id="c92ed-203">変数 `valItem` は、`int` であり、`ref int` ではありません。</span><span class="sxs-lookup"><span data-stu-id="c92ed-203">The variable `valItem` is an `int`, not a `ref int`.</span></span> <span data-ttu-id="c92ed-204">`var` キーワードを使用すると、コンパイラは、型を指定できますが、`ref` 修飾子を暗黙的に追加しません。</span><span class="sxs-lookup"><span data-stu-id="c92ed-204">The `var` keyword enables the compiler to specify the type but will not implicitly add the `ref` modifier.</span></span> <span data-ttu-id="c92ed-205">代わりに、`ref return` によって参照される値が代入の左辺にある変数に "*コピー*" されます。</span><span class="sxs-lookup"><span data-stu-id="c92ed-205">Instead, the value referred to by the `ref return` is *copied* to the variable on the left-hand side of the assignment.</span></span> <span data-ttu-id="c92ed-206">この変数は `ref` ローカル変数ではありません。</span><span class="sxs-lookup"><span data-stu-id="c92ed-206">The variable is not a `ref` local.</span></span>


    <span data-ttu-id="c92ed-207">返された参照を変更するには、`ref` 修飾子をローカル変数の宣言と `Find` の呼び出しの前に追加し、戻り値が参照の場合に変数が参照になるようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="c92ed-207">In order to modify the returned reference, you need to add the `ref` modifier to the local variable declaration and before the call to `Find` to make the variable a reference when the return value is a reference.</span></span> <span data-ttu-id="c92ed-208">ブラウザーでテスト コードを次のように変更します。</span><span class="sxs-lookup"><span data-stu-id="c92ed-208">Modify the test code in your browser to match the following:</span></span>


    [!code-csharp[EverythingByValue](~/samples/snippets/csharp/new-in-7/MatrixSearch.cs#TestByValue "test code for return object by reference")]


    <span data-ttu-id="c92ed-209">上記の例の 2 番目の `WriteLine` ステートメントは、値 `24` を出力します。これは、マトリックスのストレージが変更されたことを示しています。</span><span class="sxs-lookup"><span data-stu-id="c92ed-209">Now, the second `WriteLine` statement in the example above prints out the value `24`, indicating that the storage in the matrix has been modified.</span></span> <span data-ttu-id="c92ed-210">ローカル変数は `ref` 修飾子で宣言されており、`ref` 戻り値を受け取ります。</span><span class="sxs-lookup"><span data-stu-id="c92ed-210">The local variable has been declared with the `ref` modifier, and it will take a `ref` return.</span></span> <span data-ttu-id="c92ed-211">`ref` 変数は宣言時に初期化する必要があります。宣言と初期化を分けることはできません。</span><span class="sxs-lookup"><span data-stu-id="c92ed-211">You must initialize a `ref` variable when it is declared; you cannot split the declaration and the initialization.</span></span>


    <span data-ttu-id="c92ed-212">C# 言語には、これ以外に、`ref` ローカル変数と戻り値の誤用を防ぐ規則が 3 つあります。</span><span class="sxs-lookup"><span data-stu-id="c92ed-212">The C# language has three other rules that protect you from misusing the `ref` locals and returns:</span></span>


    * <span data-ttu-id="c92ed-213">標準的なメソッドの戻り値を `ref` ローカル変数に割り当てることはできません。</span><span class="sxs-lookup"><span data-stu-id="c92ed-213">You cannot assign a standard method return value to a `ref` local variable.</span></span>

    * <span data-ttu-id="c92ed-214">有効期間がメソッドの実行期間を超えない変数に `ref` を返すことはできません。</span><span class="sxs-lookup"><span data-stu-id="c92ed-214">You cannot return a `ref` to a variable whose lifetime does not extend beyond the execution of the method.</span></span>

    * <span data-ttu-id="c92ed-215">`ref` ローカル変数と戻り値は、非同期メソッドと共に使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="c92ed-215">`ref` locals and returns can't be used with async methods.</span></span>


    <span data-ttu-id="c92ed-216">ref ローカル変数および ref 戻り値の追加により、値のコピーを回避したり、逆参照操作を複数回実行したりすることで、より効率的なアルゴリズムを実現できます。</span><span class="sxs-lookup"><span data-stu-id="c92ed-216">The addition of ref locals and ref returns enable algorithms that are more efficient by avoiding copying values or performing dereferencing operations multiple times.</span></span>


    <span data-ttu-id="c92ed-217">詳しくは、[ref](../../language-reference/keywords/ref.md) キーワードに関する記事をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="c92ed-217">For more information, see the [ref keyword](../../language-reference/keywords/ref.md) article.</span></span>
- title: <span data-ttu-id="c92ed-218">ローカル関数でコードへのアクセスを最小限に抑える</span><span class="sxs-lookup"><span data-stu-id="c92ed-218">Minimize access to code with local functions</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"c92ed-219\">これで、他の関数の中で入れ子になるローカル関数を宣言できるようになりました。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-219\">You can now declare local functions that are nested inside other functions.</span></span> <span data-ttu-id=\"c92ed-220\">それにより、ローカル関数をなるべく見えないようにすることができます。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-220\">This enables you to minimize the visibility of these functions.</span></span> <span data-ttu-id=\"c92ed-221\">ローカル関数には明白なユース ケースが 3 つあります。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-221\">There are three obvious use cases for local functions:</span></span>\n\n- <span data-ttu-id=\"c92ed-222\">再帰関数。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-222\">Recursive functions.</span></span>\n- <span data-ttu-id=\"c92ed-223\">反復子メソッド。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-223\">Iterator methods.</span></span>\n- <span data-ttu-id=\"c92ed-224\">非同期メソッド。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-224\">Asynchronous methods.</span></span>\n\n<span data-ttu-id=\"c92ed-225\">再帰メソッドから始めましょう。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-225\">Let's start with recursive methods.</span></span> <span data-ttu-id=\"c92ed-226\">ブラウザーで次のコードを試し、`6!` (階乗) を計算します。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-226\">Try the following code in the browser to calculate `6!` (factorial):</span></span>\n\n```csharp\nint LocalFunctionFactorial(int n)\n{\n    return nthFactorial(n);\n\n    int nthFactorial(int number) => (number < 2) ? \n        1 : number * nthFactorial(number - 1);\n}\n\nConsole.WriteLine(LocalFunctionFactorial(6));\n```\n\n<span data-ttu-id=\"c92ed-227\">ローカル関数は再帰アルゴリズムを実装する優れた方法です。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-227\">Local functions are a great way to implement recursive algorithms.</span></span> <span data-ttu-id=\"c92ed-228\">他には一般的に、パブリックの反復子メソッドやパブリックの非同期メソッドで使用されます。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-228\">Other common uses are for public iterator methods and public async methods.</span></span> <span data-ttu-id=\"c92ed-229\">どちらの種類のメソッドも、プログラマーが期待するよりも遅くエラーを報告するコードを生成します。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-229\">Both types of methods generate     code that reports errors later than programmers might expect.</span></span> <span data-ttu-id=\"c92ed-230\">反復子メソッドの場合、例外が検出されるのは、返されたシーケンスを列挙するコードを呼び出した場合のみです。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-230\">In the case of iterator methods, any exceptions are observed only when calling code that enumerates the returned sequence.</span></span> <span data-ttu-id=\"c92ed-231\">非同期メソッドの場合、例外が検出されるのは、返された `Task` が待機状態になったときのみです。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-231\">In the case of async methods, any exceptions are only observed when the returned `Task` is awaited.</span></span>\n\n<span data-ttu-id=\"c92ed-232\">反復子メソッドはブラウザーで簡単に試すことができます。このチュートリアルでは反復子メソッドを使用しましょう。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-232\">Iterator methods are easier to explore in the browser, so let's use those in this exploration.</span></span> <span data-ttu-id=\"c92ed-233\">次のコードを試してください。これはブラウザーで反復子メソッドを呼び出します。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-233\">Try the following code that calls an iterator method in your browser:</span></span>\n\n[!code-csharp[IteratorMethod](~/samples/snippets/csharp/new-in-7/Iterator.cs#SnippetIteratorMethod \"Iterator method\")]\n\n<span data-ttu-id=\"c92ed-234\">コードを実行します。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-234\">Run the code.</span></span> <span data-ttu-id=\"c92ed-235\">コードが 2 つ目の結果セットの繰り返しを始めると例外がスローされることに注意してください。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-235\">Notice that the exception is thrown when the code begins iterating the second result set.</span></span> <span data-ttu-id=\"c92ed-236\">最初の結果セットを繰り返すコードは既に実行されています。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-236\">The code that iterates the first result set has already run.</span></span> <span data-ttu-id=\"c92ed-237\">このサンプルは小規模なうえに、データ構造の変更は行いません。そのため、悪影響はなく、簡単に修正できます。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-237\">This sample is both small and doesn't change any data structures, so it's harmless and easy to fix.</span></span> <span data-ttu-id=\"c92ed-238\">しかしながら、大きなプログラムの場合、2 つの反復子オブジェクトが異なる子メソッドで作成されることがあれば、根本原因を見つけることが難しくなることがあります。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-238\">But, in a larger program, where the two iterator objects may be created in different child methods the root cause could be hard to find.</span></span> <span data-ttu-id=\"c92ed-239\">最初の反復子メソッドでデータの状態が変わった場合、データの破損を引き起こすことがあります。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-239\">If the first iterator method changed data state, it could even cause data corruption.</span></span> <span data-ttu-id=\"c92ed-240\">例外は直後に、動作が完了する前にスローされることが望ましいでしょう。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-240\">You'd prefer the exception was thrown immediately, before any work is done.</span></span> <span data-ttu-id=\"c92ed-241\">パブリック メソッドによってすべての引数を検証し、ローカル関数では列挙を実行できるように、コードをリファクタリングできます。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-241\">You can refactor the code so that the public method validates all arguments, and a local function performs the enumeration:</span></span>\n\n[!code-csharp[IteratorMethodRefactored](~/samples/snippets/csharp/new-in-7/Iterator.cs#IteratorMethodLocalInteractive \"Iterator method refactored\")]\n\n<span data-ttu-id=\"c92ed-242\">先のバージョンでは、ローカル メソッドが外部メソッドのコンテキストでのみ参照されることが明確になっています。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-242\">The preceding version makes it clear that the local method is referenced only in the context of the outer method.</span></span> <span data-ttu-id=\"c92ed-243\">また、ローカル関数の規則により、開発者が誤ってクラス内の別の場所からローカル関数を呼び出して、引数の検証をバイパスできないようになっています。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-243\">The rules for local functions also ensure that a developer can't accidentally call the local function from another location in the class and bypass the argument validation.</span></span>\n\n<span data-ttu-id=\"c92ed-244\">同じ手法を `async` メソッドで使用すると、引数の検証で発生する例外が非同期操作の開始前にスローされることを保証できます。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-244\">The same technique can be employed with `async` methods to ensure that exceptions arising from argument validation are thrown before the asynchronous work begins.</span></span>\n\n> [!NOTE]\n> <span data-ttu-id=\"c92ed-245\">ローカル関数によってサポートされる設計の中には、\"*ラムダ式*\" を使用して実現できるものもあります。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-245\">Some of the designs that are supported by local functions could also be accomplished using *lambda expressions*.</span></span> <span data-ttu-id=\"c92ed-246\">興味のある方は、[その違いの詳細を確認してください](../../local-functions-vs-lambdas.md)。</span><span class=\"sxs-lookup\"><span data-stu-id=\"c92ed-246\">Those interested can [read more about the differences](../../local-functions-vs-lambdas.md).</span></span>\n"
- content: <span data-ttu-id="c92ed-247">C# 7 の主要な新機能の詳しい学習が完了しました。</span><span class="sxs-lookup"><span data-stu-id="c92ed-247">You've completed an exploration of the major new features in C# 7.</span></span> <span data-ttu-id="c92ed-248">次は、ご自分のアプリケーションで試してみましょう。</span><span class="sxs-lookup"><span data-stu-id="c92ed-248">Now try them yourself in your applications.</span></span> <span data-ttu-id="c92ed-249">完全一覧は「[C# 7 の新機能](../../whats-new/csharp-7.md)」という記事にあります。</span><span class="sxs-lookup"><span data-stu-id="c92ed-249">You can see the full list in the [what's new in C# 7](../../whats-new/csharp-7.md) article.</span></span>
