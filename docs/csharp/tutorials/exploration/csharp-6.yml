### YamlMime:Tutorial
title: <span data-ttu-id="258a8-101">C# 6 を詳しく学習する - C# に関する対話型チュートリアル</span><span class="sxs-lookup"><span data-stu-id="258a8-101">Explore C# 6 - C# interactive C# tutorial</span></span>
metadata:
  title: C# 6 を詳しく学習する - ブラウザーを使用して、C# 6 の新機能を対話形式で試す
  description: このチュートリアルでは、ブラウザーを使用して C# 6 を対話形式で詳しく学習します。 C#6 で使用できる、より簡潔で読みやすいコードにすることができる新しい表現方法を詳しく学習します。
  audience: Developer
  level: intermediate
  ms.date: 12/11/2018
  displayType: two-column
  interactive: csharp
  ms.openlocfilehash: d782899c3b29851f020cd9fc07cde8f408bf2ac5
  ms.sourcegitcommit: 6b308cf6d627d78ee36dbbae8972a310ac7fd6c8
  ms.translationtype: HT
  ms.contentlocale: ja-JP
  ms.lasthandoff: 01/23/2019
  ms.locfileid: "54634260"
items:
- durationInMinutes: 1
  content: >
    <span data-ttu-id="258a8-105">このチュートリアルでは C# 6 を対話形式で詳しく学習できます。ブラウザーを使用して C# を記述し、コードをコンパイルして実行した結果を確認します。</span><span class="sxs-lookup"><span data-stu-id="258a8-105">This tutorial lets you explore C# 6 interactively, using your browser to write C# and see the results of compiling and running your code.</span></span> <span data-ttu-id="258a8-106">これには、より新しく簡潔な C# 6 の機能を使用するため、以前の C# プラクティスを変更する一連のレッスンが含まれています。</span><span class="sxs-lookup"><span data-stu-id="258a8-106">It contains a series of lessons that modify earlier C# practices to use newer, more concise C# 6 features.</span></span> <span data-ttu-id="258a8-107">この記事の残りの部分では、これらの各機能の概要と、各機能をより詳しく学習するためのリンクを提供します。</span><span class="sxs-lookup"><span data-stu-id="258a8-107">The rest of this article provides an overview of each of these features, with a link to explore each feature.</span></span>
- title: <span data-ttu-id="258a8-108">読み取り専用の型を有効にする読み取り専用の自動プロパティ</span><span class="sxs-lookup"><span data-stu-id="258a8-108">Read-only auto-properties enable read-only types</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"258a8-109\">自動プロパティ構文に対する 2 つの機能強化 (読み取り専用の自動プロパティと自動プロパティ初期化子) により、より多くの場所で自動プロパティが使いやすくなりました。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-109\">Two enhancements to auto-property syntax make it easier to use auto-properties in more places: read-only auto-properties and auto-property initializers.</span></span> <span data-ttu-id=\"258a8-110\">次の小さなプログラムを検討します。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-110\">Consider this small program:</span></span>\n\n[!code-csharp[Starter](../../../../samples/csharp/tutorials/exploration/csharp6-starter/Program.cs)]  \n\n    \n <span data-ttu-id=\"258a8-111\">フォーカス モードに入り、上記のコードを C# 対話型ウィンドウにコピーします。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-111\">Enter Focus mode, copy the preceding code into the C# interactive window.</span></span> <span data-ttu-id=\"258a8-112\">次に、*[実行]* をクリックして、コードにより何が行われるかを確認します。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-112\">Then, click *Run* to see what the code does.</span></span> <span data-ttu-id=\"258a8-113\">`AllCaps` には、大文字の文字列を返すことに加え、プロパティ値の変更という望ましくない副作用があります。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-113\">`AllCaps` has the undesirable side effect of modifying the property values along with returning the uppercase string.</span></span> <span data-ttu-id=\"258a8-114\">`Person` クラスの作成者は、`FirstName` と `LastName` の文字列を読み取り専用にすることを意図していました。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-114\">The author of the `Person` class intended the strings for `FirstName` and `LastName` to be read-only.</span></span> <span data-ttu-id=\"258a8-115\">C# 6 では、その意図を明白にすることができます。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-115\">With C# 6, you can make that intent clear.</span></span> <span data-ttu-id=\"258a8-116\">両方のプロパティから `private set` を削除して、読み取り専用の自動プロパティを作成します。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-116\">Remove the `private set` from both properties to create a read-only auto property.</span></span> <span data-ttu-id=\"258a8-117\">*[実行]* をクリックして、`FirstName` プロパティと `LastName`プロパティが変更されるべきでないタイミングで変更される 2 つの場所をコンパイラが特定するのを確認します。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-117\">Click *Run* to see that the compiler spots the two locations where the `FirstName` and `LastName` properties are changed when they should not have been.</span></span> <span data-ttu-id=\"258a8-118\">`AllCaps` メソッドを次のコードに変更して、コンパイラ エラーを修正できます。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-118\">You can change the `AllCaps` method to the following code to fix the compiler error:</span></span>\n\n```csharp\npublic string AllCaps()\n{\n  return ToString().ToUpper();\n}\n```\n\n<span data-ttu-id=\"258a8-119\">この新しい構文を使用することで、コンパイラはプロパティを変更できないようにします。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-119\">Using this new syntax, the compiler ensures that the properties are immutable.</span></span>\n"
- title: <span data-ttu-id="258a8-120">自動プロパティのバッキング フィールドの初期化</span><span class="sxs-lookup"><span data-stu-id="258a8-120">Initialize backing fields for auto-properties</span></span>
  durationInMinutes: 1
  content: "<span data-ttu-id=\"258a8-121\">C# 6 の新しい構文により、自動プロパティに初期化子を使用することができます。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-121\">New syntax in C# 6 enables you to use initializers for auto-properties.</span></span> <span data-ttu-id=\"258a8-122\">クラスに新しい機能が増えたため、これはさらに重要になります。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-122\">This becomes more important as classes grow new capabilities.</span></span> <span data-ttu-id=\"258a8-123\">ミドル ネーム プロパティと、3 つの文字列を受け取る新しいコンストラクターを `Person` クラスに追加します。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-123\">Add a middle name property, and a new constructor that takes three strings to your `Person` class:</span></span>\n\n[!code-csharp[MiddleName](../../../../samples/csharp/tutorials/exploration/csharp6-finished/Program.cs#MiddleName)]  \n\n<span data-ttu-id=\"258a8-124\">`MiddleName` プロパティの割り当ては初期化子です。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-124\">The assignment on the `MiddleName` property is an initializer.</span></span> <span data-ttu-id=\"258a8-125\">これはミドル ネーム用にコンパイラによって生成されたバッキング フィールドを初期化します。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-125\">It initializes the compiler-generated backing field for the middle name.</span></span>\n"
- title: <span data-ttu-id="258a8-126">式形式のメンバー</span><span class="sxs-lookup"><span data-stu-id="258a8-126">Expression-bodied members</span></span>
  durationInMinutes: 2
  content: >
    <span data-ttu-id="258a8-127">式形式のメンバーは、軽量のメソッド用に軽量の構文を提供します。</span><span class="sxs-lookup"><span data-stu-id="258a8-127">Expression-bodied members provide a lightweight syntax for lightweight methods.</span></span> <span data-ttu-id="258a8-128">`Person` クラスには 2 つの最適な候補があります。</span><span class="sxs-lookup"><span data-stu-id="258a8-128">The `Person` class has two great candidates.</span></span> <span data-ttu-id="258a8-129">`ToString` の宣言を見てください。</span><span class="sxs-lookup"><span data-stu-id="258a8-129">Look at the declaration of `ToString`:</span></span>


    ```csharp

    public override string ToString()

    {
        return FirstName + " " + LastName;
    }

    ```


    <span data-ttu-id="258a8-130">`ToString` の宣言を次のコードに置き換えます。</span><span class="sxs-lookup"><span data-stu-id="258a8-130">Replace that declaration of `ToString` with the following code:</span></span>


    ```csharp

    public override string ToString() => FirstName + " " + LastName;

    ```


    <span data-ttu-id="258a8-131">同じことを `Caps` メソッドで試します。</span><span class="sxs-lookup"><span data-stu-id="258a8-131">Try the same with the `Caps` method.</span></span> <span data-ttu-id="258a8-132">これは小さな改善ですが、うまく使用することで、特にデータ転送オブジェクト (DTO) や最小限の動作を持つその他の型に対しては、もっと読みやすいコードを作成することができます。</span><span class="sxs-lookup"><span data-stu-id="258a8-132">This is a small improvement, but when used wisely it creates much more readable code, especially for Data Transfer Objects (DTOs) and other types with minimal behavior.</span></span>
- title: <span data-ttu-id="258a8-133">単一クラスのインポート</span><span class="sxs-lookup"><span data-stu-id="258a8-133">Importing a single class</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"258a8-134\">コード全体で 1 つのクラスの静的メソッドを繰り返し使用する場合は、毎回クラス名を含めるとコードの意味がわかりにくくなります。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-134\">If you repeatedly use one class' static methods throughout your code, including the class name each time obscures the meaning of your code.</span></span> <span data-ttu-id=\"258a8-135\">`Person` クラスは現在、<xref:System.Console?displayProperty=nameWithType> しか使用されていない場合でも、`System` 名前空間をインポートします。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-135\">The `Person` class currently imports the `System` namespace, even though only <xref:System.Console?displayProperty=nameWithType> is used.</span></span> <span data-ttu-id=\"258a8-136\">`using` ステートメントを次のように変更します。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-136\">Modify the `using` statement as follows:</span></span>\n\n[!code-csharp[MiddleName](../../../../samples/csharp/tutorials/exploration/csharp6-finished/Program.cs#UsingStatic)]  \n\n<span data-ttu-id=\"258a8-137\">`static using` ステートメントは、[`string`](xref:System.String) クラスや <xref:System.Math?displayProperty=nameWithType> クラスのように、多くの静的メソッドを持つ 1 つのクラスを大量に使用する大規模なプログラムではより有用になります。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-137\">The `static using` statement becomes more useful in larger programs that make extensive use of a single class with many static methods, like the [`string`](xref:System.String) class or the <xref:System.Math?displayProperty=nameWithType> class.</span></span>\n"
- title: <span data-ttu-id="258a8-138">向上した文字列形式</span><span class="sxs-lookup"><span data-stu-id="258a8-138">A better string format</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"258a8-139\">C# 6 で導入された新しい構文では、文字列と、その他の文字列値を生成するために評価される埋め込み式から、文字列を作成することができます。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-139\">C# 6 contains new syntax for composing strings from a string and embedded expressions that are evaluated to produce other string values.</span></span> <span data-ttu-id=\"258a8-140\">この構文を使用するように、`ToString` メソッドと `AllCaps` メソッドを変更できます。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-140\">You can change the `ToString` and `AllCaps` methods to use this syntax:</span></span>\n\n[!code-csharp[StringInterpolation](../../../../samples/csharp/tutorials/exploration/csharp6-finished/Program.cs#StringInterpolation)]  \n\n<span data-ttu-id=\"258a8-141\">`{` と `}` の間の位置引数の代わりに、C# 式を直接記述します。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-141\">Instead of positional arguments between the `{` and `}`, you write C# expressions directly.</span></span> <span data-ttu-id=\"258a8-142\">`Main` メソッドでも同じことができます。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-142\">You can do the same in the `Main` method.</span></span> <span data-ttu-id=\"258a8-143\">既存のコードを次のコードに置き換えます。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-143\">Replace the existing code with the following:</span></span>\n\n[!code-csharp[InterpolationMain](../../../../samples/csharp/tutorials/exploration/csharp6-finished/Program.cs#InterpolationMain)]  \n\n<span data-ttu-id=\"258a8-144\">これらの式では、変数は 1 つに制限されません。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-144\">You're not limited to a single variable in these expressions.</span></span> <span data-ttu-id=\"258a8-145\">新しい例を使用して、文字列補間で使用できるその他の式を示すように変更してみましょう。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-145\">Let's start with a new example and modify it to demonstrate other expressions you can use with string interpolation.</span></span> <span data-ttu-id=\"258a8-146\">`Main` メソッドの対話型ウィンドウに次のコードを貼り付けます。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-146\">Paste the following code into the interactive window in the `Main` method:</span></span>\n\n[!code-csharp[Phrases](../../../../samples/csharp/tutorials/exploration/csharp6-finished/Program.cs#Phrases)]  \n\n<span data-ttu-id=\"258a8-147\">ローカル変数 `average` を削除して、補間文字列式の一部としてその計算を実行できます。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-147\">You can remove the local variable `average` and perform that calculation as part of the interpolated string expression.</span></span> <span data-ttu-id=\"258a8-148\">最後の 2 行を以下に置き換えます。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-148\">Replace the last two lines with the following:</span></span>\n\n```csharp\nWriteLine($\"The average word length is: {wordLength.Average()}\");\n```\n\n<span data-ttu-id=\"258a8-149\">上記の例を実行すると、`Average` の出力の小数点以下の桁数が必要以上に多いことに気付くでしょう。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-149\">Running the preceding example, you would find that the output for `Average` has more decimal places than you would like.</span></span> <span data-ttu-id=\"258a8-150\">文字列補間の構文では、これまでの書式設定メソッドを通じて利用できるすべての書式がサポートされます。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-150\">The string interpolation syntax supports all the format strings available using earlier formatting methods.</span></span> <span data-ttu-id=\"258a8-151\">中かっこ内に書式文字列を指定します。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-151\">You specify the format string inside the braces.</span></span> <span data-ttu-id=\"258a8-152\">書式設定する式 の後に、`:` を追加します。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-152\">Add a `:` following the expression to format:</span></span>\n\n```csharp\nWriteLine($\"The average word length is: {wordLength.Average():F2}\");\n```\n"
- title: <span data-ttu-id="258a8-153">手早く簡単な null チェック</span><span class="sxs-lookup"><span data-stu-id="258a8-153">Quick and easy null checks</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"258a8-154\">`?.` (null 条件) 演算子により、追加の `if` チェックを行わなくても、`null` 値をシームレスに考慮するロジックの記述が容易になります。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-154\">The `?.` (null conditional) operator makes it easier to write logic that takes `null` values into account seamlessly, without extra `if` checks.</span></span> <span data-ttu-id=\"258a8-155\">この機能を詳しく学習するため、まず次のコードを対話型ウィンドウにコピーして、試してみましょう。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-155\">To explore the feature, start by copying the following code into the interactive window to try it:</span></span>\n\n```csharp\nusing System;\n\npublic class Program\n{\n    public static void Main()\n    {\n      string s = null;\n      Console.WriteLine(s.Length);\n    }\n}\n```\n\n<span data-ttu-id=\"258a8-156\">サンプルを実行すると、<xref:System.NullReferenceException> がスローされます。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-156\">It throws a <xref:System.NullReferenceException> when you run the sample.</span></span> <span data-ttu-id=\"258a8-157\">`.` メンバー アクセス演算子を **null 条件演算子**に変更します。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-157\">Change the `.` member access operator to the **null conditional operator**:</span></span>\n\n```csharp\nConsole.WriteLine(s?.Length);\n``` \n\n<span data-ttu-id=\"258a8-158\">これを変更すると、出力がなくなります。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-158\">After this change, there's no output.</span></span> <span data-ttu-id=\"258a8-159\">これは、`s.Length` の結果が `int` の場合、`s?.Length` の結果は `int?` となるからです。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-159\">That's because the result of `s?.Length` is an `int?` when the result of `s.Length` is an `int`.</span></span> <span data-ttu-id=\"258a8-160\">この例では、`s?.Length` は `null` です。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-160\">In this example, `s?.Length` is `null`.</span></span> <span data-ttu-id=\"258a8-161\">左オペランドが `null` の場合、`?.` は `null` を返します。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-161\">The `?.` returns `null` if its left operand is `null`.</span></span> <span data-ttu-id=\"258a8-162\">右オペランドの型が値の型である場合、`?.` 演算子はその型に対して null 許容型を返します。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-162\">If the type of the right operand is a value type, the `?.` operator returns a nullable type for that type.</span></span> <span data-ttu-id=\"258a8-163\">配列アクセスまたはインデクサー アクセスには、`?.` の他に `?[]` も使用できます。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-163\">In addition to `?.` you can use `?[]` for array or indexer access.</span></span> <span data-ttu-id=\"258a8-164\">対話型ウィンドウで次のコードを実行します。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-164\">Try the following code in the interactive window:</span></span>\n\n ```csharp\n char? c = s?[0];\n Console.WriteLine(c.HasValue);\n ```\n\n <span data-ttu-id=\"258a8-165\">複数の条件演算子は、1 つの式に結合できます。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-165\">Multiple conditional operators can be combined into a single expression.</span></span> <span data-ttu-id=\"258a8-166\">`null` 左オペランドは `null` の結果を生成し、入れ子になった if 句がメンバーのメンバーにアクセスするのを簡単に回避できるようにします。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-166\">A `null` left operand produces a `null` result, making it easy to avoid nested if clauses to access members of members.</span></span> <span data-ttu-id=\"258a8-167\">たとえば、対話型ウィンドウで次のコードを実行してみましょう。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-167\">For example, try the following code in the interactive window:</span></span>\n\n ```csharp\n string s = null;\n bool? hasMore = s?.ToCharArray()?.GetEnumerator()?.MoveNext();\n Console.WriteLine(hasMore.HasValue);\n ```\n\n <span data-ttu-id=\"258a8-168\">既定値を指定する **null 合体演算子**を使用して、前出の例を簡略化できます。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-168\">The preceding example can be simplified by using the **null coalescing operator** to provide a default value:</span></span>\n\n ```csharp\n bool hasMore = s?.ToCharArray()?.GetEnumerator()?.MoveNext() ?? false;\n Console.WriteLine(hasMore);\n ```\n\n <span data-ttu-id=\"258a8-169\">**null 条件演算子**は、`null` 値をシームレスにテストしながら、コア ロジックを明確にするコードを記述するのに役立ちます。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-169\">The **null conditional operator** helps you write code that makes your core logic clear while seamlessly testing for `null` values.</span></span>\n"
- title: <span data-ttu-id="258a8-170">例外フィルター</span><span class="sxs-lookup"><span data-stu-id="258a8-170">Exception filters</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"258a8-171\">例外フィルターを使用すると、いくつかの条件に基づいて例外をキャッチできます。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-171\">Exception filters enable you to catch an exception based on some condition.</span></span> <span data-ttu-id=\"258a8-172\">一般的な用途は、例外をログに記録するものの、それらの例外を処理しないフィルター メソッドを作成することです。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-172\">A typical use is to create a filter method that logs exceptions, but never handles those exceptions.</span></span> <span data-ttu-id=\"258a8-173\">例外フィルターはブール式です。`catch` 句を実行する必要がある場合は `true` で、例外を `catch` 句でキャッチする必要がない場合は `false` です。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-173\">An exception filter is a boolean expression that is `true` when the `catch` clause should be executed, and `false` when the exception should not be caught by the `catch` clause.</span></span> <span data-ttu-id=\"258a8-174\">対話型ウィンドウで次のコードを実行します。これにより例外の種類とメッセージがコンソールに記録されます。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-174\">Try the following code in the interactive window: It logs the exception type and message to the console.</span></span> <span data-ttu-id=\"258a8-175\">これにより例外を処理できないことを示す `false` が返されます。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-175\">It returns `false` which indicates that the exception can't be handled.</span></span> <span data-ttu-id=\"258a8-176\">対話型ウィンドウでこのプログラムを実行します。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-176\">Try the program in the interactive window.</span></span>\n\n```csharp\nusing System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        try \n        {\n            string s = null;\n            Console.WriteLine(s.Length);\n\n        } catch (Exception e) when (LogException(e))\n        {\n        }\n        Console.WriteLine(\"Exception must have been handled\");\n    }\n\n    private static bool LogException(Exception e)\n    {\n        Console.WriteLine($\"\\tIn the log routine. Caught {e.GetType()}\");\n        Console.WriteLine($\"\\tMessage: {e.Message}\");\n        return false;\n    }\n}\n```\n\n<span data-ttu-id=\"258a8-177\">`LogException` メソッドからのメッセージが表示され、それに続いて既定の例外メッセージが表示されるはずです。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-177\">You should see the message from the `LogException` method, followed by the default exception message.</span></span> <span data-ttu-id=\"258a8-178\">実験のためだけに、`return false` ステートメントを `return true` に変更してもう一度実行します。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-178\">Just to experiment, change the `return false` statement to `return true` and run this again.</span></span> <span data-ttu-id=\"258a8-179\">これで、例外がキャッチされ、プログラムの実行が完了します。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-179\">Now, the exception is caught and the program runs to completion.</span></span>\n\n<span data-ttu-id=\"258a8-180\">ログ記録のシナリオの他に、例外フィルターが最も役に立つのは、例外のプロパティにより実行するアクションを決定する場合です。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-180\">Beyond logging scenarios, exception filters can be most useful when a property of the exception determines what action to take.</span></span> <span data-ttu-id=\"258a8-181\">たとえば、<xref:System.AggregateException> の内部を見て、どのような例外が含まれているかを確認して、特定の例外に応じて適切なアクションを実行することができます。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-181\">For example, you can look inside an <xref:System.AggregateException> to see what the contained exceptions are and take some appropriate action depending on the specific exception.</span></span>\n"
- title: <span data-ttu-id="258a8-182">nameof の使用</span><span class="sxs-lookup"><span data-stu-id="258a8-182">Using nameof</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"258a8-183\">`nameof` 演算子は、任意の変数、型、型のメンバーを返します。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-183\">The `nameof` operator returns the name of any variable, a type, or a type's member.</span></span> <span data-ttu-id=\"258a8-184\">対話型ウィンドウで次のコードを実行して、その動作を確認します。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-184\">Try the following code in the interactive window to see how it works:</span></span>\n\n```csharp\nusing System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        Console.WriteLine(nameof(System.String));\n        int j = 5;\n        Console.WriteLine(nameof(j));\n        List<string> names = new List<string>();\n        Console.WriteLine(nameof(names));\n    }\n}\n```\n\n<span data-ttu-id=\"258a8-185\">出力は、変数または型の名前と一致します。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-185\">The output matches the name of the variable or type.</span></span> <span data-ttu-id=\"258a8-186\">完全修飾型名 (`System.String` など) を指定した場合でも、`nameof` 演算子は非修飾名を返します。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-186\">Even when you provided the fully qualified type name (such as `System.String`) the `nameof` operator returns the unqualified name.</span></span> <span data-ttu-id=\"258a8-187\">この機能は、パラメーターまたはプロパティの名前を文字列に変換する必要がある場合に最も役立ちます。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-187\">This feature is most useful when you need to convert a parameter or property name to a string.</span></span> <span data-ttu-id=\"258a8-188\">例としては、<xref:System.ArgumentNullException> または <xref:System.ArgumentException> をスローするための引数の名前のキャプチャや、<xref:System.ComponentModel.INotifyPropertyChanged> の実装時に変更されたプロパティの名前のキャプチャがあります。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-188\">Examples include capturing the name of an argument for throwing a <xref:System.ArgumentNullException> or <xref:System.ArgumentException>, or capturing the name of a changed property when implementing <xref:System.ComponentModel.INotifyPropertyChanged>.</span></span> \n"
- title: <span data-ttu-id="258a8-189">新しいオブジェクトの初期化の構文</span><span class="sxs-lookup"><span data-stu-id="258a8-189">New object initialization syntax</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"258a8-190\">新しいオブジェクトの初期化では、ディクショナリやその他の型の初期化を容易にするメソッドを作成することができます。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-190\">New object initialization enables you to create methods that make it easier to initialize dictionaries, and other types.</span></span> <span data-ttu-id=\"258a8-191\">ディクショナリから始めましょう。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-191\">Start with a dictionary.</span></span> <span data-ttu-id=\"258a8-192\">対話型ウィンドウで次のコードを実行します。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-192\">Run the following code in the interactive window:</span></span>\n\n```csharp\nvar messages = new Dictionary<int, string>\n{\n    [404] = \"Page not Found\",\n    [302] = \"Page moved, but left a forwarding address.\",\n    [500] = \"The web server can't come out to play today.\"\n};\n\nConsole.WriteLine(messages[302]);\n```\n\n<span data-ttu-id=\"258a8-193\">この構文は、<xref:System.Collections.IEnumerable> を実装し、パブリックにアクセスできる `Add` メソッドを持つ任意のクラスに拡張できます。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-193\">You can extend this syntax to any class that implements <xref:System.Collections.IEnumerable> and has a publicly accessible `Add` method.</span></span>  <span data-ttu-id=\"258a8-194\">対話型ウィンドウで次のサンプルを実行してみましょう。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-194\">Try the following sample in the interactive window.</span></span> <span data-ttu-id=\"258a8-195\">これにより、`IEnumerable<Point3D>` を実装し、3 つの引数を受け取るポイントを追加するメソッドを持つ `Path` クラスが作成されます。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-195\">It creates a `Path` class that implements `IEnumerable<Point3D>` and has a method to add points that takes three arguments.</span></span> <span data-ttu-id=\"258a8-196\">また、式形式のメンバーや文字列補間など、このチュートリアルで既に示した他の手法を結合します。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-196\">It also combines other techniques already demonstrated in this tutorial, such as expression-bodied members and string interpolation.</span></span> \n\n<span data-ttu-id=\"258a8-197\">`Main` メソッドでは、ポイントの座標を指定してパスを初期化します。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-197\">In the `Main` method, you initialize a path by providing coordinates for the points.</span></span> <span data-ttu-id=\"258a8-198\">これらのポイントは、`Add` メソッドを通じてコレクションに追加されます。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-198\">Those points are added to the collection through the `Add` method.</span></span>\n\n<span data-ttu-id=\"258a8-199\">`Add` メソッドも拡張メソッドとして使用できます。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-199\">The `Add` method can also be an extension method.</span></span> <span data-ttu-id=\"258a8-200\">上記のサンプルを次のように更新することができます。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-200\">You could update the preceding sample as follows.</span></span> <span data-ttu-id=\"258a8-201\">サンドボックスの制限により、対話型エクスペリエンスではこのサンプルはコンパイルされません。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-201\">This sample won't compile in the interactive experience because of sandbox limitations.</span></span> <span data-ttu-id=\"258a8-202\">お使いのコンピューターで試すことができます。</span><span class=\"sxs-lookup\"><span data-stu-id=\"258a8-202\">You can try it on your own machine.</span></span>\n\n```csharp\npublic class Path : IEnumerable<Point3D>\n{\n    private List<Point3D> points = new List<Point3D>();\n    public IEnumerator<Point3D> GetEnumerator() => points.GetEnumerator();\n    IEnumerator IEnumerable.GetEnumerator() => points.GetEnumerator();\n\n    public void Add(Point3D pt) => points.Add(pt);\n}\n\npublic static class Extensions\n{\n    public static void Add(this Path path, double x, double y, double z) => path.Add(new Point3D(x, y, z));\n}\n```\n"
- content: <span data-ttu-id="258a8-203">C# 6 の新機能の詳しい学習が完了しました。</span><span class="sxs-lookup"><span data-stu-id="258a8-203">You've completed an exploration of the new features in C# 6.</span></span> <span data-ttu-id="258a8-204">次は、ご自分のアプリケーションで試してみましょう。</span><span class="sxs-lookup"><span data-stu-id="258a8-204">Now try them yourself in your applications.</span></span>
