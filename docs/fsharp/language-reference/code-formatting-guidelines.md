---
title: "コードのフォーマットに関するガイドライン (F#)"
description: "F# のプログラミングの読みやすさ、美しさ、標準化、およびコンパイル言語のコードのインデントのフォーマットに関するガイドラインを説明します。"
keywords: "visual f#, f#, 関数型プログラミング"
author: cartermp
ms.author: phcart
ms.date: 05/16/2016
ms.topic: language-reference
ms.prod: .net
ms.technology: devlang-fsharp
ms.devlang: fsharp
ms.assetid: 3f79717c-f84e-448d-9ce4-90e40a644ba1
ms.openlocfilehash: cc56c67f356b99defd8dc28770f87be1f58443c5
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/18/2017
---
# <a name="code-formatting-guidelines"></a>コードのフォーマットに関するガイドライン

このトピックでは、f# のコードのインデントのガイドラインをまとめたものです。 F# 言語は改行文字とインデントに機密性の高いためは、読みやすさの問題、見た目の問題、または、コードを正しく書式設定するコーディングの標準化問題だけです。 正常に正しくコンパイルするコードの書式を設定する必要があります。


## <a name="general-rules-for-indentation"></a>インデントの一般的な規則
インデントが必要な場合は、スペース、タブではなくを使用する必要があります。 少なくとも 1 つの領域が必要です。 組織がインデントに使用する空白文字の数を指定するコーディング規則を作成できます。インデントを設定する各レベルのインデントの 3 つまたは 4 つのスペースが一般的です。 Visual Studio でのオプションを変更することによって、組織のインデントの標準に合わせてを構成することができます、 `Options`  ダイアログ ボックスから利用できる、`Tools`メニュー。 `Text Editor`  ノードを展開`F#` をクリックし、`Tabs`です。 使用可能なオプションの説明は、次を参照してください。[オプション、テキスト エディター、すべての言語、タブ](https://msdn.microsoft.com/library/7sffa753.aspx)です。

一般に、コンパイラがコードを解析するときは、内部スタックを現在の入れ子レベルを示すを維持します。 コードにインデントは、新しい入れ子のレベルが作成されると、か、この内部スタックにプッシュされます。 構成要素の終了時に、レベルがポップされます。 インデント レベルの終了を通知し、内部のスタックをポップする方法の 1 つが発生する、レベルなど、ポップできますをも特定のトークン、`end`キーワード、または右中かっこまたはかっこを入力します。

関数定義の種類の定義など、複数行の構成体コード`try...with`構造やループ構造にコンストラクトの開始行にインデントする必要があります。 インデントを設定した 1 行目では、同じ構成要素で後続のコードの列の位置を設定します。 インデント レベルを呼び出す、*コンテキスト*です。 列の位置と呼ばれる最小の列の設定、*オフサイド ライン*、同じコンテキストでは、後続の行のコードにします。 コードの行が発生した場合に、この設定された列の位置よりも少ないインデント、コンパイラには、コンテキストが終了したこととするようになりましたをコーディングする次のレベルに、以前のコンテキストが前提としています。 用語*オフサイド*を十分に離れたインデントされませんので、コードの行構造の末尾をトリガーする条件を記述するために使用します。 つまり、オフサイド ラインの左側にあるコードはオフサイドです。 正しくインデントされたコードで利用するオフサイド ルールの構成要素の終了を示すためにします。 インデントを不適切に使用する場合オフサイド状態コンパイラ警告を発行する可能性があります。 またはコードの誤った解釈につながることができます。

オフサイド ラインは、次のように決定されます。


- `=`トークンに関連付けられている、`let`後の最初のトークンの 1 列にオフサイド ラインが、`=`記号。


- `if...then...else`式、後の最初のトークンの列の位置、`then`キーワードまたは`else`キーワード オフサイド ラインが導入されています。


- `try...with`式、後の最初のトークン`try`オフサイド ラインします。


- `match`式、後の最初のトークン`with`とそれぞれの後に最初のトークン`->`オフサイド ラインします。


- 後の最初のトークン`with`拡張機能の種類ではオフサイド ラインが導入されています。


- 最初のトークンの後に左中かっこまたはかっこ、または後に、`begin`キーワード、オフサイド ラインが導入されています。


- キーワードの最初の文字`let`、 `if`、および`module`オフサイド ラインします。


次のコード例では、インデント規則を示します。 ここでは、print ステートメントは、適切なコンテキストと関連付けるインデントに依存します。 インデントが変わるたびにコンテキストがポップされ、以前のコンテキストを返します。 各反復の末尾にスペースを印刷するそのため、「完了」です。 オフサイド インデント、ループの一部ではないことを確立するため、1 回を出力のみがします。 文字列"最上位レベルのコンテキスト の印刷は、関数の一部ではできません。 したがって、最初に出力されます、初期化中に、静的な関数が呼び出される前にします。

[!code-fsharp[Main](../../../samples/snippets/fsharp/code-formatting/snippet1.fs)]

出力は次のとおりです。

```
Top-level context

(Negative number) Zero 1 2 3 Done!
```

長い行を中断したときは、それを囲むコンストラクトよりも行の継続をインデントする必要があります。 たとえば、次のコードに示すように、関数名の最初の文字よりも関数の引数をインデントする必要があります。

[!code-fsharp[Main](../../../samples/snippets/fsharp/code-formatting/snippet2.fs)]

これらの規則の例外があるように、次のセクションで説明します。


## <a name="indentation-in-modules"></a>モジュールのインデント
モジュールを基準としたローカル モジュール内のコードのインデントを設定する必要がありますが、最上位レベルのモジュール内のコードにインデントを解除するがないです。 Namespace 要素は、インデントする必要はありません。

次のコード例では、この問題を説明します。

[!code-fsharp[Main](../../../samples/snippets/fsharp/code-formatting/snippet3.fs)]
[!code-fsharp[Main](../../../samples/snippets/fsharp/code-formatting/snippet4.fs)]

詳細については、次を参照してください。[モジュール](modules.md)です。


## <a name="exceptions-to-the-basic-indentation-rules"></a>基本的なインデント規則の例外
一般的な規則、コンストラクトの最初の行のインデントの基準とした複数行の構造体でコードをインデントする必要があります、最初のオフサイド ラインが発生すると、コンストラクトの末尾がによって決定されるを前のセクションで説明したです。 コンテキストの末尾が、一部を構築などの場合は、規則の例外、`try...with`式では、`if...then...else`式、および使用する`and`再帰関数や型を一緒に宣言するための構文には、複数の一部が含まれています。 など、後の部分をインデントする`then`と`else`で、`if...then...else`式、同時に、トークンとレベルを開始されますが、式がコンテキストの終了を示すではなく、同じコンテキストの次の部分を表します。 したがって、`if...then...else`式は、次のコード例のように記述できます。

[!code-fsharp[Main](../../../samples/snippets/fsharp/code-formatting/snippet5.fs)]

オフサイド規則の例外にのみ適用され、`then`と`else`キーワード。 したがって、インデントを設定すると、エラーではありませんが、`then`と`else`内のコードの行をインデントするさらに、失敗している、`then`ブロックは、警告を生成します。 これは、次のコード行に示します。

[!code-fsharp[Main](../../../samples/snippets/fsharp/code-formatting/snippet6.fs)]
[!code-fsharp[Main](../../../samples/snippets/fsharp/code-formatting/snippet7.fs)]

コードに、`else`ブロック、その他の特別な規則が適用されます。 内のコードでのみ、前の例で警告が発生した、`then`内のコードではなく、ブロック、`else`ブロックします。 これにより、関数の場合に可能性のあるコードの残りの部分を強制することがなく、関数の先頭にさまざまな条件をチェックするコードを記述するため、`else`ブロックをインデントされます。 したがって、警告が生成されず、次を記述できます。

[!code-fsharp[Main](../../../samples/snippets/fsharp/code-formatting/snippet8.fs)]

別の例外として前の行は挿入演算子など、行はインデントされないときにコンテキストを終了するルールを`+`と`|>`です。 挿入演算子で始まる行は、開始を許可する`(1 + oplength)`、コンテキストの終了をトリガーすることがなく通常の位置の前に列を`oplength`演算子文字の数です。 これにより、前の行に合うように演算子の後に最初のトークンが原因です。

たとえば、次のコードで、`+`記号の前の行未満のインデントされた 2 つの列では許可されています。

[!code-fsharp[Main](../../../samples/snippets/fsharp/code-formatting/snippet9.fs)]

インデントは、通常、入れ子のレベルが高くなり、向上しますが、コンパイラが低い列の位置にインデントをリセットすることに、いくつかの構造があります。

列の位置をリセットできる構成要素は次のとおりです。


- 匿名関数の本体。 次のコードでは、印刷式はよりもよりも左にある列の位置から始まり、`fun`キーワード。 ただし、行は、前のインデント レベルの開始の左側の列で開始する必要がありますされません (つまりの左側に、`L`で`List`)。
[!code-fsharp[Main](../../../samples/snippets/fsharp/code-formatting/snippet10.fs)]

- 構成要素を囲む丸かっこまたは`begin`と`end`で、`then`または`else`のブロック、`if...then...else`インデントいいえよりも小さいかの列の位置、式が提供される、`if`キーワード。 コーディング スタイルでは、この例外開きかっこを入力または`begin`後の行の最後に使用される`then`または`else`です。


- モジュール、クラス、インターフェイス、およびで区切られた構造体の本体`begin...end`、 `{...}`、 `class...end`、または`interface...end`です。 これによりを型定義の開始キーワードできる型名と同じ行に始めキーワードよりもインデントする本文全体を強制することがなくスタイル。
[!code-fsharp[Main](../../../samples/snippets/fsharp/code-formatting/snippet13.fs)]


## <a name="see-also"></a>関連項目
[F# 言語リファレンス](index.md)
