---
title: キャストと変換 (F#)
description: F# のプログラミング言語が提供する方法の変換演算子のさまざまなプリミティブ型間での算術変換について説明します。
ms.date: 05/16/2016
ms.openlocfilehash: ba3cbed91bf6510a34bcb7ba89d34b0ea6b82711
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/04/2018
ms.locfileid: "33564496"
---
# <a name="casting-and-conversions-f"></a>キャストと変換 (F#)

このトピックでは、f# の型変換のサポートについて説明します。

## <a name="arithmetic-types"></a>数値型
F# では、変換演算子さまざまなプリミティブ型の間での算術変換など、整数と浮動小数点型の間です。 整数型および char 型の変換演算子がチェックとオンになっていないフォームです。浮動小数点演算の演算子と`enum`変換演算子がありません。 オンになっていないフォームが定義されている`Microsoft.FSharp.Core.Operators`でチェックされたフォームが定義されていると`Microsoft.FSharp.Core.Operators.Checked`です。 チェックの形式では、オーバーフローをチェックし、結果の値が対象の型の制限を超える場合、ランタイム例外を生成します。

これらの演算子は、変換先の型の名前と同じ名前です。 たとえば、次のコードを型に明示的に注釈を付ける、`byte`で 2 つの異なる意味が表示されます。 最初に見つかった位置は、型であり、2 つ目は、変換演算子です。

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet4401.fs)]

次の表は、f# で定義された変換演算子を示します。

|演算子|説明|
|--------|-----------|
|`byte`|バイト、8 ビット符号なしの型に変換します。|
|`sbyte`|符号付きバイトに変換します。|
|`int16`|16 ビット符号付き整数に変換します。|
|`uint16`|16 ビット符号なし整数に変換します。|
|`int32, int`|32 ビット符号付き整数に変換します。|
|`uint32`|32 ビット符号なし整数に変換します。|
|`int64`|64 ビット符号付き整数に変換します。|
|`uint64`|64 ビット符号なし整数に変換します。|
|`nativeint`|ネイティブ整数に変換します。|
|`unativeint`|符号なしネイティブ整数に変換します。|
|`float, double`|64 ビット IEEE 倍精度浮動小数点数に変換します。|
|`float32, single`|32 ビット IEEE 単精度浮動小数点数に変換します。|
|`decimal`|変換`System.Decimal`です。|
|`char`|変換`System.Char`、Unicode 文字。|
|`enum`|列挙型に変換します。|
実装する型をこれらの演算子を使用する組み込みのプリミティブ型に加えて`op_Explicit`または`op_Implicit`適切なシグネチャを持つメソッドです。 たとえば、`int`変換演算子は静的メソッドを提供する任意の型と連携`op_Explicit`をパラメーターとして型を受け取り、返します`int`です。 戻り値の型でメソッドをオーバー ロードできません、一般的な規則に特殊な例外としてこれを行う`op_Explicit`と`op_Implicit`です。

## <a name="enumerated-types"></a>列挙型
`enum`演算子は、一般的な演算子の型を表す 1 つの型パラメーターを受け取る、`enum`に変換します。 列挙型に変換するときの入力の種類を決定しようと推論、`enum`に変換します。 次の例では、変数`col1`明示的に注釈がありませんが、それ以降の等値テストから型を推論します。 そのため、コンパイラに変換することを推測することができます、`Color`列挙します。 型の注釈を指定する代わりと同様に`col2`次の例です。

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet4402.fs)]
    
次のコードのように、型パラメーターとして明示的にターゲットの列挙型を指定できます。

```fsharp
let col3 = enum<Color> 3
```

列挙体の基になる型が変換対象の型に互換性がある場合にのみ、列挙体で作業をキャストすることに注意してください。 次のコードでは、変換の間の不一致によりコンパイルは失敗`int32`と`uint32`です。

```fsharp
// Error: types are incompatible
let col4 : Color = enum 2u
```

詳細については、次を参照してください。[列挙](enumerations.md)です。

## <a name="casting-object-types"></a>オブジェクト型のキャスト
オブジェクト階層内の型の間の変換は、オブジェクト指向プログラミングに不可欠です。 変換の 2 つの基本的な種類があります: (キャスト) をキャストして、(ダウン キャスト)。 階層へのキャストは、ベース オブジェクトの参照に、派生オブジェクト参照からキャストを意味します。 このようなキャストが派生クラスの継承階層内の基本クラスは時間どおりに動作する保証されます。 オブジェクトが実際には、適切な送信先 (派生) 型または変換先の型から派生した型のインスタンスが場合にのみ、派生オブジェクトの参照にベース オブジェクトの参照から、階層の下位へのキャストが成功します。

F# の型変換演算子を提供します。 `:>`まで、階層はキャスト演算子および`:?>`演算子が、階層の下位にキャストします。

### <a name="upcasting"></a>アップ キャスト
多くのオブジェクト指向言語をアップ キャストは暗黙の型です。f# では、規則は若干異なります。 キャストは、型のオブジェクト、メソッドに引数を渡すときに自動的に適用されます。 ただし、モジュール内の let-bound 関数でパラメーターの型は柔軟な型として宣言されていない限り アップ キャストは自動にされません。 詳細については、次を参照してください。[フレキシブル型](flexible-Types.md)です。

`:>`演算子は、静的なキャスト、キャストが成功したがコンパイル時に決定されることを意味するを実行します。 キャストを使用する場合、`:>`が正常には、コンパイルが有効なキャストは、実行時に障害の可能性を持たない。

使用することも、`upcast`オペレーターへの変換を実行します。 次の式は、階層内の上位変換を指定します。

```fsharp
upcast expression
```

Upcast 演算子を使用する場合、コンパイラは、コンテキストからに変換する型を推論しようとします。 コンパイラがターゲットの種類を特定できない場合は、コンパイラはエラーを報告します。

### <a name="downcasting"></a>ダウン キャスト
`:?>`演算子は動的なキャスト、キャストが成功したが実行時に決定されることを意味するを実行します。 使用するキャスト、`:?>`演算子は、コンパイル時にチェックされませんが、実行時にしようとしましたが、指定した型にキャストします。 オブジェクトは、対象の型と互換性が、キャストが成功します。 ランタイムを発生させる場合は、オブジェクトは、対象の型と互換性がありません、`InvalidCastException`です。

使用することも、`downcast`演算子の動的な型変換を実行します。 次の式は、階層内の下位プログラム コンテキストから推論される型への変換を指定します。

```fsharp
downcast expression
```

場合と同様、`upcast`演算子、コンパイラは、コンテキストから特定のターゲット型を推論できない場合、エラーが報告されます。

次のコードの使用例、`:>`と`:?>`演算子。 コードに示す、`:?>`わかっている場合に、変換が成功することをスローするため、演算子が使用される最適な`InvalidCastException`場合は、変換は失敗します。 変換が成功する、型を使用するテストがわからない場合、`match`の例外を生成によるオーバーヘッドを回避しているので、式が向上します。

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet4403.fs)]

ジェネリック演算子`downcast`と`upcast`上記のコードで、引数と戻り値の種類を特定の型の推定に依存して、置き換えることができます

```fsharp
let base1 = d1 :> Base1
```

代入

```fsharp
let base1 = upcast d1
```

前のコードで引数の型と戻り値の型が`Derived1`と`Base1`、それぞれします。

型のテストの詳細については、次を参照してください。 [Match 式](match-Expressions.md)です。

## <a name="see-also"></a>関連項目
[F# 言語リファレンス](index.md)
