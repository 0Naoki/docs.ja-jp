<Type Name="TextBoxBase" FullName="System.Windows.Controls.Primitives.TextBoxBase">
  <TypeSignature Language="C#" Value="public abstract class TextBoxBase : System.Windows.Controls.Control" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract TextBoxBase extends System.Windows.Controls.Control" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.Primitives.TextBoxBase" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.Control</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Text)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.TemplatePart(Name="PART_ContentHost", Type=typeof(System.Windows.FrameworkElement))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>テキストの編集など、コントロールの機能を提供する抽象基本クラス<see cref="T:System.Windows.Controls.TextBox" />と<see cref="T:System.Windows.Controls.RichTextBox" />です。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例は、派生を使用する方法を示します<xref:System.Windows.Controls.TextBox>オブジェクトに[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]です。  
  
 [!code-xaml[TextBoxBase_Samp#TextBoxBase1](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml#textboxbase1)]  
  
 次の例は、派生を使用する方法を示します<xref:System.Windows.Controls.RichTextBox>コード内のオブジェクト。  
  
 [!code-csharp[richtextboxsnippets#_RichTextBox_MouseUpDown](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_richtextbox_mouseupdown)]
 [!code-vb[richtextboxsnippets#_RichTextBox_MouseUpDown](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_richtextbox_mouseupdown)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AcceptsReturn">
      <MemberSignature Language="C#" Value="public bool AcceptsReturn { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AcceptsReturn" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.TextBoxBase.AcceptsReturn" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーが Enter キーを押したとき、テキスト編集コントロールがどのように反応するかを示す値を取得または設定します。</summary>
        <value>
          <see langword="true" />ENTER キーを押す場合; 現在のカーソル位置に新しい行を挿入します。それ以外の場合、ENTER キーは無視されます。 既定値は<see langword="false" />の<see cref="T:System.Windows.Controls.TextBox" />と<see langword="true" />の<see cref="T:System.Windows.Controls.RichTextBox" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ENTER キーに対応して`VK_RETURN`仮想キー コード。  
  
<a name="dependencyPropertyInfo_AcceptsReturn"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsReturnProperty>|  
|メタデータ プロパティに設定します。`true`|なし|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptsReturnProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AcceptsReturnProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AcceptsReturnProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.TextBoxBase.AcceptsReturnProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Controls.Primitives.TextBoxBase.AcceptsReturn" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptsTab">
      <MemberSignature Language="C#" Value="public bool AcceptsTab { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AcceptsTab" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tab キーが押されたとき、テキスト編集コントロールがどのように反応するかを示す値を取得または設定します。</summary>
        <value>
          <see langword="true" />場合は、TAB キーを押すと現在のカーソル位置にタブ文字を挿入します。<see langword="false" />場合は、タブ ストップとしてマークされ、タブ文字を挿入できませんの次のコントロールにフォーカスを移動、TAB キーを押すとします。  
  
 既定値は <see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 タブ キーに対応して**VK_TAB**仮想キー コード。  
  
<a name="dependencyPropertyInfo_AcceptsTab"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTabProperty>|  
|メタデータ プロパティに設定します。`true`|なし|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptsTabProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AcceptsTabProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AcceptsTabProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTabProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendText">
      <MemberSignature Language="C#" Value="public void AppendText (string textData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendText(string textData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.AppendText(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textData" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="textData">テキスト コントロールの現在の内容に追加するテキストを指定する文字列。</param>
        <summary>テキスト コントロールの内容を文字列を追加します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Primitives.TextBoxBase.AppendText%2A>メソッドにより、ユーザーが多数の連結が必要な場合、パフォーマンスを向上できる文字列連結を使用する必要なく、テキスト コントロールの内容にテキストを追加します。  
  
   
  
## Examples  
 <xref:System.Windows.Controls.Primitives.TextBoxBase.AppendText%2A> メソッドの使用方法を次の例に示します。  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase11](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase11)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase11](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoWordSelection">
      <MemberSignature Language="C#" Value="public bool AutoWordSelection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoWordSelection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.TextBoxBase.AutoWordSelection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはマウスのドラッグによって単語の一部を選択すると、単語の残りの部分が選択されているかどうかを決定する値を設定します。</summary>
        <value>
          <see langword="true" />自動単語選択が有効である場合それ以外の場合、<see langword="false" />です。  
  
 既定値は <see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ときに<xref:System.Windows.Controls.Primitives.TextBoxBase.AutoWordSelection%2A>は有効な場合、その単語の一部がマウスを使用して、単語の一部にドラッグして、ユーザーが選択されているたびに、選択範囲が自動的に展開に単語全体を含めます。 ユーザーは、すぐに逆にマウス ポインターがドラッグされているように、選択がなされる方向によって単語全体の自動選択をオーバーライドできます。 この操作は、単語全体の自動選択を元に戻します、正確な単語の一部またはすべてを選択することができます。  
  
 ときに<xref:System.Windows.Controls.Primitives.TextBoxBase.AutoWordSelection%2A>は無効になっている、選択範囲が自動的に単語全体を含めるには展開されません。 ここでは、選択範囲は常に決定されます手動でします。  
  
 **注:**自動選択では、最初の単語全体でユーザーがドラッグするには影響しません。 自動選択が有効になりますこの最初の単語の境界を超えた後にのみをお勧めします。  
  
<a name="dependencyPropertyInfo_AutoWordSelection"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Controls.Primitives.TextBoxBase.AutoWordSelectionProperty>|  
|メタデータ プロパティに設定します。`true`|なし|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoWordSelectionProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AutoWordSelectionProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AutoWordSelectionProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.TextBoxBase.AutoWordSelectionProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Controls.Primitives.TextBoxBase.AutoWordSelection" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginChange">
      <MemberSignature Language="C#" Value="public void BeginChange ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginChange() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.BeginChange" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ブロックの変更を開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 **注:**を呼び出すと<xref:System.Windows.Controls.Primitives.TextBoxBase.BeginChange%2A>も呼び出す必要があります<xref:System.Windows.Controls.Primitives.TextBoxBase.EndChange%2A>ブロックの変更を完了するそれ以外の場合、例外がスローされます。  
  
 ブロックの変更は論理的に単一の取り消し単位に複数の変更をグループ化し、テキスト コンテンツまたは選択変更イベントが、ブロックの変更が終了するまで発生していることを防ぎます。 このように別のリスナーによって、同時に変更されているテキスト要素の危険性なしのテキスト要素には複数の編集をすることができます。 ブロックの変更が呼び出すことによって作成された、<xref:System.Windows.Controls.Primitives.TextBoxBase.DeclareChangeBlock%2A>メソッドです。 呼び出す、<xref:System.Windows.Controls.Primitives.TextBoxBase.BeginChange%2A>メソッドにより、対応する呼び出しまで、指定された変更ブロックに含まれるすべての後続変更、<xref:System.Windows.Controls.Primitives.TextBoxBase.EndChange%2A>メソッドが行われます。  
  
   
  
## Examples  
 次の例を使用する方法を示しています、<xref:System.Windows.Controls.Primitives.TextBoxBase.BeginChange%2A>と<xref:System.Windows.Controls.Primitives.TextBoxBase.EndChange%2A>変更ブロックを作成する方法です。  
  
 [!code-csharp[TextBoxMiscSnippets_procedural_snip#BeginChangeEndChangeCodeExampleInline1](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxMiscSnippets_procedural_snip/CSharp/BeginChangeEndChangeExample.cs#beginchangeendchangecodeexampleinline1)]
 [!code-vb[TextBoxMiscSnippets_procedural_snip#BeginChangeEndChangeCodeExampleInline1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxMiscSnippets_procedural_snip/visualbasic/beginchangeendchangeexample.vb#beginchangeendchangecodeexampleinline1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanRedo">
      <MemberSignature Language="C#" Value="public bool CanRedo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRedo" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.TextBoxBase.CanRedo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最新の元に戻す操作をやり直すことができるかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" />場合は、最新の取り消し操作をやり直すことができます。それ以外の場合、<see langword="false" />です。  
  
 このプロパティには既定値はありません。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例を使用する方法を示しています、<xref:System.Windows.Controls.Primitives.TextBoxBase.CanRedo%2A>プロパティを最新の元に戻す操作をやり直すことができるかどうかを判断します。  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase9](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase9)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase9](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanUndo">
      <MemberSignature Language="C#" Value="public bool CanUndo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanUndo" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.TextBoxBase.CanUndo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>できるかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" />最新の操作が完了しました。 指定できる場合それ以外の場合、<see langword="false" />です。  
  
 このプロパティには既定値はありません。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例を使用する方法を示しています、<xref:System.Windows.Controls.Primitives.TextBoxBase.CanUndo%2A>できるかどうかを決定するプロパティです。  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase8](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase8)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase8](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaretBrush">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush CaretBrush { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush CaretBrush" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.TextBoxBase.CaretBrush" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはテキスト ボックスのキャレットの描画に使用されるブラシを設定します。</summary>
        <value>テキスト ボックスのキャレットの描画に使用されるブラシ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例を作成、<xref:System.Windows.Controls.TextBox>し、「これは、いくつかのテキストです」ですテキストの追加。 例のセット、<xref:System.Windows.Controls.Primitives.TextBoxBase.CaretBrush%2A>と<xref:System.Windows.Controls.Control.Foreground%2A>のプロパティ、<xref:System.Windows.Controls.TextBox>青にします。  
  
 [!code-xaml[TextBaseSelectionBrush#TextBox](~/samples/snippets/csharp/VS_Snippets_Wpf/textbaseselectionbrush/CS/window1.xaml#textbox)]   
  
 前の例では、次の図のような出力を生成します。  
  
 ![青に設定された CaretBrush のあるテキスト ボックス。](~/add/media/textboxcaretbrush.png "された CaretBrush のあるテキスト ボックスが青に設定します。")  
青に設定された CaretBrush の TextBox  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaretBrushProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CaretBrushProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CaretBrushProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.TextBoxBase.CaretBrushProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Controls.Primitives.TextBoxBase.CaretBrush" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public void Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.Copy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在選択されている編集コントロールがテキストをコピー、<see cref="T:System.Windows.Clipboard" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コピー操作を選択したテキストをコピー、<xref:System.Windows.Clipboard>です。 選択したテキストがテキスト編集コントロールで、プロセスから削除されないことに注意してください。 同様のメソッド、 <xref:System.Windows.Controls.Primitives.TextBoxBase.Cut%2A>、移動するのには、現在の選択、<xref:System.Windows.Clipboard>し、テキスト、プロセス内のコントロールを編集から、選択したテキストを削除します。  
  
   
  
## Examples  
 次の例で使用する方法、<xref:System.Windows.Controls.Primitives.TextBoxBase.Copy%2A>で選択されているテキストをコピーする方法、<xref:System.Windows.Controls.TextBox>コントロール。  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase4](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase4)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase4](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase4)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">継承時の完全な信頼。 このメンバーは、部分的に信頼されたコードでは継承できません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Cut">
      <MemberSignature Language="C#" Value="public void Cut ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Cut() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.Cut" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>テキスト編集コントロールから現在の選択範囲を削除し、コピーを<see cref="T:System.Windows.Clipboard" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 切り取り操作はテキスト編集コントロールから現在の選択範囲を削除し、コピーを<xref:System.Windows.Clipboard>です。 選択したテキストが削除されたことに注意してください () から切り取りテキスト、プロセス内のコントロールを編集します。 同様のメソッド、 <xref:System.Windows.Controls.Primitives.TextBoxBase.Copy%2A>、現在の選択範囲をクリップボードにコピーが、テキスト編集コントロールから、選択したテキストは削除されません。  
  
   
  
## Examples  
 次の例で使用する方法、<xref:System.Windows.Controls.Primitives.TextBoxBase.Cut%2A>で選択されているテキストを削除する方法、<xref:System.Windows.Controls.TextBox>コントロール。  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase5](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase5)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase5](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase5)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">継承時の完全な信頼。 このメンバーは、部分的に信頼されたコードでは継承できません。</permission>
      </Docs>
    </Member>
    <Member MemberName="DeclareChangeBlock">
      <MemberSignature Language="C#" Value="public IDisposable DeclareChangeBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IDisposable DeclareChangeBlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.DeclareChangeBlock" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>変更ブロックを作成します。</summary>
        <returns><see cref="T:System.IDisposable" />新しいブロックの変更を参照するオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ブロックの変更には、複数の変更を単一の元に戻す単位に論理的にグループ化します。 ブロックの変更が呼び出すことによって作成された、<xref:System.Windows.Controls.Primitives.TextBoxBase.DeclareChangeBlock%2A>メソッドです。 呼び出す、<xref:System.Windows.Controls.Primitives.TextBoxBase.BeginChange%2A>メソッドにより、対応する呼び出しまで、指定された変更ブロックに含まれるすべての後続変更、<xref:System.Windows.Controls.Primitives.TextBoxBase.EndChange%2A>メソッドが行われます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndChange">
      <MemberSignature Language="C#" Value="public void EndChange ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndChange() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.EndChange" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>変更ブロックを終了します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 **注:**を呼び出すと<xref:System.Windows.Controls.Primitives.TextBoxBase.BeginChange%2A>も呼び出す必要があります<xref:System.Windows.Controls.Primitives.TextBoxBase.EndChange%2A>ブロックの変更を完了するそれ以外の場合、例外がスローされます。  
  
 ブロックの変更は論理的に単一の取り消し単位に複数の変更をグループ化し、テキスト コンテンツまたは選択変更イベントが、ブロックの変更が終了するまで発生していることを防ぎます。 こうすると、同時に別のプロセスによって変更されているテキスト要素の危険性なしのテキスト要素には複数の編集をすることができます。 ブロックの変更が呼び出すことによって作成された、<xref:System.Windows.Controls.Primitives.TextBoxBase.DeclareChangeBlock%2A>メソッドです。 呼び出す、<xref:System.Windows.Controls.Primitives.TextBoxBase.BeginChange%2A>メソッドにより、対応する呼び出しまで、指定された変更ブロックに含まれるすべての後続変更、<xref:System.Windows.Controls.Primitives.TextBoxBase.EndChange%2A>メソッドが行われます。  
  
   
  
## Examples  
 次の例を使用する方法を示しています、<xref:System.Windows.Controls.Primitives.TextBoxBase.BeginChange%2A>と<xref:System.Windows.Controls.Primitives.TextBoxBase.EndChange%2A>変更ブロックを作成する方法です。  
  
 [!code-csharp[TextBoxMiscSnippets_procedural_snip#BeginChangeEndChangeCodeExampleInline1](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxMiscSnippets_procedural_snip/CSharp/BeginChangeEndChangeExample.cs#beginchangeendchangecodeexampleinline1)]
 [!code-vb[TextBoxMiscSnippets_procedural_snip#BeginChangeEndChangeCodeExampleInline1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxMiscSnippets_procedural_snip/visualbasic/beginchangeendchangeexample.vb#beginchangeendchangecodeexampleinline1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExtentHeight">
      <MemberSignature Language="C#" Value="public double ExtentHeight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ExtentHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.TextBoxBase.ExtentHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示されるコンテンツ エリアの縦のサイズを取得します。</summary>
        <value>浮動小数点値で、表示されるコンテンツ エリアの縦のサイズを示す[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]です。  
  
 テキスト編集コントロールがスクロールをサポートするために構成されていない場合、このプロパティの値は 0.0 です。  
  
 このプロパティには既定値はありません。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、値を読み取る、<xref:System.Windows.Controls.Primitives.TextBoxBase.ExtentHeight%2A>プロパティです。  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase3](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase3)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExtentWidth">
      <MemberSignature Language="C#" Value="public double ExtentWidth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ExtentWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.TextBoxBase.ExtentWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示されるコンテンツ エリアの横幅を取得します。</summary>
        <value>浮動小数点値で、表示されるコンテンツ エリアの横幅を示す[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]です。  
  
 テキスト編集コントロールがスクロールをサポートするために構成されていない場合、このプロパティの値は 0.0 です。  
  
 このプロパティには既定値はありません。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、値を読み取る、<xref:System.Windows.Controls.Primitives.TextBoxBase.ExtentWidth%2A>プロパティです。  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase3](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase3)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalOffset">
      <MemberSignature Language="C#" Value="public double HorizontalOffset { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 HorizontalOffset" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.TextBoxBase.HorizontalOffset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>水平方向のスクロール位置を取得または設定します。</summary>
        <value>浮動小数点値で、水平スクロールの位置を示す[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]です。  
  
 このプロパティを設定すると、テキスト編集コントロールを水平方向の指定されたオフセットにスクロールします。 このプロパティを読み取るには、現在の水平方向のオフセットが返されます。  
  
 テキスト編集コントロールがスクロールをサポートするために構成されていない場合、このプロパティの値は 0.0 です。  
  
 このプロパティには既定値はありません。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 右から左モードで作業している場合、水平方向のオフセットが表示されるテキスト領域の右側から測定されます。それ以外の場合、左から計測されます。  
  
   
  
## Examples  
 次の例では、値を読み取る、<xref:System.Windows.Controls.Primitives.TextBoxBase.HorizontalOffset%2A>プロパティです。  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase3](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase3)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">このプロパティに負の値を設定しようとしました。</exception>
      </Docs>
    </Member>
    <Member MemberName="HorizontalScrollBarVisibility">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ScrollBarVisibility HorizontalScrollBarVisibility { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Controls.ScrollBarVisibility HorizontalScrollBarVisibility" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.TextBoxBase.HorizontalScrollBarVisibility" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ScrollBarVisibility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または水平スクロール バーが表示されるかどうかを示す値を設定します。</summary>
        <value>定義されている値、<see cref="T:System.Windows.Controls.ScrollBarVisibility" />列挙します。  
  
 既定値は <see cref="F:System.Windows.Visibility.Hidden" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_HorizontalScrollBarVisibility"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Controls.Primitives.TextBoxBase.HorizontalScrollBarVisibilityProperty>|  
|メタデータ プロパティに設定します。`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 次の例は、の値を設定する方法を示します、<xref:System.Windows.Controls.Primitives.TextBoxBase.HorizontalScrollBarVisibility%2A>プロパティを使用して[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]です。  
  
 [!code-xaml[TextBoxBase_Samp#TextBoxBase1](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml#textboxbase1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalScrollBarVisibilityProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HorizontalScrollBarVisibilityProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HorizontalScrollBarVisibilityProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.TextBoxBase.HorizontalScrollBarVisibilityProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Controls.Primitives.TextBoxBase.HorizontalScrollBarVisibility" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInactiveSelectionHighlightEnabled">
      <MemberSignature Language="C#" Value="public bool IsInactiveSelectionHighlightEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInactiveSelectionHighlightEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.TextBoxBase.IsInactiveSelectionHighlightEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはテキスト ボックスでは、テキスト ボックスにフォーカスがあるないときに、選択したテキストが表示されるかどうかを示す値を設定します。</summary>
        <value>
          <see langword="true" />テキスト ボックスにフォーカスがあるない場合に、テキスト ボックスが選択したテキストを表示する場合それ以外の場合、<see langword="false" />です。  
  
 登録済みの既定値は <see langword="false" /> です。 新機能に影響を与える値の詳細については、次を参照してください。[依存関係プロパティの値の優先順位](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsInactiveSelectionHighlightEnabled"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Controls.Primitives.TextBoxBase.IsInactiveSelectionHighlightEnabledProperty>|  
|メタデータ プロパティに設定します。`true`|なし|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInactiveSelectionHighlightEnabledProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsInactiveSelectionHighlightEnabledProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsInactiveSelectionHighlightEnabledProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.TextBoxBase.IsInactiveSelectionHighlightEnabledProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Controls.Primitives.TextBoxBase.IsInactiveSelectionHighlightEnabled" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.TextBoxBase.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>テキスト編集コントロールを操作するユーザーに対して、コントロールが読み取り専用であるかどうかを示す値を取得または設定します。</summary>
        <value>
          <see langword="true" />場合は、テキスト編集コントロールの内容はユーザーに対して読み取り専用それ以外の場合、テキスト編集コントロールの内容は、ユーザーによって変更できます。 既定値は <see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この値には、コントロールを操作しているユーザーのみに影響します。 テキスト編集コントロールの内容は、プログラムで常に変更できます。  
  
<a name="dependencyPropertyInfo_IsReadOnly"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Controls.Primitives.TextBoxBase.IsReadOnlyProperty>|  
|メタデータ プロパティに設定します。`true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnlyCaretVisible">
      <MemberSignature Language="C#" Value="public bool IsReadOnlyCaretVisible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnlyCaretVisible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.TextBoxBase.IsReadOnlyCaretVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または読み取り専用のテキスト ボックスにキャレットを表示するかどうかを示す値を設定します。</summary>
        <value>
          <see langword="true" />読み取り専用のテキスト ボックスにキャレット; が表示される場合それ以外の場合、<see langword="false" />です。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ときに<xref:System.Windows.Controls.Primitives.TextBoxBase.IsReadOnly%2A>は`true`ユーザーがテキストを選択してコピーできます。 場合、<xref:System.Windows.Controls.Primitives.TextBoxBase.IsReadOnlyCaretVisible%2A>プロパティに設定されても`true`キャレットは、テキスト ボックスにキーボード フォーカスがある場合、テキスト ボックスに表示されます。 ときに<xref:System.Windows.Controls.Primitives.TextBoxBase.IsReadOnly%2A>は`false`、<xref:System.Windows.Controls.Primitives.TextBoxBase.IsReadOnlyCaretVisible%2A>プロパティは影響を与えません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnlyCaretVisibleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsReadOnlyCaretVisibleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsReadOnlyCaretVisibleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.TextBoxBase.IsReadOnlyCaretVisibleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Controls.Primitives.TextBoxBase.IsReadOnlyCaretVisible" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnlyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsReadOnlyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsReadOnlyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.TextBoxBase.IsReadOnlyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Controls.Primitives.TextBoxBase.IsReadOnly" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSelectionActive">
      <MemberSignature Language="C#" Value="public bool IsSelectionActive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSelectionActive" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.TextBoxBase.IsSelectionActive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>テキスト ボックスにフォーカスと選択したテキストがあるかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" />テキスト ボックスにフォーカスと選択したテキストがある場合それ以外の場合、<see langword="false" />です。  
  
 登録済みの既定値は <see langword="false" /> です。 新機能に影響を与える値の詳細については、次を参照してください。[依存関係プロパティの値の優先順位](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsSelectionActive"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Controls.Primitives.TextBoxBase.IsSelectionActiveProperty>|  
|メタデータ プロパティに設定します。`true`|なし|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSelectionActiveProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsSelectionActiveProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsSelectionActiveProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.TextBoxBase.IsSelectionActiveProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Controls.Primitives.TextBoxBase.IsSelectionActive" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUndoEnabled">
      <MemberSignature Language="C#" Value="public bool IsUndoEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUndoEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.TextBoxBase.IsUndoEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはテキスト編集コントロールの取り消しのサポートが有効になっているかどうかを示す値を設定します。</summary>
        <value>
          <see langword="true" />取り消しのサポートが有効である場合それ以外の場合、<see langword="false" />です。 既定値は <see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを設定`false`元に戻すスタックをクリアします。 そのため、元に戻すを無効にし、再度有効にすると、元に戻すコマンドもは機能しません元に戻すを無効にしたときに、元に戻すスタックが空にされたため。  
  
<a name="dependencyPropertyInfo_IsUndoEnabled"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Controls.Primitives.TextBoxBase.IsUndoEnabledProperty>|  
|メタデータ プロパティに設定します。`true`|なし|  
  
   
  
## Examples  
 次の例で使用する方法、<xref:System.Windows.Controls.Primitives.TextBoxBase.IsUndoEnabled%2A>プロパティ[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]です。  
  
 [!code-xaml[TextBoxBase_Samp#TextBoxBase1](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml#textboxbase1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUndoEnabledProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsUndoEnabledProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsUndoEnabledProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.TextBoxBase.IsUndoEnabledProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Controls.Primitives.TextBoxBase.IsUndoEnabled" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LineDown">
      <MemberSignature Language="C#" Value="public void LineDown ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LineDown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.LineDown" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールの内容を 1 行下にスクロールします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例で使用する方法、<xref:System.Windows.Controls.Primitives.TextBoxBase.LineDown%2A>の内容をスクロールするメソッド、<xref:System.Windows.Controls.TextBox>コントロール。  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase13](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase13)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase13](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LineLeft">
      <MemberSignature Language="C#" Value="public void LineLeft ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LineLeft() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.LineLeft" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>1 行ずつ左へのコントロールの内容をスクロールします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例で使用する方法、<xref:System.Windows.Controls.Primitives.TextBoxBase.LineLeft%2A>の内容をスクロールするメソッド、<xref:System.Windows.Controls.TextBox>コントロール。  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase14](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase14)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase14](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LineRight">
      <MemberSignature Language="C#" Value="public void LineRight ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LineRight() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.LineRight" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>1 行ずつ右にコントロールの内容をスクロールします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例で使用する方法、<xref:System.Windows.Controls.Primitives.TextBoxBase.LineRight%2A>の内容をスクロールするメソッド、<xref:System.Windows.Controls.TextBox>コントロール。  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase15](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase15)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase15](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LineUp">
      <MemberSignature Language="C#" Value="public void LineUp ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LineUp() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.LineUp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールの内容を 1 行の上方向へスクロールします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例で使用する方法、<xref:System.Windows.Controls.Primitives.TextBoxBase.LineUp%2A>の内容をスクロールするメソッド、<xref:System.Windows.Controls.TextBox>コントロール。  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase16](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase16)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase16](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LockCurrentUndoUnit">
      <MemberSignature Language="C#" Value="public void LockCurrentUndoUnit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LockCurrentUndoUnit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.LockCurrentUndoUnit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アプリケーションの元に戻すスタックの最新の undo ユニットをロックします。 これにより、ロックされているユニットが、後で追加されている取り消し単位のトピックとマージされています。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 テキスト以外の undo ユニットが、アプリケーションのメインの元に戻すスタックに追加されると、このメソッドを呼び出します。 これにより、ロックされているユニットが、後で追加されている取り消し単位のトピックとマージされています。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnApplyTemplate">
      <MemberSignature Language="C#" Value="public override void OnApplyTemplate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void OnApplyTemplate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.OnApplyTemplate" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロール テンプレートを適用するときに呼び出されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 オーバーライド<xref:System.Windows.FrameworkElement.OnApplyTemplate%2A>です。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで実装された場合、このメソッドはアプリケーション コードまたは内部プロセスを呼び出すたびに<see cref="M:System.Windows.FrameworkElement.ApplyTemplate" />です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuOpening">
      <MemberSignature Language="C#" Value="protected override void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnContextMenuOpening(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベントの引数。</param>
        <summary>未処理のたびに呼び出されます<see cref="E:System.Windows.FrameworkElement.ContextMenuOpening" />ルーティング イベントがそのルート上で、このクラスに到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスがこのメソッドを実装している場合は、基本実装を呼び出す必要があります。  
  
 このメソッドの目的は、類似した[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: インスタンス ハンドラーではなく、クラス ハンドラーを使用して派生クラスからの一致するイベントを処理することができます。 ここでは、一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンではルーティング イベントの異なるルーティング イベントを必ずしもハンドラーを呼び出すの要素ではない子要素で発生する可能性があります。 そのため、実装、イベント引数のソースのプロパティを考慮に入れる必要があります (および再ほとんどの場合、イベントを発生させる必要がありますいないを再試行してください)。 サブクラス<xref:System.Windows.Controls.Primitives.TextBoxBase>経路イベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 1 つのシナリオでは、イベントの引数を受け取り、処理済みとして意図的にイベントをマークします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDragEnter">
      <MemberSignature Language="C#" Value="protected override void OnDragEnter (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnDragEnter(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.OnDragEnter(System.Windows.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベントに関するデータを提供します。</param>
        <summary>未処理のたびに呼び出されます<see cref="E:System.Windows.DragDrop.DragEnter" />添付ルーティング イベントがそのルート上で、このクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDragLeave">
      <MemberSignature Language="C#" Value="protected override void OnDragLeave (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnDragLeave(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.OnDragLeave(System.Windows.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベントに関するデータを提供します。</param>
        <summary>未処理のたびに呼び出されます<see cref="E:System.Windows.DragDrop.DragLeave" />添付ルーティング イベントがそのルート上で、このクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDragOver">
      <MemberSignature Language="C#" Value="protected override void OnDragOver (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnDragOver(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.OnDragOver(System.Windows.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベントに関するデータを提供します。</param>
        <summary>未処理のたびに呼び出されます<see cref="E:System.Windows.DragDrop.DragOver" />添付ルーティング イベントがそのルート上で、このクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDrop">
      <MemberSignature Language="C#" Value="protected override void OnDrop (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnDrop(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.OnDrop(System.Windows.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベントに関するデータを提供します。</param>
        <summary>未処理のたびに呼び出されます<see cref="E:System.Windows.DragDrop.DragEnter" />添付ルーティング イベントがそのルート上で、このクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGiveFeedback">
      <MemberSignature Language="C#" Value="protected override void OnGiveFeedback (System.Windows.GiveFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnGiveFeedback(class System.Windows.GiveFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベントに関するデータを提供します。</param>
        <summary>未処理のたびに呼び出されます<see cref="E:System.Windows.DragDrop.GiveFeedback" />添付ルーティング イベントがそのルート上で、このクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGotKeyboardFocus">
      <MemberSignature Language="C#" Value="protected override void OnGotKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnGotKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベントに関するデータを提供します。</param>
        <summary>未処理のたびに呼び出されます<see cref="E:System.Windows.Input.Keyboard.GotKeyboardFocus" />添付ルーティング イベントがそのルート上で、このクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected override void OnKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.OnKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベントに関するデータを提供します。</param>
        <summary>未処理のたびに呼び出されます<see cref="E:System.Windows.Input.Keyboard.KeyDown" />添付ルーティング イベントがそのルート上で、このクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnKeyUp">
      <MemberSignature Language="C#" Value="protected override void OnKeyUp (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnKeyUp(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.OnKeyUp(System.Windows.Input.KeyEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベントに関するデータを提供します。</param>
        <summary>未処理のたびに呼び出されます<see cref="E:System.Windows.Input.Keyboard.KeyUp" />添付ルーティング イベントがそのルート上で、このクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLostFocus">
      <MemberSignature Language="C#" Value="protected override void OnLostFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnLostFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.OnLostFocus(System.Windows.RoutedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベントに関するデータを提供します。</param>
        <summary>発生させる、 <see cref="E:System.Windows.UIElement.LostFocus" /> (指定された引数を使用して) イベント。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLostKeyboardFocus">
      <MemberSignature Language="C#" Value="protected override void OnLostKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnLostKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベントに関するデータを提供します。</param>
        <summary>未処理のたびに呼び出されます<see cref="E:System.Windows.Input.Keyboard.LostKeyboardFocus" />添付ルーティング イベントがそのルート上で、このクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDown">
      <MemberSignature Language="C#" Value="protected override void OnMouseDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベントに関するデータを提供します。</param>
        <summary>未処理のたびに呼び出されます<see cref="E:System.Windows.Input.Mouse.MouseDown" />添付ルーティング イベントがそのルート上で、このクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseMove">
      <MemberSignature Language="C#" Value="protected override void OnMouseMove (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseMove(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.OnMouseMove(System.Windows.Input.MouseEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベントに関するデータを提供します。</param>
        <summary>未処理のたびに呼び出されます<see cref="E:System.Windows.Input.Mouse.MouseMove" />添付ルーティング イベントがそのルート上で、このクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseUp">
      <MemberSignature Language="C#" Value="protected override void OnMouseUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベントの引数。 これらの引数は、マウス ボタンが押された、詳細と処理済みの状態が含まれます。</param>
        <summary>未処理のたびに呼び出されます<see cref="E:System.Windows.Input.Mouse.MouseUp" />イベントがそのルート上で、このクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseWheel">
      <MemberSignature Language="C#" Value="protected override void OnMouseWheel (System.Windows.Input.MouseWheelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseWheel(class System.Windows.Input.MouseWheelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseWheelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">このイベントに関連付けられているマウス ホイールの引数。</param>
        <summary>ときに呼び出される、<see cref="E:System.Windows.UIElement.MouseWheel" />イベントがこのクラス (またはこのクラスから継承するクラス) にルーティングされます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.MouseWheel>イベントは、マウス ホイールをロールバックするときに発生します。  
  
 オーバーライド<xref:System.Windows.UIElement.OnMouseWheel%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyDown">
      <MemberSignature Language="C#" Value="protected override void OnPreviewKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPreviewKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベントのデータ。</param>
        <summary><see cref="E:System.Windows.UIElement.KeyDown" /> が発生するときに呼び出されます。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected override void OnQueryContinueDrag (System.Windows.QueryContinueDragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnQueryContinueDrag(class System.Windows.QueryContinueDragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベントに関するデータを提供します。</param>
        <summary>未処理のたびに呼び出されます<see cref="E:System.Windows.DragDrop.QueryContinueDrag" />添付ルーティング イベントがそのルート上で、このクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドが実装されている場合に、実装で base() を呼び出すことはお勧めもします。 要件に応じて、特別な処理の前後 base() を呼び出すことがあります。  
  
 このメソッドの目的は、類似した[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: インスタンス ハンドラーではなく、クラス ハンドラーを使用して派生クラスからの一致するイベントを処理することができます。 ここでは、一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンではルーティング イベントの異なるルーティング イベントを必ずしもハンドラーを呼び出すの要素ではない子要素で発生する可能性があります。 そのため、実装、イベント引数のソースのプロパティを考慮に入れる必要があります (および再ほとんどの場合、イベントを発生させる必要がありますいないを再試行してください)。 サブクラス<xref:System.Windows.Controls.Primitives.TextBoxBase>経路イベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 1 つのシナリオでは、イベントの引数およびイベントを処理済みとしてマークします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnQueryCursor">
      <MemberSignature Language="C#" Value="protected override void OnQueryCursor (System.Windows.Input.QueryCursorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnQueryCursor(class System.Windows.Input.QueryCursorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.QueryCursorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベントに関するデータを提供します。</param>
        <summary>未処理のたびに呼び出されます<see cref="E:System.Windows.Input.Mouse.QueryCursor" />添付ルーティング イベントがそのルート上で、このクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSelectionChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectionChanged (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectionChanged(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.OnSelectionChanged(System.Windows.RoutedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">関連付けられている引数、<see cref="E:System.Windows.Controls.Primitives.TextBoxBase.SelectionChanged" />イベント。</param>
        <summary>キャレットまたは現在の選択範囲の位置を変更したときに呼び出されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを発生させる、<xref:System.Windows.Controls.Primitives.TextBoxBase.SelectionChanged>イベント。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTemplateChanged">
      <MemberSignature Language="C#" Value="protected override void OnTemplateChanged (System.Windows.Controls.ControlTemplate oldTemplate, System.Windows.Controls.ControlTemplate newTemplate);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnTemplateChanged(class System.Windows.Controls.ControlTemplate oldTemplate, class System.Windows.Controls.ControlTemplate newTemplate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.OnTemplateChanged(System.Windows.Controls.ControlTemplate,System.Windows.Controls.ControlTemplate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldTemplate" Type="System.Windows.Controls.ControlTemplate" />
        <Parameter Name="newTemplate" Type="System.Windows.Controls.ControlTemplate" />
      </Parameters>
      <Docs>
        <param name="oldTemplate">A<see cref="T:System.Windows.Controls.ControlTemplate" />現在アクティブになっているコントロールのテンプレートを指定するオブジェクト。</param>
        <param name="newTemplate">A<see cref="T:System.Windows.Controls.ControlTemplate" />を使用する新しいコントロール テンプレートを指定するオブジェクト。</param>
        <summary>コントロール テンプレートが変更されたときに呼び出されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 オーバーライド<xref:System.Windows.Controls.Control.OnTemplateChanged%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTextChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnTextChanged (System.Windows.Controls.TextChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTextChanged(class System.Windows.Controls.TextChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.OnTextChanged(System.Windows.Controls.TextChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.TextChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">関連付けられている引数、<see cref="E:System.Windows.Controls.Primitives.TextBoxBase.TextChanged" />イベント。</param>
        <summary>この編集コントロールのコンテンツが変更されたときに呼び出されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを発生させる、<xref:System.Windows.Controls.Primitives.TextBoxBase.TextChanged>イベント。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTextInput">
      <MemberSignature Language="C#" Value="protected override void OnTextInput (System.Windows.Input.TextCompositionEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnTextInput(class System.Windows.Input.TextCompositionEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.OnTextInput(System.Windows.Input.TextCompositionEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TextCompositionEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベントに関するデータを提供します。</param>
        <summary>未処理のたびに呼び出されます<see cref="E:System.Windows.Input.TextCompositionManager.TextInput" />添付ルーティング イベントがそのルート上で、このクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PageDown">
      <MemberSignature Language="C#" Value="public void PageDown ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PageDown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.PageDown" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールの内容を 1 ページ下にスクロールします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例で使用する方法、<xref:System.Windows.Controls.Primitives.TextBoxBase.PageDown%2A>の内容をスクロールするメソッド、<xref:System.Windows.Controls.TextBox>コントロール。  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase17](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase17)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase17](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PageLeft">
      <MemberSignature Language="C#" Value="public void PageLeft ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PageLeft() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.PageLeft" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>1 つのページを左にコントロールの内容をスクロールします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例で使用する方法、<xref:System.Windows.Controls.Primitives.TextBoxBase.PageLeft%2A>の内容をスクロールするメソッド、<xref:System.Windows.Controls.TextBox>コントロール。  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase18](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase18)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase18](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PageRight">
      <MemberSignature Language="C#" Value="public void PageRight ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PageRight() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.PageRight" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>1 ページずつ右にコントロールの内容をスクロールします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例で使用する方法、<xref:System.Windows.Controls.Primitives.TextBoxBase.PageRight%2A>の内容をスクロールするメソッド、<xref:System.Windows.Controls.TextBox>コントロール。  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase19](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase19)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase19](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase19)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PageUp">
      <MemberSignature Language="C#" Value="public void PageUp ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PageUp() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.PageUp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>1 ページ上のコントロールの内容をスクロールします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例で使用する方法、<xref:System.Windows.Controls.Primitives.TextBoxBase.PageUp%2A>の内容をスクロールするメソッド、<xref:System.Windows.Controls.TextBox>コントロール。  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase20](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase20)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase20](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Paste">
      <MemberSignature Language="C#" Value="public void Paste ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Paste() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.Paste" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>テキスト編集コントロールで現在の選択範囲には、クリップボードの内容を貼り付けます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例で使用する方法、<xref:System.Windows.Controls.Primitives.TextBoxBase.Paste%2A>に選択したコンテンツを貼り付けるメソッド、<xref:System.Windows.Controls.TextBox>コントロール。  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase6](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase6)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase6](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Redo">
      <MemberSignature Language="C#" Value="public bool Redo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Redo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.Redo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>最新の元に戻すコマンドを元に戻します。 つまり、元に戻すスタックに最新の undo ユニットをやり直します。</summary>
        <returns>
          <see langword="true" />やり直し操作が成功した場合それ以外の場合、<see langword="false" />です。 このメソッドが戻る<see langword="false" />(元に戻すスタックが空の) で使用できる元に戻すコマンドが存在しない場合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <xref:System.Windows.Controls.Primitives.TextBoxBase.Redo%2A> メソッドの使用方法を次の例に示します。  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase9](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase9)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase9](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToEnd">
      <MemberSignature Language="C#" Value="public void ScrollToEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScrollToEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.ScrollToEnd" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コンテンツの最後に編集コントロールのビューをスクロールします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例で使用する方法、<xref:System.Windows.Controls.Primitives.TextBoxBase.ScrollToEnd%2A>の内容をスクロールするメソッド、<xref:System.Windows.Controls.TextBox>コントロール。  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase22](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase22)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase22](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToHome">
      <MemberSignature Language="C#" Value="public void ScrollToHome ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScrollToHome() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.ScrollToHome" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ビューポートの先頭に編集コントロールのビューをスクロールします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例で使用する方法、<xref:System.Windows.Controls.Primitives.TextBoxBase.ScrollToHome%2A>の内容をスクロールするメソッド、<xref:System.Windows.Controls.TextBox>コントロール。  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase21](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase21)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase21](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToHorizontalOffset">
      <MemberSignature Language="C#" Value="public void ScrollToHorizontalOffset (double offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScrollToHorizontalOffset(float64 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.ScrollToHorizontalOffset(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="offset">スクロール先の水平方向オフセットを指定する倍精度浮動小数点型の値。</param>
        <summary>編集コントロールの内容を、指定された水平方向オフセットまでスクロールします。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToVerticalOffset">
      <MemberSignature Language="C#" Value="public void ScrollToVerticalOffset (double offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScrollToVerticalOffset(float64 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.ScrollToVerticalOffset(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="offset">スクロールする垂直オフセットを指定する double 値。</param>
        <summary>指定した垂直方向のオフセットに編集コントロールの内容をスクロールします。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectAll">
      <MemberSignature Language="C#" Value="public void SelectAll ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SelectAll() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.SelectAll" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>テキスト編集コントロールのすべての内容を選択します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例で使用する方法、<xref:System.Windows.Controls.Primitives.TextBoxBase.SelectAll%2A>の内容をすべて選択するメソッド、<xref:System.Windows.Controls.TextBox>コントロール。  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase7](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase7)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase7](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionBrush">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush SelectionBrush { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush SelectionBrush" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.TextBoxBase.SelectionBrush" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または選択したテキストを強調表示するブラシを設定します。</summary>
        <value>選択したテキストを強調表示するブラシ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定して選択したテキストを強調表示するブラシを指定することができます、<xref:System.Windows.Controls.Primitives.TextBoxBase.SelectionBrush%2A>と<xref:System.Windows.Controls.Primitives.TextBoxBase.SelectionOpacity%2A>プロパティです。 <xref:System.Windows.Controls.Primitives.TextBoxBase.SelectionOpacity%2A>プロパティの不透明度を指定する、<xref:System.Windows.Controls.Primitives.TextBoxBase.SelectionBrush%2A>です。  
  
   
  
## Examples  
 次の例を作成、<xref:System.Windows.Controls.TextBox>し、「これは、いくつかのテキストです」ですテキストの追加。 例のセット、<xref:System.Windows.Controls.Primitives.TextBoxBase.SelectionBrush%2A>赤にプロパティと<xref:System.Windows.Controls.Primitives.TextBoxBase.SelectionOpacity%2A>プロパティを選択したテキストの外観をカスタマイズする 0.5 にします。  
  
 [!code-xaml[TextBaseSelectionBrush#TextBox](~/samples/snippets/csharp/VS_Snippets_Wpf/textbaseselectionbrush/CS/window1.xaml#textbox)]   
  
 次の図は、<xref:System.Windows.Controls.TextBox>前の例のテキストを選択します。  
  
 ![Selectionbrush が赤の TextBox](~/add/media/textboxselectionbrush.png "selectionbrush が赤の TextBox")  
Selectionbrush が赤に設定されたテキスト ボックスで選択したテキスト  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionBrushProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty SelectionBrushProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty SelectionBrushProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.TextBoxBase.SelectionBrushProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Controls.Primitives.TextBoxBase.SelectionBrush" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler SelectionChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler SelectionChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.Primitives.TextBoxBase.SelectionChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>テキストの選択が変更されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_SelectionChanged"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Controls.Primitives.TextBoxBase.SelectionChangedEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.RoutedEventHandler>|  
  
   
  
## Examples  
 次の例は、処理する方法を示します、<xref:System.Windows.Controls.Primitives.TextBoxBase.SelectionChanged>コードを使用してイベント。  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase10](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase10)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase10](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent SelectionChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent SelectionChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.TextBoxBase.SelectionChangedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.Controls.Primitives.TextBoxBase.SelectionChanged" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionOpacity">
      <MemberSignature Language="C#" Value="public double SelectionOpacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 SelectionOpacity" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.TextBoxBase.SelectionOpacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定の不透明度、<see cref="P:System.Windows.Controls.Primitives.TextBoxBase.SelectionBrush" />です。</summary>
        <value>不透明度、<see cref="P:System.Windows.Controls.Primitives.TextBoxBase.SelectionBrush" />です。 既定値は 0.4 です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合<xref:System.Windows.Controls.Primitives.TextBoxBase.SelectionOpacity%2A>を 0 に設定されている、<xref:System.Windows.Controls.Primitives.TextBoxBase.SelectionBrush%2A>は透過的とは表示されません。 場合<xref:System.Windows.Controls.Primitives.TextBoxBase.SelectionOpacity%2A>1.0 以上に設定されている、<xref:System.Windows.Controls.Primitives.TextBoxBase.SelectionBrush%2A>は非透過的と、選択したテキストが表示されません。  
  
   
  
## Examples  
 次の例を作成、<xref:System.Windows.Controls.TextBox>し、「これは、いくつかのテキストです」ですテキストの追加。 例のセット、<xref:System.Windows.Controls.Primitives.TextBoxBase.SelectionBrush%2A>赤にプロパティと<xref:System.Windows.Controls.Primitives.TextBoxBase.SelectionOpacity%2A>プロパティを選択したテキストの外観をカスタマイズする 0.5 にします。  
  
 [!code-xaml[TextBaseSelectionBrush#TextBox](~/samples/snippets/csharp/VS_Snippets_Wpf/textbaseselectionbrush/CS/window1.xaml#textbox)]   
  
 次の図は、<xref:System.Windows.Controls.TextBox>前の例のテキストを選択します。  
  
 ![Selectionbrush が赤の TextBox](~/add/media/textboxselectionbrush.png "selectionbrush が赤の TextBox")  
SelectionOpacity を 0.5 に設定されたテキスト ボックスで選択したテキスト  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionOpacityProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty SelectionOpacityProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty SelectionOpacityProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.TextBoxBase.SelectionOpacityProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Controls.Primitives.TextBoxBase.SelectionOpacity" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SpellCheck">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.SpellCheck SpellCheck { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.SpellCheck SpellCheck" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.TextBoxBase.SpellCheck" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.SpellCheck</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得、<see cref="T:System.Windows.Controls.SpellCheck" />のテキスト コンテンツ内のスペル ミスへのアクセスを提供するオブジェクト、<see cref="T:System.Windows.Controls.Primitives.TextBoxBase" />または<see cref="T:System.Windows.Controls.RichTextBox" />です。</summary>
        <value>A<see cref="T:System.Windows.Controls.SpellCheck" />のテキスト コンテンツ内のスペル ミスへのアクセスを提供するオブジェクト、<see cref="T:System.Windows.Controls.Primitives.TextBoxBase" />または<see cref="T:System.Windows.Controls.RichTextBox" />です。  
  
 このプロパティには既定値はありません。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TextChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.TextChangedEventHandler TextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.TextChangedEventHandler TextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.Primitives.TextBoxBase.TextChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.TextChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>テキスト要素内でコンテンツが変更されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.TextBox>、そのテキストを変更; ときに、このイベントが発生の<xref:System.Windows.Controls.RichTextBox>、このイベントは、いずれかのコンテンツまたは変更 (たとえば、画像、テーブル、または背景色) を書式設定します。  
  
<a name="routedEventInfo_TextChanged"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Controls.Primitives.TextBoxBase.TextChangedEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Controls.TextChangedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TextChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TextChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.TextBoxBase.TextChangedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.Controls.Primitives.TextBoxBase.TextChanged" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Undo">
      <MemberSignature Language="C#" Value="public bool Undo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Undo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.Undo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>最新の元に戻すコマンドを元に戻します。 つまり、元に戻すスタックに最新の元に戻す単位を元に戻します。</summary>
        <returns>
          <see langword="true" />元に戻す操作が成功した場合それ以外の場合、<see langword="false" />です。 このメソッドが戻る<see langword="false" />元に戻すスタックが空の場合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <xref:System.Windows.Controls.Primitives.TextBoxBase.Undo%2A> メソッドの使用方法を次の例に示します。  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase8](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase8)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase8](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UndoLimit">
      <MemberSignature Language="C#" Value="public int UndoLimit { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 UndoLimit" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.TextBoxBase.UndoLimit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または元に戻すキューに格納されているアクションの数を設定します。</summary>
        <value>元に戻すキューに格納されているアクションの数。 既定値は、-1 で、元に戻すキューが使用可能なメモリを制限します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定<xref:System.Windows.Controls.Primitives.TextBoxBase.UndoLimit%2A>元に戻すキューをクリアします。 ときに<xref:System.Windows.Controls.Primitives.TextBoxBase.UndoLimit%2A>設定を-1 アンドゥ キューが使用可能なメモリによってのみ制限されます。 ときに<xref:System.Windows.Controls.Primitives.TextBoxBase.UndoLimit%2A>設定は 0 に元に戻すが無効になって、<xref:System.Windows.Controls.Primitives.TextBoxBase>です。  
  
 <xref:System.Windows.Controls.Primitives.TextBoxBase.UndoLimit%2A>.NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework のバージョンおよび依存関係](~/docs/framework/migration-guide/versions-and-dependencies.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.Controls.Primitives.TextBoxBase.UndoLimit" />呼び出した後に設定されている<see cref="M:System.Windows.Controls.Primitives.TextBoxBase.BeginChange" />を呼び出す前に<see cref="M:System.Windows.Controls.Primitives.TextBoxBase.EndChange" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="UndoLimitProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty UndoLimitProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty UndoLimitProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.TextBoxBase.UndoLimitProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Controls.Primitives.TextBoxBase.UndoLimit" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Primitives.TextBoxBase.UndoLimitProperty>.NET Framework version 3.5 で導入されました。 詳細については、次を参照してください。[バージョンおよび依存関係](~/docs/framework/migration-guide/versions-and-dependencies.md)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VerticalOffset">
      <MemberSignature Language="C#" Value="public double VerticalOffset { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 VerticalOffset" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.TextBoxBase.VerticalOffset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>垂直方向のスクロール位置を取得または設定します。</summary>
        <value>浮動小数点値で垂直スクロール位置を示す[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]です。  
  
 このプロパティを設定すると、テキスト編集コントロールを垂直方向、指定したオフセットをスクロールします。 このプロパティを読み取るには、現在の垂直方向のオフセットが返されます。  
  
 テキスト編集コントロールがスクロールをサポートするために構成されていない場合、このプロパティの値は 0.0 です。  
  
 このプロパティには既定値はありません。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 縦方向のオフセットは、表示されるテキスト領域の一番上から測定されます。  
  
   
  
## Examples  
 次の例では、値を読み取る、<xref:System.Windows.Controls.Primitives.TextBoxBase.VerticalOffset%2A>プロパティです。  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase3](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase3)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">このプロパティに負の値を設定しようとしました。</exception>
      </Docs>
    </Member>
    <Member MemberName="VerticalScrollBarVisibility">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ScrollBarVisibility VerticalScrollBarVisibility { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Controls.ScrollBarVisibility VerticalScrollBarVisibility" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.TextBoxBase.VerticalScrollBarVisibility" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ScrollBarVisibility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>垂直スクロール バーが表示されるかどうかを示す値を取得または設定します。</summary>
        <value>定義されている値、<see cref="T:System.Windows.Controls.ScrollBarVisibility" />列挙します。  
  
 既定値は <see cref="F:System.Windows.Visibility.Hidden" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_VerticalScrollBarVisibility"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Controls.Primitives.TextBoxBase.VerticalScrollBarVisibilityProperty>|  
|メタデータ プロパティに設定します。`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VerticalScrollBarVisibilityProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty VerticalScrollBarVisibilityProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty VerticalScrollBarVisibilityProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.TextBoxBase.VerticalScrollBarVisibilityProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Controls.Primitives.TextBoxBase.VerticalScrollBarVisibility" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewportHeight">
      <MemberSignature Language="C#" Value="public double ViewportHeight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ViewportHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.TextBoxBase.ViewportHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スクロール可能なコンテンツ エリアの縦のサイズを取得します。</summary>
        <value>浮動小数点値で、スクロール可能なコンテンツ エリアの縦のサイズを示す[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]です。  
  
 テキスト編集コントロールがスクロールをサポートするために構成されていない場合、このプロパティの値は 0.0 です。  
  
 このプロパティには既定値はありません。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、値を読み取る、<xref:System.Windows.Controls.Primitives.TextBoxBase.ViewportHeight%2A>プロパティです。  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase3](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase3)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewportWidth">
      <MemberSignature Language="C#" Value="public double ViewportWidth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ViewportWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.TextBoxBase.ViewportWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スクロール可能なコンテンツ エリアの横幅を取得します。</summary>
        <value>浮動小数点値で、スクロール可能なコンテンツ領域の水平方向のサイズを示す[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]です。  
  
 テキスト編集コントロールがスクロールをサポートするために構成されていない場合、このプロパティの値は 0.0 です。  
  
 このプロパティには既定値はありません。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、値を読み取る、<xref:System.Windows.Controls.Primitives.TextBoxBase.ViewportWidth%2A>プロパティです。  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase3](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase3)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
