<Type Name="Socket" FullName="System.Net.Sockets.Socket">
  <TypeSignature Language="C#" Value="public class Socket : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Socket extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.Socket" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Berkeley ソケット インターフェイスを実装します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>クラスは、ネットワーク通信について豊富な一連のメソッドとプロパティを提供します。 <xref:System.Net.Sockets.Socket>クラスはどちらも実行を同期できに示されている通信プロトコルのいずれかを使用して非同期のデータ転送、<xref:System.Net.Sockets.ProtocolType>列挙します。  
  
 <xref:System.Net.Sockets.Socket>クラスが非同期メソッド用の .NET Framework 名前付けパターンに従います。 たとえば、同期<xref:System.Net.Sockets.Socket.Receive%2A>メソッドは非同期に対応<xref:System.Net.Sockets.Socket.BeginReceive%2A>と<xref:System.Net.Sockets.Socket.EndReceive%2A>メソッドです。  
  
 アプリケーションには、実行中に 1 つのスレッドのみ必要とする場合は、次のメソッドは、同期動作モード用に設計されてを使用します。  
  
-   使用した接続に、サーバーがリッスンできる TCP などの接続指向プロトコルを使用している場合、<xref:System.Net.Sockets.Socket.Listen%2A>メソッドです。 <xref:System.Net.Sockets.Socket.Accept%2A>メソッド プロセスすべての着信接続を要求しを返します、<xref:System.Net.Sockets.Socket>ことは、データをリモート ホストに通信するために使用することができます。 この返さ<xref:System.Net.Sockets.Socket>を呼び出して、<xref:System.Net.Sockets.Socket.Send%2A>または<xref:System.Net.Sockets.Socket.Receive%2A>メソッドです。 呼び出す、<xref:System.Net.Sockets.Socket.Bind%2A>メソッドを呼び出す前に、<xref:System.Net.Sockets.Socket.Listen%2A>メソッドのローカル IP アドレスとポート番号を指定する場合。 基になるサービス プロバイダーのポートを割り当てる空きをする場合は、ゼロのポート番号を使用します。 リッスンしているホストに接続する場合は、呼び出し、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドです。 データを通信するために呼び出す、<xref:System.Net.Sockets.Socket.Send%2A>または<xref:System.Net.Sockets.Socket.Receive%2A>メソッドです。  
  
-   UDP などのコネクションレスのプロトコルを使用している場合は、すべての接続をリッスンする必要はありません。 呼び出す、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドを受信データグラムを受け入れるようにします。 使用して、<xref:System.Net.Sockets.Socket.SendTo%2A>データグラムをリモート ホストに送信するメソッド。  
  
 実行中に個別のスレッドを使用して通信を処理するには、次のメソッドは、非同期の操作モード用に設計されてを使用します。  
  
-   TCP などの接続指向プロトコルを使用している場合を使用して、 <xref:System.Net.Sockets.Socket>、 <xref:System.Net.Sockets.Socket.BeginConnect%2A>、および<xref:System.Net.Sockets.Socket.EndConnect%2A>リッスン中のホストに接続する方法です。 使用して、<xref:System.Net.Sockets.Socket.BeginSend%2A>と<xref:System.Net.Sockets.Socket.EndSend%2A>または<xref:System.Net.Sockets.Socket.BeginReceive%2A>と<xref:System.Net.Sockets.Socket.EndReceive%2A>データを非同期的に通信するメソッド。 使用して接続要求を処理できる<xref:System.Net.Sockets.Socket.BeginAccept%2A>と<xref:System.Net.Sockets.Socket.EndAccept%2A>です。  
  
-   UDP などのコネクションレスのプロトコルを使用している場合を使用できます<xref:System.Net.Sockets.Socket.BeginSendTo%2A>と<xref:System.Net.Sockets.Socket.EndSendTo%2A>、データグラムを送信して<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>と<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>データグラムを受信します。  
  
 ソケットに対して複数の非同期操作を実行する場合、必ずしもで完了しなかった開始される順序。  
  
 完成した送信とデータを受信したらを使用して、<xref:System.Net.Sockets.Socket.Shutdown%2A>無効にする方法、<xref:System.Net.Sockets.Socket>です。 呼び出した後<xref:System.Net.Sockets.Socket.Shutdown%2A>を呼び出し、<xref:System.Net.Sockets.Socket.Close%2A>に関連付けられているすべてのリソースを解放するメソッド、<xref:System.Net.Sockets.Socket>です。  
  
 <xref:System.Net.Sockets.Socket>クラスでは、構成することができます、<xref:System.Net.Sockets.Socket>を使用して、<xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッドです。 使用してこれらの設定を取得、<xref:System.Net.Sockets.Socket.GetSocketOption%2A>メソッドです。  
  
> [!NOTE]
>  比較的単純なアプリケーションを作成して、最大のパフォーマンスは必要ない場合、は、使用を検討して<xref:System.Net.Sockets.TcpClient>、 <xref:System.Net.Sockets.TcpListener>、および<xref:System.Net.Sockets.UdpClient>です。 これらのクラスに簡素化され、ユーザーにわかりやすいインターフェイスを提供する<xref:System.Net.Sockets.Socket>通信します。  
  
   
  
## Examples  
 次のコード例に示す方法、<xref:System.Net.Sockets.Socket>クラスは、HTTP サーバーにデータを送信し、応答を受信するために使用できます。 この例は、ページ全体を受信するまでブロックします。  
  
 [!code-cpp[System.Net.Sockets.Socket#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CPP/socket.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CS/socket.cs#1)]
 [!code-vb[System.Net.Sockets.Socket#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.Socket/VB/socket.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission">発信接続を確立するか、受信要求を受け入れます。</permission>
    <threadsafe>このクラスのインスタンスでは、スレッド セーフです。</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketInformation socketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketInformation socketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketInformation" Type="System.Net.Sockets.SocketInformation" />
      </Parameters>
      <Docs>
        <param name="socketInformation">によって返されるソケット情報<see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />です。</param>
        <summary>新しいインスタンスを初期化、<see cref="T:System.Net.Sockets.Socket" />クラスから返された値を指定して<see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出す場合は、<xref:System.Net.Sockets.Socket.%23ctor%2A>複数回の各呼び出しの引数と同じバイト配列を持つコンス トラクターは、複数の管理を作成する、<xref:System.Net.Sockets.Socket>同一の基になるソケットで秒です。 この方法はお勧めします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="socketType"><see cref="T:System.Net.Sockets.SocketType" /> 値のいずれか。</param>
        <param name="protocolType"><see cref="T:System.Net.Sockets.ProtocolType" /> 値のいずれか。</param>
        <summary>新しいインスタンスを初期化、<see cref="T:System.Net.Sockets.Socket" />クラスの指定したソケットの種類とプロトコルを使用します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `socketType`パラメーターの型を指定、<xref:System.Net.Sockets.Socket>クラスおよび`protocolType`パラメーターで使用されるプロトコルを指定<xref:System.Net.Sockets.Socket>です。 2 つのパラメーターが独立してではありません。 多くの場合、<xref:System.Net.Sockets.Socket>型は、プロトコルで暗黙の型。 場合の組み合わせ<xref:System.Net.Sockets.Socket>種類とプロトコル型の結果、無効な<xref:System.Net.Sockets.Socket>、このコンス トラクターをスロー、<xref:System.Net.Sockets.SocketException>です。  
  
> [!NOTE]
>  このコンス トラクターをスローした場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">組み合わせ<paramref name="socketType" />と<paramref name="protocolType" />結果ソケットは無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.AddressFamily addressFamily, System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.AddressFamily addressFamily, valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="addressFamily" Type="System.Net.Sockets.AddressFamily" />
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="addressFamily"><see cref="T:System.Net.Sockets.AddressFamily" /> 値のいずれか。</param>
        <param name="socketType"><see cref="T:System.Net.Sockets.SocketType" /> 値のいずれか。</param>
        <param name="protocolType"><see cref="T:System.Net.Sockets.ProtocolType" /> 値のいずれか。</param>
        <summary>新しいインスタンスを初期化、<see cref="T:System.Net.Sockets.Socket" />クラスの指定したアドレス ファミリ、ソケットの種類およびプロトコルを使用します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `addressFamily`パラメーターを指定するアドレス指定スキーム、<xref:System.Net.Sockets.Socket>クラスの使用方法、`socketType`パラメーターの型を指定、<xref:System.Net.Sockets.Socket>クラス、および`protocolType`パラメーターで使用されるプロトコルを指定<xref:System.Net.Sockets.Socket>です。 次の 3 つのパラメーターが独立してではありません。 一部のアドレス ファミリを制限、および多くの場合、どのプロトコルを使用することができます、<xref:System.Net.Sockets.Socket>型は、プロトコルで暗黙の型。 場合、アドレス ファミリの組み合わせ<xref:System.Net.Sockets.Socket>型、およびプロトコルの種類は、無効な<xref:System.Net.Sockets.Socket>、このコンス トラクターをスロー、<xref:System.Net.Sockets.SocketException>です。  
  
> [!NOTE]
>  このコンス トラクターをスローした場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例は、のインスタンスを作成する方法を示します、<xref:System.Net.Sockets.Socket>クラスです。  
  
 [!code-cpp[Socket_Send_Recieve#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Recieve/CPP/source.cpp#1)]
 [!code-csharp[Socket_Send_Recieve#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Recieve/CS/source.cs#1)]
 [!code-vb[Socket_Send_Recieve#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Recieve/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">組み合わせ<paramref name="addressFamily" />、 <paramref name="socketType" />、および<paramref name="protocolType" />結果ソケットは無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Accept ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket Accept() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Accept" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>新たに作成<see cref="T:System.Net.Sockets.Socket" />を新しく作成された接続。</summary>
        <returns>A<see cref="T:System.Net.Sockets.Socket" />の新しく作成された接続。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Accept%2A>同期的に待機中のソケットの接続要求のキューから最初の保留中の接続要求を抽出を作成し、新しい<xref:System.Net.Sockets.Socket>です。 返されるこれを使用することはできません<xref:System.Net.Sockets.Socket>接続キューからその他の接続を受け入れるようにします。 ただし、呼び出すことができます、<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>メソッドの返された<xref:System.Net.Sockets.Socket>をリモート ホストのネットワーク アドレスとポート番号を識別します。  
  
 ブロッキング モード<xref:System.Net.Sockets.Socket.Accept%2A>受信接続の試行がキューに登録するまでブロックします。 接続を受け入れる元<xref:System.Net.Sockets.Socket>キューの着信接続を要求するまで閉じることが続行されます。  
  
 非ブロッキングを使用してこのメソッドを呼び出すかどうか<xref:System.Net.Sockets.Socket>、および接続要求がキューに入れ、<xref:System.Net.Sockets.Socket.Accept%2A>をスロー、<xref:System.Net.Sockets.SocketException>です。 表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  呼び出しの前に、<xref:System.Net.Sockets.Socket.Accept%2A>メソッド、最初に呼び出す必要があります、<xref:System.Net.Sockets.Socket.Listen%2A>をリッスンし、接続要求をキューにメソッドです。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例は、単純なを受け入れる<xref:System.Net.Sockets.Socket>接続します。  
  
 [!code-cpp[Classic Socket.Accept Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Accept Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Accept Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Accept Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Accept Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Accept Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.InvalidOperationException">接続の受け入れ側のソケットがリッスンしていません。 呼び出す必要があります<see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />と<see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />呼び出す前に<see cref="M:System.Net.Sockets.Socket.Accept" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="AcceptAsync">
      <MemberSignature Language="C#" Value="public bool AcceptAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool AcceptAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />この非同期ソケット操作に使用するオブジェクト。</param>
        <summary>着信接続の試行をそのまま使用する非同期操作を開始します。</summary>
        <returns>返します<see langword="true" />I/O 操作が保留中の場合。 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />でイベントを<paramref name="e" />パラメーターが操作の完了時に発生します。  
  
 返します<see langword="false" />場合は、I/O 操作が同期的に完了します。 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />でイベントを<paramref name="e" />パラメーターは発生しません。 および、<paramref name="e" />操作の結果を取得するメソッドの呼び出しが戻った後にすぐに、パラメーターを調べることがありますとして渡されたオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向プロトコルを使用できる、<xref:System.Net.Sockets.Socket.AcceptAsync%2A>着信接続を非同期的に処理するメソッドと試みます。 非同期的に接続を受け入れると、個別の実行スレッド内でデータを送受信する機能を提供します。 呼び出しの前に、<xref:System.Net.Sockets.Socket.AcceptAsync%2A>メソッドを呼び出す必要があります、<xref:System.Net.Sockets.Socket.Listen%2A>をリッスンし、接続要求をキューにメソッドです。  
  
 完了の通知、イベント ハンドラーを実装するコールバック メソッドを作成する必要があります\<SocketAsyncEventArgs > を委任し、それを<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>イベント。  
  
 次のプロパティとイベントを<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>オブジェクトが必要。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 呼び出し元は、既存のオプションで指定できます<xref:System.Net.Sockets.Socket>を指定して、着信接続に使用する、<xref:System.Net.Sockets.Socket>で使用する、<xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType>プロパティです。  
  
 場合、<xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType>プロパティが null、新しい<xref:System.Net.Sockets.Socket>が同じで構築されて<xref:System.Net.Sockets.Socket.AddressFamily%2A>、 <xref:System.Net.Sockets.Socket.SocketType%2A>、および<xref:System.Net.Sockets.Socket.ProtocolType%2A>現在<xref:System.Net.Sockets.Socket>として設定し、<xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType>プロパティです。  
  
 呼び出し元の設定、<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>を呼び出す前に必要なすべてのユーザー状態オブジェクトのプロパティ、<xref:System.Net.Sockets.Socket.AcceptAsync%2A>メソッド情報をコールバック メソッドで取得できるようにします。 コールバックは、1 つのオブジェクトより多くの情報を必要とする場合は、メンバーとして他の必要な状態情報を保持するために、小さいクラスを作成できます。  
  
 必要に応じて、後にソケット上のデータの最初のブロックを受信するためのバッファーを指定する場合があります、<xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッドが成功します。 ここで、<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>プロパティを受信するデータを格納しているバッファーに設定する必要があります、<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>プロパティをバッファーに受信するデータのバイトの最大数に設定する必要があります。 使用してこれらのプロパティを設定することができます、<xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType>メソッドです。 使用するために渡されたバッファーの一部が内部的に使用される、基になる Winsock AcceptEx 呼び出しです。 つまり、返されるデータの量が常の値より小さい、<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>プロパティを<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>指定されたインスタンスです。 内部的に使用されるバッファーの容量は、ソケット アドレス ファミリに変わります。 必要な最小バッファー サイズは、288 バイトです。 大きなバッファー サイズが指定されている場合、 <xref:System.Net.Sockets.Socket> Winsock AcceptEx 呼び出しで受け取ったアドレス データ以外のいくつかの余分なデータを必要として、この余分なデータが受信されるまで待機します。 タイムアウトが発生した場合、接続がリセットされます。 それで余分なデータが特定の容量の予測される場合、最小バッファー サイズとこの金額に、バッファーのサイズを設定する必要があります。  
  
 完了コールバック メソッドを調べる必要があります、<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>プロパティかどうかを<xref:System.Net.Sockets.Socket.AcceptAsync%2A>操作は成功しました。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>イベントの接続が許可されていない場合に発生して発生することができます、<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>設定するプロパティを<xref:System.Net.Sockets.SocketError.ConnectionReset>です。 これは、ポートを半開 SYN 型スキャンを使用してスキャンの結果として発生することができます (SYN SYN ACK]-> [RST シーケンス ->)。 アプリケーションを使用して、<xref:System.Net.Sockets.Socket.AcceptAsync%2A>この条件を処理するメソッドを準備する必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">引数が有効ではありません。 この例外は、指定されたバッファーが十分な大きさがない場合に発生します。 バッファーが 2 以上にする必要があります * (sizeof(SOCKADDR_STORAGE + 16) バイトです。  
  
 この例外は、複数のバッファーが指定されている場合にも発生、<see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />プロパティが null でないです。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">引数が範囲外です。 場合、例外が発生、<see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />が 0 未満です。</exception>
        <exception cref="T:System.InvalidOperationException">無効な操作が要求されました。 場合、この例外が発生した承諾<see cref="T:System.Net.Sockets.Socket" />がリッスンしていない接続または承認されたソケットをバインドします。  
  
 呼び出す必要があります、<see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />と<see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />メソッドを呼び出す前に、<see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />メソッドです。  
  
 この例外は、ソケットが既に接続されているか、ソケット操作は、既にに進行状況を指定していた場合にも発生<paramref name="e" />パラメーター。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.NotSupportedException">Windows XP 以降はこのメソッドに必要です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="AddressFamily">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.AddressFamily AddressFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.AddressFamily AddressFamily" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.AddressFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.AddressFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アドレス ファミリを取得、<see cref="T:System.Net.Sockets.Socket" />です。</summary>
        <value><see cref="T:System.Net.Sockets.AddressFamily" /> 値のいずれか。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.AddressFamily>をアドレス指定スキームを指定のインスタンス、<xref:System.Net.Sockets.Socket>クラスを使用できます。 このプロパティは読み取り専用と設定されているときに、<xref:System.Net.Sockets.Socket>を作成します。  
  
   
  
## Examples  
 次のコード例では表示、 <xref:System.Net.Sockets.AddressFamily>、 <xref:System.Net.Sockets.SocketType>、および<xref:System.Net.Sockets.ProtocolType>コンソールにします。  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Available">
      <MemberSignature Language="C#" Value="public int Available { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Available" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Available" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ネットワークから受信した、読み取り可能なデータ量を取得します。</summary>
        <value>ネットワークから受信した、読み取り可能なデータのバイト数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非ブロッキングを使用している場合<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Available%2A>を呼び出す前に、読み取り用のデータがキューに置かれたかどうかを決定することをお勧めは<xref:System.Net.Sockets.Socket.Receive%2A>します。 使用可能なデータは、読み取り用のネットワーク バッファーにキューに置かれたデータの合計サイズです。 ネットワーク バッファーにデータがキューにない場合<xref:System.Net.Sockets.Socket.Available%2A>0 を返します。  
  
 リモート ホストがシャット ダウン、または、接続を閉じる場合<xref:System.Net.Sockets.Socket.Available%2A>スローすることができます、<xref:System.Net.Sockets.SocketException>です。 表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例では、呼び出し元の IOControl FIONREAD と使用可能なプロパティを使用した結果を比較します。  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求の状態情報を格納するオブジェクト。</param>
        <summary>着信接続の試行をそのまま使用する非同期操作を開始します。</summary>
        <returns><see cref="T:System.IAsyncResult" />非同期の参照を<see cref="T:System.Net.Sockets.Socket" />作成します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向プロトコルを使用できる、<xref:System.Net.Sockets.Socket.BeginAccept%2A>着信接続を非同期的に処理するメソッドと試みます。 非同期的に接続を受け入れると、個別の実行スレッド内でデータを送受信する機能を提供します。 呼び出しの前に、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドを呼び出す必要があります、<xref:System.Net.Sockets.Socket.Listen%2A>をリッスンし、接続要求をキューにメソッドです。  
  
 実装するコールバック メソッドを作成する必要があります、<xref:System.AsyncCallback>を委任し、その名前を渡す、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドです。 そのためには、少なくとも、リッスンを渡す必要があります<xref:System.Net.Sockets.Socket>オブジェクトを<xref:System.Net.Sockets.Socket.BeginAccept%2A>を通じて、`state`パラメーター。 コールバックは、詳細を必要とする場合は、保持するために小さなクラスを作成することができます、<xref:System.Net.Sockets.Socket>およびその他の必要な情報です。 このクラスのインスタンスを渡す、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドによって、`state`パラメーター。  
  
 コールバック メソッドを呼び出す必要がある、<xref:System.Net.Sockets.Socket.EndAccept%2A>メソッドです。 アプリケーションを呼び出すと<xref:System.Net.Sockets.Socket.BeginAccept%2A>、通常、システムは別のスレッドを使用して、指定されたコールバック メソッドを実行してでブロック<xref:System.Net.Sockets.Socket.EndAccept%2A>保留中の接続が取得されるまでです。 <xref:System.Net.Sockets.Socket.EndAccept%2A>新しい戻ります<xref:System.Net.Sockets.Socket>オブジェクトをリモート ホストとのデータの送受信に使用できます。 返されるこれを使用することはできません<xref:System.Net.Sockets.Socket>接続キューからその他の接続を受け入れるようにします。 場合は、元のスレッドをブロックを呼び出した後、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドを使用して<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>です。 Set メソッドを呼び出す、<xref:System.Threading.ManualResetEvent>元のスレッドに実行を継続する場合は、コールバック メソッドにします。  
  
 システムは、呼び出し元のスレッドを使用して、コールバック メソッドを呼び出す可能性があります。 ここで、<xref:System.IAsyncResult.CompletedSynchronously%2A>プロパティで返された<xref:System.IAsyncResult>ことを示すために設定されます、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドは同期的に完了しました。  
  
 コールバック メソッドの記述の詳細については、次を参照してください。[コールバック メソッドとしてのデリゲートをマーシャ リング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)です。  
  
 保留中の呼び出しをキャンセルする、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッド、閉じる、<xref:System.Net.Sockets.Socket>です。 ときに、<xref:System.Net.Sockets.Socket.Close%2A>メソッドを呼び出すための非同期操作が進行中に渡されたコールバック、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドが呼び出されます。  後続の呼び出し、<xref:System.Net.Sockets.Socket.EndAccept%2A>メソッドがスローされます、<xref:System.ObjectDisposedException>操作が取り消されましたことを示すためにします。  
  
> [!NOTE]
>  使用することができます、 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 、返されたプロパティ<xref:System.Net.Sockets.Socket>をリモート ホストのネットワーク アドレスとポート番号を識別します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケット バージョン 2 API エラー コードのドキュメントに MSDN でエラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッドです。 特定のコンテキストの初回使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。  
  
   
  
## Examples  
 次のコード例は、非同期的に受信接続を受信しようとします。  
  
 [!code-cpp[Socket_Async_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Async_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Async_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />オブジェクトが閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">Windows NT は、このメソッドに必要です。</exception>
        <exception cref="T:System.InvalidOperationException">接続の受け入れ側のソケットがリッスンしていません。 呼び出す必要があります<see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />と<see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />呼び出す前に<see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />です。  
  
 または  
  
 受け入れられたソケットがバインドされています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="receiveSize" /> が 0 未満です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="receiveSize" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="receiveSize">送信側からそのまま使用するバイト数。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求の状態情報を格納するオブジェクト。</param>
        <summary>着信接続試行を受け入れる非同期操作を開始し、クライアント アプリケーションによって送信されるデータの最初のブロックを受け取ります。</summary>
        <returns><see cref="T:System.IAsyncResult" />非同期の参照を<see cref="T:System.Net.Sockets.Socket" />作成します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向プロトコルを使用できる、<xref:System.Net.Sockets.Socket.BeginAccept%2A>着信接続を非同期的に処理するメソッドと試みます。 非同期接続の受け入れを使用すると、個別の実行スレッド内でデータを送受信できます。 このオーバー ロードでは、初期の転送に同意するバイト数を指定することができます、`receiveSize`パラメーター。  
  
 呼び出しの前に、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドを呼び出す必要があります、<xref:System.Net.Sockets.Socket.Listen%2A>をリッスンし、接続要求をキューにメソッドです。  
  
 実装するコールバック メソッドを作成する必要があります、<xref:System.AsyncCallback>を委任し、その名前を渡す、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドです。 そのためには、少なくとも、リッスンを渡す必要があります<xref:System.Net.Sockets.Socket>オブジェクトを<xref:System.Net.Sockets.Socket.BeginAccept%2A>を通じて、`state`パラメーター。 コールバックは、詳細を必要とする場合は、保持するために小さなクラスを作成することができます、<xref:System.Net.Sockets.Socket>およびその他の必要な情報です。 このクラスのインスタンスを渡す、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドによって、`state`パラメーター。  
  
 コールバック メソッドを呼び出す必要がある、<xref:System.Net.Sockets.Socket.EndAccept%2A>メソッドです。 アプリケーションを呼び出すと<xref:System.Net.Sockets.Socket.BeginAccept%2A>、通常、システムは別のスレッドを使用して、指定されたコールバック メソッドを実行してでブロック<xref:System.Net.Sockets.Socket.EndAccept%2A>保留中の接続が取得されるまでです。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>新しいを返します<xref:System.Net.Sockets.Socket>リモート ホストとのデータの送受信を行えます。 返されるこれを使用することはできません<xref:System.Net.Sockets.Socket>接続キューからその他の接続を受け入れるようにします。 場合は、元のスレッドをブロックを呼び出した後、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドを使用して<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>です。 Set メソッドを呼び出す、<xref:System.Threading.ManualResetEvent>元のスレッドに実行を継続する場合は、コールバック メソッドにします。  
  
 システムは、呼び出し元のスレッドを使用して、コールバック メソッドを呼び出す可能性があります。 ここで、<xref:System.IAsyncResult.CompletedSynchronously%2A>プロパティで返された<xref:System.IAsyncResult>ことを示すために設定されます、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドは同期的に完了しました。  
  
 コールバック メソッドの記述の詳細については、次を参照してください。[コールバック メソッドとしてのデリゲートをマーシャ リング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)です。  
  
 保留中の呼び出しをキャンセルする、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッド、閉じる、<xref:System.Net.Sockets.Socket>です。  ときに、<xref:System.Net.Sockets.Socket.Close%2A>メソッドを呼び出すための非同期操作が進行中に渡されたコールバック、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドが呼び出されます。  後続の呼び出し、<xref:System.Net.Sockets.Socket.EndAccept%2A>メソッドがスローされます、<xref:System.ObjectDisposedException>操作が取り消されましたことを示すためにします。  
  
> [!NOTE]
>  使用してを呼び出すことができます、 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 、返されたプロパティ<xref:System.Net.Sockets.Socket>をリモート ホストのネットワーク アドレスとポート番号を識別するオブジェクト。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッドです。 特定のコンテキストの初回使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。  
  
   
  
## Examples  
 次のコード例は、ソケットを開き、非同期接続を受け入れます。 この例では、ソケットは、最初の 10 バイトのデータを受け取っています。 受信したバイト数と、データは、コールバック デリゲートをコンソールに表示されます。 参照してください<xref:System.Net.Sockets.Socket.BeginReceive%2A>残りのデータを受信する方法の詳細についてはします。  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />オブジェクトが閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">Windows NT は、このメソッドに必要です。</exception>
        <exception cref="T:System.InvalidOperationException">接続の受け入れ側のソケットがリッスンしていません。 呼び出す必要があります<see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />と<see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />呼び出す前に<see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />です。  
  
 または  
  
 受け入れられたソケットがバインドされています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="receiveSize" /> が 0 未満です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (System.Net.Sockets.Socket acceptSocket, int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.Net.Sockets.Socket acceptSocket, int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="acceptSocket" Type="System.Net.Sockets.Socket" />
        <Parameter Name="receiveSize" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="acceptSocket">受け入れた <see cref="T:System.Net.Sockets.Socket" /> オブジェクト。 この値は <see langword="null" /> の場合もあります。</param>
        <param name="receiveSize">受信するバイトの最大数。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求の状態情報を格納するオブジェクト。</param>
        <summary>指定したソケットの受信接続の試行を受け入れる非同期操作を開始し、クライアント アプリケーションによって送信されるデータの最初のブロックを受け取ります。</summary>
        <returns><see cref="T:System.IAsyncResult" />非同期の参照オブジェクト<see cref="T:System.Net.Sockets.Socket" />オブジェクトを作成します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向プロトコルを使用できる、<xref:System.Net.Sockets.Socket.BeginAccept%2A>着信接続を非同期的に処理するメソッドと試みます。 非同期的に接続を受け入れると、個別の実行スレッド内でデータを送受信する機能を提供します。 このオーバー ロードで受け入れられたソケットを指定することができます、`acceptSocket`パラメーター。 このパラメーターは場合`null`、受け入れられたソケットがによって作成された、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドです。 初期転送に同意するバイト数を指定することができます、`receiveSize`パラメーター。  
  
 呼び出しの前に、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドを呼び出す必要があります、<xref:System.Net.Sockets.Socket.Listen%2A>をリッスンし、接続要求をキューにメソッドです。  
  
 実装するコールバック メソッドを作成する必要があります、<xref:System.AsyncCallback>を委任し、その名前を渡す、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドです。 そのためには、少なくとも、リッスンを渡す必要があります<xref:System.Net.Sockets.Socket>オブジェクトを<xref:System.Net.Sockets.Socket.BeginAccept%2A>を通じて、`state`パラメーター。 コールバックは、詳細を必要とする場合は、保持するために小さなクラスを作成することができます、<xref:System.Net.Sockets.Socket>およびその他の必要な情報です。 このクラスのインスタンスを渡す、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドによって、`state`パラメーター。  
  
 コールバック メソッドを呼び出す必要がある、<xref:System.Net.Sockets.Socket.EndAccept%2A>メソッドです。 アプリケーションを呼び出すと<xref:System.Net.Sockets.Socket.BeginAccept%2A>、通常、システムは別のスレッドを使用して、指定されたコールバック メソッドを実行してでブロック<xref:System.Net.Sockets.Socket.EndAccept%2A>保留中の接続が取得されるまでです。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>新しいを返します<xref:System.Net.Sockets.Socket>オブジェクトをリモート ホストとのデータの送受信に使用できます。 返されるこれを使用することはできません<xref:System.Net.Sockets.Socket>接続キューからその他の接続を受け入れるようにします。 場合は、元のスレッドをブロックを呼び出した後、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドを使用して<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>です。 Set メソッドを呼び出す、<xref:System.Threading.ManualResetEvent>元のスレッドに実行を継続する場合は、コールバック メソッドにします。  
  
 システムは、呼び出し元のスレッドを使用して、コールバック メソッドを呼び出す可能性があります。 ここで、<xref:System.IAsyncResult.CompletedSynchronously%2A>プロパティで返された<xref:System.IAsyncResult>ことを示すために設定されます、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドは同期的に完了しました。  
  
 コールバック メソッドの作成方法の詳細については、次を参照してください。[コールバック メソッドとしてのデリゲートをマーシャ リング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)です。  
  
 保留中の呼び出しをキャンセルする、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッド、閉じる、<xref:System.Net.Sockets.Socket>です。 ときに、<xref:System.Net.Sockets.Socket.Close%2A>メソッドを呼び出すための非同期操作が進行中に渡されたコールバック、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドが呼び出されます。  後続の呼び出し、<xref:System.Net.Sockets.Socket.EndAccept%2A>メソッドがスローされます、<xref:System.ObjectDisposedException>操作が取り消されましたことを示すためにします。  
  
> [!NOTE]
>  使用することができます、 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 、返されたプロパティ<xref:System.Net.Sockets.Socket>をリモート ホストのネットワーク アドレスとポート番号を識別するオブジェクト。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッドです。 特定のコンテキストの初回使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。  
  
   
  
## Examples  
 次のコード例は、ソケットを開き、非同期接続を受け入れます。 この例では、ソケットは最初の 10 バイトのデータを受け入れます。 と`acceptSocket`パラメーターは`null`、強制的に実行する、<xref:System.Net.Sockets.Socket.BeginAccept%2A>受け入れられたソケットを作成する方法です。 受信したバイト数と、データは、コールバック デリゲートをコンソールに表示されます。 参照してください<xref:System.Net.Sockets.Socket.BeginReceive%2A>残りのデータを受信する方法の詳細についてはします。  
  
 [!code-cpp[NCLSocketEnhancements#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#7)]
 [!code-csharp[NCLSocketEnhancements#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />オブジェクトが閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">Windows NT は、このメソッドに必要です。</exception>
        <exception cref="T:System.InvalidOperationException">接続の受け入れ側のソケットがリッスンしていません。 呼び出す必要があります<see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />と<see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />呼び出す前に<see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />です。  
  
 または  
  
 受け入れられたソケットがバインドされています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="receiveSize" /> が 0 未満です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint end_point, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint end_point, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="end_point">To be added.</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求の状態情報を格納するオブジェクト。</param>
        <summary>リモート ホスト接続への非同期要求を開始します。</summary>
        <returns><see cref="T:System.IAsyncResult" />非同期接続を参照します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向のプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドへの接続への非同期要求の開始、`remoteEP`パラメーター。 コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.BeginConnect%2A>既定のリモート ホストを確立します。 接続するか、既定のリモート ホストの設定を非同期的に個別の実行スレッド内でデータを送受信する機能を提供します。  
  
 実装するコールバック メソッドを作成することができます、<xref:System.AsyncCallback>を委任し、その名前を渡す、<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドです。 少なくとも、渡す必要があります、<xref:System.Net.Sockets.Socket>に<xref:System.Net.Sockets.Socket.BeginConnect%2A>を通じて、`state`パラメーター。 コールバックは、詳細を必要とする場合は、保持するために小さなクラスを作成することができます、 <xref:System.Net.Sockets.Socket>、およびその他の必要な情報です。 このクラスのインスタンスを渡す、<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドによって、`state`パラメーター。  
  
 コールバック メソッドを呼び出す必要がある、<xref:System.Net.Sockets.Socket.EndConnect%2A>メソッドです。 アプリケーションを呼び出すと<xref:System.Net.Sockets.Socket.BeginConnect%2A>、システムは、指定されたコールバック メソッドを実行する別のスレッドを使用しでブロックされます<xref:System.Net.Sockets.Socket.EndConnect%2A>まで、<xref:System.Net.Sockets.Socket>が正常に接続するか、例外をスローします。 場合は、元のスレッドをブロックを呼び出した後、<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドを使用して<xref:System.Threading.WaitHandle.WaitOne%2A>です。 Set メソッドを呼び出す、<xref:System.Threading.ManualResetEvent>元のスレッドに実行を継続する場合は、コールバック メソッドにします。 コールバック メソッドの記述の詳細については、次を参照してください。[コールバック メソッドとしてのデリゲートをマーシャ リング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)です。  
  
 UDP などのコネクションレスのプロトコルを使用している場合を呼び出す必要はありません<xref:System.Net.Sockets.Socket.BeginConnect%2A>データを送受信する前にします。 使用することができます<xref:System.Net.Sockets.Socket.BeginSendTo%2A>と<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>のリモート ホストと通信します。 呼び出す場合<xref:System.Net.Sockets.Socket.BeginConnect%2A>、指定した既定以外のアドレスから受信する任意のデータグラムは破棄されます。 既定のリモート ホストが、ブロードキャスト アドレスを設定する場合は、最初に呼び出す必要があります<xref:System.Net.Sockets.Socket.SetSocketOption%2A>にブロードキャストを設定および`true`です。 できない場合は、<xref:System.Net.Sockets.Socket.BeginConnect%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。  
  
 接続指向のプロトコルを使用しているし、呼び出さないかどうか<xref:System.Net.Sockets.Socket.Bind%2A>呼び出す前に<xref:System.Net.Sockets.Socket.BeginConnect%2A>、基になるサービス プロバイダーが最も適切なローカル ネットワーク アドレスとポート番号を割り当てます。 コネクションレスのプロトコルを使用している場合、サービス プロバイダーを割り当てませんローカル ネットワーク アドレスとポート番号を呼び出すまで、<xref:System.Net.Sockets.Socket.BeginSend%2A>または<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドです。 既定のリモート ホストを変更する場合は、呼び出し、<xref:System.Net.Sockets.Socket.BeginConnect%2A>目的のエンドポイントを使用してメソッドです。  
  
 保留中の呼び出しをキャンセルする、<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッド、閉じる、<xref:System.Net.Sockets.Socket>です。 ときに、<xref:System.Net.Sockets.Socket.Close%2A>メソッドを呼び出すための非同期操作が進行中に渡されたコールバック、<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドが呼び出されます。  後続の呼び出し、<xref:System.Net.Sockets.Socket.EndConnect%2A>メソッドがスローされます、<xref:System.ObjectDisposedException>操作が取り消されましたことを示すためにします。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このソケットが解除されていたし場合<xref:System.Net.Sockets.Socket.BeginConnect%2A>操作が完了するまで終了しないスレッドで呼び出す必要があります。 これは、基になるプロバイダーの制限です。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッドです。 特定のコンテキストの初回使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。  
  
   
  
## Examples  
 次のコード例では、非同期接続の試行を開始します。  
  
 [!code-cpp[Socket_Async_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Async_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Async_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="remoteEP" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し履歴の上位にある呼び出し元には、要求された操作に対するアクセス許可がありません。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" />を呼び出して待機状態が配置されている<see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />、または非同期操作が既に進行中です。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="address">リモート ホストの <see cref="T:System.Net.IPAddress" />。</param>
        <param name="port">リモート ホストのポート番号。</param>
        <param name="callback">To be added.</param>
        <param name="state">接続操作に関する情報を格納するユーザー定義のオブジェクト。 このオブジェクトは、<c>で</c>委任操作が完了するとします。</param>
        <summary>リモート ホスト接続への非同期要求を開始します。 ホストがで指定された、<see cref="T:System.Net.IPAddress" />とポート番号。</summary>
        <returns><see cref="T:System.IAsyncResult" />非同期接続を参照します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同期の<xref:System.Net.Sockets.Socket.BeginConnect%2A>操作を呼び出すことによって完了する必要があります、<xref:System.Net.Sockets.Socket.EndConnect%2A>メソッドです。 通常、このメソッドはによって、`requestCallback`を委任します。  
  
 このメソッドは、操作が完了するまでにはブロックされません。 操作が完了するまでブロックするには、いずれかを使用、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドのオーバー ロードまたは<xref:System.Net.Sockets.Socket.EndConnect%2A>です。  
  
 保留中の呼び出しをキャンセルする、<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッド、閉じる、<xref:System.Net.Sockets.Socket>です。 ときに、<xref:System.Net.Sockets.Socket.Close%2A>メソッドを呼び出すための非同期操作が進行中に渡されたコールバック、<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドが呼び出されます。  後続の呼び出し、<xref:System.Net.Sockets.Socket.EndConnect%2A>メソッドがスローされます、<xref:System.ObjectDisposedException>操作が取り消されましたことを示すためにします。  
  
 詳細については、非同期プログラミング モデルを使用して、次を参照してください[同期のメソッドを非同期に呼び出す。](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このソケットが解除されていたし場合<xref:System.Net.Sockets.Socket.BeginConnect%2A>操作が完了するまで終了しないスレッドで呼び出す必要があります。 これは、基になるプロバイダーの制限です。 また、<xref:System.Net.EndPoint>は別にする必要がありますを使用します。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッドです。 特定のコンテキストの初回使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。  
  
   
  
## Examples  
 次のコード例では、非同期接続の試行を開始します。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#7)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="address" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Net.Sockets.Socket" />ソケット ファミリに含まれない。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">ポート番号が正しくありません。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="address" /> の長さが 0 です。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" />を呼び出して待機状態が配置されている<see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />、または非同期操作が既に進行中です。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" />
        <Parameter Name="port" Type="System.Int32" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="addresses">少なくとも 1 つ<see cref="T:System.Net.IPAddress" />、リモート ホストを指定します。</param>
        <param name="port">リモート ホストのポート番号。</param>
        <param name="callback">To be added.</param>
        <param name="state">接続操作に関する情報を格納するユーザー定義のオブジェクト。 このオブジェクトは、<c>で</c>委任操作が完了するとします。</param>
        <summary>リモート ホスト接続への非同期要求を開始します。 ホストがで指定された、<see cref="T:System.Net.IPAddress" />配列とポート番号。</summary>
        <returns><see cref="T:System.IAsyncResult" />非同期接続を参照します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同期の<xref:System.Net.Sockets.Socket.BeginConnect%2A>操作を呼び出すことによって完了する必要があります、<xref:System.Net.Sockets.Socket.EndConnect%2A>メソッドです。 通常、このメソッドはによって、`requestCallback`を委任します。  
  
 このメソッドは、操作が完了するまでにはブロックされません。 操作が完了するまでブロックするには、いずれかを使用、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドのオーバー ロードします。  
  
 保留中の呼び出しをキャンセルする、<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッド、閉じる、<xref:System.Net.Sockets.Socket>です。 ときに、<xref:System.Net.Sockets.Socket.Close%2A>メソッドを呼び出すための非同期操作が進行中に渡されたコールバック、<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドが呼び出されます。  後続の呼び出し、<xref:System.Net.Sockets.Socket.EndConnect%2A>メソッドがスローされます、<xref:System.ObjectDisposedException>操作が取り消されましたことを示すためにします。  
  
 詳細については、非同期プログラミング モデルを使用して、次を参照してください。[同期のメソッドを非同期に呼び出す](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)です。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このソケットが解除されていたし場合<xref:System.Net.Sockets.Socket.BeginConnect%2A>操作が完了するまで終了しないスレッドで呼び出す必要があります。 これは、基になるプロバイダーの制限です。 また、<xref:System.Net.EndPoint>は別にする必要がありますを使用します。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッドです。 特定のコンテキストの初回使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。  
  
   
  
## Examples  
 次のコード例では、非同期接続の試行を開始します。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="addresses" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドを使用するソケット<see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />または<see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">ポート番号が無効です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="address" /> の長さが 0 です。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" />を呼び出して待機状態が配置されている<see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />、または非同期操作が既に進行中です。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="host">リモート ホストの名前。</param>
        <param name="port">リモート ホストのポート番号。</param>
        <param name="callback">To be added.</param>
        <param name="state">接続操作に関する情報を格納するユーザー定義のオブジェクト。 このオブジェクトは、<c>で</c>委任操作が完了するとします。</param>
        <summary>リモート ホスト接続への非同期要求を開始します。 ホストはホスト名とポート番号で指定されます。</summary>
        <returns><see cref="T:System.IAsyncResult" />非同期接続を参照します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同期の<xref:System.Net.Sockets.Socket.BeginConnect%2A>操作を呼び出すことによって完了する必要があります、<xref:System.Net.Sockets.Socket.EndConnect%2A>メソッドです。 通常、このメソッドはによって、`requestCallback`を委任します。  
  
 このメソッドは、操作が完了するまでにはブロックされません。 操作が完了するまでブロックするには、いずれかを使用、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドのオーバー ロードします。  
  
 保留中の呼び出しをキャンセルする、<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッド、閉じる、<xref:System.Net.Sockets.Socket>です。 ときに、<xref:System.Net.Sockets.Socket.Close%2A>メソッドを呼び出すための非同期操作が進行中に渡されたコールバック、<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドが呼び出されます。  後続の呼び出し、<xref:System.Net.Sockets.Socket.EndConnect%2A>メソッドがスローされます、<xref:System.ObjectDisposedException>操作が取り消されましたことを示すためにします。  
  
 詳細については、非同期プログラミング モデルを使用して、次を参照してください[同期のメソッドを非同期に呼び出す。](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このソケットが解除されていたし場合<xref:System.Net.Sockets.Socket.BeginConnect%2A>操作が完了するまで終了しないスレッドで呼び出す必要があります。 これは、基になるプロバイダーの制限です。 また、<xref:System.Net.EndPoint>は別にする必要がありますを使用します。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッドです。 特定のコンテキストの初回使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。  
  
   
  
## Examples  
 次のコード例では、非同期接続の試行を開始します。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#3)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="host" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドが内のソケットに対して有効では、<see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />または<see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />ファミリ。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">ポート番号が無効です。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" />を呼び出して待機状態が配置されている<see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />、または非同期操作が既に進行中です。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginDisconnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginDisconnect (bool reuseSocket, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginDisconnect(bool reuseSocket, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">
          <see langword="true" />接続が閉じられた後にこのソケットを再利用できる場合それ以外の場合、<see langword="false" />です。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求の状態情報を格納するオブジェクト。</param>
        <summary>リモート エンドポイントから切断への非同期要求を開始します。</summary>
        <returns><see cref="T:System.IAsyncResult" />非同期操作を参照するオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向のプロトコルを使用している場合は、呼び出す、<xref:System.Net.Sockets.Socket.BeginDisconnect%2A>リモート エンドポイントからの切断要求を送信します。 場合`reuseSocket`は`true`ソケットを再利用することができます。  
  
 <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>メソッドは、指定されたコールバック メソッドを呼び出す別のスレッドを使用します。 <xref:System.Net.Sockets.Socket.EndDisconnect%2A>メソッドは、保留中の切断までブロックが完了しました。 コールバック メソッドの作成方法の詳細については、次を参照してください。[コールバック メソッドとしてのデリゲートをマーシャ リング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)です。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>例外を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例では、非同期通信のソケットを作成し、リモート ホストにデータを送信します。 データが送信されると、<xref:System.Net.Sockets.Socket.Shutdown%2A>送信を停止し、受信アクティビティのために呼び出されます。 <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>切断要求を開始すると呼びます。 要求が完了したら、<xref:System.Net.Sockets.Socket.Connected%2A>プロパティは、ソケットが切断されているかどうかをテストするクエリを実行します。  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">オペレーティング システムが Windows 2000 以前のバージョン、および、このメソッドには、Windows XP が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />オブジェクトが閉じられました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">型の配列<see cref="T:System.Byte" />受信したデータの記憶域の場所はします。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="callback">操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">受信操作に関する情報を含むユーザー定義のオブジェクト。 このオブジェクトは、操作の完了時に <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> デリゲートに渡されます。</param>
        <summary>接続からデータを非同期的に受信を開始<see cref="T:System.Net.Sockets.Socket" />です。</summary>
        <returns><see cref="T:System.IAsyncResult" />非同期の読み取りを参照します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同期の<xref:System.Net.Sockets.Socket.BeginReceive%2A>操作を呼び出すことによって完了する必要があります、<xref:System.Net.Sockets.Socket.EndReceive%2A>メソッドです。 通常、このメソッドはによって、`callback`を委任します。  
  
 このメソッドは、操作が完了するまでにはブロックされません。 操作が完了するまでブロックするには、いずれかを使用、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドのオーバー ロードします。  
  
 [キャンセル] を保留中<xref:System.Net.Sockets.Socket.BeginReceive%2A>を呼び出し、<xref:System.Net.Sockets.Socket.Close%2A>メソッドです。  
  
 詳細については、非同期プログラミング モデルを使用して、次を参照してください。[同期のメソッドを非同期に呼び出す](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)です。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I/O が取り消されました。 操作が完了する前に、スレッドが終了した場合、保留中の非同期操作が失敗することができます。  
  
> [!NOTE]
>  `state`ユーザー定義のクラスのインスタンス化します。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッドです。 特定のコンテキストの初回使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" />閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">型の配列<see cref="T:System.Byte" />受信したデータの記憶域の場所はします。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="errorCode">A<see cref="T:System.Net.Sockets.SocketError" />ソケット エラーを格納するオブジェクト。</param>
        <param name="callback">操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">受信操作に関する情報を含むユーザー定義のオブジェクト。 このオブジェクトは、操作の完了時に <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> デリゲートに渡されます。</param>
        <summary>接続からデータを非同期的に受信を開始<see cref="T:System.Net.Sockets.Socket" />です。</summary>
        <returns><see cref="T:System.IAsyncResult" />非同期の読み取りを参照します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同期の<xref:System.Net.Sockets.Socket.BeginReceive%2A>操作を呼び出すことによって完了する必要があります、<xref:System.Net.Sockets.Socket.EndReceive%2A>メソッドです。 通常、このメソッドはによって、`callback`を委任します。  
  
 このメソッドは、操作が完了するまでにはブロックされません。 操作が完了するまでブロックするには、いずれかを使用、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドのオーバー ロードします。  
  
 [キャンセル] を保留中<xref:System.Net.Sockets.Socket.BeginReceive%2A>を呼び出し、<xref:System.Net.Sockets.Socket.Close%2A>メソッドです。  
  
 詳細については、非同期プログラミング モデルを使用して、次を参照してください。[同期のメソッドを非同期に呼び出す](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)です。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I/O が取り消されました。 操作が完了する前に、スレッドが終了した場合、保留中の非同期操作が失敗することができます。  
  
> [!NOTE]
>  `state`ユーザー定義のクラスのインスタンス化します。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッドです。 特定のコンテキストの初回使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" />閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">型の配列<see cref="T:System.Byte" />受信したデータの記憶域の場所はします。</param>
        <param name="offset">内の 0 から始まる位置、<c>バッファー</c>受信データを格納するパラメーターです。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socket_flags">To be added.</param>
        <param name="callback">操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">受信操作に関する情報を含むユーザー定義のオブジェクト。 このオブジェクトは、操作の完了時に <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> デリゲートに渡されます。</param>
        <summary>接続からデータを非同期的に受信を開始<see cref="T:System.Net.Sockets.Socket" />です。</summary>
        <returns><see cref="T:System.IAsyncResult" />非同期の読み取りを参照します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同期の<xref:System.Net.Sockets.Socket.BeginReceive%2A>操作を呼び出すことによって完了する必要があります、<xref:System.Net.Sockets.Socket.EndReceive%2A>メソッドです。 通常、このメソッドはによって、`callback`を委任します。  
  
 このメソッドは、操作が完了するまでにはブロックされません。 操作が完了するまでブロックするには、いずれかを使用、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドのオーバー ロードします。  
  
 [キャンセル] を保留中<xref:System.Net.Sockets.Socket.BeginReceive%2A>を呼び出し、<xref:System.Net.Sockets.Socket.Close%2A>メソッドです。  
  
 詳細については、非同期プログラミング モデルを使用して、次を参照してください。[同期のメソッドを非同期に呼び出す](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)です。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I/O が取り消されました。 操作が完了する前に、スレッドが終了した場合、保留中の非同期操作が失敗することができます。  
  
> [!NOTE]
>  `state`ユーザー定義のクラスのインスタンス化します。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッドです。 特定のコンテキストの初回使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。  
  
   
  
## Examples  
 次のコード例は、接続からデータを非同期的に受信を開始<xref:System.Net.Sockets.Socket>です。  
  
 [!code-cpp[Socket_Async_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Async_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Async_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#11)]  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" />閉じられました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> が 0 未満です。  
  
 または  
  
 <paramref name="offset" />長さより大きい<paramref name="buffer" />です。  
  
 または  
  
 <paramref name="size" /> が 0 未満です。  
  
 または  
  
 <paramref name="size" />長さより大きい<paramref name="buffer" />負の値、<paramref name="offset" />パラメーター。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags flags, out System.Net.Sockets.SocketError error, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags flags, [out] valuetype System.Net.Sockets.SocketError&amp; error, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">型の配列<see cref="T:System.Byte" />受信したデータの記憶域の場所はします。</param>
        <param name="offset">内の場所<c>バッファー</c>を受信したデータを格納します。</param>
        <param name="size">受信するバイト数。</param>
        <param name="flags">To be added.</param>
        <param name="error">To be added.</param>
        <param name="callback">操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">受信操作に関する情報を含むユーザー定義のオブジェクト。 このオブジェクトは、操作の完了時に <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> デリゲートに渡されます。</param>
        <summary>接続からデータを非同期的に受信を開始<see cref="T:System.Net.Sockets.Socket" />です。</summary>
        <returns><see cref="T:System.IAsyncResult" />非同期の読み取りを参照します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同期の<xref:System.Net.Sockets.Socket.BeginReceive%2A>操作を呼び出すことによって完了する必要があります、<xref:System.Net.Sockets.Socket.EndReceive%2A>メソッドです。 通常、このメソッドはによって、`callback`を委任します。  
  
 このメソッドは、操作が完了するまでにはブロックされません。 操作が完了するまでブロックするには、いずれかを使用、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドのオーバー ロードします。  
  
 [キャンセル] を保留中<xref:System.Net.Sockets.Socket.BeginReceive%2A>を呼び出し、<xref:System.Net.Sockets.Socket.Close%2A>メソッドです。  
  
 詳細については、非同期プログラミング モデルを使用して、次を参照してください。[同期のメソッドを非同期に呼び出す](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)です。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I/O が取り消されました。 操作が完了する前に、スレッドが終了した場合、保留中の非同期操作が失敗することができます。  
  
> [!NOTE]
>  `state`ユーザー定義のクラスのインスタンス化します。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッドです。 特定のコンテキストの初回使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" />閉じられました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> が 0 未満です。  
  
 または  
  
 <paramref name="offset" />長さより大きい<paramref name="buffer" />です。  
  
 または  
  
 <paramref name="size" /> が 0 未満です。  
  
 または  
  
 <paramref name="size" />長さより大きい<paramref name="buffer" />負の値、<paramref name="offset" />パラメーター。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, ref System.Net.EndPoint remote_end, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint&amp; remote_end, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">型の配列<see cref="T:System.Byte" />受信したデータの記憶域の場所はします。</param>
        <param name="offset">内の 0 から始まる位置、<c>バッファー</c>データを格納するパラメーターです。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socket_flags">To be added.</param>
        <param name="remote_end">To be added.</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求の状態情報を格納するオブジェクト。</param>
        <summary>指定したネットワーク デバイスからデータを非同期的に受信を開始します。</summary>
        <returns><see cref="T:System.IAsyncResult" />非同期の読み取りを参照します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>メソッドが、リモート ホストからコネクションレス データグラムを非同期的に読み取りを開始します。 呼び出す、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>メソッドは、個別の実行スレッド内でデータを受信する機能を提供します。  
  
 実装するコールバック メソッドを作成することができます、<xref:System.AsyncCallback>を委任し、その名前を渡す、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>メソッドです。 これを行う、非常に最小値で、`state`パラメーターが、接続されているを含む必要がありますまたは既定の<xref:System.Net.Sockets.Socket>の通信に使用されています。 コールバックは、詳細を必要とする場合は、保持するために小さなクラスを作成することができます、<xref:System.Net.Sockets.Socket>およびその他の必要な情報です。 このクラスのインスタンスを渡す、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>メソッドによって、`state`パラメーター。  
  
 コールバック メソッドを呼び出す必要がある、<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>メソッドです。 アプリケーションを呼び出すと<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>、システムが、指定されたコールバック メソッドを実行する別のスレッドを使用、およびを<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>まで、<xref:System.Net.Sockets.Socket>データを読み取るか例外をスローします。 場合は、元のスレッドをブロックを呼び出した後、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>メソッドを使用して<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>です。 元のスレッドに実行を継続する場合は、コールバック メソッドにはセット メソッドを呼び出します。 コールバック メソッドの作成方法の詳細については、次を参照してください。[コールバック メソッドとしてのデリゲートをマーシャ リング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)です。  
  
> [!NOTE]
>  呼び出しの前に<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>、明示的にバインドする必要があります、<xref:System.Net.Sockets.Socket>を使用して、ローカル エンドポイントを<xref:System.Net.Sockets.Socket.Bind%2A>メソッド、または<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。  
  
 このメソッドにデータを読み込みます、`buffer`パラメーター、およびデータの送信元となるエンドポイントをホストするリモート キャプチャします。 このエンドポイントを取得する方法についてを参照してください<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>です。 このメソッドは非同期的に不明なホストまたは複数のホストからコネクションレス データグラムを受信する場合に便利です。 このような場合は、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>はローカル ネットワーク バッファーに書き込まれる最初のエンキューされたデータグラムを読み取ります。 受信したデータグラムがのサイズよりも大きいかどうか`buffer`、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>メソッドは入力`buffer`メッセージは、可能であれば、throw の多くで、<xref:System.Net.Sockets.SocketException>です。 信頼性の低いプロトコルを使用している場合、余分なデータが失われます。 信頼性の高いプロトコルを使用している場合、超過データは、サービス プロバイダーによって保持するを呼び出して取得することができます、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>のに十分な大きさのバッファーを持つメソッドです。  
  
 リモート ホストのエンドポイントが常に返される、アプリケーションでは明示的にバインドする必要がありますのことを保証するために、<xref:System.Net.Sockets.Socket>ローカル エンドポイントを使用して、<xref:System.Net.Sockets.Socket.Bind%2A>メソッドと、呼び出し、<xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッドを`optionLevel`パラメーターに設定<xref:System.Net.Sockets.SocketOptionLevel.IP>または<xref:System.Net.Sockets.SocketOptionLevel.IPv6>、必要に応じて、`optionName`パラメーターに設定<xref:System.Net.Sockets.SocketOptionName.PacketInformation>、および`optionValue`を呼び出す前にこのオプションを有効にするパラメーター、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>メソッド。 それ以外の場合、可能であれば、受信側が呼び出される前に、送信者のデータグラムの数が送信する場合は、返されていないリモート ホストのエンドポイントの<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>メソッドです。  
  
 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>向けコネクションレスのプロトコルを接続指向プロトコルも使用できます。 これを行う場合は、する必要がありますまずか、リモート ホスト接続を確立するを呼び出して、 <xref:System.Net.Sockets.Socket.Connect%2A>  /  <xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドを呼び出して、受信接続要求を受け入れるか、<xref:System.Net.Sockets.Socket.Accept%2A>または<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドです。 呼び出す場合は、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>確立するか、接続を受け入れる前にメソッドが表示されます、<xref:System.Net.Sockets.SocketException>です。 呼び出しの前にコネクションレスのプロトコルの既定のリモート ホストを確立することも、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>メソッドです。 このような場合は、のいずれかで、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>メソッドは無視されます、`remoteEP`パラメーターとのみデータが、接続されているまたは既定のリモート ホストを受信します。  
  
 接続指向のソケットと<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>がで指定したバイトの数まで使用できる多くのデータを読み取り、`size`パラメーター。  
  
 [キャンセル] を保留中<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>を呼び出し、<xref:System.Net.Sockets.Socket.Close%2A>メソッドです。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッドです。 特定のコンテキストの初回使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。  
  
   
  
## Examples  
 次のコード例は、リモート ホストから非同期的にコネクションレス データグラムを受信します。  
  
 [!code-cpp[Socket_Async_Send_Receive#41](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#41)]
 [!code-csharp[Socket_Async_Send_Receive#41](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#41)]
 [!code-vb[Socket_Async_Send_Receive#41](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="remoteEP" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> が 0 未満です。  
  
 または  
  
 <paramref name="offset" />長さより大きい<paramref name="buffer" />です。  
  
 または  
  
 <paramref name="size" /> が 0 未満です。  
  
 または  
  
 <paramref name="size" />長さより大きい<paramref name="buffer" />負の値、<paramref name="offset" />パラメーター。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し履歴の上位にある呼び出し元には、要求された操作に対するアクセス許可がありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveMessageFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">型の配列<see cref="T:System.Byte" />受信したデータの記憶域の場所はします。</param>
        <param name="offset">内の 0 から始まる位置、<c>バッファー</c>データを格納するパラメーターです。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" />データのソースを表すです。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求の状態情報を格納するオブジェクト。</param>
        <summary>指定して、データ バッファーの指定した位置に指定されたデータのバイト数を非同期に受け取る開始<see cref="T:System.Net.Sockets.SocketFlags" />エンドポイントとパケットの情報を格納および.</summary>
        <returns><see cref="T:System.IAsyncResult" />非同期の読み取りを参照します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同期の受信操作呼び出しで完了する必要があります、<xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A>メソッドです。 通常、このメソッドはによって、`asyncCallback`を委任します。  
  
 このメソッドは、操作が完了するまでにはブロックされません。 操作が完了するまでをブロックするを使用して、<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>メソッドです。  
  
 [キャンセル] を保留中<xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A>を呼び出し、<xref:System.Net.Sockets.Socket.Close%2A>メソッドです。  
  
 詳細については、非同期プログラミング モデルを使用して、次を参照してください[同期のメソッドを非同期に呼び出す。](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 このメソッドにデータを読み込みます、`buffer`パラメーター、およびデータの送信元となるエンドポイントをホストするリモート キャプチャだけでなく、受信したパケットに関する情報。 このエンドポイントを取得する方法についてを参照してください<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>です。 このメソッドは非同期的に不明なホストまたは複数のホストからコネクションレス データグラムを受信する場合に便利です。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッドです。 特定のコンテキストの初回使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="remoteEP" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> が 0 未満です。  
  
 または  
  
 <paramref name="offset" />長さより大きい<paramref name="buffer" />です。  
  
 または  
  
 <paramref name="size" /> が 0 未満です。  
  
 または  
  
 <paramref name="size" />長さより大きい<paramref name="buffer" />負の値、<paramref name="offset" />パラメーター。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">オペレーティング システムが Windows 2000 以前のバージョン、および、このメソッドには、Windows XP が必要です。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">型の配列<see cref="T:System.Byte" />送信するデータを格納しています。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求の状態情報を格納するオブジェクト。</param>
        <summary>接続されたデータを非同期的に送信<see cref="T:System.Net.Sockets.Socket" />です。</summary>
        <returns><see cref="T:System.IAsyncResult" />非同期送信を参照します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドで確立されているリモート ホストへの非同期送信操作を開始、 <xref:System.Net.Sockets.Socket.Connect%2A>、 <xref:System.Net.Sockets.Socket.BeginConnect%2A>、 <xref:System.Net.Sockets.Socket.Accept%2A>、または<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドです。 <xref:System.Net.Sockets.Socket.BeginSend%2A>最初に呼び出す必要はない場合、例外がスローされます<xref:System.Net.Sockets.Socket.Accept%2A>、 <xref:System.Net.Sockets.Socket.BeginAccept%2A>、 <xref:System.Net.Sockets.Socket.Connect%2A>、または<xref:System.Net.Sockets.Socket.BeginConnect%2A>です。 呼び出す、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドは、個別の実行スレッド内でデータを送信する機能を提供します。  
  
 実装するコールバック メソッドを作成することができます、<xref:System.AsyncCallback>を委任し、その名前を渡す、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドです。 これを行う、非常に最小値で、`state`パラメーターが、接続されているを含む必要がありますまたは既定の<xref:System.Net.Sockets.Socket>の通信に使用されています。 コールバックは、詳細を必要とする場合は、小さなクラスまたは構造体を作成することができます、<xref:System.Net.Sockets.Socket>およびその他の必要な情報です。 このクラスのインスタンスを渡す、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドによって、`state`パラメーター。  
  
 コールバック メソッドを呼び出す必要がある、<xref:System.Net.Sockets.Socket.EndSend%2A>メソッドです。 アプリケーションを呼び出すと<xref:System.Net.Sockets.Socket.BeginSend%2A>、システムは、指定されたコールバック メソッドを実行する別のスレッドを使用しでブロックされます<xref:System.Net.Sockets.Socket.EndSend%2A>まで、<xref:System.Net.Sockets.Socket>を要求したバイト数を送信または例外をスローします。 場合は、元のスレッドをブロックを呼び出した後、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドを使用して、<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>メソッドです。 元のスレッドに実行を継続する場合は、コールバック メソッドにはセット メソッドを呼び出します。 コールバック メソッドの記述の詳細については、次を参照してください。[コールバック メソッドとしてのデリゲートをマーシャ リング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)です。  
  
 接続指向プロトコルでは、意図したものが<xref:System.Net.Sockets.Socket.BeginSend%2A>最初を呼び出すことのコネクションレスのプロトコルでも、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.BeginConnect%2A>既定のリモート ホストを構築する方法です。 使用する必要があります複数の異なるホストにデータを送信する、コネクションレスのプロトコルとプランを使用している場合<xref:System.Net.Sockets.Socket.BeginSendTo%2A>です。 使用することが<xref:System.Net.Sockets.Socket.BeginSendTo%2A>で既定のリモート ホストを確立した後でも<xref:System.Net.Sockets.Socket.Connect%2A>です。 呼び出しの前に既定のリモート ホストを変更することもできます。<xref:System.Net.Sockets.Socket.BeginSend%2A>を別の呼び出しを行って<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.BeginConnect%2A>です。 コネクションレスのプロトコルを使用している場合は、バッファーのサイズが、基になるサービス プロバイダーのパケットの最大サイズを超えていないことを確認する必要もあります。 場合は、データグラムが送信されず<xref:System.Net.Sockets.Socket.BeginSend%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。  
  
 指定した場合、<xref:System.Net.Sockets.SocketFlags.DontRoute>としてフラグを設定、`socketflags`パラメーターに、データを送信すると、ルーティングされません。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I/O が取り消されました。 操作が完了する前に、スレッドが終了した場合、保留中の非同期操作が失敗することができます。  
  
> [!NOTE]
>  `state`ユーザー定義のクラスのインスタンス化します。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されることは示しません。 転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されている場合を除きがブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッドです。 特定のコンテキストの初回使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> が空です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">型の配列<see cref="T:System.Byte" />送信するデータを格納しています。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="errorCode">A<see cref="T:System.Net.Sockets.SocketError" />ソケット エラーを格納するオブジェクト。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求の状態情報を格納するオブジェクト。</param>
        <summary>接続されたデータを非同期的に送信<see cref="T:System.Net.Sockets.Socket" />です。</summary>
        <returns><see cref="T:System.IAsyncResult" />非同期送信を参照します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドで確立されているリモート ホストへの非同期送信操作を開始、 <xref:System.Net.Sockets.Socket.Connect%2A>、 <xref:System.Net.Sockets.Socket.BeginConnect%2A>、 <xref:System.Net.Sockets.Socket.Accept%2A>、または<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドです。 <xref:System.Net.Sockets.Socket.BeginSend%2A>最初に呼び出す必要はない場合、例外がスローされます<xref:System.Net.Sockets.Socket.Accept%2A>、 <xref:System.Net.Sockets.Socket.BeginAccept%2A>、 <xref:System.Net.Sockets.Socket.Connect%2A>、または<xref:System.Net.Sockets.Socket.BeginConnect%2A>です。 呼び出す、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドは、個別の実行スレッド内でデータを送信する機能を提供します。  
  
 実装するコールバック メソッドを作成することができます、<xref:System.AsyncCallback>を委任し、その名前を渡す、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドです。 これを行う、非常に最小値で、`state`パラメーターが、接続されているを含む必要がありますまたは既定の<xref:System.Net.Sockets.Socket>の通信に使用されています。 コールバックは、詳細を必要とする場合は、小さなクラスまたは構造体を作成することができます、<xref:System.Net.Sockets.Socket>およびその他の必要な情報です。 このクラスのインスタンスを渡す、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドによって、`state`パラメーター。  
  
 コールバック メソッドを呼び出す必要がある、<xref:System.Net.Sockets.Socket.EndSend%2A>メソッドです。 アプリケーションを呼び出すと<xref:System.Net.Sockets.Socket.BeginSend%2A>、システムは、指定されたコールバック メソッドを実行する別のスレッドを使用しでブロックされます<xref:System.Net.Sockets.Socket.EndSend%2A>まで、<xref:System.Net.Sockets.Socket>を要求したバイト数を送信または例外をスローします。 場合は、元のスレッドをブロックを呼び出した後、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドを使用して、<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>メソッドです。 Set メソッドを呼び出す、<xref:System.Threading.ManualResetEvent>元のスレッドに実行を継続する場合は、コールバック メソッドにします。 コールバック メソッドの記述の詳細については、次を参照してください。[コールバック メソッドとしてのデリゲートをマーシャ リング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)です。  
  
 接続指向プロトコルでは、意図したものが<xref:System.Net.Sockets.Socket.BeginSend%2A>最初を呼び出すことのコネクションレスのプロトコルでも、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.BeginConnect%2A>既定のリモート ホストを構築する方法です。 使用する必要があります複数の異なるホストにデータを送信する、コネクションレスのプロトコルとプランを使用している場合<xref:System.Net.Sockets.Socket.BeginSendTo%2A>です。 使用することが<xref:System.Net.Sockets.Socket.BeginSendTo%2A>で既定のリモート ホストを確立した後でも<xref:System.Net.Sockets.Socket.Connect%2A>です。 呼び出しの前に既定のリモート ホストを変更することもできます。<xref:System.Net.Sockets.Socket.BeginSend%2A>を別の呼び出しを行って<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.BeginConnect%2A>です。 コネクションレスのプロトコルを使用している場合は、バッファーのサイズが、基になるサービス プロバイダーのパケットの最大サイズを超えていないことを確認する必要もあります。 場合は、データグラムが送信されず<xref:System.Net.Sockets.Socket.BeginSend%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。  
  
 指定した場合、<xref:System.Net.Sockets.SocketFlags.DontRoute>としてフラグを設定、`socketflags`パラメーターに、データを送信すると、ルーティングされません。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I/O が取り消されました。 操作が完了する前に、スレッドが終了した場合、保留中の非同期操作が失敗することができます。  
  
> [!NOTE]
>  `state`ユーザー定義のクラスのインスタンス化します。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されることは示しません。 転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されている場合を除きがブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッドです。 特定のコンテキストの初回使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> が空です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">型の配列<see cref="T:System.Byte" />送信するデータを格納しています。</param>
        <param name="offset">内の 0 から始まる位置、<c>バッファー</c>データの送信を開始する位置を示すパラメーターです。</param>
        <param name="size">送信するバイト数。</param>
        <param name="socket_flags">To be added.</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求の状態情報を格納するオブジェクト。</param>
        <summary>接続されたデータを非同期的に送信<see cref="T:System.Net.Sockets.Socket" />です。</summary>
        <returns><see cref="T:System.IAsyncResult" />非同期送信を参照します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドで確立されているリモート ホストへの非同期送信操作を開始、 <xref:System.Net.Sockets.Socket.Connect%2A>、 <xref:System.Net.Sockets.Socket.BeginConnect%2A>、 <xref:System.Net.Sockets.Socket.Accept%2A>、または<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドです。 <xref:System.Net.Sockets.Socket.BeginSend%2A>最初に呼び出す必要はない場合、例外がスローされます<xref:System.Net.Sockets.Socket.Accept%2A>、 <xref:System.Net.Sockets.Socket.BeginAccept%2A>、 <xref:System.Net.Sockets.Socket.Connect%2A>、または<xref:System.Net.Sockets.Socket.BeginConnect%2A>です。 呼び出す、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドは、個別の実行スレッド内でデータを送信する機能を提供します。  
  
 実装するコールバック メソッドを作成することができます、<xref:System.AsyncCallback>を委任し、その名前を渡す、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドです。 これを行う、非常に最小値で、`state`パラメーターが、接続されているを含む必要がありますまたは既定の<xref:System.Net.Sockets.Socket>の通信に使用されています。 コールバックは、詳細を必要とする場合は、小さなクラスまたは構造体を作成することができます、<xref:System.Net.Sockets.Socket>およびその他の必要な情報です。 このクラスのインスタンスを渡す、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドによって、`state`パラメーター。  
  
 コールバック メソッドを呼び出す必要がある、<xref:System.Net.Sockets.Socket.EndSend%2A>メソッドです。 アプリケーションを呼び出すと<xref:System.Net.Sockets.Socket.BeginSend%2A>、システムは、指定されたコールバック メソッドを実行する別のスレッドを使用しでブロックされます<xref:System.Net.Sockets.Socket.EndSend%2A>まで、<xref:System.Net.Sockets.Socket>を要求したバイト数を送信または例外をスローします。 場合は、元のスレッドをブロックを呼び出した後、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドを使用して、<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>メソッドです。 元のスレッドに実行を継続する場合は、コールバック メソッドにはセット メソッドを呼び出します。 コールバック メソッドの記述の詳細については、次を参照してください。[コールバック メソッドとしてのデリゲートをマーシャ リング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)です。  
  
 接続指向プロトコルでは、意図したものが<xref:System.Net.Sockets.Socket.BeginSend%2A>最初を呼び出すことのコネクションレスのプロトコルでも、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.BeginConnect%2A>既定のリモート ホストを構築する方法です。 使用する必要があります複数の異なるホストにデータを送信する、コネクションレスのプロトコルとプランを使用している場合<xref:System.Net.Sockets.Socket.BeginSendTo%2A>です。 使用することが<xref:System.Net.Sockets.Socket.BeginSendTo%2A>で既定のリモート ホストを確立した後でも<xref:System.Net.Sockets.Socket.Connect%2A>です。 呼び出しの前に既定のリモート ホストを変更することもできます。<xref:System.Net.Sockets.Socket.BeginSend%2A>を別の呼び出しを行って<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.BeginConnect%2A>です。 コネクションレスのプロトコルを使用している場合は、バッファーのサイズが、基になるサービス プロバイダーのパケットの最大サイズを超えていないことを確認する必要もあります。 場合は、データグラムが送信されず<xref:System.Net.Sockets.Socket.BeginSend%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。  
  
 指定した場合、<xref:System.Net.Sockets.SocketFlags.DontRoute>としてフラグを設定、`socketflags`パラメーターに、データを送信すると、ルーティングされません。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I/O が取り消されました。 操作が完了する前に、スレッドが終了した場合、保留中の非同期操作が失敗することができます。  
  
> [!NOTE]
>  `state`ユーザー定義のクラスのインスタンス化します。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されることは示しません。 転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されている場合を除きがブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッドです。 特定のコンテキストの初回使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。  
  
   
  
## Examples  
 次のコード例では、リモート ホストへのデータを非同期的に送信を開始します。  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 「解説」を参照してください。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> が 0 未満です。  
  
 または  
  
 <paramref name="offset" />長さよりも小さい<paramref name="buffer" />です。  
  
 または  
  
 <paramref name="size" /> が 0 未満です。  
  
 または  
  
 <paramref name="size" />長さより大きい<paramref name="buffer" />負の値、<paramref name="offset" />パラメーター。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">型の配列<see cref="T:System.Byte" />送信するデータを格納しています。</param>
        <param name="offset">内の 0 から始まる位置、<c>バッファー</c>データの送信を開始する位置を示すパラメーターです。</param>
        <param name="size">送信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="errorCode">A<see cref="T:System.Net.Sockets.SocketError" />ソケット エラーを格納するオブジェクト。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求の状態情報を格納するオブジェクト。</param>
        <summary>接続されたデータを非同期的に送信<see cref="T:System.Net.Sockets.Socket" />です。</summary>
        <returns><see cref="T:System.IAsyncResult" />非同期送信を参照します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドで確立されているリモート ホストへの非同期送信操作を開始、 <xref:System.Net.Sockets.Socket.Connect%2A>、 <xref:System.Net.Sockets.Socket.BeginConnect%2A>、 <xref:System.Net.Sockets.Socket.Accept%2A>、または<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドです。 <xref:System.Net.Sockets.Socket.BeginSend%2A>最初に呼び出す必要はない場合、例外がスローされます<xref:System.Net.Sockets.Socket.Accept%2A>、 <xref:System.Net.Sockets.Socket.BeginAccept%2A>、 <xref:System.Net.Sockets.Socket.Connect%2A>、または<xref:System.Net.Sockets.Socket.BeginConnect%2A>です。 呼び出す、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドは、個別の実行スレッド内でデータを送信する機能を提供します。  
  
 実装するコールバック メソッドを作成することができます、<xref:System.AsyncCallback>を委任し、その名前を渡す、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドです。 これを行う、非常に最小値で、`state`パラメーターが、接続されているを含む必要がありますまたは既定の<xref:System.Net.Sockets.Socket>の通信に使用されています。 コールバックは、詳細を必要とする場合は、小さなクラスまたは構造体を作成することができます、<xref:System.Net.Sockets.Socket>およびその他の必要な情報です。 このクラスのインスタンスを渡す、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドによって、`state`パラメーター。  
  
 コールバック メソッドを呼び出す必要がある、<xref:System.Net.Sockets.Socket.EndSend%2A>メソッドです。 アプリケーションを呼び出すと<xref:System.Net.Sockets.Socket.BeginSend%2A>、システムは、指定されたコールバック メソッドを実行する別のスレッドを使用しでブロックされます<xref:System.Net.Sockets.Socket.EndSend%2A>まで、<xref:System.Net.Sockets.Socket>を要求したバイト数を送信または例外をスローします。 場合は、元のスレッドをブロックを呼び出した後、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドを使用して、<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>メソッドです。 元のスレッドに実行を継続する場合は、コールバック メソッドにはセット メソッドを呼び出します。 コールバック メソッドの記述の詳細については、次を参照してください。[コールバック メソッドとしてのデリゲートをマーシャ リング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)です。  
  
 接続指向プロトコルでは、意図したものが<xref:System.Net.Sockets.Socket.BeginSend%2A>最初を呼び出すことのコネクションレスのプロトコルでも、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.BeginConnect%2A>既定のリモート ホストを構築する方法です。 使用する必要があります複数の異なるホストにデータを送信する、コネクションレスのプロトコルとプランを使用している場合<xref:System.Net.Sockets.Socket.BeginSendTo%2A>です。 使用することが<xref:System.Net.Sockets.Socket.BeginSendTo%2A>で既定のリモート ホストを確立した後でも<xref:System.Net.Sockets.Socket.Connect%2A>です。 呼び出しの前に既定のリモート ホストを変更することもできます。<xref:System.Net.Sockets.Socket.BeginSend%2A>を別の呼び出しを行って<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.BeginConnect%2A>です。 コネクションレスのプロトコルを使用している場合は、バッファーのサイズが、基になるサービス プロバイダーのパケットの最大サイズを超えていないことを確認する必要もあります。 場合は、データグラムが送信されず<xref:System.Net.Sockets.Socket.BeginSend%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。  
  
 指定した場合、<xref:System.Net.Sockets.SocketFlags.DontRoute>としてフラグを設定、`socketflags`パラメーターに、データを送信すると、ルーティングされません。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I/O が取り消されました。 操作が完了する前に、スレッドが終了した場合、保留中の非同期操作が失敗することができます。  
  
> [!NOTE]
>  `state`ユーザー定義のクラスのインスタンス化します。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されることは示しません。 転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されている場合を除きがブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッドです。 特定のコンテキストの初回使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 「解説」を参照してください。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> が 0 未満です。  
  
 または  
  
 <paramref name="offset" />長さよりも小さい<paramref name="buffer" />です。  
  
 または  
  
 <paramref name="size" /> が 0 未満です。  
  
 または  
  
 <paramref name="size" />長さより大きい<paramref name="buffer" />負の値、<paramref name="offset" />パラメーター。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="fileName">送信するファイルの名前とパスを表す文字列。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求の状態情報を格納するオブジェクト。</param>
        <summary>ファイル送信<paramref name="fileName" />に接続された<see cref="T:System.Net.Sockets.Socket" />オブジェクトを使用して、<see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" />フラグ。</summary>
        <returns><see cref="T:System.IAsyncResult" />非同期送信を表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードは、そのファイルを送信`fileName`接続されたソケットにします。 場合`fileName`されますが、ローカルのディレクトリでファイルの名前だけで識別可能性があります。 それ以外の場合、完全なパスとファイルの名前を指定する必要があります。 ワイルドカード ("..\\\myfile.txt") と UNC 共有名 ("\\\\\\\shared ディレクトリ\\\myfile.txt") はサポートされています。 ファイルが見つからない場合、例外<xref:System.IO.FileNotFoundException>がスローされます。  
  
 このメソッドを使用して、 `TransmitFile` Windows Sockets 2 API である関数。 詳細については、`TransmitFile`関数およびそのフラグは、MSDN ライブラリの Windows Sockets ドキュメントを参照してください。  
  
 <xref:System.Net.Sockets.Socket.BeginSendFile%2A>メソッドで確立されているリモート ホストへの非同期送信操作を開始、 <xref:System.Net.Sockets.Socket.Connect%2A>、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、 <xref:System.Net.Sockets.Socket.Accept%2A>、または<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドです。 <xref:System.Net.Sockets.Socket.BeginSendFile%2A>最初に呼び出す必要はありませんは例外をスロー <xref:System.Net.Sockets.Socket.Accept%2A>、 <xref:System.Net.Sockets.Socket.BeginAccept%2A>、 <xref:System.Net.Sockets.Socket.Connect%2A>、または<xref:System.Net.Sockets.Socket.BeginConnect%2A>です。 呼び出す、<xref:System.Net.Sockets.Socket.BeginSendFile%2A>メソッドでは、個別の実行スレッド内のファイルを送信することができます。  
  
 操作を完了するには、によって呼び出されるコールバック メソッドを作成することができます、<xref:System.AsyncCallback>パラメーターを委任します。 これを行う、非常に最小値で、`state`パラメーターを含める必要があります、<xref:System.Net.Sockets.Socket>の通信に使用されているオブジェクトします。 コールバックは、詳細を必要とする場合は、クラスまたは構造体を作成することができます、<xref:System.Net.Sockets.Socket>およびその他の必要な情報です。 このカスタム オブジェクトのインスタンスを渡す、<xref:System.Net.Sockets.Socket.BeginSendFile%2A>メソッドによって、`state`パラメーター。  
  
 コールバック メソッドを呼び出す必要があります、<xref:System.Net.Sockets.Socket.EndSendFile%2A>メソッドです。 アプリケーションを呼び出すと<xref:System.Net.Sockets.Socket.BeginSendFile%2A>、システムを別のスレッドを使用して、指定されたコールバック メソッドを実行してでブロック<xref:System.Net.Sockets.Socket.EndSendFile%2A>まで、<xref:System.Net.Sockets.Socket>ファイル全体を送信または例外をスローします。 コールバック メソッドの記述の詳細については、次を参照してください。[コールバック メソッドとしてのデリゲートをマーシャ リング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)です。  
  
 接続指向プロトコルでは、意図したものが<xref:System.Net.Sockets.Socket.BeginSendFile%2A>最初を呼び出すことのコネクションレスのプロトコルでも、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.BeginConnect%2A>既定のリモート ホストを構築する方法です。 コネクションレスのプロトコルを使用してファイルのサイズが、基になるサービス プロバイダーのパケットの最大サイズを超えていないことを確認する必要があります。 場合は、データグラムが送信されず<xref:System.Net.Sockets.Socket.BeginSendFile%2A>スロー、<xref:System.Net.Sockets.SocketException>例外。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>例外を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッドです。 特定のコンテキストの初回使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。  
  
   
  
## Examples  
 次のコード例では、作成し、非同期通信のソケットを接続します。 最初に、ファイル"text.txt"は、リモート ホストに非同期的に送信されます。 コールバック デリゲート呼び出し<xref:System.Net.Sockets.Socket.EndSendFile%2A>転送を完了します。  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />オブジェクトが閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">ソケットがリモート ホストに接続されていません。</exception>
        <exception cref="T:System.IO.FileNotFoundException">ファイル <paramref name="fileName" /> が見つかりませんでした。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 「解説」を参照してください。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="preBuffer" Type="System.Byte[]" />
        <Parameter Name="postBuffer" Type="System.Byte[]" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="fileName">送信されるファイルの名前とパスを表す文字列。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <param name="preBuffer">A<see cref="T:System.Byte" />ファイルが送信される前に送信するデータを含む配列。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <param name="postBuffer">A<see cref="T:System.Byte" />ファイルが送信された後に送信するデータを格納する配列。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <param name="flags">ビットごとの組み合わせ<see cref="T:System.Net.Sockets.TransmitFileOptions" />値。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" />この操作が完了したときに呼び出されるデリゲート。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <param name="state">この要求の状態情報を含むユーザー定義のオブジェクト。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <summary>接続された、ファイルとデータのバッファーを非同期に送信<see cref="T:System.Net.Sockets.Socket" />オブジェクト。</summary>
        <returns><see cref="T:System.IAsyncResult" />非同期操作を表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードには、送信するファイルとビットごとの組み合わせの名が必要です。<xref:System.Net.Sockets.TransmitFileOptions>値。 `preBuffer`パラメーターには、ファイルの前にすべてのデータが含まれています。 `postBuffer`ファイルを使用するデータが含まれています。 場合`fileName`されますが、ローカルのディレクトリでファイルの名前だけで識別可能性があります。 それ以外の場合、完全なパスとファイルの名前を指定する必要があります。 ワイルドカード ("..\\\myfile.txt") と UNC 共有名 ("\\\\\\\shared ディレクトリ\\\myfile.txt") はサポートされています。 ファイルが見つからない場合、例外<xref:System.IO.FileNotFoundException>がスローされます。  
  
 `flags`パラメーターは、ファイルの転送に関する追加情報がウィンドウのソケット サービス プロバイダーを提供します。 このパラメーターを使用する方法の詳細については、次を参照してください。<xref:System.Net.Sockets.TransmitFileOptions>です。  
  
 このメソッドを使用して、 `TransmitFile` Windows Sockets 2 API である関数。 詳細については、`TransmitFile`関数およびそのフラグは、MSDN ライブラリの Windows Sockets ドキュメントを参照してください。  
  
 <xref:System.Net.Sockets.Socket.BeginSendFile%2A>メソッドで確立されているリモート ホストへの非同期送信操作を開始、 <xref:System.Net.Sockets.Socket.Connect%2A>、 <xref:System.Net.Sockets.Socket.BeginConnect%2A>、 <xref:System.Net.Sockets.Socket.Accept%2A>、または<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドです。 <xref:System.Net.Sockets.Socket.BeginSendFile%2A>最初に呼び出す必要はありませんは例外をスロー <xref:System.Net.Sockets.Socket.Accept%2A>、 <xref:System.Net.Sockets.Socket.BeginAccept%2A>、 <xref:System.Net.Sockets.Socket.Connect%2A>、または<xref:System.Net.Sockets.Socket.BeginConnect%2A>です。 呼び出す、<xref:System.Net.Sockets.Socket.BeginSendFile%2A>メソッドは、個別の実行スレッド内のファイルを送信する機能を提供します。  
  
 操作を完了するには、によって呼び出されるコールバック メソッドを作成することができます、<xref:System.AsyncCallback>パラメーターを委任します。 これを行う、非常に最小値で、`state`パラメーターを含める必要があります、<xref:System.Net.Sockets.Socket>の通信に使用されているオブジェクトします。 コールバックは、詳細を必要とする場合は、クラスまたは構造体を作成することができます、<xref:System.Net.Sockets.Socket>およびその他の必要な情報です。 このカスタム オブジェクトのインスタンスを渡す、<xref:System.Net.Sockets.Socket.BeginSendFile%2A>メソッドによって、`state`パラメーター。  
  
 コールバック メソッドを呼び出す必要があります、<xref:System.Net.Sockets.Socket.EndSendFile%2A>メソッドです。 アプリケーションを呼び出すと<xref:System.Net.Sockets.Socket.BeginSendFile%2A>、システムを別のスレッドを使用して、指定されたコールバック メソッドを実行してでブロック<xref:System.Net.Sockets.Socket.EndSendFile%2A>まで、<xref:System.Net.Sockets.Socket>ファイル全体を送信または例外をスローします。 コールバック メソッドの記述の詳細については、次を参照してください。[コールバック メソッドとしてのデリゲートをマーシャ リング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)です。  
  
 接続指向プロトコルでは、意図したものが<xref:System.Net.Sockets.Socket.BeginSendFile%2A>最初を呼び出すことのコネクションレスのプロトコルでも、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.BeginConnect%2A>既定のリモート ホストを構築する方法です。 コネクションレスのプロトコルを使用している場合は、ファイルのサイズが、基になるサービス プロバイダーのパケットの最大サイズを超えていないことを確認する必要もあります。 場合は、データグラムが送信されず<xref:System.Net.Sockets.Socket.BeginSendFile%2A>スロー、<xref:System.Net.Sockets.SocketException>例外。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>例外を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッドです。 特定のコンテキストの初回使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。  
  
   
  
## Examples  
 次のコード例を作成し、非同期通信のソケットを接続し、リモート ホストにファイルの"text.txt"を非同期的に送信を開始します。 この例では、`preBuffer`と`postBuffer`データのファイルとその既定値を送信するために作成が<xref:System.Net.Sockets.TransmitFileOptions>値を使用します。 コールバック デリゲート呼び出し<xref:System.Net.Sockets.Socket.EndSendFile%2A>転送を完了します。  
  
 [!code-cpp[NCLSocketEnhancements#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#10)]
 [!code-csharp[NCLSocketEnhancements#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />オブジェクトが閉じられました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 「解説」を参照してください。</exception>
        <exception cref="T:System.NotSupportedException">オペレーティング システムが Windows NT 以降です。  
  
 \- または  
  
 ソケットがリモート ホストに接続されていません。</exception>
        <exception cref="T:System.IO.FileNotFoundException">ファイル <paramref name="fileName" /> が見つかりませんでした。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendTo">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, System.Net.EndPoint remote_end, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint remote_end, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">型の配列<see cref="T:System.Byte" />送信するデータを格納しています。</param>
        <param name="offset">内の 0 から始まる位置<c>バッファー</c>データの送信を開始する位置を示すです。</param>
        <param name="size">送信するバイト数。</param>
        <param name="socket_flags">To be added.</param>
        <param name="remote_end">To be added.</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求の状態情報を格納するオブジェクト。</param>
        <summary>特定のリモート ホストにデータを非同期的に送信します。</summary>
        <returns><see cref="T:System.IAsyncResult" />非同期送信を参照します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>メソッドで指定されたリモート ホストへの非同期送信操作を開始、`remoteEP`パラメーター。 呼び出す、<xref:System.Net.Sockets.Socket.BeginSendTo%2A>メソッドは、個別の実行スレッド内でデータを送信する機能を提供します。 コネクションレス プロトコルは、意図したものが<xref:System.Net.Sockets.Socket.BeginSendTo%2A>コネクションレス型との接続指向プロトコルの両方で動作します。  
  
 実装するコールバック メソッドを作成することができます、<xref:System.AsyncCallback>を委任し、その名前を渡す、<xref:System.Net.Sockets.Socket.BeginSendTo%2A>メソッドです。 これを行う、非常に最小値で、`state`パラメーターが、接続されているを含む必要がありますまたは既定の<xref:System.Net.Sockets.Socket>の通信に使用されています。 コールバックは、詳細を必要とする場合は、保持するために小さなクラスを作成することができます、 <xref:System.Net.Sockets.Socket>、およびその他の必要な情報です。 このクラスのインスタンスを渡す、<xref:System.Net.Sockets.Socket.BeginSendTo%2A>メソッドによって、`state`パラメーター。  
  
 コールバック メソッドを呼び出す必要がある、<xref:System.Net.Sockets.Socket.EndSendTo%2A>メソッドです。 アプリケーションを呼び出すと<xref:System.Net.Sockets.Socket.BeginSendTo%2A>、システムは、指定されたコールバック メソッドを実行する別のスレッドを使用しでブロックされます<xref:System.Net.Sockets.Socket.EndSendTo%2A>まで、<xref:System.Net.Sockets.Socket>を要求したバイト数を送信または例外をスローします。 場合は、元のスレッドをブロックを呼び出した後、<xref:System.Net.Sockets.Socket.BeginSendTo%2A>メソッドを使用して、<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>メソッドです。 元のスレッドに実行を継続する場合は、コールバック メソッドにはセット メソッドを呼び出します。 コールバック メソッドの記述に関する追加情報を参照してください。[コールバック メソッドとしてのデリゲートをマーシャ リング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)です。  
  
 最初に呼び出す必要がある接続指向のプロトコルを使用している場合、 <xref:System.Net.Sockets.Socket.Connect%2A>、 <xref:System.Net.Sockets.Socket.BeginConnect%2A>、 <xref:System.Net.Sockets.Socket.Accept%2A>、または<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッド、または<xref:System.Net.Sockets.Socket.BeginSendTo%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>無視されます、`remoteEP`パラメーターと送信のデータを<xref:System.Net.EndPoint>で確立されている、 <xref:System.Net.Sockets.Socket.Connect%2A>、 <xref:System.Net.Sockets.Socket.BeginConnect%2A>、 <xref:System.Net.Sockets.Socket.Accept%2A>、または<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドです。  
  
 コネクションレスのプロトコルを使用している場合は既定のリモート ホストとの確立する必要はありません、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドを呼び出す前に<xref:System.Net.Sockets.Socket.SendTo%2A>です。 この呼び出しをする場合にだけ、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドです。 呼び出す場合、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドを呼び出す前に<xref:System.Net.Sockets.Socket.SendTo%2A>、`remoteEP`パラメーターは、操作のみを送信するため、指定された既定のリモート ホストに上書きされます。 必要はありませんを呼び出して、<xref:System.Net.Sockets.Socket.Bind%2A>メソッドです。 この場合、基になるサービス プロバイダーは、最も適切なローカル ネットワーク アドレスとポート番号を割り当てられます。 基になるサービス プロバイダーは、空いているポートを選択する場合は、ゼロのポート番号を使用します。 使用することができます、割り当てられているローカル ネットワーク アドレスとポート番号を識別する必要がある場合、<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>後プロパティ、<xref:System.Net.Sockets.Socket.EndSendTo%2A>メソッドが正常に完了するとします。  
  
 ブロードキャスト アドレスにデータを送信する場合は、最初に呼び出す必要があります、<xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッドと set ソケット オプションを<xref:System.Net.Sockets.SocketOptionName?displayProperty=nameWithType>です。 のバッファーのサイズが、基になるサービス プロバイダーのパケットの最大サイズを超えていないことを確認必要もあります。 場合は、データグラムが送信されず<xref:System.Net.Sockets.Socket.EndSendTo%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。  
  
 指定した場合、<xref:System.Net.Sockets.SocketFlags.DontRoute>としてフラグを設定、`socketflags`パラメーターに、データを送信すると、ルーティングされません。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッドです。 特定のコンテキストの初回使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。  
  
   
  
## Examples  
 次のコード例は、指定したリモート ホストにデータを非同期的に送信します。  
  
 [!code-cpp[Socket_Async_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Async_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Async_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="remoteEP" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> が 0 未満です。  
  
 または  
  
 <paramref name="offset" />長さより大きい<paramref name="buffer" />です。  
  
 または  
  
 <paramref name="size" /> が 0 未満です。  
  
 または  
  
 <paramref name="size" />長さより大きい<paramref name="buffer" />負の値、<paramref name="offset" />パラメーター。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し履歴の上位にある呼び出し元には、要求された操作に対するアクセス許可がありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public void Bind (System.Net.EndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Bind(class System.Net.EndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP">ローカル<see cref="T:System.Net.EndPoint" />に関連付ける、<see cref="T:System.Net.Sockets.Socket" />です。</param>
        <summary>関連付けます、<see cref="T:System.Net.Sockets.Socket" />ローカル エンドポイントを使用します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Net.Sockets.Socket.Bind%2A>メソッドを特定のローカル エンドポイントを使用する必要がある場合。 呼び出す必要があります<xref:System.Net.Sockets.Socket.Bind%2A>を呼び出す前に、<xref:System.Net.Sockets.Socket.Listen%2A>メソッドです。 呼び出す必要はありません<xref:System.Net.Sockets.Socket.Bind%2A>使用する前に、<xref:System.Net.Sockets.Socket.Connect%2A>メソッド、ローカルの特定のエンドポイントを使用する必要があります。 使用することができます、<xref:System.Net.Sockets.Socket.Bind%2A>コネクションレス型との接続指向プロトコルの両方のメソッドです。  
  
 呼び出す前に<xref:System.Net.Sockets.Socket.Bind%2A>、ローカルを作成する必要がありますまず<xref:System.Net.IPEndPoint>データをやり取りするからです。 ローカル アドレスの割り当てを限定しない場合は、作成、<xref:System.Net.IPEndPoint>を使用して<xref:System.Net.IPAddress.Any?displayProperty=nameWithType>アドレス パラメーターと、基になるサービス プロバイダーは、最も適切なネットワーク アドレスを割り当てます。 これにより、複数のネットワーク インターフェイスがある場合に、アプリケーションを簡略化のに役立ちます。 使用されているローカル ポートを限定しない場合は、作成、<xref:System.Net.IPEndPoint>ポート番号として 0 を使用します。 この場合、サービス プロバイダーは 1024 ~ 5000 で、使用可能なポート番号を割り当てます。  
  
 上記の方法を使用する場合は、呼び出すことによってどのようなローカル ネットワーク アドレスとポート番号が割り当てられてを検出することができます、<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>です。 接続指向のプロトコルを使用している場合<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>への呼び出しを行った後まで、ローカルで割り当てられているネットワーク アドレスは返されません、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.EndConnect%2A>メソッドです。 コネクションレスのプロトコルを使用している場合はありませんこの情報にアクセスする送信を完了したかが表示されるまでです。  
  
 UDP ソケットがインターフェイスについては、受信したパケットを受信する場合は、<xref:System.Net.Sockets.Socket.SetSocketOption%2A>と共にソケット オプションに設定して、メソッドを明示的に呼び出されなければなりません<xref:System.Net.Sockets.SocketOptionName.PacketInformation>呼び出し直後後、<xref:System.Net.Sockets.Socket.Bind%2A>メソッドです。  
  
> [!NOTE]
>  マルチキャスト データグラムを受信する場合は、呼び出す必要があります、<xref:System.Net.Sockets.Socket.Bind%2A>マルチキャストのポート番号を持つメソッドです。  
  
> [!NOTE]
>  呼び出す必要があります、<xref:System.Net.Sockets.Socket.Bind%2A>メソッド コネクションレス データグラムを使用して受信する場合、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドです。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を呼び出すときに、<xref:System.Net.Sockets.Socket.Bind%2A>メソッドを使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例のバインド、<xref:System.Net.Sockets.Socket>指定したローカル エンドポイントを使用します。  
  
 [!code-cpp[Classic Socket.Bind Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Bind Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Bind Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Bind Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Bind Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Bind Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="localEP" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し履歴の上位にある呼び出し元には、要求された操作に対するアクセス許可がありません。</exception>
        <permission cref="T:System.Net.SocketPermission">によって定義されたホストからの接続を受け入れるため<paramref name="localEP" />です。 関連する列挙。<see cref="F:System.Net.NetworkAccess.Accept" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Blocking">
      <MemberSignature Language="C#" Value="public bool Blocking { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Blocking" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Blocking" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定を示す値かどうか、<see cref="T:System.Net.Sockets.Socket" />ブロッキング モードにします。</summary>
        <value>
          <see langword="true" />場合、<see cref="T:System.Net.Sockets.Socket" />がブロックされます。 それ以外の場合、<see langword="false" />です。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Blocking%2A>プロパティを示すかどうか、<xref:System.Net.Sockets.Socket>ブロッキング モードでは、します。  
  
 ブロッキング モードでは、すると、メソッドがすぐに完了しない場合、アプリケーションは、要求された操作が完了するまで実行をブロックします。 要求された操作の完了がいない場合でも続行、変更を実行する場合、<xref:System.Net.Sockets.Socket.Blocking%2A>プロパティを`false`です。 <xref:System.Net.Sockets.Socket.Blocking%2A>プロパティが非同期メソッドに対して影響を与えません。 使用している場合を送信し、データの非同期受信の実行をブロックする、<xref:System.Threading.ManualResetEvent>クラスです。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="CancelConnectAsync">
      <MemberSignature Language="C#" Value="public static void CancelConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />のいずれかを呼び出すことにより、リモート ホストへの接続を要求に使用されるオブジェクト、<see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />メソッドです。</param>
        <summary>リモート ホスト接続への非同期要求を取り消します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.CancelConnectAsync%2A>メソッドは、リモート ホスト接続への非同期要求をキャンセルします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="e" />パラメーターを null にすることはできません、 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> null にすることはできません。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し履歴の上位にある呼び出し元には、要求された操作に対するアクセス許可がありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>閉じる、<see cref="T:System.Net.Sockets.Socket" />接続と関連付けられているリリースのすべてのリソース。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Close%2A>メソッドは、リモート ホスト接続を閉じると、リリースのすべてのマネージおよびアンマネージ リソースに関連付けられている、<xref:System.Net.Sockets.Socket>です。 決算時に、<xref:System.Net.Sockets.Socket.Connected%2A>プロパティに設定されている`false`です。  
  
 接続指向プロトコルは勧めを呼び出すこと<xref:System.Net.Sockets.Socket.Shutdown%2A>呼び出す前に、<xref:System.Net.Sockets.Socket.Close%2A>メソッドです。 これにより、すべてのデータが送信されが閉じる前に、接続されたソケットで受信したことです。  
  
 呼び出す必要がある場合<xref:System.Net.Sockets.Socket.Close%2A>最初呼び出さず<xref:System.Net.Sockets.Socket.Shutdown%2A>、データ キューを設定して送信される出力方向の送信にあることを確認することができます、 <xref:System.Net.Sockets.SocketOptionName.DontLinger> <xref:System.Net.Sockets.Socket>オプションを`false`と 0 以外のタイムアウト間隔を指定します。 <xref:System.Net.Sockets.Socket.Close%2A>このデータが送信されるまで、または指定したタイムアウトの期限が切れるまで、ブロックされます。 設定した場合<xref:System.Net.Sockets.SocketOptionName.DontLinger>に`false`0 のタイムアウト間隔を指定して<xref:System.Net.Sockets.Socket.Close%2A>の接続を解放し、送信キューに置かれたデータを自動的に破棄します。  
  
> [!NOTE]
>  設定する、<xref:System.Net.Sockets.SocketOptionName.DontLinger>ソケット オプションに`false`、作成、 <xref:System.Net.Sockets.LingerOption>、enabled プロパティを設定`true`、設定と、<xref:System.Net.Sockets.LingerOption.LingerTime%2A>プロパティ、目的のタイムアウト期間をします。 これを使用して<xref:System.Net.Sockets.LingerOption>と共に、<xref:System.Net.Sockets.SocketOptionName.DontLinger>ソケット オプションを呼び出して、<xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッドです。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例が閉じ、<xref:System.Net.Sockets.Socket>です。  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close (int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close(int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="timeout">最大待機<c>タイムアウト</c>ソケットを閉じる、残りのデータを送信する秒数。</param>
        <summary><see cref="T:System.Net.Sockets.Socket" /> 接続を閉じ、すべての関連付けられているリソースを指定したタイムアウトで解放して、キューに置かれたデータの送信を許可します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Close%2A>メソッドは、リモート ホスト接続を閉じると、リリースのすべてのマネージおよびアンマネージ リソースに関連付けられている、<xref:System.Net.Sockets.Socket>です。 決算時に、<xref:System.Net.Sockets.Socket.Connected%2A>プロパティに設定されている`false`です。  
  
 接続指向プロトコルは勧めを呼び出すこと<xref:System.Net.Sockets.Socket.Shutdown%2A>呼び出す前に<xref:System.Net.Sockets.Socket.Close%2A>です。 これにより、すべてのデータが送信されが閉じる前に、接続されたソケットで受信したことです。  
  
 呼び出す必要がある場合<xref:System.Net.Sockets.Socket.Close%2A>最初呼び出さず<xref:System.Net.Sockets.Socket.Shutdown%2A>、データ キューを設定して送信される出力方向の送信にあることを確認することができます、<xref:System.Net.Sockets.SocketOptionName.DontLinger>オプションを`false`と 0 以外のタイムアウト間隔を指定します。 <xref:System.Net.Sockets.Socket.Close%2A>このデータが送信されるまで、または指定したタイムアウトの期限が切れるまで、ブロックされます。 設定した場合<xref:System.Net.Sockets.SocketOptionName.DontLinger>に`false`0 のタイムアウト間隔を指定して<xref:System.Net.Sockets.Socket.Close%2A>の接続を解放し、送信キューに置かれたデータを自動的に破棄します。  
  
> [!NOTE]
>  設定する、<xref:System.Net.Sockets.SocketOptionName.DontLinger>ソケット オプションに`false`、作成、<xref:System.Net.Sockets.LingerOption>に有効なプロパティを設定`true`、設定と、<xref:System.Net.Sockets.LingerOption.LingerTime%2A>プロパティを目的のタイムアウト期間。 これを使用して<xref:System.Net.Sockets.LingerOption>と共に、<xref:System.Net.Sockets.SocketOptionName.DontLinger>ソケット オプションを呼び出して、<xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッドです。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例を終了する方法を示しています、<xref:System.Net.Sockets.Socket>です。  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="remoteEP">リモート デバイスを表す <see cref="T:System.Net.EndPoint" />。</param>
        <summary>リモート ホストへの接続を確立します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 TCP などの接続指向プロトコルを使用している場合、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドは同期的に間のネットワーク接続を確立<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>と指定したリモート エンドポイント。 コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.Connect%2A>既定のリモート ホストを確立します。 呼び出した後<xref:System.Net.Sockets.Socket.Connect%2A>のリモート デバイスにデータを送信することができます、<xref:System.Net.Sockets.Socket.Send%2A>メソッド、またはリモート デバイスからデータを受信、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドです。  
  
 UDP などのコネクションレスのプロトコルを使用している場合を呼び出す必要はありません<xref:System.Net.Sockets.Socket.Connect%2A>データを送受信する前にします。 使用することができます<xref:System.Net.Sockets.Socket.SendTo%2A>と<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>リモート ホストを同期的に通信するためにします。 呼び出す場合<xref:System.Net.Sockets.Socket.Connect%2A>、指定した既定以外のアドレスから受信する任意のデータグラムは破棄されます。 既定のリモート ホストが、ブロードキャスト アドレスを設定する場合は、最初に呼び出す必要があります、<xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッドと set ソケット オプションを<xref:System.Net.Sockets.SocketOptionName?displayProperty=nameWithType>、または<xref:System.Net.Sockets.Socket.Connect%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
 <xref:System.Net.Sockets.Socket.Connect%2A>メソッド ブロックを明示的に設定する場合を除き、<xref:System.Net.Sockets.Socket.Blocking%2A>プロパティを`false`呼び出しの前に<xref:System.Net.Sockets.Socket.Connect%2A>です。 TCP とする無効化をブロックするように、接続指向のプロトコルを使用している場合<xref:System.Net.Sockets.Socket.Connect%2A>がスローされます、<xref:System.Net.Sockets.SocketException>時接続を確立する必要があるためです。 既定のリモート ホストを確立するだけであるために、コネクションレスのプロトコルは例外をスローしません。 使用することができます<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得します。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。 接続指向で、リモート ホスト接続が開始されて、エラーに WSAEWOULDBLOCK が返される場合は<xref:System.Net.Sockets.Socket>、まだ完了していませんが正常にします。 使用して、<xref:System.Net.Sockets.Socket.Poll%2A>タイミングを決定するメソッド、<xref:System.Net.Sockets.Socket>が終了した接続です。  
  
> [!NOTE]
>  接続指向のプロトコルを使用しているしを呼び出さなかったかどうか<xref:System.Net.Sockets.Socket.Bind%2A>呼び出す前に<xref:System.Net.Sockets.Socket.Connect%2A>、基になるサービス プロバイダーは、ローカル ネットワーク アドレスとポート番号を割り当てます。 コネクションレスのプロトコルを使用している場合、サービス プロバイダーを割り当てませんローカル ネットワーク アドレスとポート番号の送信を完了するか、操作が表示されるまでです。 既定のリモート ホストを変更する場合は、呼び出す<xref:System.Net.Sockets.Socket.Connect%2A>目的のエンドポイントを指定しています。  
  
> [!NOTE]
>  ソケットが以前切断された場合は、接続を復元する、このメソッドを使用できません。 非同期のいずれかを使用して<xref:System.Net.Sockets.Socket.BeginConnect%2A>を再接続する方法です。 これは、基になるプロバイダーの制限です。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例では、リモート エンドポイントに接続し、接続を検証します。  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="remoteEP" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し履歴の上位にある呼び出し元には、要求された操作に対するアクセス許可がありません。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" />を呼び出して待機状態が配置されている<see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />です。</exception>
        <permission cref="T:System.Net.SocketPermission">リモート ホストに接続します。 関連する列挙。<see cref="F:System.Net.NetworkAccess.Connect" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress address, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address">リモート ホストの IP アドレス。</param>
        <param name="port">リモート ホストのポート番号。</param>
        <summary>リモート ホストへの接続を確立します。 ホストは、IP アドレスとポート番号で指定されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 TCP などの接続指向プロトコルを使用している場合、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドは同期的に間のネットワーク接続を確立<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>と指定したリモート エンドポイント。 コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.Connect%2A>既定のリモート ホストを確立します。 呼び出した後<xref:System.Net.Sockets.Socket.Connect%2A>のリモート デバイスにデータを送信することができます、<xref:System.Net.Sockets.Socket.Send%2A>メソッド、またはリモート デバイスからデータを受信、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドです。  
  
 UDP などのコネクションレスのプロトコルを使用している場合を呼び出す必要はありません<xref:System.Net.Sockets.Socket.Connect%2A>データを送受信する前にします。 使用することができます<xref:System.Net.Sockets.Socket.SendTo%2A>と<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>リモート ホストを同期的に通信するためにします。 呼び出す場合<xref:System.Net.Sockets.Socket.Connect%2A>指定された既定以外のアドレスから受信する任意のデータグラムは破棄されます。 既定のリモート ホストが、ブロードキャスト アドレスを設定する場合は、最初に呼び出す必要があります、<xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッドと set ソケット オプションを<xref:System.Net.Sockets.SocketOptionName?displayProperty=nameWithType>、または<xref:System.Net.Sockets.Socket.Connect%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
 <xref:System.Net.Sockets.Socket.Connect%2A>具体的に設定していない場合、メソッドはブロック、<xref:System.Net.Sockets.Socket.Blocking%2A>プロパティを`false`呼び出しの前に<xref:System.Net.Sockets.Socket.Connect%2A>です。 TCP とする無効化をブロックするように、接続指向のプロトコルを使用している場合<xref:System.Net.Sockets.Socket.Connect%2A>がスローされます、<xref:System.Net.Sockets.SocketException>時接続を確立する必要があるためです。 既定のリモート ホストを確立するだけであるために、コネクションレスのプロトコルは例外をスローしません。 使用することができます<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得します。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。 接続指向で、リモート ホスト接続が開始されて、エラーに WSAEWOULDBLOCK が返される場合は<xref:System.Net.Sockets.Socket>、まだ完了していませんが正常にします。 使用して、<xref:System.Net.Sockets.Socket.Poll%2A>タイミングを決定するメソッド、<xref:System.Net.Sockets.Socket>が終了した接続です。  
  
> [!NOTE]
>  接続指向のプロトコルを使用しているしを呼び出さなかったかどうか<xref:System.Net.Sockets.Socket.Bind%2A>呼び出す前に<xref:System.Net.Sockets.Socket.Connect%2A>、基になるサービス プロバイダーは、ローカル ネットワーク アドレスとポート番号を割り当てます。 コネクションレスのプロトコルを使用している場合、サービス プロバイダーを割り当てませんローカル ネットワーク アドレスとポート番号の送信を完了するか、操作が表示されるまでです。 既定のリモート ホストを変更する場合は、呼び出す<xref:System.Net.Sockets.Socket.Connect%2A>目的のエンドポイントを指定しています。  
  
> [!NOTE]
>  ソケットが以前切断された場合は、接続を復元する、このメソッドを使用できません。 非同期のいずれかを使用して<xref:System.Net.Sockets.Socket.BeginConnect%2A>を再接続する方法です。 これは、基になるプロバイダーの制限です。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例では、リモート エンドポイントに接続し、接続を検証します。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#4)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="address" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">ポート番号が無効です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドが内のソケットに対して有効では、<see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />または<see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />ファミリ。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="address" /> の長さが 0 です。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" />を呼び出して待機状態が配置されている<see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress[] addresses, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress[] addresses, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="addresses">リモート ホストの IP アドレス。</param>
        <param name="port">リモート ホストのポート番号。</param>
        <summary>リモート ホストへの接続を確立します。 ホストは、IP アドレスの配列とポート番号で指定されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドはすぐに呼び出しの後に通常使用<xref:System.Net.Dns.GetHostAddresses%2A>、1 つのホストの複数の IP アドレスを返すことができます。 TCP などの接続指向プロトコルを使用している場合、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドは同期的に間のネットワーク接続を確立<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>と指定したリモート エンドポイント。 コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.Connect%2A>既定のリモート ホストを確立します。 呼び出した後<xref:System.Net.Sockets.Socket.Connect%2A>のリモート デバイスにデータを送信することができます、<xref:System.Net.Sockets.Socket.Send%2A>メソッド、またはリモート デバイスからデータを受信、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドです。  
  
 UDP などのコネクションレスのプロトコルを使用している場合を呼び出す必要はありません<xref:System.Net.Sockets.Socket.Connect%2A>データを送受信する前にします。 使用することができます<xref:System.Net.Sockets.Socket.SendTo%2A>と<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>リモート ホストを同期的に通信するためにします。 呼び出す場合<xref:System.Net.Sockets.Socket.Connect%2A>指定された既定以外のアドレスから受信する任意のデータグラムは破棄されます。 既定のリモート ホストが、ブロードキャスト アドレスを設定する場合は、最初に呼び出す必要があります、<xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッドと set ソケット オプションを<xref:System.Net.Sockets.SocketOptionName?displayProperty=nameWithType>、または<xref:System.Net.Sockets.Socket.Connect%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
 <xref:System.Net.Sockets.Socket.Connect%2A>具体的に設定していない場合、メソッドはブロック、<xref:System.Net.Sockets.Socket.Blocking%2A>プロパティを`false`呼び出しの前に<xref:System.Net.Sockets.Socket.Connect%2A>です。 TCP とする無効化をブロックするように、接続指向のプロトコルを使用している場合<xref:System.Net.Sockets.Socket.Connect%2A>がスローされます、<xref:System.Net.Sockets.SocketException>時接続を確立する必要があるためです。 既定のリモート ホストを確立するだけであるために、コネクションレスのプロトコルは例外をスローしません。 使用することができます<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得します。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。 接続指向で、リモート ホスト接続が開始されて、エラーに WSAEWOULDBLOCK が返される場合は<xref:System.Net.Sockets.Socket>、まだ完了していませんが正常にします。 使用して、<xref:System.Net.Sockets.Socket.Poll%2A>タイミングを決定するメソッド、<xref:System.Net.Sockets.Socket>が終了した接続です。  
  
> [!NOTE]
>  接続指向のプロトコルを使用しているしを呼び出さなかったかどうか<xref:System.Net.Sockets.Socket.Bind%2A>呼び出す前に<xref:System.Net.Sockets.Socket.Connect%2A>、基になるサービス プロバイダーは、ローカル ネットワーク アドレスとポート番号を割り当てます。 コネクションレスのプロトコルを使用している場合、サービス プロバイダーを割り当てませんローカル ネットワーク アドレスとポート番号の送信を完了するか、操作が表示されるまでです。 既定のリモート ホストを変更する場合は、呼び出す<xref:System.Net.Sockets.Socket.Connect%2A>目的のエンドポイントを指定しています。  
  
> [!NOTE]
>  ソケットが以前切断された場合は、接続を復元する、このメソッドを使用できません。 非同期のいずれかを使用して<xref:System.Net.Sockets.Socket.BeginConnect%2A>を再接続する方法です。 これは、基になるプロバイダーの制限です。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例では、リモート エンドポイントに接続し、接続を検証します。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#5)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="addresses" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">ポート番号が無効です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドが内のソケットに対して有効では、<see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />または<see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />ファミリ。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="address" /> の長さが 0 です。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" />を呼び出して待機状態が配置されている<see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (string host, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(string host, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="host">リモート ホストの名前。</param>
        <param name="port">リモート ホストのポート番号。</param>
        <summary>リモート ホストへの接続を確立します。 ホストはホスト名とポート番号で指定されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 TCP などの接続指向プロトコルを使用している場合、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドは同期的に間のネットワーク接続を確立<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>と指定したリモート ホストします。 コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.Connect%2A>既定のリモート ホストを確立します。 呼び出した後<xref:System.Net.Sockets.Socket.Connect%2A>のリモート デバイスにデータを送信することができます、<xref:System.Net.Sockets.Socket.Send%2A>メソッド、またはリモート デバイスからデータを受信、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドです。  
  
 UDP などのコネクションレスのプロトコルを使用している場合を呼び出す必要はありません<xref:System.Net.Sockets.Socket.Connect%2A>データを送受信する前にします。 使用することができます<xref:System.Net.Sockets.Socket.SendTo%2A>と<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>リモート ホストを同期的に通信するためにします。 呼び出す場合<xref:System.Net.Sockets.Socket.Connect%2A>指定された既定以外のアドレスから受信する任意のデータグラムは破棄されます。 既定のリモート ホストが、ブロードキャスト アドレスを設定する場合は、最初に呼び出す必要があります、<xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッドと set ソケット オプションを<xref:System.Net.Sockets.SocketOptionName?displayProperty=nameWithType>、または<xref:System.Net.Sockets.Socket.Connect%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
 <xref:System.Net.Sockets.Socket.Connect%2A>具体的に設定していない場合、メソッドはブロック、<xref:System.Net.Sockets.Socket.Blocking%2A>プロパティを`false`呼び出しの前に<xref:System.Net.Sockets.Socket.Connect%2A>です。 TCP とする無効化をブロックするように、接続指向のプロトコルを使用している場合<xref:System.Net.Sockets.Socket.Connect%2A>がスローされます、<xref:System.Net.Sockets.SocketException>時接続を確立する必要があるためです。 既定のリモート ホストを確立するだけであるために、コネクションレスのプロトコルは例外をスローしません。 使用することができます<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得します。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。 接続指向で、リモート ホスト接続が開始されて、エラーに WSAEWOULDBLOCK が返される場合は<xref:System.Net.Sockets.Socket>、まだ完了していませんが正常にします。 使用して、<xref:System.Net.Sockets.Socket.Poll%2A>タイミングを決定するメソッド、<xref:System.Net.Sockets.Socket>が終了した接続です。  
  
 IPv6 が有効になっている場合、<xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29>メソッドは両方とも IPv6 に解決されるホストに接続して IPv4 アドレス、IPv4 アドレスの前に最初に、IPv6 アドレスに接続試行します。 これには、ホストが、IPv6 アドレスでリッスンしていない場合、接続の確立に時間が遅延の影響があります。  
  
> [!NOTE]
>  接続指向のプロトコルを使用しているしを呼び出さなかったかどうか<xref:System.Net.Sockets.Socket.Bind%2A>呼び出す前に<xref:System.Net.Sockets.Socket.Connect%2A>、基になるサービス プロバイダーは、ローカル ネットワーク アドレスとポート番号を割り当てます。 コネクションレスのプロトコルを使用している場合、サービス プロバイダーを割り当てませんローカル ネットワーク アドレスとポート番号の送信を完了するか、操作が表示されるまでです。 既定のリモート ホストを変更する場合は、呼び出す<xref:System.Net.Sockets.Socket.Connect%2A>目的のエンドポイントを指定しています。  
  
> [!NOTE]
>  ソケットが以前切断された場合は、接続を復元する、このメソッドを使用できません。 非同期のいずれかを使用して<xref:System.Net.Sockets.Socket.BeginConnect%2A>を再接続する方法です。 これは、基になるプロバイダーの制限です。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例では、リモート エンドポイントに接続し、接続を検証します。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#6)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="host" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">ポート番号が無効です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドが内のソケットに対して有効では、<see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />または<see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />ファミリ。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" />を呼び出して待機状態が配置されている<see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public bool ConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />この非同期ソケット操作に使用するオブジェクト。</param>
        <summary>リモート ホストに接続するための非同期要求を開始します。</summary>
        <returns>返します<see langword="true" />I/O 操作が保留中の場合。 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />でイベントを<paramref name="e" />パラメーターが操作の完了時に発生します。  
  
 返します<see langword="false" />場合は、I/O 操作が同期的に完了します。 ここで、<see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />でイベントを<paramref name="e" />パラメーターは発生しません。 と<paramref name="e" />操作の結果を取得するメソッドの呼び出しが戻った後にすぐに、パラメーターを調べることがありますとして渡されたオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向のプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッドは、リモート ホストに接続するための非同期要求を開始します。 コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.ConnectAsync%2A>既定のリモート ホストを確立します。  
  
 完了の通知、イベント ハンドラーを実装するコールバック メソッドを作成する必要があります\<SocketAsyncEventArgs > を委任し、アタッチするためのコールバック、<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>イベント。  
  
 呼び出し元を設定する必要があります、<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>プロパティを<xref:System.Net.IPEndPoint>リモート ホストに接続するのです。  
  
 呼び出し元の設定、<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>を呼び出す前に必要なすべてのユーザー状態オブジェクトのプロパティ、<xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッド情報をコールバック メソッドで取得できるようにします。 コールバックは、1 つのオブジェクトより多くの情報を必要とする場合は、メンバーとして他の必要な状態情報を保持するために、小さいクラスを作成できます。  
  
 UDP などのコネクションレスのプロトコルを使用している場合を呼び出す必要はありません<xref:System.Net.Sockets.Socket.ConnectAsync%2A>データを送受信する前にします。 使用することができます<xref:System.Net.Sockets.Socket.SendToAsync%2A>と<xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A>のリモート ホストと通信します。 呼び出す場合<xref:System.Net.Sockets.Socket.ConnectAsync%2A>、指定した既定以外のアドレスから受信する任意のデータグラムは破棄されます。 既定のリモート ホストを変更する場合は、呼び出し、<xref:System.Net.Sockets.Socket.ConnectAsync%2A>目的のエンドポイントを使用してメソッドです。  
  
 ブロードキャスト アドレスに既定のリモート ホストを設定する場合は、最初に呼び出す必要があります<xref:System.Net.Sockets.Socket.SetSocketOption%2A>にブロードキャストを設定および`true`です。 これが行われていない場合、<xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッドがスローされます、<xref:System.Net.Sockets.SocketException>です。  
  
 次のプロパティとイベントを<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>オブジェクトが必要。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 必要に応じて、バッファー提供することが後に、ソケットにアトミックに送信されます、<xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッドが成功します。 ここで、<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>プロパティが送信するデータを格納しているバッファーに設定する必要があります、<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>プロパティをバッファーから送信するデータのバイト数に設定する必要があります。 接続が確立されると、このバッファーのデータが送信されます。  
  
 接続指向のプロトコルを使用しているし、呼び出さないかどうか<xref:System.Net.Sockets.Socket.Bind%2A>呼び出す前に<xref:System.Net.Sockets.Socket.ConnectAsync%2A>、基になるサービス プロバイダーが最も適切なローカル ネットワーク アドレスとポート番号を割り当てます。  
  
 コネクションレスのプロトコルを使用している場合、サービス プロバイダーを割り当てませんローカル ネットワークの IP アドレスとポート番号を呼び出すまで、<xref:System.Net.Sockets.Socket.SendAsync%2A>または<xref:System.Net.Sockets.Socket.ReceiveAsync%2A>メソッドです。  
  
 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッドでのスロー<xref:System.NotSupportedException>場合のアドレス ファミリ、<xref:System.Net.Sockets.Socket>と<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>同じアドレス ファミリではありません。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>このメソッドを呼び出したときに使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">引数が有効ではありません。 複数のバッファーが指定されている場合、この例外が発生した、<see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />プロパティが null でないです。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="e" />パラメーターを null にすることはできません、 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> null にすることはできません。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" />は進行状況を使用してリッスンまたはソケット操作が既に、<see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />で指定されたオブジェクト、<paramref name="e" />パラメーター。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.NotSupportedException">Windows XP 以降はこのメソッドに必要です。 場合にもこの例外が発生したローカル エンドポイントおよび<see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />同じアドレス ファミリではありません。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し履歴の上位にある呼び出し元には、要求された操作に対するアクセス許可がありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public static bool ConnectAsync (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType, System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ConnectAsync(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType, class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="socketType"><see cref="T:System.Net.Sockets.SocketType" /> 値のいずれか。</param>
        <param name="protocolType"><see cref="T:System.Net.Sockets.ProtocolType" /> 値のいずれか。</param>
        <param name="e"><see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />この非同期ソケット操作に使用するオブジェクト。</param>
        <summary>リモート ホストに接続するための非同期要求を開始します。</summary>
        <returns>返します<see langword="true" />I/O 操作が保留中の場合。 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />でイベントを<paramref name="e" />パラメーターが操作の完了時に発生します。  
  
 返します<see langword="false" />場合は、I/O 操作が同期的に完了します。 ここで、<see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />でイベントを<paramref name="e" />パラメーターは発生しません。 と<paramref name="e" />操作の結果を取得するメソッドの呼び出しが戻った後にすぐに、パラメーターを調べることがありますとして渡されたオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向のプロトコルを使用している場合、M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs) メソッドは、リモート ホストに接続するための非同期要求を開始します。 コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.ConnectAsync%2A>で指定された既定のリモート ホストを確立、`socketType`と`protocolType`パラメーター。  
  
 完了の通知、イベント ハンドラーを実装するコールバック メソッドを作成する必要があります\<SocketAsyncEventArgs > を委任し、アタッチするためのコールバック、<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>イベント。  
  
 呼び出し元を設定する必要があります、<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>プロパティを<xref:System.Net.IPEndPoint>リモート ホストに接続するのです。  
  
 呼び出し元の設定、<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>を呼び出す前に必要なすべてのユーザー状態オブジェクトのプロパティ、<xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッド情報をコールバック メソッドで取得できるようにします。 コールバックは、1 つのオブジェクトより多くの情報を必要とする場合は、メンバーとして他の必要な状態情報を保持するために、小さいクラスを作成できます。  
  
 UDP などのコネクションレスのプロトコルを使用している場合を呼び出す必要はありません<xref:System.Net.Sockets.Socket.ConnectAsync%2A>データを送受信する前にします。 使用することができます<xref:System.Net.Sockets.Socket.SendToAsync%2A>と<xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A>のリモート ホストと通信します。 呼び出す場合<xref:System.Net.Sockets.Socket.ConnectAsync%2A>、指定した既定以外のアドレスから受信する任意のデータグラムは破棄されます。 既定のリモート ホストを変更する場合は、呼び出し、<xref:System.Net.Sockets.Socket.ConnectAsync%2A>目的のエンドポイントを使用してメソッドです。  
  
 ブロードキャスト アドレスに既定のリモート ホストを設定する場合は、最初に呼び出す必要があります<xref:System.Net.Sockets.Socket.SetSocketOption%2A>にブロードキャストを設定および`true`です。 これが行われていない場合、<xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッドがスローされます、<xref:System.Net.Sockets.SocketException>です。  
  
 次のプロパティとイベントを<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>オブジェクトが必要。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 必要に応じて、バッファー提供することが後に、ソケットにアトミックに送信されます、<xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッドが成功します。 ここで、<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>プロパティが送信するデータを格納しているバッファーに設定する必要があります、<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>プロパティをバッファーから送信するデータのバイト数に設定する必要があります。 接続が確立されると、このバッファーのデータが送信されます。  
  
 接続指向のプロトコルを使用しているし、呼び出さないかどうか<xref:System.Net.Sockets.Socket.Bind%2A>呼び出す前に<xref:System.Net.Sockets.Socket.ConnectAsync%2A>、基になるサービス プロバイダーが最も適切なローカル ネットワーク アドレスとポート番号を割り当てます。  
  
 コネクションレスのプロトコルを使用している場合、サービス プロバイダーを割り当てませんローカル ネットワークの IP アドレスとポート番号を呼び出すまで、<xref:System.Net.Sockets.Socket.SendAsync%2A>または<xref:System.Net.Sockets.Socket.ReceiveAsync%2A>メソッドです。  
  
 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッドでのスロー<xref:System.NotSupportedException>場合のアドレス ファミリ、<xref:System.Net.Sockets.Socket>と<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>同じアドレス ファミリではありません。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>このメソッドを呼び出したときに使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">引数が有効ではありません。 複数のバッファーが指定されている場合、この例外が発生した、<see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />プロパティが null でないです。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="e" />パラメーターを null にすることはできません、 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> null にすることはできません。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" />は進行状況を使用してリッスンまたはソケット操作が既に、<see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />で指定されたオブジェクト、<paramref name="e" />パラメーター。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.NotSupportedException">Windows XP 以降はこのメソッドに必要です。 場合にもこの例外が発生したローカル エンドポイントおよび<see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />同じアドレス ファミリではありません。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し履歴の上位にある呼び出し元には、要求された操作に対するアクセス許可がありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Connected">
      <MemberSignature Language="C#" Value="public bool Connected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Connected" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Connected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>示す値を取得するかどうか、 <see cref="T:System.Net.Sockets.Socket" /> 、最後の時点でのリモート ホストに接続されている<see cref="Overload:System.Net.Sockets.Socket.Send" />または<see cref="Overload:System.Net.Sockets.Socket.Receive" />操作します。</summary>
        <value>
          <see langword="true" />場合、<see cref="T:System.Net.Sockets.Socket" />が最新の操作の時点でのリモート リソースに接続されている、それ以外の場合、<see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Connected`プロパティ、接続の状態を取得、<xref:System.Net.Sockets.Socket>最後の I/O 操作の時点でします。 返す場合`false`、<xref:System.Net.Sockets.Socket>されたか、接続されていない、または接続されていません。  
  
 値、<xref:System.Net.Sockets.Socket.Connected%2A>プロパティには、最新の操作の時点で接続の状態が反映されます。 接続の現在の状態を確認する必要がある場合は、非ブロッキングを持つ 0 バイトの Send 呼び出しをください。 呼び出しの成功または WAEWOULDBLOCK エラー コード (10035) がスローされる場合、は、ソケットがまだ接続しているです。それ以外の場合、ソケットが接続していません。  
  
 呼び出す場合<xref:System.Net.Sockets.Socket.Connect%2A>ユーザー データグラム プロトコル (UDP) ソケット上、<xref:System.Net.Sockets.Socket.Connected%2A>プロパティは常に返します`true`。 ただし、この操作では、UDP のコネクションレス型固有であるは変更されません。  
  
   
  
## Examples  
 次のコード例は、チェックをリモート エンドポイントに接続する、<xref:System.Net.Sockets.Socket.Connected%2A>プロパティ、接続の現在の状態を確認します。  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public void Disconnect (bool reuseSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Disconnect(bool reuseSocket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">
          <see langword="true" />現在の接続が閉じられた後にこのソケットを再利用できる場合それ以外の場合、<see langword="false" />です。</param>
        <summary>ソケット接続を閉じるし、ソケットの再利用できるようにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向のプロトコルを使用している場合は、ソケットを閉じるにこのメソッドを使用できます。 このメソッドが設定されている接続およびセットには、終了、<xref:System.Net.Sockets.Socket.Connected%2A>プロパティを`false`です。 ただし場合、`reuseSocket`は`true`ソケットを再利用することができます。  
  
 すべてのデータで送信および受信ソケットが閉じられる前にするを呼び出す必要があります<xref:System.Net.Sockets.Socket.Shutdown%2A>呼び出す前に、<xref:System.Net.Sockets.Socket.Disconnect%2A>メソッドです。  
  
 呼び出す必要がある場合<xref:System.Net.Sockets.Socket.Disconnect%2A>最初呼び出さず<xref:System.Net.Sockets.Socket.Shutdown%2A>、設定することができます、 <xref:System.Net.Sockets.SocketOptionName.DontLinger> <xref:System.Net.Sockets.Socket>オプションを`false`データ キューは送信方向の送信にあることを確認する 0 以外のタイムアウト間隔を指定します。 <xref:System.Net.Sockets.Socket.Disconnect%2A>データが送信されるまで、または指定したタイムアウトが経過するまでブロックします。 設定した場合<xref:System.Net.Sockets.SocketOptionName.DontLinger>に`false`0 のタイムアウト間隔を指定して<xref:System.Net.Sockets.Socket.Close%2A>の接続を解放し、送信キューに置かれたデータを自動的に破棄します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例では、同期通信のソケットを作成し、リモート ホストにいくつかのデータを送信します。 呼び出して<xref:System.Net.Sockets.Socket.Shutdown%2A>を送信を停止し、受信アクティビティ、および<xref:System.Net.Sockets.Socket.Disconnect%2A>、ソケット接続を閉じます。  
  
 [!code-cpp[Nclsocketenhancements#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#12)]
 [!code-csharp[Nclsocketenhancements#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">このメソッドは、Windows 2000 またはそれ以前、または例外がスローされます。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />オブジェクトが閉じられました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="DisconnectAsync">
      <MemberSignature Language="C#" Value="public bool DisconnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DisconnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />この非同期ソケット操作に使用するオブジェクト。</param>
        <summary>リモート エンドポイントから切断への非同期要求を開始します。</summary>
        <returns>返します<see langword="true" />I/O 操作が保留中の場合。 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />でイベントを<paramref name="e" />パラメーターが操作の完了時に発生します。  
  
 返します<see langword="false" />場合は、I/O 操作が同期的に完了します。 ここで、<see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />でイベントを<paramref name="e" />パラメーターは発生しません。 と<paramref name="e" />操作の結果を取得するメソッドの呼び出しが戻った後にすぐに、パラメーターを調べることがありますとして渡されたオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向のプロトコルを使用する場合の呼び出し、<xref:System.Net.Sockets.Socket.DisconnectAsync%2A>メソッドがリモート エンドポイントからの接続が切断を要求します。 設定した場合<xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType>に`true`で、`e`パラメーター、ソケットを再利用できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="e" />パラメーターを null にすることはできません。</exception>
        <exception cref="T:System.InvalidOperationException">ソケット操作が既に進行中の使用中、<see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />で指定されたオブジェクト、<paramref name="e" />パラメーター。</exception>
        <exception cref="T:System.NotSupportedException">Windows XP 以降はこのメソッドに必要です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> クラスの現在のインスタンスによって使用されているすべてのリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Dispose` を使い終わったら <xref:System.Net.Sockets.Socket> を呼び出します。 `Dispose` メソッドによって、<xref:System.Net.Sockets.Socket> は使用不可の状態になります。 呼び出した後`Dispose`へのすべての参照を解放する必要があります、<xref:System.Net.Sockets.Socket>ガベージ コレクターがメモリを再利用できるようにする、<xref:System.Net.Sockets.Socket>占有されていた。  
  
 詳細については、次を参照してください。[アンマネージ リソースのクリーンアップ](~/docs/standard/garbage-collection/unmanaged.md)と[Dispose メソッドの実装](~/docs/standard/garbage-collection/implementing-dispose.md)です。  
  
> [!NOTE]
>  `Dispose` への最後の参照を解放する前に、必ず <xref:System.Net.Sockets.Socket> を呼び出してください。 そうしないと、ガベージ コレクターが <xref:System.Net.Sockets.Socket> オブジェクトの `Finalize` メソッドを呼び出すまで、使用されているリソースは解放されません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          マネージ リソースとアンマネージ リソースの両方を解放する場合は <see langword="true" />。アンマネージ リソースだけを解放する場合は <see langword="false" />。</param>
        <summary><see cref="T:System.Net.Sockets.Socket" /> が使用しているアンマネージ リソースを解放します。オプションでマネージ リソースも破棄します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、パブリック`Dispose()`メソッドおよび<xref:System.Object.Finalize%2A>メソッドです。 `Dispose()`プロテクト呼び出します`Dispose(Boolean)`メソッドを`disposing`パラメーターに設定`true`です。 <xref:System.Object.Finalize%2A>呼び出す`Dispose`で`disposing`'éý'`false`です。  
  
 `disposing` パラメーターが `true` の場合、このメソッドは、この <xref:System.Net.Sockets.Socket> が参照しているすべてのマネージ オブジェクトによって保持されているリソースをすべて解放します。 このメソッドは、参照される各オブジェクトの `Dispose()` メソッドを呼び出します。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> は、他のオブジェクトから複数回呼び出すことができます。 <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" /> をオーバーライドする場合は、以前に <see langword="Dispose" /> を呼び出したときに破棄されたオブジェクトを参照しないように注意する必要があります。 実装する方法の詳細についての<see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />を参照してください[Dispose メソッドの実装](~/docs/standard/garbage-collection/implementing-dispose.md)です。  
  
 詳細については<see langword="Dispose" />と<see cref="M:System.Object.Finalize" />を参照してください[アンマネージ リソースのクリーンアップ](~/docs/standard/garbage-collection/unmanaged.md)と[Finalize メソッドをオーバーライドする](http://msdn.microsoft.com/en-us/8026cb68-fe93-43fc-96c1-c09ad7d64cd3)です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DontFragment">
      <MemberSignature Language="C#" Value="public bool DontFragment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DontFragment" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DontFragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定、<see cref="T:System.Boolean" />を指定する値かどうか、<see cref="T:System.Net.Sockets.Socket" />断片化のインターネット プロトコル (IP) データグラムを許可します。</summary>
        <value>
          <see langword="true" />場合、<see cref="T:System.Net.Sockets.Socket" />データグラム フラグメントを許可して、それ以外の<see langword="false" />します。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 データグラムでは、そのサイズが、最大転送単位 (MTU) の伝送媒体を超えたときに断片化が必要です。 データグラムは、送信ホスト (すべてのインターネット プロトコル バージョン) または中間ルーター (インターネット プロトコル バージョン 4 のみ) で断片化している可能性があります。 場合は、データグラムを断片化している必要があります、および<xref:System.Net.Sockets.Socket.DontFragment%2A>オプションが設定されている、データグラム破棄され、インターネット制御メッセージ プロトコル (ICMP) エラー メッセージが、データグラムの送信者に返されます。  
  
 伝送制御プロトコル (TCP) ソケットにこのプロパティを設定する効果はありません。  
  
   
  
## Examples  
 使用を次のコード例に示します、<xref:System.Net.Sockets.Socket.DontFragment%2A>プロパティです。  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">内のソケットに対してのみこのプロパティを設定することができます、<see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />または<see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />ファミリ。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="DualMode">
      <MemberSignature Language="C#" Value="public bool DualMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DualMode" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DualMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> が IPv4 と IPv6 の両方に使用されるデュアル モード ソケットであるかどうか指定する <see cref="T:System.Boolean" /> 値を取得または設定します。</summary>
        <value>
          <see langword="true" />場合、<see cref="T:System.Net.Sockets.Socket" />デュアル モードのソケットは、それ以外の<see langword="false" />します。 既定値は、<see langword="false" /> です。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DuplicateAndClose">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketInformation DuplicateAndClose (int targetProcessId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Net.Sockets.SocketInformation DuplicateAndClose(int32 targetProcessId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoLimitation("We do not support passing sockets across processes, we merely allow this API to pass the socket across AppDomains")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketInformation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetProcessId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="targetProcessId">参照をソケットの複製が作成された対象プロセスの ID。</param>
        <summary>ターゲット プロセスでは、ソケットの参照を複製し、このプロセスのソケットを閉じます。</summary>
        <returns>ターゲット プロセスに渡されるソケットの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ターゲット プロセスを使用する必要があります<xref:System.Net.Sockets.Socket.%23ctor%2A>重複するソケットのインスタンスを作成します。  
  
 呼び出す場合は、<xref:System.Net.Sockets.Socket.%23ctor%2A>複数回の各呼び出しの引数と同じバイト配列を持つコンス トラクターは、複数の管理を作成する、<xref:System.Net.Sockets.Socket>と基になるソケットの同じインスタンスです。 この方法はお勧めします。  
  
 ソケットを作成するプロセスは、非同期メソッドを使用している場合 (<xref:System.Net.Sockets.Socket.BeginReceive%2A>または<xref:System.Net.Sockets.Socket.BeginSend%2A>)、プロセスを設定する必要があります最初、<xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A>プロパティをソケットを引き起こす可能性があります、作成したプロセスの完了ポートへバインド true をそれ以外の場合、<xref:System.ArgumentNullException>ターゲット プロセスでスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="targetProcessID" />有効なプロセス id がありません。  
  
 または  
  
 ソケットの参照の複製に失敗しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="EnableBroadcast">
      <MemberSignature Language="C#" Value="public bool EnableBroadcast { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableBroadcast" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定、<see cref="T:System.Boolean" />値を指定するかどうか、<see cref="T:System.Net.Sockets.Socket" />送信またはブロードキャスト パケットを受信できます。</summary>
        <value>
          <see langword="true" />場合、<see cref="T:System.Net.Sockets.Socket" />により、ブロードキャスト パケット、それ以外の<see langword="false" />します。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ブロードキャストが、特定のサブネットに制限されており、ユーザー データグラム プロトコル (UDP) を使用する必要があります。255.255.255.255 以外にパケットを送信することによってインターネット プロトコル バージョン 4 では、ローカル サブネットにブロードキャストことができます。または、ホストの部分を設定するすべてのビットをインターネット プロトコル (IP) アドレスの一部でネットワーク向けのブロードキャスト アドレスを使用することができます。 たとえば、お客様の IP アドレスは 192.168.1.40 (255.255.255.0--ネットマスク付きのクラス C アドレスは、ネットワーク部分は、最初の 3 つのオクテットでは、およびホスト部分は、最後のオクテット、)、ブロードキャスト アドレスは 192.168.1.255 します。  
  
 伝送制御プロトコル (TCP) ソケットにこのプロパティを設定する効果はありません。  
  
   
  
## Examples  
 使用を次のコード例に示します、<xref:System.Net.Sockets.Socket.EnableBroadcast%2A>プロパティです。  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">このオプションは、データグラム ソケットの場合のみ有効です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>非同期的に受信接続の試行を受け入れるし、新たに作成<see cref="T:System.Net.Sockets.Socket" />をリモート ホスト間の通信を処理します。</summary>
        <returns>A<see cref="T:System.Net.Sockets.Socket" />リモート ホストとの通信を処理します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>呼び出しを完了<xref:System.Net.Sockets.Socket.BeginAccept%2A>です。 呼び出しの前に<xref:System.Net.Sockets.Socket.BeginAccept%2A>を実装するコールバック メソッドを作成する必要があります、<xref:System.AsyncCallback>を委任します。 このコールバック メソッドは、個別のスレッドで実行され、後にシステムによって呼び出される、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドを返します。 これに同意する必要があります、`asyncResult`パラメーターから返される、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドです。  
  
 コールバック メソッド内で、<xref:System.IAsyncResult.AsyncState%2A>のメソッド、`asyncResult`を取得するパラメーター、<xref:System.Net.Sockets.Socket>になる接続の試行が行われています。 取得した後に、 <xref:System.Net.Sockets.Socket>、呼び出すことができます、<xref:System.Net.Sockets.Socket.EndAccept%2A>メソッドが、接続試行を正常に完了します。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>メソッドは、接続が保留状態になるまで、ブロック、着信接続のキューにします。 <xref:System.Net.Sockets.Socket.EndAccept%2A>メソッドは、受信接続を許可し、新しい返します<xref:System.Net.Sockets.Socket>を使用して、データを送信し、リモート ホストからデータを受け取ることができます。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例は、非同期要求を終了し、新たに作成<xref:System.Net.Sockets.Socket>受信接続要求を受け入れるようにします。 完全な例には、ソケットと非同期通信には、次を参照してください。[ソケットのコード例](~/docs/framework/network-programming/socket-code-examples.md)です。  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="result" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="result" />呼び出しによって作成されていない<see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />メソッドが既に呼び出されています。</exception>
        <exception cref="T:System.NotSupportedException">Windows NT は、このメソッドに必要です。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]&amp;" RefType="out" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="buffer">型の配列<see cref="T:System.Byte" />転送されたバイト数を格納しています。</param>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" />この非同期操作だけでなくすべてのユーザーの状態情報を格納するオブジェクトがデータを定義します。</param>
        <summary>非同期的に受信接続の試行を受け入れるし、新たに作成<see cref="T:System.Net.Sockets.Socket" />リモート ホスト間の通信を処理するオブジェクト。 このメソッドは、初期データの転送を格納するバッファーを返します。</summary>
        <returns>A<see cref="T:System.Net.Sockets.Socket" />リモート ホストとの通信を処理するオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>呼び出しを完了<xref:System.Net.Sockets.Socket.BeginAccept%2A>です。 呼び出しの前に<xref:System.Net.Sockets.Socket.BeginAccept%2A>、によって呼び出されるコールバック メソッドを作成する必要があります、<xref:System.AsyncCallback>を委任します。 このコールバック メソッドは、個別のスレッドで実行され、後にシステムによって呼び出される、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドを返します。  
  
 コールバック メソッド内で、<xref:System.IAsyncResult.AsyncState%2A>のメソッド、`asyncResult`を取得するパラメーター、<xref:System.Net.Sockets.Socket>になる接続の試行が行われています。 取得した後に、 <xref:System.Net.Sockets.Socket>、呼び出すことができます、<xref:System.Net.Sockets.Socket.EndAccept%2A>メソッドが、接続試行を正常に完了します。 `buffer`このオーバー ロードのパラメーターへの呼び出しで受け取ったデータを格納して<xref:System.Net.Sockets.Socket.BeginAccept%2A>と`bytesTransferred`パラメーターには呼び出しで転送されたバイト数が含まれています。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>メソッドは、接続が保留状態になるまで、ブロック、着信接続のキューにします。 <xref:System.Net.Sockets.Socket.EndAccept%2A>メソッドは、受信接続を許可し、新しい返します<xref:System.Net.Sockets.Socket>を使用して、データを送信し、リモート ホストからデータを受け取ることができます。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例では<xref:System.Net.Sockets.Socket.BeginAccept%2A>作成、ソケットを接続して、最初の 10 バイトのデータをそのまま使用します。 コールバック デリゲート呼び出し<xref:System.Net.Sockets.Socket.EndAccept%2A>非同期要求を終了します。 送信バイト数と、データが返されます、`buffer`と`bytesTransferred`このメソッドのパラメーター、コンソールに表示されます。  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Windows NT は、このメソッドに必要です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />オブジェクトが閉じられました。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> が空です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" />呼び出しによって作成されていない<see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />メソッドが既に呼び出されています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">アクセスしようとするときにエラーが発生しました、<see cref="T:System.Net.Sockets.Socket" /></exception>
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, out int bytesTransferred, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, [out] int32&amp; bytesTransferred, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]&amp;" RefType="out" />
        <Parameter Name="bytesTransferred" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="buffer">型の配列<see cref="T:System.Byte" />転送されたバイト数を格納しています。</param>
        <param name="bytesTransferred">転送されたバイト数。</param>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" />この非同期操作だけでなくすべてのユーザーの状態情報を格納するオブジェクトがデータを定義します。</param>
        <summary>非同期的に受信接続の試行を受け入れるし、新たに作成<see cref="T:System.Net.Sockets.Socket" />リモート ホスト間の通信を処理するオブジェクト。 このメソッドは、初期のデータと転送されたバイト数を格納するバッファーを返します。</summary>
        <returns>A<see cref="T:System.Net.Sockets.Socket" />リモート ホストとの通信を処理するオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>呼び出しを完了<xref:System.Net.Sockets.Socket.BeginAccept%2A>です。 呼び出しの前に<xref:System.Net.Sockets.Socket.BeginAccept%2A>、によって呼び出されるコールバック メソッドを作成する必要があります、<xref:System.AsyncCallback>を委任します。 このコールバック メソッドは、個別のスレッドで実行され、後にシステムによって呼び出される、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドを返します。 これに同意する必要があります、`asyncResult`パラメーターから返される、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドです。  
  
 コールバック メソッド内で、<xref:System.IAsyncResult.AsyncState%2A>のメソッド、`asyncResult`を取得するパラメーター、<xref:System.Net.Sockets.Socket>になる接続の試行が行われています。 取得した後に、 <xref:System.Net.Sockets.Socket>、呼び出すことができます、<xref:System.Net.Sockets.Socket.EndAccept%2A>メソッドが、接続試行を正常に完了します。 `buffer`このオーバー ロードのパラメーターへの呼び出しで受け取ったデータを格納して<xref:System.Net.Sockets.Socket.BeginAccept%2A>と`bytesTransferred`パラメーターには呼び出しで転送されたバイト数が含まれています。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>メソッドは、接続が保留状態になるまで、ブロック、着信接続のキューにします。 <xref:System.Net.Sockets.Socket.EndAccept%2A>メソッドは、受信接続を許可し、新しい返します<xref:System.Net.Sockets.Socket>を使用して、データを送信し、リモート ホストからデータを受け取ることができます。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例では<xref:System.Net.Sockets.Socket.BeginAccept%2A>作成、ソケットを接続して、最初の 10 バイトのデータをそのまま使用します。 コールバック デリゲート呼び出し<xref:System.Net.Sockets.Socket.EndAccept%2A>非同期要求を終了します。 送信バイト数と、データが返されます、`buffer`と`bytesTransferred`このメソッドのパラメーター、コンソールに表示されます。  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Windows NT は、このメソッドに必要です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />オブジェクトが閉じられました。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> が空です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" />呼び出しによって作成されていない<see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />メソッドが既に呼び出されています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">アクセスしようとするときにエラーが発生しました、<see cref="T:System.Net.Sockets.Socket" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndConnect">
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>要求の保留中の非同期接続を終了します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndConnect%2A>非同期リモート ホスト接続要求を完了したブロッキング メソッド内で起動、<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドです。  
  
 呼び出しの前に<xref:System.Net.Sockets.Socket.BeginConnect%2A>を実装するコールバック メソッドを作成する必要があります、<xref:System.AsyncCallback>を委任します。 このコールバック メソッドが別のスレッドで実行され、後にシステムによって呼び出される<xref:System.Net.Sockets.Socket.BeginConnect%2A>を返します。 コールバック メソッドに同意する必要があります、<xref:System.IAsyncResult>によって返される、<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドのパラメーターとして。  
  
 コールバック メソッド内で、<xref:System.IAsyncResult.AsyncState%2A>のメソッド、<xref:System.IAsyncResult>を取得するパラメーター、<xref:System.Net.Sockets.Socket>になる接続の試行が行われています。 取得した後に、 <xref:System.Net.Sockets.Socket>、呼び出すことができます、<xref:System.Net.Sockets.Socket.EndConnect%2A>メソッドが、接続試行を正常に完了します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例では、非同期接続の試行を終了します。 完全な例には、ソケットと非同期通信には、次を参照してください。[ソケットのコード例](~/docs/framework/network-programming/socket-code-examples.md)です。  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="result" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="result" />呼び出しによって返されませんでした、<see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />メソッドです。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />非同期の接続が呼び出されました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndDisconnect">
      <MemberSignature Language="C#" Value="public void EndDisconnect (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndDisconnect(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" />状態情報およびこの非同期操作のすべてのユーザー定義データを格納するオブジェクト。</param>
        <summary>保留中の非同期切断要求を終了します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndDisconnect%2A>呼び出しを完了<xref:System.Net.Sockets.Socket.BeginDisconnect%2A>です。 <xref:System.Net.Sockets.Socket.EndDisconnect%2A>メソッドは、切断が完了するまでブロックします。 非同期操作については、MSDN ライブラリの非同期プログラミングの概要のトピックを参照してください。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例では、非同期通信のソケットを作成し、リモート ホストにデータを送信します。 データが送信されると、<xref:System.Net.Sockets.Socket.Shutdown%2A>送信を停止し、受信アクティビティのために呼び出されます。 <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>切断要求を開始すると呼びます。 コールバック デリゲート呼び出し<xref:System.Net.Sockets.Socket.EndDisconnect%2A>非同期要求を終了します。 要求が完了したら、<xref:System.Net.Sockets.Socket.Connected%2A>プロパティは、ソケットが切断されているかどうかをテストするクエリを実行します。  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">オペレーティング システムが Windows 2000 以前のバージョン、および、このメソッドには、Windows XP が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />オブジェクトが閉じられました。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" />呼び出しによって返されませんでした、<see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />メソッドです。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" />非同期の接続が呼び出されました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.Net.WebException">切断要求がタイムアウトしました。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>保留中の非同期読み取りを終了します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndReceive%2A>メソッドで開始された非同期の読み取り操作が完了すると、<xref:System.Net.Sockets.Socket.BeginReceive%2A>メソッドです。  
  
 呼び出しの前に<xref:System.Net.Sockets.Socket.BeginReceive%2A>を実装するコールバック メソッドを作成する必要があります、<xref:System.AsyncCallback>を委任します。 このコールバック メソッドが別のスレッドで実行され、後にシステムによって呼び出される<xref:System.Net.Sockets.Socket.BeginReceive%2A>を返します。 コールバック メソッドに同意する必要があります、<xref:System.IAsyncResult>によって返される、<xref:System.Net.Sockets.Socket.BeginReceive%2A>メソッドのパラメーターとして。  
  
 コールバック メソッド内で、<xref:System.IAsyncResult.AsyncState%2A>のメソッド、<xref:System.IAsyncResult>に渡される状態オブジェクトを取得する、<xref:System.Net.Sockets.Socket.BeginReceive%2A>メソッドです。 受信側の抽出<xref:System.Net.Sockets.Socket>この状態オブジェクトから。 取得した後に、 <xref:System.Net.Sockets.Socket>、呼び出すことができます、<xref:System.Net.Sockets.Socket.EndReceive%2A>メソッドを正常に読み取り操作を完了して、読み取られたバイト数を返します。  
  
 <xref:System.Net.Sockets.Socket.EndReceive%2A>メソッドはデータが読み取られるまでブロックします。 コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.EndReceive%2A>はネットワークの着信バッファーで使用できる最初のエンキューされたデータグラムを読み取ります。 接続指向のプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.EndReceive%2A>メソッドは現状有姿で指定したバイトの数まで使用可能な多くのデータを読み取る、`size`のパラメーター、<xref:System.Net.Sockets.Socket.BeginReceive%2A>メソッドです。 リモート ホストがシャット ダウンした場合、<xref:System.Net.Sockets.Socket>との接続、<xref:System.Net.Sockets.Socket.Shutdown%2A>メソッド、および利用可能なすべてのデータを受信、<xref:System.Net.Sockets.Socket.EndReceive%2A>メソッドはすぐに完了し、0 バイトを返します。  
  
 受信したデータを取得する呼び出し、<xref:System.IAsyncResult.AsyncState%2A>のメソッド、 <xref:System.IAsyncResult>、し、結果の状態オブジェクトに含まれているバッファーを抽出します。  
  
 [キャンセル] を保留中<xref:System.Net.Sockets.Socket.BeginReceive%2A>を呼び出し、<xref:System.Net.Sockets.Socket.Close%2A>メソッドです。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I/O が取り消されました。 操作が完了する前に、スレッドが終了した場合、保留中の非同期操作が失敗することができます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例では、保留中の非同期読み取りを終了します。 完全な例には、ソケットと非同期通信には、次を参照してください。[ソケットのコード例](~/docs/framework/network-programming/socket-code-examples.md)です。  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="result" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="result" />呼び出しによって返されませんでした、<see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />メソッドです。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />以前の非同期読み取りが呼び出されました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" />状態情報およびこの非同期操作のすべてのユーザー定義データを格納します。</param>
        <param name="errorCode">A<see cref="T:System.Net.Sockets.SocketError" />ソケット エラーを格納するオブジェクト。</param>
        <summary>保留中の非同期読み取りを終了します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndReceive%2A>メソッドで開始された非同期の読み取り操作が完了すると、<xref:System.Net.Sockets.Socket.BeginReceive%2A>メソッドです。  
  
 呼び出しの前に<xref:System.Net.Sockets.Socket.BeginReceive%2A>を実装するコールバック メソッドを作成する必要があります、<xref:System.AsyncCallback>を委任します。 このコールバック メソッドが別のスレッドで実行され、後にシステムによって呼び出される<xref:System.Net.Sockets.Socket.BeginReceive%2A>を返します。 コールバック メソッドに同意する必要があります、<xref:System.IAsyncResult>によって返される、<xref:System.Net.Sockets.Socket.BeginReceive%2A>メソッドのパラメーターとして。  
  
 コールバック メソッド内で、<xref:System.IAsyncResult.AsyncState%2A>のメソッド、<xref:System.IAsyncResult>に渡される状態オブジェクトを取得する、<xref:System.Net.Sockets.Socket.BeginReceive%2A>メソッドです。 受信側の抽出<xref:System.Net.Sockets.Socket>この状態オブジェクトから。 取得した後に、 <xref:System.Net.Sockets.Socket>、呼び出すことができます、<xref:System.Net.Sockets.Socket.EndReceive%2A>メソッドを正常に読み取り操作を完了して、読み取られたバイト数を返します。  
  
 <xref:System.Net.Sockets.Socket.EndReceive%2A>メソッドはデータが読み取られるまでブロックします。 コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.EndReceive%2A>はネットワークの着信バッファーで使用できる最初のエンキューされたデータグラムを読み取ります。 接続指向のプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.EndReceive%2A>メソッドは現状有姿で指定したバイトの数まで使用可能な多くのデータを読み取る、`size`のパラメーター、<xref:System.Net.Sockets.Socket.BeginReceive%2A>メソッドです。 リモート ホストがシャット ダウンした場合、<xref:System.Net.Sockets.Socket>との接続、<xref:System.Net.Sockets.Socket.Shutdown%2A>メソッド、および利用可能なすべてのデータを受信、<xref:System.Net.Sockets.Socket.EndReceive%2A>メソッドはすぐに完了し、0 バイトを返します。  
  
 受信したデータを取得する呼び出し、<xref:System.IAsyncResult.AsyncState%2A>のメソッド、 <xref:System.IAsyncResult>、し、結果の状態オブジェクトに含まれているバッファーを抽出します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I/O が取り消されました。 操作が完了する前に、スレッドが終了した場合、保留中の非同期操作が失敗することができます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" />呼び出しによって返されませんでした、<see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />メソッドです。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />以前の非同期読み取りが呼び出されました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReceiveFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult result, ref System.Net.EndPoint end_point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult result, class System.Net.EndPoint&amp; end_point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <param name="end_point">To be added.</param>
        <summary>特定のエンドポイントからの保留中の非同期読み取りを終了します。</summary>
        <returns>成功した場合、バイト数を受信します。 失敗した場合は、0 を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>メソッドで開始された非同期の読み取り操作が完了すると、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>メソッドです。  
  
 呼び出しの前に<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>を実装するコールバック メソッドを作成する必要があります、<xref:System.AsyncCallback>を委任します。 このコールバック メソッドが別のスレッドで実行され、後にシステムによって呼び出される<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>を返します。 コールバック メソッドに同意する必要があります、<xref:System.IAsyncResult>によって返される、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>メソッドのパラメーターとして。  
  
 コールバック メソッド内で、<xref:System.IAsyncResult.AsyncState%2A>のメソッド、<xref:System.IAsyncResult>に渡される状態オブジェクトを取得する、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>メソッドです。 受信側の抽出<xref:System.Net.Sockets.Socket>この状態オブジェクトから。 取得した後に、 <xref:System.Net.Sockets.Socket>、呼び出すことができます、<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>メソッドを正常に読み取り操作を完了して、読み取られたバイト数を返します。  
  
 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>メソッドはデータが読み取られるまでブロックします。 コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>はネットワークの着信バッファーで使用できる最初のエンキューされたデータグラムを読み取ります。 接続指向のプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>メソッドは現状有姿で指定したバイトの数まで使用可能な多くのデータを読み取る、`size`のパラメーター、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>メソッドです。 リモート ホストがシャット ダウンした場合、<xref:System.Net.Sockets.Socket>との接続、<xref:System.Net.Sockets.Socket.Shutdown%2A>メソッド、および利用可能なすべてのデータを受信、<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>メソッドはすぐに完了し、0 バイトを返します。 受信したデータを取得する呼び出し、<xref:System.IAsyncResult.AsyncState%2A>のメソッド、<xref:System.IAsyncResult>オブジェクト、および結果の状態オブジェクトに含まれているバッファーを抽出します。 元のホストを識別するための抽出、<xref:System.Net.EndPoint>にキャストし、<xref:System.Net.IPEndPoint>です。 使用して、 <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> IP アドレスを取得するメソッドと<xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType>ポート番号を取得します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例は、特定の保留中の非同期読み込みを終了<xref:System.Net.EndPoint>です。  
  
 [!code-cpp[Socket_Async_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Async_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Async_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" />呼び出しによって返されませんでした、<see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />メソッドです。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />以前の非同期読み取りが呼び出されました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveMessageFrom (IAsyncResult asyncResult, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint endPoint, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveMessageFrom(class System.IAsyncResult asyncResult, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; endPoint, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags&amp;" RefType="ref" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint&amp;" RefType="ref" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" />状態情報およびこの非同期操作のすべてのユーザー定義データを格納します。</param>
        <param name="socketFlags">ビットごとの組み合わせ、<see cref="T:System.Net.Sockets.SocketFlags" />受信パケットの値。</param>
        <param name="endPoint">コピー元 <see cref="T:System.Net.EndPoint" />。</param>
        <param name="ipPacketInformation"><see cref="T:System.Net.IPAddress" />と受信パケットのインターフェイスです。</param>
        <summary>特定のエンドポイントからの保留中の非同期読み取りを終了します。 このメソッドは、詳細については、パケットよりもことがわかります。<see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />です。</summary>
        <returns>成功した場合、バイト数を受信します。 失敗した場合は、0 を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 操作が完了していない場合、このメソッドはそれまでブロックします。  
  
 この操作を同期的に実行するを使用して、<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>メソッドです。  
  
 調べる`ipPacketInformation`かどうか、ユニキャスト、マルチキャスト、またはブロードキャスト アドレスを使用してデータグラムが送信されたかを知る必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> は <see langword="null" /> です  
  
 または  
  
 <paramref name="endPoint" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" />呼び出しによって返されませんでした、<see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />メソッドです。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />以前の非同期読み取りが呼び出されました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>保留中の非同期送信を終了します。</summary>
        <returns>かどうか、成功した、送信したバイト数を<see cref="T:System.Net.Sockets.Socket" />、それ以外の無効な<see cref="T:System.Net.Sockets.Socket" />エラーです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSend%2A>開始された非同期送信操作が完了した<xref:System.Net.Sockets.Socket.BeginSend%2A>です。  
  
 呼び出しの前に<xref:System.Net.Sockets.Socket.BeginSend%2A>を実装するコールバック メソッドを作成する必要があります、<xref:System.AsyncCallback>を委任します。 このコールバック メソッドが別のスレッドで実行され、後にシステムによって呼び出される<xref:System.Net.Sockets.Socket.BeginSend%2A>を返します。 コールバック メソッドに同意する必要があります、<xref:System.IAsyncResult>によって返される、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドのパラメーターとして。  
  
 コールバック メソッド内で、<xref:System.IAsyncResult.AsyncState%2A>のメソッド、<xref:System.IAsyncResult>送信を取得するパラメーター<xref:System.Net.Sockets.Socket>です。 取得した後に、 <xref:System.Net.Sockets.Socket>、呼び出すことができます、<xref:System.Net.Sockets.Socket.EndSend%2A>を正常に送信操作を完了し、送信されたバイト数を返すメソッド。  
  
 コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.EndSend%2A>データグラムが送信されるまでブロックされます。 接続指向のプロトコルを使用している場合<xref:System.Net.Sockets.Socket.EndSend%2A>バッファーの一部が送信されるまでブロックされます。 戻り値の場合<xref:System.Net.Sockets.Socket.EndSend%2A>バッファーができなかったことを示します呼び出す完全に送信される、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドを再度、未送信のデータを保持するバッファーを変更します。  
  
 送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに基になるシステムは大量の送信データが収集されるまでに伝送を遅れる可能性があります。 正常に完了する、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I/O が取り消されました。 操作が完了する前に、スレッドが終了した場合、保留中の非同期操作が失敗することができます。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されることは示しません。 転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されている場合を除きがブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例では、保留中の非同期送信を終了します。  
  
 [!code-cpp[Socket_Async_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Async_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Async_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="result" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="result" />呼び出しによって返されませんでした、<see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />メソッドです。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />非同期の送信が呼び出されました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" />この非同期操作の状態情報を格納します。</param>
        <param name="errorCode">A<see cref="T:System.Net.Sockets.SocketError" />ソケット エラーを格納するオブジェクト。</param>
        <summary>保留中の非同期送信を終了します。</summary>
        <returns>かどうか、成功した、送信したバイト数を<see cref="T:System.Net.Sockets.Socket" />、それ以外の無効な<see cref="T:System.Net.Sockets.Socket" />エラーです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSend%2A>開始された非同期送信操作が完了した<xref:System.Net.Sockets.Socket.BeginSend%2A>です。  
  
 呼び出しの前に<xref:System.Net.Sockets.Socket.BeginSend%2A>を実装するコールバック メソッドを作成する必要があります、<xref:System.AsyncCallback>を委任します。 このコールバック メソッドが別のスレッドで実行され、後にシステムによって呼び出される<xref:System.Net.Sockets.Socket.BeginSend%2A>を返します。 コールバック メソッドに同意する必要があります、<xref:System.IAsyncResult>によって返される、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドのパラメーターとして。  
  
 コールバック メソッド内で、<xref:System.IAsyncResult.AsyncState%2A>のメソッド、<xref:System.IAsyncResult>送信を取得するパラメーター<xref:System.Net.Sockets.Socket>です。 取得した後に、 <xref:System.Net.Sockets.Socket>、呼び出すことができます、<xref:System.Net.Sockets.Socket.EndSend%2A>を正常に送信操作を完了し、送信されたバイト数を返すメソッド。  
  
 コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.EndSend%2A>データグラムが送信されるまでブロックされます。 接続指向のプロトコルを使用している場合<xref:System.Net.Sockets.Socket.EndSend%2A>バッファーの一部が送信されるまでブロックされます。 戻り値の場合<xref:System.Net.Sockets.Socket.EndSend%2A>バッファーができなかったことを示します呼び出す完全に送信される、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドを再度、未送信のデータを保持するバッファーを変更します。  
  
 送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに基になるシステムは大量の送信データが収集されるまでに伝送を遅れる可能性があります。 正常に完了する、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I/O が取り消されました。 操作が完了する前に、スレッドが終了した場合、保留中の非同期操作が失敗することができます。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されることは示しません。 転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されている場合を除きがブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" />呼び出しによって返されませんでした、<see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />メソッドです。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />非同期の送信が呼び出されました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndSendFile">
      <MemberSignature Language="C#" Value="public void EndSendFile (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndSendFile(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" />この非同期操作の状態情報を格納するオブジェクト。</param>
        <summary>ファイルの保留中の非同期送信を終了します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSendFile%2A>開始された非同期送信操作が完了した<xref:System.Net.Sockets.Socket.BeginSendFile%2A>です。  
  
 呼び出しの前に<xref:System.Net.Sockets.Socket.BeginSendFile%2A>を実装するコールバック メソッドを作成する必要があります、<xref:System.AsyncCallback>を委任します。 このコールバック メソッドが別のスレッドで実行され、後にシステムによって呼び出される<xref:System.Net.Sockets.Socket.BeginSendFile%2A>を返します。 コールバック メソッドに同意する必要があります、<xref:System.IAsyncResult>によって返されるオブジェクト、<xref:System.Net.Sockets.Socket.BeginSendFile%2A>メソッドのパラメーターとして。  
  
 コールバック メソッド内で、<xref:System.IAsyncResult.AsyncState%2A>のメソッド、<xref:System.IAsyncResult>送信を取得するパラメーター<xref:System.Net.Sockets.Socket>です。 取得した後に、 <xref:System.Net.Sockets.Socket>、呼び出すことができます、<xref:System.Net.Sockets.Socket.EndSendFile%2A>メソッドが正常に送信操作を完了します。  
  
 コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.EndSendFile%2A>データグラムを送信するまでブロックします。 接続指向のプロトコルを使用している場合<xref:System.Net.Sockets.Socket.EndSendFile%2A>ファイル全体を送信するまでブロックします。 送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに基になるシステムは大量の送信データが収集されるまでに伝送を遅れる可能性があります。 正常に完了する、<xref:System.Net.Sockets.Socket.BeginSendFile%2A>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例を作成し、非同期通信のソケットを接続し、リモート ホストにファイルの"text.txt"を非同期的に送信を開始します。 コールバック デリゲート呼び出し<xref:System.Net.Sockets.Socket.EndSendFile%2A>転送を完了します。  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Windows NT は、このメソッドに必要です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />オブジェクトが閉じられました。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> が空です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" />呼び出しによって返されませんでした、<see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />メソッドです。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" />非同期が呼び出された<see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 「解説」を参照してください。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndSendTo">
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>特定の場所に保留中の非同期送信を終了します。</summary>
        <returns>かどうか、成功した、送信したバイト数です。それ以外の場合、無効な<see cref="T:System.Net.Sockets.Socket" />エラーです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSendTo%2A>開始された非同期送信操作が完了した<xref:System.Net.Sockets.Socket.BeginSendTo%2A>です。  
  
 呼び出しの前に<xref:System.Net.Sockets.Socket.BeginSendTo%2A>を実装するコールバック メソッドを作成する必要があります、<xref:System.AsyncCallback>を委任します。 このコールバック メソッドが別のスレッドで実行され、後にシステムによって呼び出される<xref:System.Net.Sockets.Socket.BeginReceive%2A>を返します。 コールバック メソッドに同意する必要があります、<xref:System.IAsyncResult>によって返される、<xref:System.Net.Sockets.Socket.BeginSendTo%2A>メソッドのパラメーターとして。  
  
 コールバック メソッド内で、<xref:System.IAsyncResult.AsyncState%2A>のメソッド、<xref:System.IAsyncResult>送信を取得するパラメーター<xref:System.Net.Sockets.Socket>です。 取得した後に、 <xref:System.Net.Sockets.Socket>、呼び出すことができます、<xref:System.Net.Sockets.Socket.EndSendTo%2A>を正常に送信操作を完了し、送信されたバイト数を返すメソッド。  
  
 コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.EndSendTo%2A>データグラムが送信されるまでブロックされます。 接続指向のプロトコルを使用している場合<xref:System.Net.Sockets.Socket.EndSendTo%2A>要求されたバイト数を送信するまでブロックされます。 送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに基になるシステムは大量の送信データが収集されるまでに伝送を遅れる可能性があります。 正常に完了する、<xref:System.Net.Sockets.Socket.BeginSendTo%2A>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例では、特定の場所への非同期送信を終了します。  
  
 [!code-cpp[Socket_Async_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Async_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Async_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="result" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="result" />呼び出しによって返されませんでした、<see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />メソッドです。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />非同期の送信が呼び出されました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定、<see cref="T:System.Boolean" />値を指定するかどうか、<see cref="T:System.Net.Sockets.Socket" />により、ポートにバインドするプロセスは 1 つだけです。</summary>
        <value>
          <see langword="true" />場合、<see cref="T:System.Net.Sockets.Socket" />特定のポートにバインドする 1 つだけのソケットは、それ以外の場合、<see langword="false" />です。 既定値は<see langword="true" />Windows Server 2003 および Windows XP Service Pack 2、および<see langword="false" />他のすべてのバージョン。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合<xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A>は`false`、複数のソケットを使用することができます、<xref:System.Net.Sockets.Socket.Bind%2A>特定のポートにバインドするメソッド以外の場合は、ソケットの 1 つのみただしがポートに送信されるネットワーク トラフィックの操作を実行できます。 複数のソケットが使用を試みると、<xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29>より特定の IP アドレスを持つ 1 つはそのポートに送信されるネットワーク トラフィックを処理し、特定のポートにバインドするメソッド。  
  
 場合<xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A>は`true`の最初の使用、<xref:System.Net.Sockets.Socket.Bind%2A>インターネット プロトコル (IP) アドレスに関係なく、特定のポートにバインドしようとするメソッドは成功します。 の後続のすべての使用、<xref:System.Net.Sockets.Socket.Bind%2A>元は、ソケットをバインドするまでのポートが失敗するようにバインドしようとするメソッドが破棄されます。  
  
 このプロパティは、前に設定する必要があります<xref:System.Net.Sockets.Socket.Bind%2A>が呼び出された場合、<xref:System.InvalidOperationException>がスローされます。  
  
   
  
## Examples  
 使用を次のコード例に示します、<xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A>プロパティです。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />これが呼び出された<see cref="T:System.Net.Sockets.Socket" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Socket ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Finalize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> クラスによって使用されていたリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>クラスのファイナライザーの呼び出し、<xref:System.Net.Sockets.Socket.Close%2A>を終了するメソッド、<xref:System.Net.Sockets.Socket>に関連付けられているリソースを解放し、<xref:System.Net.Sockets.Socket>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public object GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 値のいずれか。</param>
        <param name="optionName"><see cref="T:System.Net.Sockets.SocketOptionName" /> 値のいずれか。</param>
        <summary>指定した値を返します<see cref="T:System.Net.Sockets.Socket" />オプション、オブジェクトとして表されます。</summary>
        <returns>オプションの値を表すオブジェクト。 ときに、<paramref name="optionName" />にパラメーターが設定されている<see cref="F:System.Net.Sockets.SocketOptionName.Linger" />、戻り値のインスタンス、<see cref="T:System.Net.Sockets.LingerOption" />クラスです。 ときに<paramref name="optionName" />に設定されている<see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" />または<see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" />、戻り値がのインスタンス、<see cref="T:System.Net.Sockets.MulticastOption" />クラスです。 ときに<paramref name="optionName" />、他の値は、戻り値は整数です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>オプションは、現在の動作を決定<xref:System.Net.Sockets.Socket>です。 このオーバー ロードを使用して取得する、 <xref:System.Net.Sockets.SocketOptionName.Linger>、 <xref:System.Net.Sockets.SocketOptionName.AddMembership>、および<xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket>オプション。 <xref:System.Net.Sockets.SocketOptionName.Linger>オプションを使用して<xref:System.Net.Sockets.Socket>の`optionLevel`パラメーター。 <xref:System.Net.Sockets.SocketOptionName.AddMembership>と<xref:System.Net.Sockets.SocketOptionName.DropMembership>を使用して<xref:System.Net.Sockets.SocketOptionLevel.IP>です。 上記のオプションのいずれかの値の設定を使用する場合、<xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッドです。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例の取得、<xref:System.Net.Sockets.LingerOption>と<xref:System.Net.Sockets.Socket.Send%2A>タイムアウト値し、それらをコンソールに表示します。  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。  
  
 または  
  
 <paramref name="optionName" />サポートされていない値に設定された<see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public void GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 値のいずれか。</param>
        <param name="optionName"><see cref="T:System.Net.Sockets.SocketOptionName" /> 値のいずれか。</param>
        <param name="optionValue">型の配列<see cref="T:System.Byte" />オプションの設定を受信することができます。</param>
        <summary>指定したを返します<see cref="T:System.Net.Sockets.Socket" />オプションの設定、バイト配列として表されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>オプションは、現在の動作を決定<xref:System.Net.Sockets.Socket>です。 このメソッドの正常完了時に、によって指定された配列、`optionValue`パラメーターには、指定した値が含まれています。<xref:System.Net.Sockets.Socket>オプション。  
  
 ときの長さ、`optionValue`配列は、指定した値を格納するために必要なバイト数よりも小さい<xref:System.Net.Sockets.Socket>オプション、<xref:System.Net.Sockets.Socket.GetSocketOption%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。 このオーバー ロードを使用して、任意のソケットのブール値または整数値で表されます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例の取得、<xref:System.Net.Sockets.LingerOption>と<xref:System.Net.Sockets.Socket.Send%2A>タイムアウト値し、それらをコンソールに表示します。  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。  
  
 \- または  
  
 .NET Compact Framework アプリケーションで、Windows CE の既定のバッファー領域は、32,768 バイトに設定されます。 変更することができます、ソケット バッファー領域あたり<see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />します。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public byte[] GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 値のいずれか。</param>
        <param name="optionName"><see cref="T:System.Net.Sockets.SocketOptionName" /> 値のいずれか。</param>
        <param name="optionLength">想定される戻り値の長さ、(バイト単位)。</param>
        <summary>指定した値を返します<see cref="T:System.Net.Sockets.Socket" />配列内のオプションです。</summary>
        <returns>型の配列<see cref="T:System.Byte" />ソケット オプションの値を格納しています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `optionLength`パラメーターが返されるバイト配列の最大サイズを設定します。 オプションの値には、以下のバイト数が必要とする場合、配列にはそれだけ多くのバイト数。 オプションの値より多くの容量が必要な場合<xref:System.Net.Sockets.Socket.GetSocketOption%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 このオーバー ロードを使用して、任意のソケットのブール値または整数値で表されます。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例の取得、<xref:System.Net.Sockets.LingerOption>と<xref:System.Net.Sockets.Socket.Send%2A>タイムアウト値し、それらをコンソールに表示します。  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。  
  
 \- または  
  
 .NET Compact Framework アプリケーションで、Windows CE の既定のバッファー領域は、32,768 バイトに設定されます。 変更することができます、ソケット バッファー領域あたり<see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />します。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>オペレーティング システム ハンドルを取得、<see cref="T:System.Net.Sockets.Socket" />です。</summary>
        <value><see cref="T:System.IntPtr" />のオペレーティング システム ハンドルを表す、<see cref="T:System.Net.Sockets.Socket" />です。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (int ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(int32 ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Int32" />
        <Parameter Name="optionInValue" Type="System.Byte[]" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="ioControlCode"><see cref="T:System.Int32" />実行する操作のコントロールのコードを指定します。</param>
        <param name="optionInValue">A<see cref="T:System.Byte" />操作で必要な入力データを格納する配列。</param>
        <param name="optionOutValue">A<see cref="T:System.Byte" />操作によって返される出力データを含む配列。</param>
        <summary>動作モードは低レベルの設定、<see cref="T:System.Net.Sockets.Socket" />数値制御コードを使用します。</summary>
        <returns>バイト数、<paramref name="optionOutValue" />パラメーター。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.IOControl%2A>メソッドは、オペレーティング システムへの低レベルのアクセスを提供<xref:System.Net.Sockets.Socket>の現在のインスタンスの基になる、<xref:System.Net.Sockets.Socket>クラスです。 詳細については、MSDN ライブラリの WSAIoctl ドキュメントを参照してください。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例では、FIONREAD と使用可能なプロパティの結果を比較します。  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.InvalidOperationException">使用せず、ブロックしているモードを変更しようとしましたが、<see cref="P:System.Net.Sockets.Socket.Blocking" />プロパティです。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し履歴内の呼び出し元には、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">アンマネージ コードを実行します。 関連する列挙値:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />です。</permission>
      </Docs>
    </Member>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (System.Net.Sockets.IOControlCode ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(valuetype System.Net.Sockets.IOControlCode ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Net.Sockets.IOControlCode" />
        <Parameter Name="optionInValue" Type="System.Byte[]" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">A<see cref="T:System.Net.Sockets.IOControlCode" />実行する操作のコントロールのコードを指定します。</param>
        <param name="optionInValue">型の配列<see cref="T:System.Byte" />操作で必要な入力データを格納しています。</param>
        <param name="optionOutValue">型の配列<see cref="T:System.Byte" />操作によって返される出力データを格納しています。</param>
        <summary>動作モードは低レベルの設定、<see cref="T:System.Net.Sockets.Socket" />を使用して、<see cref="T:System.Net.Sockets.IOControlCode" />制御コードを指定する列挙体です。</summary>
        <returns>バイト数、<paramref name="optionOutValue" />パラメーター。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、オペレーティング システムへの低レベルのアクセスを提供<xref:System.Net.Sockets.Socket>の現在のインスタンスの基になる、<xref:System.Net.Sockets.Socket>クラスです。 詳細については、MSDN ライブラリの WSAIoctl ドキュメントを参照してください。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例は、呼び出し元の結果を比較して<xref:System.Net.Sockets.Socket.IOControl%2A>で<xref:System.Net.Sockets.IOControlCode.DataToRead>と<xref:System.Net.Sockets.Socket.Available%2A>プロパティです。  
  
 [!code-cpp[NCLSocketIoControl1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl1/CPP/iocontrolcode.cpp#1)]
 [!code-csharp[NCLSocketIoControl1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl1/CS/iocontrolcode.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.InvalidOperationException">使用せず、ブロックしているモードを変更しようとしましたが、<see cref="P:System.Net.Sockets.Socket.Blocking" />プロパティです。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">アンマネージ コードを実行します。 関連する列挙値:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />です。</permission>
      </Docs>
    </Member>
    <Member MemberName="IsBound">
      <MemberSignature Language="C#" Value="public bool IsBound { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBound" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.IsBound" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>示す値を取得するかどうか、<see cref="T:System.Net.Sockets.Socket" />は特定のローカル ポートにバインドします。</summary>
        <value>
          <see langword="true" />場合、 <see cref="T:System.Net.Sockets.Socket" /> 、それ以外のローカル ポートにバインドされた<see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出すことによって明示的にバインドされている場合、ソケットは、ローカル ポートにバインドされたと見なされます、<xref:System.Net.Sockets.Socket.Bind%2A>メソッド、またはのようなメンバーを呼び出すことによって暗黙的にバインドされた<xref:System.Net.Sockets.Socket.Connect%2A>、 <xref:System.Net.Sockets.Socket.SendTo%2A>、または<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>、一時的なローカル ポート (空きポート 1024、オペレーティング システムによって選択されているより大きいです) を使用する。サーバーを使用して、<xref:System.Net.Sockets.Socket.Bind%2A>クライアントがそれらに接続できるように、既知のポートにバインドするメソッド。  
  
   
  
## Examples  
 使用を次のコード例に示します、<xref:System.Net.Sockets.Socket.IsBound%2A>プロパティです。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LingerState">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.LingerOption LingerState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.LingerOption LingerState" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LingerState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.LingerOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定を指定する値かどうか、<see cref="T:System.Net.Sockets.Socket" />で、保留中のすべてのデータを送信するために、ソケットの終了を遅延します。</summary>
        <value>A<see cref="T:System.Net.Sockets.LingerOption" />ソケットを閉じるときの待機をする方法を指定します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.LingerState%2A>プロパティ方法を変更<xref:System.Net.Sockets.Socket.Close%2A>メソッドは動作します。 このプロパティ セットが Winsock によってする接続をリセットすることができます、条件を変更する場合。 接続のリセットに IP プロトコルの動作に基づいて引き続き発生します。  
  
 このプロパティは、接続指向の接続を開いたまま呼び出しの後に時間の長さを制御<xref:System.Net.Sockets.Socket.Close%2A>データが送信するのには残ります。  
  
 呼び出すと、ピアにデータを送信する方法は、このデータが出力方向のネットワーク バッファーに配置されます。 このプロパティは、前に、リモート ホストにこのデータが送信されるように使用できる、<xref:System.Net.Sockets.TcpClient.Close%2A>メソッドは、接続を切断します。  
  
 接続を維持できるように、作成、 <xref:System.Net.Sockets.LingerOption> 、目的の値を含むをインスタンス化し、設定、<xref:System.Net.Sockets.Socket.LingerState%2A>プロパティをこのインスタンスにします。  
  
 次の表の動作、<xref:System.Net.Sockets.Socket.Close%2A>メソッドの有効な値を<xref:System.Net.Sockets.LingerOption.Enabled%2A>プロパティおよび<xref:System.Net.Sockets.LingerOption.LingerTime%2A>に格納されているプロパティ、<xref:System.Net.Sockets.Socket.LingerState%2A>プロパティです。  
  
|LingerState.Enabled|LingerState.LingerTime|動作|  
|-------------------------|----------------------------|--------------|  
|`false`(無効)、既定値|タイムアウトは適用、されません (既定値)。|既定の IP プロトコル タイムアウトの期限が切れるまで、保留中のデータ送信を試みます。|  
|`true`(有効)|0 以外のタイムアウト|指定したタイムアウトが経過するまでの試行が失敗した場合は、Winsock 接続がリセット保留中のデータ送信を試みます。|  
|`true`(有効)|0 のタイムアウト|保留中のデータを破棄します。 接続志向ソケット (たとえば、TCP) の場合は、Winsock は接続をリセットします。|  
  
 IP スタックは、接続のラウンド トリップ時間に基づいて使用する既定の IP プロトコルのタイムアウト期間を計算します。 ほとんどの場合、スタックによって計算されたタイムアウトは、アプリケーションで定義された 1 より関連性が高いです。 ソケットの既定の動作は、このとき、<xref:System.Net.Sockets.Socket.LingerState%2A>プロパティが設定されていません。  
  
 ときに、<xref:System.Net.Sockets.LingerOption.LingerTime%2A>に格納されているプロパティ、<xref:System.Net.Sockets.Socket.LingerState%2A>プロパティは、既定の IP プロトコル タイムアウトよりも大きい設定、既定の IP プロトコル タイムアウトを引き続き適用を上書きします。  
  
   
  
## Examples  
 使用を次のコード例に示します、<xref:System.Net.Sockets.Socket.LingerState%2A>プロパティです。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Listen">
      <MemberSignature Language="C#" Value="public void Listen (int backlog);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Listen(int32 backlog) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backlog" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="backlog">保留中の接続のキューの最大長。</param>
        <summary>場所、<see cref="T:System.Net.Sockets.Socket" />リッスン状態にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Listen%2A>接続指向により<xref:System.Net.Sockets.Socket>受信試行の接続をリッスンするようにします。 `backlog`パラメーターできますのキューへの同意に着信接続の数を指定します。 調べるには、接続の最大数を指定することができます、取得、<xref:System.Net.Sockets.SocketOptionName.MaxConnections>値。 <xref:System.Net.Sockets.Socket.Listen%2A>ブロックされません。  
  
 表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。 使用して<xref:System.Net.Sockets.Socket.Accept%2A>または<xref:System.Net.Sockets.Socket.BeginAccept%2A>キューからの接続を受け入れます。  
  
> [!NOTE]
>  呼び出す必要があります、<xref:System.Net.Sockets.Socket.Bind%2A>メソッドを呼び出す前に<xref:System.Net.Sockets.Socket.Listen%2A>、または<xref:System.Net.Sockets.Socket.Listen%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
> [!NOTE]
>  バックログ パラメーターは、オペレーティング システムに応じて異なる値に制限されます。 高い値を指定することがありますが、バックログは限られたオペレーティング システムに基づくです。  
  
   
  
## Examples  
 次のコード例では<xref:System.Net.Sockets.Socket>受信接続をリッスンするようにします。  
  
 [!code-cpp[Classic Socket.Listen Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Listen Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Listen Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Listen Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Listen Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Listen Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="LocalEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint LocalEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint LocalEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ローカル エンドポイントを取得します。</summary>
        <value><see cref="T:System.Net.EndPoint" />を<see cref="T:System.Net.Sockets.Socket" />通信に使用します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>プロパティを取得、<xref:System.Net.EndPoint>するローカル IP アドレスとポート番号を格納している、<xref:System.Net.Sockets.Socket>がバインドされています。 これをキャストする必要があります<xref:System.Net.EndPoint>を<xref:System.Net.IPEndPoint>すべての情報を取得する前にします。 呼び出すことができます、<xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType>ローカルを取得する方法を<xref:System.Net.IPAddress>、および<xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType>ローカル ポート番号を取得します。  
  
 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>通常プロパティへの呼び出しを加えた後、<xref:System.Net.Sockets.Socket.Bind%2A>メソッドです。 ソケットのローカル IP アドレスとポート番号を割り当てるシステムを許可する場合、<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>最初の I/O 操作の後にプロパティが設定されます。 接続指向プロトコルでは、最初の I/O 操作になりますへの呼び出し、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドです。 コネクションレスのプロトコルを最初の I/O 操作では、送信のいずれかまたは受信呼び出しは。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例では、取得し、ローカルおよびリモート エンドポイントを表示します。  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="MulticastLoopback">
      <MemberSignature Language="C#" Value="public bool MulticastLoopback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MulticastLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または発信マルチキャスト パケットが送信元アプリケーションに配信されるかどうかを指定する値を設定します。</summary>
        <value>
          <see langword="true" />場合、<see cref="T:System.Net.Sockets.Socket" />出力方向のマルチキャスト パケットが受信それ以外の場合、<see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 マルチキャストは、インターネット上の多対多の通信用のスケーラブルな方法です。 マルチキャスト アドレスをサブスクライブしているプロセス次に、サブスクライブしているプロセスが送信したすべてのパケットは、マルチキャスト アドレスをサブスクライブしている他のすべてのプロセスによって受信されます。  
  
 伝送制御プロトコル (TCP) ソケットにこのプロパティを設定する効果はありません。  
  
   
  
## Examples  
 使用を次のコード例に示します、<xref:System.Net.Sockets.Socket.MulticastLoopback%2A>プロパティです。  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="NoDelay">
      <MemberSignature Language="C#" Value="public bool NoDelay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NoDelay" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.NoDelay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定、<see cref="T:System.Boolean" />を指定する値かどうか、ストリーム<see cref="T:System.Net.Sockets.Socket" />Nagle アルゴリズムを使用しています。</summary>
        <value>
          <see langword="false" />場合、 <see cref="T:System.Net.Sockets.Socket" /> Nagle アルゴリズムを使用して、それ以外の<see langword="true" />します。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nagle アルゴリズムは、ソケット バッファーの小さなパケットを結合し、特定の状況で 1 つのパケットで送信したりすることで、ネットワーク トラフィックを減らすために設計されています。 TCP パケットは、header、および送信されるデータの 40 バイトで構成されます。 Tcp の小さいデータ パケットが送信されると、TCP ヘッダーに起因するオーバーヘッドは、ネットワーク トラフィックのかなりの部分になります。負荷の高いネットワークでは、このオーバーヘッドの結果として得られる輻輳失われたデータグラムと再送信、だけでなく輻輳による過剰な伝達時間なることができます。 Nagle アルゴリズムでは、送信の新しい TCP segmentswhen 新しい未確認の接続で previouslytransmitted データが残っている場合、ユーザーから到着するデータを送信を禁止します。  
  
 ネットワーク アプリケーションの大部分は、Nagle アルゴリズムを使用する必要があります。  
  
 ユーザー データグラム プロトコル (UDP) ソケットにこのプロパティを設定しても影響します。  
  
   
  
## Examples  
 使用を次のコード例に示します、<xref:System.Net.Sockets.Socket.NoDelay%2A>プロパティです。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">アクセスしようとするときにエラーが発生しました、<see cref="T:System.Net.Sockets.Socket" />です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>基になるオペレーティング システムおよびネットワーク アダプターが、インターネット プロトコル バージョン 4 (IPv4) をサポートするかどうかを示します。</summary>
        <value>
          <see langword="true" />オペレーティング システムおよびネットワーク アダプターの IPv4 プロトコルをサポートしている場合それ以外の場合、<see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 オペレーティング システムでは、IPv4 と IPv6 の両方のプロトコルをサポート可能性があります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>基になるオペレーティング システムおよびネットワーク アダプターが、インターネット プロトコル バージョン 6 (IPv6) をサポートするかどうかを示します。</summary>
        <value>
          <see langword="true" />場合は、IPv6 プロトコルをサポートしているオペレーティング システムおよびネットワーク アダプターそれ以外の場合、<see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 オペレーティング システムでは、IPv4 と IPv6 の両方のプロトコルをサポート可能性があります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Poll">
      <MemberSignature Language="C#" Value="public bool Poll (int microSeconds, System.Net.Sockets.SelectMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Poll(int32 microSeconds, valuetype System.Net.Sockets.SelectMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="microSeconds" Type="System.Int32" />
        <Parameter Name="mode" Type="System.Net.Sockets.SelectMode" />
      </Parameters>
      <Docs>
        <param name="microSeconds">マイクロ秒単位での応答を待機する時間。</param>
        <param name="mode"><see cref="T:System.Net.Sockets.SelectMode" /> 値のいずれか。</param>
        <summary>ステータスを決定、<see cref="T:System.Net.Sockets.Socket" />です。</summary>
        <returns>状態、<see cref="T:System.Net.Sockets.Socket" />で渡されるポーリング モード値に基づいて、<paramref name="mode" />パラメーター。  
  
 <list type="table"><listheader><term>モード  
  
 </term><description>戻り値  
  
 </description></listheader><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectRead" /></term><description><see langword="true" />場合<see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />が呼び出された時点で、接続が保留中です。  
  
 または  
  
 <see langword="true" />データを読み取ることがある場合  
  
 または  
  
 <see langword="true" />場合は、接続が閉じ、リセット、または終了します。  
  
 返しますそれ以外の場合、<see langword="false" />です。  
  
 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectWrite" /></term><description><see langword="true" />を処理している場合、 <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />、との接続は成功しました。  
  
 または  
  
 <see langword="true" />データを送信することができます。 場合、  
  
 返しますそれ以外の場合、<see langword="false" />です。  
  
 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectError" /></term><description><see langword="true" />処理している場合、<see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />がブロックしないと、接続が失敗しました。  
  
 または  
  
 <see langword="true" />場合<see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" />がセットと帯域外のデータは使用できません。  
  
 返しますそれ以外の場合、<see langword="false" />です。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Poll%2A>メソッドの状態を確認、<xref:System.Net.Sockets.Socket>です。 指定<xref:System.Net.Sockets.SelectMode?displayProperty=nameWithType>の`selectMode`パラメーターかどうかを<xref:System.Net.Sockets.Socket>を読み取ることができます。 指定<xref:System.Net.Sockets.SelectMode?displayProperty=nameWithType>かどうかを<xref:System.Net.Sockets.Socket>が書き込み可能です。 使用して<xref:System.Net.Sockets.SelectMode?displayProperty=nameWithType>エラー状態を検出するためにします。 <xref:System.Net.Sockets.Socket.Poll%2A>単位で指定された期間までの実行がブロックされます`microseconds`が経過しました。 設定、`microSeconds`の応答を無限に待機する場合は負の整数へのパラメーターです。 複数のソケットの状態を確認するには、使用を好む場合がある、<xref:System.Net.Sockets.Socket.Select%2A>メソッドです。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメソッドは、切断されたネットワーク ケーブルなどの接続に関する問題の特定の種類を検出できない場合や、リモート ホストが異常停止されたことです。 このようなエラーを検出するためにデータの送受信を送信しようとする必要があります。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例は、ソケットを作成しは、サーバーに接続を使用して<xref:System.Net.Sockets.Socket.Poll%2A>ソケットの状態を確認します。  
  
 [!code-cpp[SelectModeExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SelectModeExample/CPP/source.cpp#1)]
 [!code-csharp[SelectModeExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SelectModeExample/CS/source.cs#1)]
 [!code-vb[SelectModeExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/SelectModeExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="mode" />パラメーターは、のいずれかではない、<see cref="T:System.Net.Sockets.SelectMode" />値。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 以下の「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="ProtocolType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.ProtocolType ProtocolType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.ProtocolType ProtocolType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ProtocolType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.ProtocolType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>プロトコルの種類を取得、<see cref="T:System.Net.Sockets.Socket" />です。</summary>
        <value><see cref="T:System.Net.Sockets.ProtocolType" /> 値のいずれか。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ProtocolType%2A>場合、プロパティが設定、<xref:System.Net.Sockets.Socket>が作成されを使用するプロトコルを指定<xref:System.Net.Sockets.Socket>です。  
  
   
  
## Examples  
 次のコード例では表示、 <xref:System.Net.Sockets.AddressFamily>、 <xref:System.Net.Sockets.SocketType>、および<xref:System.Net.Sockets.ProtocolType>コンソールにします。  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">型の配列<see cref="T:System.Byte" />受信したデータの記憶域の場所はします。</param>
        <summary>バインドされたデータを受け取る<see cref="T:System.Net.Sockets.Socket" />受信バッファーにします。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A>メソッドがバッファー パラメーターにデータを読み取り、読み取られたバイト数を返します。 呼び出すことができます<xref:System.Net.Sockets.Socket.Receive%2A>接続指向とコネクションレス ソケットの両方からです。  
  
 のみこのオーバー ロードでは、受信バッファーを提供する必要があります。 バッファーの既定値は 0、サイズの既定値は、パラメーターの長さ、バッファー、オフセット、および<xref:System.Net.Sockets.SocketFlags>値の既定値は<xref:System.Net.Sockets.SocketFlags.None>します。  
  
 接続指向のプロトコルを使用している必要がありますか呼び出し<xref:System.Net.Sockets.Socket.Connect%2A>リモート ホスト接続を確立または<xref:System.Net.Sockets.Socket.Accept%2A>を呼び出す前に着信接続を受け入れるように<xref:System.Net.Sockets.Socket.Receive%2A>です。 <xref:System.Net.Sockets.Socket.Receive%2A>メソッドで確立されているリモート ホストから到着するデータを読み取るだけが、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドです。 コネクションレスのプロトコルを使用している場合は、使用することも、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドです。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>すべてのホストから着信するデータを受信できます。  
  
 読み取り、使用可能なデータがない場合、<xref:System.Net.Sockets.Socket.Receive%2A>しないデータがある、タイムアウト値を使用して設定された場合を除き、<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>です。 タイムアウト値を超えている場合、<xref:System.Net.Sockets.Socket.Receive%2A>呼び出しがスローされます、<xref:System.Net.Sockets.SocketException>です。 モードの非ブロッキングであるし、利用可能なデータがない場合、プロトコル スタック バッファー、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはすぐに完了し、スロー、<xref:System.Net.Sockets.SocketException>です。 使用することができます、<xref:System.Net.Sockets.Socket.Available%2A>プロパティ データが読み取り可能かを判断します。 ときに<xref:System.Net.Sockets.Socket.Available%2A>0 以外の場合は、受信操作を再試行してください。  
  
 接続指向を使用している場合<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドは、バッファーのサイズの最大使用可能な多くのデータを読み取る。 リモート ホストがシャット ダウンした場合、<xref:System.Net.Sockets.Socket>との接続、<xref:System.Net.Sockets.Socket.Shutdown%2A>メソッド、および利用可能なすべてのデータを受信、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはすぐに完了し、0 バイトを返します。  
  
 コネクションレス型を使用している場合<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>で指定した宛先アドレスの最初のキューに置かれたデータグラムを読み取り、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドです。 受信したデータグラムがのサイズよりも大きいかどうか、`buffer`パラメーター、`buffer`設定します。 メッセージの最初の部分に余分なデータは失われますと<xref:System.Net.Sockets.SocketException>がスローされます。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例は、接続上のデータを受け取る<xref:System.Net.Sockets.Socket>です。  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し履歴内の呼び出し元には、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるため。 関連する列挙値:<see cref="F:System.Net.NetworkAccess.Accept" />です。</permission>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="buffers">一連の<see cref="T:System.ArraySegment`1" />型の s<see cref="T:System.Byte" />受信したデータを格納しています。</param>
        <summary>バインドされたデータを受け取る<see cref="T:System.Net.Sockets.Socket" />受信バッファーの一覧にします。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、バッファー パラメーターにデータを読み取りますを正常に読み取られたバイト数を返します。 接続指向とコネクションレス ソケットの両方から呼び出すことができます。  
  
 このオーバー ロードでは、どちらかを指定する必要があります。 または以上の受信バッファー。  
  
 接続指向のプロトコルを使用している必要がありますか呼び出し<xref:System.Net.Sockets.Socket.Connect%2A>リモート ホスト接続を確立または<xref:System.Net.Sockets.Socket.Accept%2A>を呼び出す前に着信接続を受け入れるように<xref:System.Net.Sockets.Socket.Receive%2A>です。 <xref:System.Net.Sockets.Socket.Receive%2A>メソッドは、リモート ホストでの接続確立から到着するデータのみ読み取る、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドです。 コネクションレスのプロトコルを使用している場合は、使用することも、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドです。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>すべてのホストから着信するデータを受信できます。  
  
 読み取り、使用可能なデータがない場合、<xref:System.Net.Sockets.Socket.Receive%2A>しないデータがある、タイムアウト値を使用して設定された場合を除き、<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>です。 タイムアウト値を超えている場合、<xref:System.Net.Sockets.Socket.Receive%2A>呼び出しがスローされます、<xref:System.Net.Sockets.SocketException>です。 モードの非ブロッキングであるし、利用可能なデータがない場合、プロトコル スタック バッファー、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはすぐに完了し、スロー、<xref:System.Net.Sockets.SocketException>です。 使用することができます、<xref:System.Net.Sockets.Socket.Available%2A>プロパティ データが読み取り可能かを判断します。 ときに<xref:System.Net.Sockets.Socket.Available%2A>0 以外の場合は、受信操作を再試行してください。  
  
 接続指向を使用している場合<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドは、バッファーのサイズの最大使用可能な多くのデータを読み取る。 リモート ホストがシャット ダウンした場合、<xref:System.Net.Sockets.Socket>との接続、<xref:System.Net.Sockets.Socket.Shutdown%2A>メソッド、および利用可能なすべてのデータを受信、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはすぐに完了し、0 バイトを返します。  
  
 場合は、コネクションレス型を使用している<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>で指定した宛先アドレスから最初にキュー入れられたデータグラムを読み取り、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドです。 受信したデータグラムがのサイズよりも大きいかどうか、`buffers`パラメーター、`buffers`設定します。 メッセージの最初の部分に余分なデータは失われますと<xref:System.Net.Sockets.SocketException>がスローされます。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
 **注**このメンバーは、アプリケーションでネットワーク トレースを有効にする場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセス中にエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">型の配列<see cref="T:System.Byte" />受信したデータの記憶域の場所はします。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>バインドされたデータを受け取る<see cref="T:System.Net.Sockets.Socket" />受信バッファーに指定して<see cref="T:System.Net.Sockets.SocketFlags" />です。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A>メソッドがバッファー パラメーターにデータを読み取り、読み取られたバイト数を返します。 呼び出すことができます<xref:System.Net.Sockets.Socket.Receive%2A>接続指向とコネクションレス ソケットの両方からです。  
  
 このオーバー ロードだけ指定する必要が受信バッファーと、必要な<xref:System.Net.Sockets.SocketFlags>します。 バッファーのオフセットの既定値は 0 で、サイズの既定値はバイト パラメーターの長さ。  
  
 接続指向のプロトコルを使用している必要がありますか呼び出し<xref:System.Net.Sockets.Socket.Connect%2A>リモート ホスト接続を確立または<xref:System.Net.Sockets.Socket.Accept%2A>を呼び出す前に着信接続を受け入れるように<xref:System.Net.Sockets.Socket.Receive%2A>です。 <xref:System.Net.Sockets.Socket.Receive%2A>メソッドで確立されているリモート ホストから到着するデータを読み取るだけが、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドです。 コネクションレスのプロトコルを使用している場合は、使用することも、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドです。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>すべてのホストから着信するデータを受信できます。  
  
 読み取り、使用可能なデータがない場合、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはデータが読み取られるまでブロックします。 モードの非ブロッキングであるし、プロトコル スタック バッファーの使用可能なデータがない場合、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはすぐに完了し、スロー、<xref:System.Net.Sockets.SocketException>です。 使用することができます、<xref:System.Net.Sockets.Socket.Available%2A>プロパティ データが読み取り可能かを判断します。 ときに<xref:System.Net.Sockets.Socket.Available%2A>0 以外の場合は、再試行してください、受信操作します。  
  
 接続指向を使用している場合<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドは、バッファーのサイズの最大使用量のデータを読み取る。 リモート ホストがシャット ダウンした場合、<xref:System.Net.Sockets.Socket>との接続、<xref:System.Net.Sockets.Socket.Shutdown%2A>メソッド、および利用可能なすべてのデータを受信、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはすぐに完了し、0 バイトを返します。  
  
 場合は、コネクションレス型を使用している<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>で指定した宛先アドレスから最初にキュー入れられたデータグラムを読み取り、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドです。 受信したデータグラムがのサイズよりも大きいかどうか、`buffer`パラメーター、`buffer`設定します。 メッセージの最初の部分に余分なデータは失われますと<xref:System.Net.Sockets.SocketException>がスローされます。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例は、データ バッファーを指定し、<xref:System.Net.Sockets.SocketFlags>接続上のデータを受信するため<xref:System.Net.Sockets.Socket>です。  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し履歴内の呼び出し元には、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるため。 関連する列挙値:<see cref="F:System.Net.NetworkAccess.Accept" />です。</permission>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffers">一連の<see cref="T:System.ArraySegment`1" />型の s<see cref="T:System.Byte" />受信したデータを格納しています。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>バインドされたデータを受け取る<see cref="T:System.Net.Sockets.Socket" />、受信バッファーの一覧を指定して<see cref="T:System.Net.Sockets.SocketFlags" />です。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドにデータを読み込みます、`buffers`パラメーターと正常に読み取られたバイト数を返します。 接続指向とコネクションレス ソケットの両方から呼び出すことができます。  
  
 このオーバー ロードでは、どちらかを指定する必要があります。 または以上の受信バッファー。 <xref:System.Net.Sockets.SocketFlags>値の既定値は<xref:System.Net.Sockets.SocketFlags.None>します。  
  
 接続指向のプロトコルを使用している必要がありますか呼び出し<xref:System.Net.Sockets.Socket.Connect%2A>リモート ホスト接続を確立または<xref:System.Net.Sockets.Socket.Accept%2A>を呼び出す前に着信接続を受け入れるように<xref:System.Net.Sockets.Socket.Receive%2A>です。 <xref:System.Net.Sockets.Socket.Receive%2A>メソッドは、リモート ホストでの接続確立から到着するデータのみ読み取る、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドです。 コネクションレスのプロトコルを使用している場合は、使用することも、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドです。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>すべてのホストから着信するデータを受信できます。  
  
 読み取り、使用可能なデータがない場合、<xref:System.Net.Sockets.Socket.Receive%2A>しないデータがある、タイムアウト値を使用して設定された場合を除き、<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>です。 タイムアウト値を超えている場合、<xref:System.Net.Sockets.Socket.Receive%2A>スローされます、<xref:System.Net.Sockets.SocketException>です。 モードの非ブロッキングであるし、利用可能なデータがない場合、プロトコル スタック バッファー、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはすぐに完了し、スロー、<xref:System.Net.Sockets.SocketException>です。 使用することができます、<xref:System.Net.Sockets.Socket.Available%2A>プロパティ データが読み取り可能かを判断します。 ときに<xref:System.Net.Sockets.Socket.Available%2A>0 以外の場合は、受信操作を再試行してください。  
  
 接続指向を使用している場合<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドは、バッファーのサイズの最大使用可能な多くのデータを読み取る。 リモート ホストがシャット ダウンした場合、<xref:System.Net.Sockets.Socket>との接続、<xref:System.Net.Sockets.Socket.Shutdown%2A>メソッド、および利用可能なすべてのデータを受信、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはすぐに完了し、0 バイトを返します。  
  
 場合は、コネクションレス型を使用している<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>で指定した宛先アドレスから最初にキュー入れられたデータグラムを読み取り、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドです。 受信したデータグラムがのサイズよりも大きいかどうか、`buffers`パラメーター、`buffers`設定します。 メッセージの最初の部分に余分なデータは失われますと<xref:System.Net.Sockets.SocketException>がスローされます。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例は、接続上のデータを受信する方法を示します<xref:System.Net.Sockets.Socket>です。  
  
 [!code-cpp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CPP/sendgeneric.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CS/sendgeneric.cs#2)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> は <see langword="null" /> です。  
  
 または  
  
 <paramref name="buffers" />.カウントは 0 です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセス中にエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるため。 関連する列挙値:<see cref="F:System.Net.NetworkAccess.Accept" />です。</permission>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">型の配列<see cref="T:System.Byte" />受信したデータの記憶域の場所はします。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>指定したデータのバイト数をバインドから受信<see cref="T:System.Net.Sockets.Socket" />受信バッファーに指定して<see cref="T:System.Net.Sockets.SocketFlags" />です。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A>メソッドへのデータを読み取り、`buffer`パラメーターと正常に読み取られたバイト数を返します。 呼び出すことができます<xref:System.Net.Sockets.Socket.Receive%2A>接続指向とコネクションレス ソケットの両方からです。  
  
 このオーバー ロードだけが必要です、受信バッファー、バイトを受信して、必要な数を指定する<xref:System.Net.Sockets.SocketFlags>です。  
  
 接続指向のプロトコルを使用している必要がありますか呼び出し<xref:System.Net.Sockets.Socket.Connect%2A>リモート ホスト接続を確立または<xref:System.Net.Sockets.Socket.Accept%2A>を呼び出す前に着信接続を受け入れるように<xref:System.Net.Sockets.Socket.Receive%2A>です。 <xref:System.Net.Sockets.Socket.Receive%2A>メソッドで確立されているリモート ホストから到着するデータを読み取るだけが、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドです。 コネクションレスのプロトコルを使用している場合は、使用することも、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドです。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>すべてのホストから着信するデータを受信できます。  
  
 読み取り、使用可能なデータがない場合、<xref:System.Net.Sockets.Socket.Receive%2A>しないデータがある、タイムアウト値を使用して設定された場合を除き、<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>です。 タイムアウト値を超えている場合、<xref:System.Net.Sockets.Socket.Receive%2A>呼び出しがスローされます、<xref:System.Net.Sockets.SocketException>です。 モードの非ブロッキングであるし、利用可能なデータがない場合、プロトコル スタック バッファー、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはすぐに完了し、スロー、<xref:System.Net.Sockets.SocketException>です。 使用することができます、<xref:System.Net.Sockets.Socket.Available%2A>プロパティ データが読み取り可能かを判断します。 ときに<xref:System.Net.Sockets.Socket.Available%2A>0 以外の場合は、再試行してください、受信操作します。  
  
 接続指向を使用している場合<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドは、数で指定したバイトの使用可能な多くのデータを読み取る、`size`パラメーター。 リモート ホストがシャット ダウンした場合、<xref:System.Net.Sockets.Socket>との接続、<xref:System.Net.Sockets.Socket.Shutdown%2A>メソッド、および利用可能なすべてのデータを受信、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはすぐに完了し、0 バイトを返します。  
  
 コネクションレス型を使用している場合<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>で指定した宛先アドレスの最初のキューに置かれたデータグラムを読み取り、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドです。 受信したデータグラムがのサイズよりも大きいかどうか、`buffer`パラメーター、`buffer`設定します。 メッセージの最初の部分に余分なデータは失われますと<xref:System.Net.Sockets.SocketException>がスローされます。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次にデータを受信する`buffer`を指定して<xref:System.Net.Sockets.SocketFlags.None>の<xref:System.Net.Sockets.SocketFlags>します。  
  
 [!code-cpp[Socket_Send_Recieve#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Recieve/CPP/source.cpp#4)]
 [!code-csharp[Socket_Send_Recieve#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Recieve/CS/source.cs#4)]
 [!code-vb[Socket_Send_Recieve#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Recieve/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="size" />サイズを超える<paramref name="buffer" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し履歴内の呼び出し元には、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるため。 関連する列挙値:<see cref="F:System.Net.NetworkAccess.Accept" />です。</permission>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffers">一連の<see cref="T:System.ArraySegment`1" />型の s<see cref="T:System.Byte" />受信したデータを格納しています。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="errorCode">A<see cref="T:System.Net.Sockets.SocketError" />ソケット エラーを格納するオブジェクト。</param>
        <summary>バインドされたデータを受け取る<see cref="T:System.Net.Sockets.Socket" />、受信バッファーの一覧を指定して<see cref="T:System.Net.Sockets.SocketFlags" />です。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドにデータを読み込みます、`buffers`パラメーターと正常に読み取られたバイト数を返します。 接続指向とコネクションレス ソケットの両方から呼び出すことができます。  
  
 このオーバー ロードでは、どちらかを指定する必要があります。 または以上の受信バッファー。 <xref:System.Net.Sockets.SocketFlags>値の既定値は<xref:System.Net.Sockets.SocketFlags.None>します。  
  
 接続指向のプロトコルを使用している必要がありますか呼び出し<xref:System.Net.Sockets.Socket.Connect%2A>リモート ホスト接続を確立または<xref:System.Net.Sockets.Socket.Accept%2A>を呼び出す前に着信接続を受け入れるように<xref:System.Net.Sockets.Socket.Receive%2A>です。 <xref:System.Net.Sockets.Socket.Receive%2A>メソッドは、リモート ホストでの接続確立から到着するデータのみ読み取る、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドです。 コネクションレスのプロトコルを使用している場合は、使用することも、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドです。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>すべてのホストから着信するデータを受信できます。  
  
 読み取り、使用可能なデータがない場合、<xref:System.Net.Sockets.Socket.Receive%2A>しないデータがある、タイムアウト値を使用して設定された場合を除き、<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>です。 タイムアウト値を超えている場合、<xref:System.Net.Sockets.Socket.Receive%2A>スローされます、<xref:System.Net.Sockets.SocketException>です。 モードの非ブロッキングであるし、利用可能なデータがない場合、プロトコル スタック バッファー、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはすぐに完了し、スロー、<xref:System.Net.Sockets.SocketException>です。 使用することができます、<xref:System.Net.Sockets.Socket.Available%2A>プロパティ データが読み取り可能かを判断します。 ときに<xref:System.Net.Sockets.Socket.Available%2A>0 以外の場合は、受信操作を再試行してください。  
  
 接続指向を使用している場合<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドは、バッファーのサイズの最大使用可能な多くのデータを読み取る。 リモート ホストがシャット ダウンした場合、<xref:System.Net.Sockets.Socket>との接続、<xref:System.Net.Sockets.Socket.Shutdown%2A>メソッド、および利用可能なすべてのデータを受信、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはすぐに完了し、0 バイトを返します。  
  
 コネクションレス型を使用している場合<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>で指定した宛先アドレスの最初のキューに置かれたデータグラムを読み取り、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドです。 受信したデータグラムがのサイズよりも大きいかどうか、`buffers`パラメーター、`buffers`設定します。 メッセージの最初の部分に余分なデータは失われますと<xref:System.Net.Sockets.SocketException>がスローされます。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> は <see langword="null" /> です。  
  
 または  
  
 <paramref name="buffers" />.カウントは 0 です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセス中にエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるため。 関連する列挙値:<see cref="F:System.Net.NetworkAccess.Accept" />です。</permission>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの格納場所である、<see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">内の場所<c>バッファー</c>を受信したデータを格納します。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>指定したバイト数をバインドから受け取る<see cref="T:System.Net.Sockets.Socket" />受信バッファーの指定したオフセット位置に指定して<see cref="T:System.Net.Sockets.SocketFlags" />です。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A>メソッドがバッファー パラメーターにデータを読み取り、読み取られたバイト数を返します。 呼び出すことができます<xref:System.Net.Sockets.Socket.Receive%2A>接続指向とコネクションレス ソケットの両方からです。  
  
 接続指向のプロトコルを使用している必要がありますか呼び出し<xref:System.Net.Sockets.Socket.Connect%2A>リモート ホスト接続を確立または<xref:System.Net.Sockets.Socket.Accept%2A>を呼び出す前に着信接続を受け入れるように<xref:System.Net.Sockets.Socket.Receive%2A>です。 <xref:System.Net.Sockets.Socket.Receive%2A>メソッドで確立されているリモート ホストから到着するデータを読み取るだけが、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドです。 コネクションレスのプロトコルを使用している場合は、使用することも、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドです。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>すべてのホストから着信するデータを受信できます。  
  
 読み取り、使用可能なデータがない場合、<xref:System.Net.Sockets.Socket.Receive%2A>しないデータがある、タイムアウト値を使用して設定された場合を除き、<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>です。 タイムアウト値を超えている場合、<xref:System.Net.Sockets.Socket.Receive%2A>呼び出しがスローされます、<xref:System.Net.Sockets.SocketException>です。 モードの非ブロッキングであるし、利用可能なデータがない場合、プロトコル スタック バッファー、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはすぐに完了し、スロー、<xref:System.Net.Sockets.SocketException>です。 ソケットへのアクセスを試行しているときにエラーが発生しました。 以下の「解説」を参照してください。 使用することができます、<xref:System.Net.Sockets.Socket.Available%2A>プロパティ データが読み取り可能かを判断します。 ときに<xref:System.Net.Sockets.Socket.Available%2A>0 以外の場合は、受信操作を再試行してください。  
  
 接続指向を使用している場合<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドがサイズ パラメーターで指定したバイトの数までの使用可能な多くのデータを読み取る。 リモート ホストがシャット ダウンした場合、<xref:System.Net.Sockets.Socket>との接続、<xref:System.Net.Sockets.Socket.Shutdown%2A>メソッド、および利用可能なすべてのデータを受信、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはすぐに完了し、0 バイトを返します。  
  
 コネクションレス型を使用している場合<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>で指定した宛先アドレスの最初のキューに置かれたデータグラムを読み取り、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドです。 受信したデータグラムがのサイズよりも大きいかどうか、`buffer`パラメーター、`buffer`設定します。 メッセージの最初の部分に余分なデータは失われますと<xref:System.Net.Sockets.SocketException>がスローされます。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例は、接続上のデータを受信する前に、データ バッファー、オフセット、サイズ、およびソケット フラグを指定します。<xref:System.Net.Sockets.Socket>です。  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> が 0 未満です。  
  
 または  
  
 <paramref name="offset" />長さより大きい<paramref name="buffer" />です。  
  
 または  
  
 <paramref name="size" /> が 0 未満です。  
  
 または  
  
 <paramref name="size" />長さより大きい<paramref name="buffer" />負の値、<paramref name="offset" />パラメーター。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" />値の有効な組み合わせではありません。  
  
 または  
  
 <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" />プロパティが設定されませんでした。  
  
 または  
  
 <see cref="T:System.Net.Sockets.Socket" /> にアクセス中にオペレーティング システム エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し履歴内の呼び出し元には、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるため。 関連する列挙値:<see cref="F:System.Net.NetworkAccess.Accept" />です。</permission>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">型の配列<see cref="T:System.Byte" />受信したデータの記憶域の場所はします。</param>
        <param name="offset">内の位置、<c>バッファー</c>を受信したデータを格納するパラメーターです。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="errorCode">A<see cref="T:System.Net.Sockets.SocketError" />ソケット エラーを格納するオブジェクト。</param>
        <summary>バインドされたデータを受け取る<see cref="T:System.Net.Sockets.Socket" />受信バッファーに指定して<see cref="T:System.Net.Sockets.SocketFlags" />です。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A>メソッドがバッファー パラメーターにデータを読み取り、読み取られたバイト数を返します。 呼び出すことができます<xref:System.Net.Sockets.Socket.Receive%2A>接続指向とコネクションレス ソケットの両方からです。  
  
 接続指向のプロトコルを使用している必要がありますか呼び出し<xref:System.Net.Sockets.Socket.Connect%2A>リモート ホスト接続を確立または<xref:System.Net.Sockets.Socket.Accept%2A>を呼び出す前に着信接続を受け入れるように<xref:System.Net.Sockets.Socket.Receive%2A>です。 <xref:System.Net.Sockets.Socket.Receive%2A>メソッドで確立されているリモート ホストから到着するデータを読み取るだけが、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドです。 コネクションレスのプロトコルを使用している場合は、使用することも、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドです。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>すべてのホストから着信するデータを受信できます。  
  
 読み取り、使用可能なデータがない場合、<xref:System.Net.Sockets.Socket.Receive%2A>しないデータがある、タイムアウト値を使用して設定された場合を除き、<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>です。 タイムアウト値を超えている場合、<xref:System.Net.Sockets.Socket.Receive%2A>呼び出しがスローされます、<xref:System.Net.Sockets.SocketException>です。 モードの非ブロッキングであるし、利用可能なデータがない場合、プロトコル スタック バッファー、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはすぐに完了し、スロー、<xref:System.Net.Sockets.SocketException>です。 ソケットへのアクセスを試行しているときにエラーが発生しました。 以下の「解説」を参照してください。 使用することができます、<xref:System.Net.Sockets.Socket.Available%2A>プロパティ データが読み取り可能かを判断します。 ときに<xref:System.Net.Sockets.Socket.Available%2A>0 以外の場合は、受信操作を再試行してください。  
  
 接続指向を使用している場合<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドがサイズ パラメーターで指定したバイトの数までの使用可能な多くのデータを読み取る。 リモート ホストがシャット ダウンした場合、<xref:System.Net.Sockets.Socket>との接続、<xref:System.Net.Sockets.Socket.Shutdown%2A>メソッド、および利用可能なすべてのデータを受信、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはすぐに完了し、0 バイトを返します。  
  
 コネクションレス型を使用している場合<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>で指定した宛先アドレスの最初のキューに置かれたデータグラムを読み取り、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドです。 受信したデータグラムがのサイズよりも大きいかどうか、`buffer`パラメーター、`buffer`設定します。 メッセージの最初の部分に余分なデータは失われますと<xref:System.Net.Sockets.SocketException>がスローされます。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> が 0 未満です。  
  
 または  
  
 <paramref name="offset" />長さより大きい<paramref name="buffer" />です。  
  
 または  
  
 <paramref name="size" /> が 0 未満です。  
  
 または  
  
 <paramref name="size" />長さより大きい<paramref name="buffer" />負の値、<paramref name="offset" />パラメーター。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" />値の有効な組み合わせではありません。  
  
 または  
  
 <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> プロパティが設定されていません。  
  
 または  
  
 <see cref="T:System.Net.Sockets.Socket" /> にアクセス中にオペレーティング システム エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し履歴内の呼び出し元には、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるため。 関連する列挙値:<see cref="F:System.Net.NetworkAccess.Accept" />です。</permission>
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />この非同期ソケット操作に使用するオブジェクト。</param>
        <summary>非同期要求を接続からデータを受信開始<see cref="T:System.Net.Sockets.Socket" />オブジェクト。</summary>
        <returns>返します<see langword="true" />I/O 操作が保留中の場合。 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />でイベントを<paramref name="e" />パラメーターが操作の完了時に発生します。  
  
 返します<see langword="false" />場合は、I/O 操作が同期的に完了します。 ここで、<see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />でイベントを<paramref name="e" />パラメーターは発生しません。 と<paramref name="e" />操作の結果を取得するメソッドの呼び出しが戻った後にすぐに、パラメーターを調べることがありますとして渡されたオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveAsync%2A>メソッドを使用してのソケットまたはバインドされたコネクションレス ソケットを接続および着信データの読み取りに使用します。 ソケットのローカル アドレスは認識されている必要があります。  
  
 バインドのコネクションレス ソケットは、この関数は、受信したメッセージの受け入れ元となるアドレスを制限します。 関数には、接続で指定されたリモート アドレスからのメッセージのみを返します。 その他のアドレスからのメッセージが自動的に破棄されます。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType>プロパティを`e`パラメーターが読み取り要求に関する追加情報がウィンドウのソケットのサービス プロバイダーを提供します。 このパラメーターを使用する方法の詳細については、次を参照してください。<xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>です。  
  
 次のプロパティとイベントを<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>オブジェクトが正常にこのメソッドを呼び出す必要があります。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> または <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>場合<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>設定されています。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>場合<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>設定されています。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 呼び出し元の設定、<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>を呼び出す前に必要なすべてのユーザー状態オブジェクトのプロパティ、<xref:System.Net.Sockets.Socket.ReceiveAsync%2A>メソッド情報をコールバック メソッドで取得できるようにします。 コールバックは、1 つのオブジェクトより多くの情報を必要とする場合は、メンバーとして他の必要な状態情報を保持するために、小さいクラスを作成できます。  
  
 バイト ストリーム スタイルのソケットの受信データが、バッファーが指定された、接続を終了すると、または内部バッファー内のデータがなくなるまで、バッファーに配置されます。  
  
 関連付けられているバッファーの合計サイズの最大バッファーにメッセージ指向のソケットの場合は、受信メッセージが配置されて、`e`パラメーター。 メッセージがバッファーよりも大きい場合は、バッファーがメッセージの最初の部分が入力されます。  
  
 接続指向のソケットに対して、<xref:System.Net.Sockets.Socket.ReceiveAsync%2A>メソッドが正常に終了するかどうか、ソケットは、バイト ストリーム メッセージ指向に依存している 2 つの方法のいずれかで仮想回線を示すことができます。 バイト ストリーム、正常に閉じられたと以上のバイトを読み取ることが 0 バイトが読み取られたことを示します。 ここで、ゼロ バイトのメッセージがで使用できる多くの場合、メッセージ指向のソケットの<xref:System.Net.Sockets.SocketException>で、<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>ネイティブ Winsock WSAEDISCON エラー コード (10101) に設定が正常に閉じられたを示すために使用します。 いずれの場合、<xref:System.Net.Sockets.SocketException>で、<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>ネイティブ Winsock WSAECONNRESET に設定エラー コード (10054) を示す強制終了が発生しました。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">引数が無効です。 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />または<see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />プロパティを<paramref name="e" />パラメーターが有効なバッファーを参照する必要があります。 セットが、同時に両方のいずれか、またはこれらのプロパティの他の可能性があります。</exception>
        <exception cref="T:System.InvalidOperationException">ソケット操作が既に進行中の使用中、<see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />で指定されたオブジェクト、<paramref name="e" />パラメーター。</exception>
        <exception cref="T:System.NotSupportedException">Windows XP 以降はこのメソッドに必要です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveBufferSize">
      <MemberSignature Language="C#" Value="public int ReceiveBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定の受信バッファーのサイズを指定する値、<see cref="T:System.Net.Sockets.Socket" />です。</summary>
        <value><see cref="T:System.Int32" />受信バッファーのバイト単位のサイズを格納します。 既定値は 8192 です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 大きなバッファー サイズは可能性がある空の受信確認 (TCP パケット データ部分はありません) の数を削減は、接続に関する問題を認識を遅らせるも可能性があります。 大きなファイルを転送するか、高帯域幅、待機時間の長い接続 (サテライト ブロード バンド プロバイダーなどです。) を使用している場合は、バッファー サイズを増やすことを検討してください。  
  
   
  
## Examples  
 使用を次のコード例に示します、<xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A>プロパティです。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">設定操作に指定された値が 0 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの格納場所である、<see cref="T:System.Byte" /> 型の配列。</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" />、リモート サーバーを表す参照によって渡されます。</param>
        <summary>データ バッファーにデータグラムを受信し、エンドポイントを格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドへのデータを読み取り、`buffer`パラメーターが正常に読み取られたバイト数を返し、データの送信元となるリモート ホストのエンドポイントをキャプチャします。 このメソッドは、不明なホストまたは複数のホストからコネクションレス データグラムを受信する場合に便利です。  
  
 このオーバー ロードだけ指定する必要が receive `buffer`、および<xref:System.Net.EndPoint>リモート ホストを表すです。 バッファーは、既定値は 0 をオフセットします。 既定値の長さは、サイズ、`buffer`パラメーターおよび`socketFlags`値の既定値は<xref:System.Net.Sockets.SocketFlags.None>します。  
  
> [!NOTE]
>  呼び出しの前に<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>、明示的にバインドする必要があります、<xref:System.Net.Sockets.Socket>を使用して、ローカル エンドポイントを<xref:System.Net.Sockets.Socket.Bind%2A>メソッドです。 そうしない場合<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。  
  
 コネクションレスのプロトコルで<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>はローカル ネットワーク バッファーに書き込まれる最初のエンキューされたデータグラムを読み取ります。 受信したデータグラムがのサイズよりも大きいかどうか`buffer`、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドは入力`buffer`メッセージは、可能であれば、throw の多くで、<xref:System.Net.Sockets.SocketException>です。 信頼性の低いプロトコルを使用している場合、余分なデータが失われます。 信頼性の高いプロトコルを使用している場合、超過データは、サービス プロバイダーによって保持するを呼び出して取得することができます、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>のに十分な大きさのバッファーを持つメソッドです。  
  
 読み取り、使用可能なデータがない場合、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドはデータが読み取られるまでブロックします。 モードの非ブロッキングであるし、利用可能なデータがない場合、プロトコル スタック バッファー、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドはすぐに完了し、スロー、<xref:System.Net.Sockets.SocketException>です。 使用することができます、<xref:System.Net.Sockets.Socket.Available%2A>プロパティ データが読み取り可能かを判断します。 ときに<xref:System.Net.Sockets.Socket.Available%2A>0 以外の場合は、受信操作を再試行してください。  
  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>向けコネクションレスのプロトコルを接続指向プロトコルも使用できます。 これを行う場合は、する必要がありますまずか、リモート ホスト接続を確立するを呼び出して、<xref:System.Net.Sockets.Socket.Connect%2A>メソッド着信リモートを受け入れるかを呼び出して接続をホスト、<xref:System.Net.Sockets.Socket.Accept%2A>メソッドです。 確立したり、接続を呼び出す前に許可しない場合、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドが表示されます、<xref:System.Net.Sockets.SocketException>です。 呼び出しの前にコネクションレスのプロトコルの既定のリモート ホストを確立することも、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドです。 このような場合は、のいずれかで、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドは無視されます、`remoteEP`パラメーターとのみデータが、接続されているまたは既定のリモート ホストを受信します。  
  
 接続指向のソケットと<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>のサイズの最大使用量のデータを読み取る`buffer`です。 リモート ホストがシャット ダウンした場合、<xref:System.Net.Sockets.Socket>との接続、<xref:System.Net.Sockets.Socket.Shutdown%2A>メソッド、および利用可能なすべてのデータを受信、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドはすぐに完了し、0 バイトを返します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily>の<xref:System.Net.EndPoint>で使用される<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>と一致する必要があります、<xref:System.Net.Sockets.AddressFamily>の<xref:System.Net.EndPoint>で使用される<xref:System.Net.Sockets.Socket.SendTo%2A>です。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例では、リモート ホストからコネクションレス データグラムを受信します。  
  
 [!code-cpp[Socket_Sync_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Sync_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Sync_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="remoteEP" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し履歴内の呼び出し元には、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるため。 関連する列挙値:<see cref="F:System.Net.NetworkAccess.Accept" />です。</permission>
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">型の配列<see cref="T:System.Byte" />受信したデータの記憶域の場所はします。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" />、リモート サーバーを表す参照によって渡されます。</param>
        <summary>指定して、データ バッファーのデータグラムを受信<see cref="T:System.Net.Sockets.SocketFlags" />、し、エンドポイントを格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドへのデータを読み取り、`buffer`パラメーターが正常に読み取られたバイト数を返し、データの送信元となるリモート ホストのエンドポイントをキャプチャします。 このメソッドは、不明なホストまたは複数のホストからコネクションレス データグラムを受信する場合に便利です。  
  
 このオーバー ロードだけ指定する必要が受信バッファー、必要な<xref:System.Net.Sockets.SocketFlags>、および<xref:System.Net.EndPoint>リモート ホストを表すです。 オフセットの既定値 0 およびサイズの既定値は、バッファーのパラメーターの長さ。  
  
> [!NOTE]
>  呼び出しの前に<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>、明示的にバインドする必要があります、<xref:System.Net.Sockets.Socket>を使用して、ローカル エンドポイントを<xref:System.Net.Sockets.Socket.Bind%2A>メソッドです。 そうしない場合<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。  
  
 コネクションレスのプロトコルで<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>はローカル ネットワーク バッファーに書き込まれる最初のエンキューされたデータグラムを読み取ります。 受信したデータグラムがのサイズよりも大きいかどうか`buffer`、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドは入力`buffer`メッセージは、可能であれば、throw の多くで、<xref:System.Net.Sockets.SocketException>です。 信頼性の低いプロトコルを使用している場合、余分なデータが失われます。 信頼性の高いプロトコルを使用している場合、超過データは、サービス プロバイダーによって保持するを呼び出して取得することができます、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>のに十分な大きさのバッファーを持つメソッドです。  
  
 読み取り、使用可能なデータがない場合、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドはデータが読み取られるまでブロックします。 モードの非ブロッキングであるし、利用可能なデータがない場合、プロトコル スタック バッファー、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドはすぐに完了し、スロー、<xref:System.Net.Sockets.SocketException>です。 使用することができます、<xref:System.Net.Sockets.Socket.Available%2A>プロパティ データが読み取り可能かを判断します。 ときに<xref:System.Net.Sockets.Socket.Available%2A>0 以外の場合は、受信操作を再試行してください。  
  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>向けコネクションレスのプロトコルを接続指向プロトコルも使用できます。 これを行う場合は、する必要がありますまずか、リモート ホスト接続を確立するを呼び出して、<xref:System.Net.Sockets.Socket.Connect%2A>メソッド着信リモートを受け入れるかを呼び出して接続をホスト、<xref:System.Net.Sockets.Socket.Accept%2A>メソッドです。 確立したり、接続を呼び出す前に許可しない場合、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドが表示されます、<xref:System.Net.Sockets.SocketException>です。 呼び出しの前にコネクションレスのプロトコルの既定のリモート ホストを確立することも、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドです。 このような場合は、のいずれかで、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドは無視されます、`remoteEP`パラメーターとのみデータが、接続されているまたは既定のリモート ホストを受信します。  
  
 接続指向のソケットと<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>のサイズの最大使用量のデータを読み取る`buffer`です。 リモート ホストがシャット ダウンした場合、<xref:System.Net.Sockets.Socket>との接続、<xref:System.Net.Sockets.Socket.Shutdown%2A>メソッド、および利用可能なすべてのデータを受信、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドはすぐに完了し、0 バイトを返します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily>の<xref:System.Net.EndPoint>で使用される<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>と一致する必要があります、<xref:System.Net.Sockets.AddressFamily>の<xref:System.Net.EndPoint>で使用される<xref:System.Net.Sockets.Socket.SendTo%2A>です。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例では、リモート ホストからコネクションレス データグラムを受信します。 <xref:System.Net.Sockets.SocketFlags>渡される、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドです。  
  
 [!code-cpp[Socket_Sync_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Sync_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Sync_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="remoteEP" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し履歴内の呼び出し元には、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるため。 関連する列挙値:<see cref="F:System.Net.NetworkAccess.Accept" />です。</permission>
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの格納場所である、<see cref="T:System.Byte" /> 型の配列。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" />、リモート サーバーを表す参照によって渡されます。</param>
        <summary>指定したバイト数を指定して、データ バッファーに受け取る<see cref="T:System.Net.Sockets.SocketFlags" />、し、エンドポイントを格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドへのデータを読み取り、`buffer`パラメーターが正常に読み取られたバイト数を返し、データの送信元となるリモート ホストのエンドポイントをキャプチャします。 このメソッドは、不明なホストまたは複数のホストからコネクションレス データグラムを受信する場合に便利です。  
  
 このオーバー ロードだけ指定する必要が、必要なを受信するバイト数、受信バッファー <xref:System.Net.Sockets.SocketFlags>、および<xref:System.Net.EndPoint>リモート ホストを表すです。 バッファーは、既定値は 0 をオフセットします。  
  
 コネクションレスのプロトコルで<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>はローカル ネットワーク バッファーに書き込まれる最初のエンキューされたデータグラムを読み取ります。 受信したデータグラムがのサイズよりも大きいかどうか`buffer`、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドは入力`buffer`メッセージは、可能であれば、throw の多くで、<xref:System.Net.Sockets.SocketException>です。 信頼性の低いプロトコルを使用している場合、余分なデータが失われます。 信頼性の高いプロトコルを使用している場合、超過データは、サービス プロバイダーによって保持するを呼び出して取得することができます、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>のに十分な大きさのバッファーを持つメソッドです。  
  
 読み取り、使用可能なデータがない場合、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドはデータが読み取られるまでブロックします。 モードの非ブロッキングであるし、利用可能なデータがない場合、プロトコル スタック バッファー、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドはすぐに完了し、スロー、<xref:System.Net.Sockets.SocketException>です。 使用することができます、<xref:System.Net.Sockets.Socket.Available%2A>プロパティ データが読み取り可能かを判断します。 ときに<xref:System.Net.Sockets.Socket.Available%2A>0 以外の場合は、受信操作を再試行してください。  
  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>向けコネクションレスのプロトコルを接続指向プロトコルも使用できます。 これを行う場合は、する必要がありますまずか、リモート ホスト接続を確立するを呼び出して、<xref:System.Net.Sockets.Socket.Connect%2A>メソッド着信リモートを受け入れるかを呼び出して接続をホスト、<xref:System.Net.Sockets.Socket.Accept%2A>メソッドです。 確立したり、接続を呼び出す前に許可しない場合、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドが表示されます、<xref:System.Net.Sockets.SocketException>です。 呼び出しの前にコネクションレスのプロトコルの既定のリモート ホストを確立することも、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドです。 このような場合は、のいずれかで、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドは無視されます、`remoteEP`パラメーターとのみデータが、接続されているまたは既定のリモート ホストを受信します。  
  
 接続指向のソケットと<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>がで指定したバイトの数まで使用できる多くのデータを読み取り、`size`パラメーター。 リモート ホストがシャット ダウンした場合、<xref:System.Net.Sockets.Socket>との接続、<xref:System.Net.Sockets.Socket.Shutdown%2A>メソッド、および利用可能なすべてのデータを受信、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドはすぐに完了し、0 バイトを返します。  
  
> [!NOTE]
>  呼び出しの前に<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>、明示的にバインドする必要があります、<xref:System.Net.Sockets.Socket>を使用して、ローカル エンドポイントを<xref:System.Net.Sockets.Socket.Bind%2A>メソッドです。 そうしない場合<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily>の<xref:System.Net.EndPoint>で使用される<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>と一致する必要があります、<xref:System.Net.Sockets.AddressFamily>の<xref:System.Net.EndPoint>で使用される<xref:System.Net.Sockets.Socket.SendTo%2A>です。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例では、リモート ホストからコネクションレス データグラムを受信します。 バッファー サイズ、および<xref:System.Net.Sockets.SocketFlags>に渡される、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドです。  
  
 [!code-cpp[Socket_Sync_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Sync_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Sync_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="remoteEP" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="size" /> が 0 未満です。  
  
 または  
  
 <paramref name="size" />長さより大きい<paramref name="buffer" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" />値の有効な組み合わせではありません。  
  
 または  
  
 <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" />プロパティが設定されませんでした。  
  
 または  
  
 <see cref="T:System.Net.Sockets.Socket" /> にアクセス中にオペレーティング システム エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し履歴内の呼び出し元には、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるため。 関連する列挙値:<see cref="F:System.Net.NetworkAccess.Accept" />です。</permission>
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの格納場所である、<see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">内の位置、<c>バッファー</c>を受信したデータを格納するパラメーターです。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" />、リモート サーバーを表す参照によって渡されます。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用して、指定したバイト数のデータを受信して、データ バッファー内の指定した位置に格納します。またエンドポイントを格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドへのデータを読み取り、`buffer`パラメーターが正常に読み取られたバイト数を返し、データの送信元となるリモート ホストのエンドポイントをキャプチャします。 このメソッドは、不明なホストまたは複数のホストからコネクションレス データグラムを受信する場合に便利です。  
  
 コネクションレスのプロトコルで<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>はローカル ネットワーク バッファーに書き込まれる最初のエンキューされたデータグラムを読み取ります。 受信したデータグラムがのサイズよりも大きいかどうか`buffer`、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドは入力`buffer`メッセージは、可能であれば、throw の多くで、<xref:System.Net.Sockets.SocketException>です。 信頼性の低いプロトコルを使用している場合、余分なデータが失われます。 信頼性の高いプロトコルを使用している場合、超過データは、サービス プロバイダーによって保持するを呼び出して取得することができます、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>のに十分な大きさのバッファーを持つメソッドです。  
  
 読み取り、使用可能なデータがない場合、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドはデータが読み取られるまでブロックします。 モードの非ブロッキングであるし、利用可能なデータがない場合、プロトコル スタック バッファー、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドはすぐに完了し、スロー、<xref:System.Net.Sockets.SocketException>です。 使用することができます、<xref:System.Net.Sockets.Socket.Available%2A>プロパティ データが読み取り可能かを判断します。 ときに<xref:System.Net.Sockets.Socket.Available%2A>0 以外の場合は、受信操作を再試行してください。  
  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>向けコネクションレスのプロトコルを接続指向プロトコルも使用できます。 これを行う場合は、する必要がありますまずか、リモート ホスト接続を確立するを呼び出して、<xref:System.Net.Sockets.Socket.Connect%2A>メソッド着信リモートを受け入れるかを呼び出して接続をホスト、<xref:System.Net.Sockets.Socket.Accept%2A>メソッドです。 確立したり、接続を呼び出す前に許可しない場合、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドが表示されます、<xref:System.Net.Sockets.SocketException>です。 呼び出しの前にコネクションレスのプロトコルの既定のリモート ホストを確立することも、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドです。 このような場合は、のいずれかで、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドは無視されます、`remoteEP`パラメーターとのみデータが、接続されているまたは既定のリモート ホストを受信します。  
  
 接続指向のソケットと<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>はバイト単位で指定された量まで利用可能な量のデータを読み取り、`size`パラメーター。 リモート ホストがシャット ダウンした場合、<xref:System.Net.Sockets.Socket>との接続、<xref:System.Net.Sockets.Socket.Shutdown%2A>メソッド、および利用可能なすべてのデータを受信、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドはすぐに完了し、0 バイトを返します。  
  
> [!NOTE]
>  呼び出しの前に<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>、明示的にバインドする必要があります、<xref:System.Net.Sockets.Socket>を使用して、ローカル エンドポイントを<xref:System.Net.Sockets.Socket.Bind%2A>メソッドです。 そうしない場合<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily>の<xref:System.Net.EndPoint>で使用される<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>と一致する必要があります、<xref:System.Net.Sockets.AddressFamily>の<xref:System.Net.EndPoint>で使用される<xref:System.Net.Sockets.Socket.SendTo%2A>です。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例では、リモート ホストからコネクションレス データグラムを受信します。 オフセット、バッファー サイズ、および<xref:System.Net.Sockets.SocketFlags>に渡される、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドです。  
  
 [!code-cpp[Socket_Sync_Send_Receive#12](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#12)]
 [!code-csharp[Socket_Sync_Send_Receive#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#12)]
 [!code-vb[Socket_Sync_Send_Receive#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="remoteEP" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> が 0 未満です。  
  
 または  
  
 <paramref name="offset" />長さより大きい<paramref name="buffer" />です。  
  
 または  
  
 <paramref name="size" /> が 0 未満です。  
  
 または  
  
 <paramref name="size" />長さより大きい、<paramref name="buffer" />オフセット パラメーターの値を減算します。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" />値の有効な組み合わせではありません。  
  
 または  
  
 <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" />プロパティが設定されませんでした。  
  
 または  
  
 ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるため。 関連する列挙値:<see cref="F:System.Net.NetworkAccess.Accept" />です。</permission>
      </Docs>
    </Member>
    <Member MemberName="ReceiveFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />この非同期ソケット操作に使用するオブジェクト。</param>
        <summary>指定したネットワーク デバイスからデータを非同期的に受信を開始します。</summary>
        <returns>返します<see langword="true" />I/O 操作が保留中の場合。 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />でイベントを<paramref name="e" />パラメーターが操作の完了時に発生します。  
  
 返します<see langword="false" />場合は、I/O 操作が同期的に完了します。 ここで、<see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />でイベントを<paramref name="e" />パラメーターは発生しません。 と<paramref name="e" />操作の結果を取得するメソッドの呼び出しが戻った後にすぐに、パラメーターを調べることがありますとして渡されたオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A>コネクションレス ソケット上のデータを受信するには、主にメソッドを使用します。 ソケットのローカル アドレスは認識されている必要があります。  
  
 呼び出し元を設定する必要があります、<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>プロパティを<xref:System.Net.IPEndPoint>リモート ホストの元のデータを受信することです。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType>プロパティを`e`パラメーターが読み取り要求に関する追加情報がウィンドウのソケットのサービス プロバイダーを提供します。 このパラメーターを使用する方法の詳細については、次を参照してください。<xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>です。  
  
 次のプロパティとイベントを<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>オブジェクトが正常にこのメソッドを呼び出す必要があります。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 呼び出し元の設定、<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>を呼び出す前に必要なすべてのユーザー状態オブジェクトのプロパティ、<xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A>メソッド情報をコールバック メソッドで取得できるようにします。 コールバックは、1 つのオブジェクトより多くの情報を必要とする場合は、メンバーとして他の必要な状態情報を保持するために、小さいクラスを作成できます。  
  
 メッセージ指向のソケットでは、受信メッセージは、バッファーの合計サイズの最大バッファーに配置します。 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>と<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>プロパティは、バッファー内のデータの配置場所と、データの量を決定します。  
  
 バイト ストリーム – スタイルのソケットの受信データが、バッファーが指定された、接続を終了すると、または内部バッファー内のデータがなくなるまで、バッファーに配置されます。 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>と<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>プロパティは、バッファー内のデータの配置場所と、データの量を決定します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> Null にすることはできません。</exception>
        <exception cref="T:System.InvalidOperationException">ソケット操作が既に進行中の使用中、<see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />で指定されたオブジェクト、<paramref name="e" />パラメーター。</exception>
        <exception cref="T:System.NotSupportedException">Windows XP 以降はこのメソッドに必要です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int ReceiveMessageFrom (byte[] buffer, int offset, int size, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; remoteEP, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags&amp;" RefType="ref" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの格納場所である、<see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">内の位置、<c>バッファー</c>を受信したデータを格納するパラメーターです。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" />、リモート サーバーを表す参照によって渡されます。</param>
        <param name="ipPacketInformation">アドレスとインターフェイスの情報を保持する <see cref="T:System.Net.Sockets.IPPacketInformation" />。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用して、指定したバイト数のデータをデータ バッファー内の指定した位置で受信して、エンドポイントおよびパケット情報を格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>メソッドへのデータを読み取り、`buffer`パラメーターが正常に読み取られたバイト数を返し、データの送信元、受信したパケットに関する情報だけでなく、リモート ホストのエンドポイントをキャプチャします。  
  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>コネクションレス ソケットでメッセージ データを受信するには、主にメソッドを使用します。 ソケットのローカル アドレスは認識されている必要があります。 このメソッドは、データグラムと生のソケットとのみ使用できます。 ソケットの種類に設定されたソケットを初期化する必要があります<xref:System.Net.Sockets.SocketType.Dgram>または<xref:System.Net.Sockets.SocketType.Raw>このメソッドを呼び出す前にします。 これを使用して、ソケットを作成するとき<xref:System.Net.Sockets.Socket.%23ctor%2A>です。  
  
 メッセージ指向のソケットでは、受信メッセージに配置、`buffer`パラメーターで指定された合計サイズの最大、`size`パラメーター。 `offset`パラメーター内の場所を決定する、`buffer`データが配置されます。 配置している実際のデータ量、`buffer`によって返される、<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>メソッドです。  
  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>メソッドに自動的にメソッドを設定、<xref:System.Net.Sockets.SocketOptionName.PacketInformation>ソケット オプションに`true`初めて呼び出された、指定された<xref:System.Net.Sockets.Socket>です。 ただし、返された<xref:System.Net.Sockets.IPPacketInformation>オブジェクトがのみ有効になります、ソケット オプションが設定された後に、ローカル コンピューターに到達するパケットです。 ローカル エンドポイントにバインドされている場合、ソケットの間でパケットが送信する場合 (によって明示的に、<xref:System.Net.Sockets.Socket.Bind%2A>メソッドまたはの 1 つによって暗黙的に、 <xref:System.Net.Sockets.Socket.Connect%2A>、 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>、 <xref:System.Net.Sockets.Socket.SendTo%2A>、または<xref:System.Net.Sockets.Socket.SendToAsync%2A>メソッド) とその最初の呼び出し、<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>へのメソッドを呼び出し<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>メソッドは無効な<xref:System.Net.Sockets.IPPacketInformation>これらのパケットのオブジェクト。  
  
 ようにすべて<xref:System.Net.Sockets.IPPacketInformation>オブジェクトが有効で、アプリケーションを設定する必要があります、<xref:System.Net.Sockets.SocketOptionName.PacketInformation>ソケット オプションに`true`を使用して、ローカル エンドポイントにバインドされる前に、<xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29>メソッドです。  
  
 アプリケーションを調べることができます、`ipPacketInformation`ユニキャスト、マルチキャスト、またはブロードキャスト アドレスを使用してデータグラムが送信されたかを把握する必要がある場合のパラメーターです。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily>の<xref:System.Net.EndPoint>で使用される<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>と一致する必要があります、<xref:System.Net.Sockets.AddressFamily>の<xref:System.Net.EndPoint>で使用される<xref:System.Net.Sockets.Socket.SendTo%2A>です。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。  
  
 \-または、  
  
 <paramref name="remoteEP" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> が 0 未満です。  
  
 または  
  
 <paramref name="offset" />長さより大きい<paramref name="buffer" />です。  
  
 または  
  
 <paramref name="size" /> が 0 未満です。  
  
 または  
  
 <paramref name="size" />長さより大きい、<paramref name="buffer" />オフセット パラメーターの値を減算します。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" />値の有効な組み合わせではありません。  
  
 または  
  
 <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" />プロパティが設定されませんでした。  
  
 または  
  
 .NET Framework は、AMD 64 ビット プロセッサで実行されています。  
  
 または  
  
 ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">オペレーティング システムが Windows 2000 以前のバージョン、および、このメソッドには、Windows XP が必要です。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるため。 関連する列挙値:<see cref="F:System.Net.NetworkAccess.Accept" />です。</permission>
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveMessageFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveMessageFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />この非同期ソケット操作に使用するオブジェクト。</param>
        <summary>指定して、データ バッファー内の指定位置に指定されたデータのバイト数を非同期に受け取る開始<see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" />、し、エンドポイントとパケットの情報を格納します。</summary>
        <returns>返します<see langword="true" />I/O 操作が保留中の場合。 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />でイベントを<paramref name="e" />パラメーターが操作の完了時に発生します。  
  
 返します<see langword="false" />場合は、I/O 操作が同期的に完了します。 ここで、<see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />でイベントを<paramref name="e" />パラメーターは発生しません。 と<paramref name="e" />操作の結果を取得するメソッドの呼び出しが戻った後にすぐに、パラメーターを調べることがありますとして渡されたオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>コネクションレス ソケットでメッセージ データを受信するには、主にメソッドを使用します。 ソケットのローカル アドレスは認識されている必要があります。 このメソッドは、データグラムと生のソケットとのみ使用できます。 ソケットの種類に設定されたソケットを初期化する必要があります<xref:System.Net.Sockets.SocketType.Dgram>または<xref:System.Net.Sockets.SocketType.Raw>このメソッドを呼び出す前にします。 これを使用して、ソケットを作成するとき<xref:System.Net.Sockets.Socket.%23ctor%2A>です。  
  
 呼び出し元を設定する必要があります、<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>プロパティを<xref:System.Net.IPEndPoint>リモート ホストの元のデータを受信することです。  
  
 次のプロパティとイベントを<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>オブジェクトが正常にこのメソッドを呼び出す必要があります。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 呼び出し元の設定、<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>を呼び出す前に必要なすべてのユーザー状態オブジェクトのプロパティ、<xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>メソッド情報をコールバック メソッドで取得できるようにします。 コールバックは、1 つのオブジェクトより多くの情報を必要とする場合は、メンバーとして他の必要な状態情報を保持するために、小さいクラスを作成できます。  
  
 メッセージ指向のソケットでは、受信メッセージは、バッファーの合計サイズの最大バッファーに配置します。 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>と<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>プロパティは、バッファー内のデータの配置場所と、データの量を決定します。  
  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>メソッドが自動的に設定、<xref:System.Net.Sockets.SocketOptionName.PacketInformation>ソケット オプションに`true`初めて呼び出された、指定された<xref:System.Net.Sockets.Socket>です。 ただし、<xref:System.Net.Sockets.IPPacketInformation>オブジェクトがのみ有効になります、ソケット オプションが設定された後に、ローカル コンピューターに到達するパケットです。 ソケットがローカル エンドポイントにバインドされている場合、ソケットの間でパケットが送信する場合 (によって明示的に、<xref:System.Net.Sockets.Socket.Bind%2A>メソッドまたはの 1 つによって暗黙的に、 <xref:System.Net.Sockets.Socket.Connect%2A>、 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>、 <xref:System.Net.Sockets.Socket.SendTo%2A>、または<xref:System.Net.Sockets.Socket.SendToAsync%2A>メソッド) および最初の呼び出し、<xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>へのメソッドを呼び出し<xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>メソッドは無効になります<xref:System.Net.Sockets.IPPacketInformation>これらのパケットのオブジェクト。  
  
 ようにすべて<xref:System.Net.Sockets.IPPacketInformation>オブジェクトが有効で、アプリケーションを設定する必要があります、<xref:System.Net.Sockets.SocketOptionName.PacketInformation>ソケット オプションに`true`を使用して、ローカル エンドポイントにバインドされる前に、<xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29>メソッドです。  
  
 アプリケーションは、その結果を調べることができます<xref:System.Net.Sockets.IPPacketInformation>オブジェクトのかどうか、ユニキャスト、マルチキャスト、またはブロードキャスト アドレスを使用してデータグラムが送信されたかを知る必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> Null にすることはできません。</exception>
        <exception cref="T:System.NotSupportedException">Windows XP 以降はこのメソッドに必要です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveTimeout">
      <MemberSignature Language="C#" Value="public int ReceiveTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>これまでの時間を指定する値の設定を取得または同期<see cref="Overload:System.Net.Sockets.Socket.Receive" />呼び出しがタイムアウトします。</summary>
        <value>タイムアウト値 (ミリ秒)。 既定値は 0、無限のタイムアウト期間を示します。 -1 を指定するには、無限のタイムアウト期間も示します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオプションを適用する同期<xref:System.Net.Sockets.Socket.Receive%2A>呼び出しのみです。 タイムアウト期間を超えた場合、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドがスローされます、<xref:System.Net.Sockets.SocketException>です。  
  
   
  
## Examples  
 使用を次のコード例に示します、<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A>プロパティです。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">設定操作に指定された値は、-1 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoteEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint RemoteEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint RemoteEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>リモート エンドポイントを取得します。</summary>
        <value><see cref="T:System.Net.EndPoint" />いる、<see cref="T:System.Net.Sockets.Socket" />が通信しています。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向のプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>プロパティを取得、<xref:System.Net.EndPoint>するリモート IP アドレスとポート番号を格納している、<xref:System.Net.Sockets.Socket>が接続されています。 コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>既定リモート IP アドレスとポート番号が含まれています、<xref:System.Net.Sockets.Socket>と通信します。 これをキャストする必要があります<xref:System.Net.EndPoint>を<xref:System.Net.IPEndPoint>すべての情報を取得する前にします。 呼び出すことができます、<xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType>リモートを取得する方法を<xref:System.Net.IPAddress>、および<xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType>をリモートのポート番号を取得する方法です。  
  
 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>いずれかへの呼び出し後に設定されている<xref:System.Net.Sockets.Socket.Accept%2A>または<xref:System.Net.Sockets.Socket.Connect%2A>です。 以前にこのプロパティにアクセスしようとする場合<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例では、取得し、ローカルおよびリモート エンドポイントを表示します。  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public static void Select (System.Collections.IList checkRead, System.Collections.IList checkWrite, System.Collections.IList checkError, int microSeconds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Select(class System.Collections.IList checkRead, class System.Collections.IList checkWrite, class System.Collections.IList checkError, int32 microSeconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="checkRead" Type="System.Collections.IList" />
        <Parameter Name="checkWrite" Type="System.Collections.IList" />
        <Parameter Name="checkError" Type="System.Collections.IList" />
        <Parameter Name="microSeconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="checkRead">読みやすさを確認する <see cref="T:System.Net.Sockets.Socket" /> インスタンスの <see cref="T:System.Collections.IList" />。</param>
        <param name="checkWrite"><see cref="T:System.Collections.IList" />の<see cref="T:System.Net.Sockets.Socket" />書き込みの許可を確認するインスタンス。</param>
        <param name="checkError"><see cref="T:System.Collections.IList" />の<see cref="T:System.Net.Sockets.Socket" />エラーをチェックするインスタンス。</param>
        <param name="microSeconds">タイムアウト値 (マイクロ秒)。 値が -1 の場合は、タイムアウトが無限であることを示します。</param>
        <summary>1 つまたは複数のソケットのステータスを判断します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Select%2A>1 つまたは複数のステータスを決定する静的メソッドは、<xref:System.Net.Sockets.Socket>インスタンス。 1 つまたは複数のソケットを配置する必要があります、<xref:System.Collections.IList>使用する前に、<xref:System.Net.Sockets.Socket.Select%2A>メソッドです。 読みやすさを呼び出して確認<xref:System.Net.Sockets.Socket.Select%2A>で、<xref:System.Collections.IList>として、`checkRead`パラメーター。 確認するには、どうを使用して、`checkWrite`パラメーター。 エラー条件を検出するため使用`checkError`です。 呼び出した後<xref:System.Net.Sockets.Socket.Select%2A>、<xref:System.Collections.IList>の条件を満たすソケットのみが格納されます。  
  
 リッスン状態の場合は、読みやすくすることを意味する呼び出し<xref:System.Net.Sockets.Socket.Accept%2A>ブロックすることがなくは成功します。 接続を受け入れている場合、読みやすさはデータが読み取り可能であるを意味します。 このような場合は、すべての受信操作はブロックすることがなく成功します。 読みやすくすることもあるかどうか、リモート<xref:System.Net.Sockets.Socket>がシャット ダウン接続以外の場合はそのケースへの呼び出し<xref:System.Net.Sockets.Socket.Receive%2A>は返されたゼロのバイト数で、すぐに戻ります。  
  
 <xref:System.Net.Sockets.Socket.Select%2A>時に返す目的のソケットの少なくとも 1 つ (におけるソケット、 `checkRead`、 `checkWrite`、および`checkError`を一覧表示) が、指定した条件を満たしている、または`microSeconds`パラメーターを超過すると、どちらか早い方です。 設定`microSeconds`を-1 に無限のタイムアウトを指定します。  
  
 非ブロッキング呼び出しを行う場合<xref:System.Net.Sockets.Socket.Connect%2A>、書き込みの許可が正常に接続していることを意味します。 確立された接続がある場合、書き込みの許可は、すべての送信操作はブロックすることがなく成功を意味します。  
  
 非ブロッキング呼び出しを行ったかどうか<xref:System.Net.Sockets.Socket.Connect%2A>、`checkerror`パラメーターが正常に接続されていないソケットを識別します。  
  
> [!NOTE]
>  使用して、<xref:System.Net.Sockets.Socket.Poll%2A>メソッドの場合は、1 つの状態を判別する<xref:System.Net.Sockets.Socket>です。  
  
> [!NOTE]
>  このメソッドは、切断されたネットワーク ケーブルなどの接続に関する問題の特定の種類を検出できない場合や、リモート ホストが異常停止されたことです。 このようなエラーを検出するためにデータの送受信を送信しようとする必要があります。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
   
  
## Examples  
 次のコード例では<xref:System.Net.Sockets.Socket.Select%2A>接続要求をリッスンしているソケットを決定します。  
  
 [!code-cpp[Socket_Select#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Select/CPP/source.cpp#1)]
 [!code-csharp[Socket_Select#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Select/CS/source.cs#1)]
 [!code-vb[Socket_Select#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Select/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="checkRead" /> パラメーターは <see langword="null" /> または空です。  
  
 および  
  
 <paramref name="checkWrite" /> パラメーターは <see langword="null" /> または空です。  
  
 および  
  
 <paramref name="checkError" /> パラメーターは <see langword="null" /> または空です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</param>
        <summary>接続されたデータを送信<see cref="T:System.Net.Sockets.Socket" />です。</summary>
        <returns>送信されたバイト数、<see cref="T:System.Net.Sockets.Socket" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A>指定されたリモート ホストにデータを同期的に送信、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドを正常に送信したバイト数を返します。 <xref:System.Net.Sockets.Socket.Send%2A>接続指向とコネクションレス プロトコルの両方を使用できます。  
  
 このオーバー ロードには、送信するデータを格納しているバッファーが必要です。 <xref:System.Net.Sockets.SocketFlags>を 0 に初期値として、バッファーのオフセットの既定値は 0、およびバッファーのサイズを既定値を送信するバイト数。  
  
 コネクションレスのプロトコルを使用している場合を呼び出す必要があります<xref:System.Net.Sockets.Socket.Connect%2A>このメソッドを呼び出す前に、または<xref:System.Net.Sockets.Socket.Send%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 いずれかを使用する必要があります、接続指向プロトコルを使用している場合<xref:System.Net.Sockets.Socket.Connect%2A>リモート ホスト接続を確立するかを使用して<xref:System.Net.Sockets.Socket.Accept%2A>着信接続を受け入れるようにします。  
  
 使用する必要があります複数の異なるホストにデータを送信する、コネクションレスのプロトコルとプランを使用している場合、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドです。 使用しない場合、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドを呼び出す必要が<xref:System.Net.Sockets.Socket.Connect%2A>への各呼び出しの前に<xref:System.Net.Sockets.Socket.Send%2A>です。 使用することができます<xref:System.Net.Sockets.Socket.SendTo%2A>で既定のリモート ホストを確立した後でも<xref:System.Net.Sockets.Socket.Connect%2A>です。 呼び出しの前に既定のリモート ホストを変更することもできます。<xref:System.Net.Sockets.Socket.Send%2A>を別の呼び出しを行って<xref:System.Net.Sockets.Socket.Connect%2A>です。  
  
 接続指向のプロトコルを使用している場合<xref:System.Net.Sockets.Socket.Send%2A>を使用して、タイムアウトが設定されていない限り、すべてのバッファー内のバイトを送信するまでブロックされます<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>です。 タイムアウト値を超えている場合、<xref:System.Net.Sockets.Socket.Send%2A>呼び出しがスローされます、<xref:System.Net.Sockets.SocketException>です。 モードでは非ブロッキング、<xref:System.Net.Sockets.Socket.Send%2A>送信バッファー内のバイト数より小さい場合でも正常に完了場合があります。 送信されたバイト数を追跡して、アプリケーションが、バッファー内のバイトを送信するまで、操作を再試行する、アプリケーションの責任です。 また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに基になるシステムは大量の送信データが収集されるまでに伝送を遅れる可能性があります。 正常に完了する、<xref:System.Net.Sockets.Socket.Send%2A>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されることは示しません。 転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されている場合を除きがブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例を示しますに接続されたデータの送信<xref:System.Net.Sockets.Socket>です。  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="buffers">一連の<see cref="T:System.ArraySegment`1" />型の s<see cref="T:System.Byte" />送信されるデータを格納しています。</param>
        <summary>一覧内のバッファー セットの接続に送信<see cref="T:System.Net.Sockets.Socket" />です。</summary>
        <returns>送信されたバイト数、<see cref="T:System.Net.Sockets.Socket" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A>接続指向とコネクションレス プロトコルの両方を使用できます。  
  
 このオーバー ロードには、送信するデータを含む、少なくとも 1 つのバッファーが必要です。  
  
 コネクションレスのプロトコルを使用している場合を呼び出す必要があります<xref:System.Net.Sockets.Socket.Connect%2A>このメソッドを呼び出す前に、または<xref:System.Net.Sockets.Socket.Send%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 いずれかを使用する必要があります、接続指向プロトコルを使用している場合<xref:System.Net.Sockets.Socket.Connect%2A>リモート ホスト接続を確立するかを使用して<xref:System.Net.Sockets.Socket.Accept%2A>着信接続を受け入れるようにします。  
  
 使用する必要があります複数の異なるホストにデータを送信する、コネクションレスのプロトコルとプランを使用している場合、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドです。 使用しない場合、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドを呼び出す必要が<xref:System.Net.Sockets.Socket.Connect%2A>への各呼び出しの前に<xref:System.Net.Sockets.Socket.Send%2A>です。 使用することができます<xref:System.Net.Sockets.Socket.SendTo%2A>で既定のリモート ホストを確立した後でも<xref:System.Net.Sockets.Socket.Connect%2A>です。 呼び出しの前に既定のリモート ホストを変更することもできます。<xref:System.Net.Sockets.Socket.Send%2A>を別の呼び出しを行って<xref:System.Net.Sockets.Socket.Connect%2A>です。  
  
 接続指向のプロトコルを使用している場合<xref:System.Net.Sockets.Socket.Send%2A>を使用して、タイムアウトが設定されていない限り、すべてのバッファー内のバイトを送信するまでブロックされます<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>です。 タイムアウト値を超えている場合、<xref:System.Net.Sockets.Socket.Send%2A>呼び出しがスローされます、<xref:System.Net.Sockets.SocketException>です。 モードでは非ブロッキング、<xref:System.Net.Sockets.Socket.Send%2A>送信バッファー内のバイト数より小さい場合でも正常に完了場合があります。 送信されたバイト数を追跡して、アプリケーションが、バッファー内のバイトを送信するまで、操作を再試行する、アプリケーションの責任です。 また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに基になるシステムは大量の送信データが収集されるまでに伝送を遅れる可能性があります。 正常に完了する、<xref:System.Net.Sockets.Socket.Send%2A>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されることは示しません。 転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されている場合を除きがブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> が空です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>接続されたデータを送信<see cref="T:System.Net.Sockets.Socket" />指定して<see cref="T:System.Net.Sockets.SocketFlags" />です。</summary>
        <returns>送信されたバイト数、<see cref="T:System.Net.Sockets.Socket" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A>確立されているリモート ホストにデータを同期的に送信、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドを正常に送信したバイト数を返します。 <xref:System.Net.Sockets.Socket.Send%2A>接続指向とコネクションレス プロトコルの両方のメソッドを使用できます。  
  
 このオーバー ロードは、送信するデータを格納するバッファーとビットごとの組み合わせが必要です。<xref:System.Net.Sockets.SocketFlags>です。 バッファーは、既定値は 0、およびバッファーのサイズを既定値を送信するバイト数をオフセットします。 指定した場合、<xref:System.Net.Sockets.SocketFlags.DontRoute>としてフラグを設定、`socketflags`パラメーターの値に、データを送信すると、ルーティングされません。  
  
 コネクションレスのプロトコルを使用している場合を呼び出す必要があります<xref:System.Net.Sockets.Socket.Connect%2A>このメソッドを呼び出す前に、または<xref:System.Net.Sockets.Socket.Send%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 いずれかを使用する必要があります、接続指向プロトコルを使用している場合<xref:System.Net.Sockets.Socket.Connect%2A>リモート ホスト接続を確立するかを使用して<xref:System.Net.Sockets.Socket.Accept%2A>着信接続を受け入れるようにします。  
  
 使用する必要があります複数の異なるホストにデータを送信する、コネクションレスのプロトコルとプランを使用している場合、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドです。 使用しない場合、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドを呼び出す必要が、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドに対する各呼び出しの前に<xref:System.Net.Sockets.Socket.Send%2A>です。 使用することができます<xref:System.Net.Sockets.Socket.SendTo%2A>で既定のリモート ホストを確立した後でも<xref:System.Net.Sockets.Socket.Connect%2A>です。 呼び出しの前に既定のリモート ホストを変更することもできます。<xref:System.Net.Sockets.Socket.Send%2A>を別の呼び出しを行って<xref:System.Net.Sockets.Socket.Connect%2A>です。  
  
 接続指向のプロトコルを使用している場合<xref:System.Net.Sockets.Socket.Send%2A>を使用して、タイムアウトが設定されていない限り、すべてのバッファー内のバイトを送信するまでブロックされます<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>です。 タイムアウト値を超えている場合、<xref:System.Net.Sockets.Socket.Send%2A>呼び出しがスローされます、<xref:System.Net.Sockets.SocketException>です。 モードでは非ブロッキング、<xref:System.Net.Sockets.Socket.Send%2A>送信バッファー内のバイト数より小さい場合でも正常に完了場合があります。 送信されたバイト数を追跡して、アプリケーションが要求されたバイト数を送信するまで、操作を再試行する、アプリケーションの責任です。 また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに基になるシステムは大量の送信データが収集されるまでに伝送を遅れる可能性があります。 正常に完了する、<xref:System.Net.Sockets.Socket.Send%2A>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
> [!NOTE]
>  バッファーのサイズが、基になるサービス プロバイダーのパケットの最大サイズを超えていないことを確認する必要があります。 場合は、データグラムが送信されず<xref:System.Net.Sockets.Socket.Send%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されることは示しません。 転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されている場合を除きがブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例を示しますに接続されたデータの送信<xref:System.Net.Sockets.Socket>です。  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffers">一連の<see cref="T:System.ArraySegment`1" />型の s<see cref="T:System.Byte" />送信されるデータを格納しています。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>一覧内のバッファー セットの接続に送信<see cref="T:System.Net.Sockets.Socket" />を指定して<see cref="T:System.Net.Sockets.SocketFlags" />です。</summary>
        <returns>送信されたバイト数、<see cref="T:System.Net.Sockets.Socket" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードには、送信するデータを含む、少なくとも 1 つのバッファーが必要です。 <xref:System.Net.Sockets.SocketFlags>値の既定値は 0 です。 指定した場合、<xref:System.Net.Sockets.SocketFlags.DontRoute>としてフラグを設定、`socketFlags`パラメーターに、データを送信すると、ルーティングされません。  
  
 コネクションレスのプロトコルを使用している場合を呼び出す必要があります<xref:System.Net.Sockets.Socket.Connect%2A>このメソッドを呼び出す前に、または<xref:System.Net.Sockets.Socket.Send%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 いずれかを使用する必要があります、接続指向プロトコルを使用している場合<xref:System.Net.Sockets.Socket.Connect%2A>リモート ホスト接続を確立するかを使用して<xref:System.Net.Sockets.Socket.Accept%2A>着信接続を受け入れるようにします。  
  
 使用する必要があります複数の異なるホストにデータを送信する、コネクションレスのプロトコルとプランを使用している場合、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドです。 使用しない場合、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドを呼び出す必要が<xref:System.Net.Sockets.Socket.Connect%2A>への各呼び出しの前に<xref:System.Net.Sockets.Socket.Send%2A>です。 使用することができます<xref:System.Net.Sockets.Socket.SendTo%2A>で既定のリモート ホストを確立した後でも<xref:System.Net.Sockets.Socket.Connect%2A>です。 呼び出しの前に既定のリモート ホストを変更することもできます。<xref:System.Net.Sockets.Socket.Send%2A>を別の呼び出しを行って<xref:System.Net.Sockets.Socket.Connect%2A>です。  
  
 接続指向のプロトコルを使用している場合<xref:System.Net.Sockets.Socket.Send%2A>を使用して、タイムアウトが設定されていない限り、すべてのバッファー内のバイトを送信するまでブロックされます<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>です。 タイムアウト値を超えている場合、<xref:System.Net.Sockets.Socket.Send%2A>呼び出しがスローされます、<xref:System.Net.Sockets.SocketException>です。 モードでは非ブロッキング、<xref:System.Net.Sockets.Socket.Send%2A>送信バッファー内のバイト数より小さい場合でも正常に完了場合があります。 送信されたバイト数を追跡して、アプリケーションが、バッファー内のバイトを送信するまで、操作を再試行する、アプリケーションの責任です。 また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに基になるシステムは大量の送信データが収集されるまでに伝送を遅れる可能性があります。 正常に完了する、<xref:System.Net.Sockets.Socket.Send%2A>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されることは示しません。 転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されている場合を除きがブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> が空です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="size">送信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>指定したデータのバイト数を接続に送信<see cref="T:System.Net.Sockets.Socket" />を指定して<see cref="T:System.Net.Sockets.SocketFlags" />です。</summary>
        <returns>送信されたバイト数、<see cref="T:System.Net.Sockets.Socket" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A>確立されているリモート ホストにデータを同期的に送信、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドを正常に送信したバイト数を返します。 <xref:System.Net.Sockets.Socket.Send%2A>接続指向とコネクションレス プロトコルの両方を使用できます。  
  
 このオーバー ロードには、送信するバイト数といずれかのビットごとの組み合わせを送信するデータを格納するバッファーが必要です。<xref:System.Net.Sockets.SocketFlags>です。 指定した場合、<xref:System.Net.Sockets.SocketFlags.DontRoute>としてフラグを設定、`socketflags`パラメーターに、データを送信すると、ルーティングされません。  
  
 コネクションレスのプロトコルを使用している場合を呼び出す必要があります<xref:System.Net.Sockets.Socket.Connect%2A>このメソッドを呼び出す前に、または<xref:System.Net.Sockets.Socket.Send%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 いずれかを使用する必要があります、接続指向プロトコルを使用している場合<xref:System.Net.Sockets.Socket.Connect%2A>リモート ホスト接続を確立するかを使用して<xref:System.Net.Sockets.Socket.Accept%2A>着信接続を受け入れるようにします。  
  
 使用する必要があります複数の異なるホストにデータを送信する、コネクションレスのプロトコルとプランを使用している場合、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドです。 使用しない場合、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドを呼び出す必要が、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドに対する各呼び出しの前に、<xref:System.Net.Sockets.Socket.Send%2A>メソッドです。 使用することができます<xref:System.Net.Sockets.Socket.SendTo%2A>で既定のリモート ホストを確立した後でも<xref:System.Net.Sockets.Socket.Connect%2A>です。 呼び出しの前に既定のリモート ホストを変更することもできます。<xref:System.Net.Sockets.Socket.Send%2A>を別の呼び出しを行って<xref:System.Net.Sockets.Socket.Connect%2A>です。  
  
 接続指向プロトコルが<xref:System.Net.Sockets.Socket.Send%2A>を使用して、タイムアウトが設定されていない限り、要求されたバイト数を送信するまでブロックされます<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>です。 タイムアウト値を超えている場合、<xref:System.Net.Sockets.Socket.Send%2A>呼び出しがスローされます、<xref:System.Net.Sockets.SocketException>です。 モードでは非ブロッキング、<xref:System.Net.Sockets.Socket.Send%2A>送信を要求したバイト数よりも少ない場合でも正常に完了場合があります。 送信されたバイト数を追跡して、アプリケーションが要求されたバイト数を送信するまで、操作を再試行する、アプリケーションの責任です。 また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに基になるシステムは大量の送信データが収集されるまでに伝送を遅れる可能性があります。 正常に完了する、<xref:System.Net.Sockets.Socket.Send%2A>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
> [!NOTE]
>  サイズが、基になるサービス プロバイダーのパケットの最大サイズを超えていないことを確認する必要があります。 場合は、データグラムが送信されず<xref:System.Net.Sockets.Socket.Send%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されることは示しません。 転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されている場合を除きがブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例は、バッファーで見つかったデータを送信し、指定<xref:System.Net.Sockets.SocketFlags.None>の<xref:System.Net.Sockets.SocketFlags>します。  
  
 [!code-cpp[Socket_Sync_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Sync_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Sync_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="size" />0 未満か、バッファーのサイズを超えています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" />値の有効な組み合わせではありません。  
  
 または  
  
 ソケットへのアクセス中に、オペレーティング システム エラーが発生します。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffers">一連の<see cref="T:System.ArraySegment`1" />型の s<see cref="T:System.Byte" />送信されるデータを格納しています。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="errorCode">A<see cref="T:System.Net.Sockets.SocketError" />ソケット エラーを格納するオブジェクト。</param>
        <summary>一覧内のバッファー セットの接続に送信<see cref="T:System.Net.Sockets.Socket" />を指定して<see cref="T:System.Net.Sockets.SocketFlags" />です。</summary>
        <returns>送信されたバイト数、<see cref="T:System.Net.Sockets.Socket" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードには、送信するデータを含む、少なくとも 1 つのバッファーが必要です。 <xref:System.Net.Sockets.SocketFlags>値の既定値は 0 です。 指定した場合、<xref:System.Net.Sockets.SocketFlags.DontRoute>としてフラグを設定、`socketFlags`パラメーターに、データを送信すると、ルーティングされません。  
  
 コネクションレスのプロトコルを使用している場合を呼び出す必要があります<xref:System.Net.Sockets.Socket.Connect%2A>このメソッドを呼び出す前に、または<xref:System.Net.Sockets.Socket.Send%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 いずれかを使用する必要があります、接続指向プロトコルを使用している場合<xref:System.Net.Sockets.Socket.Connect%2A>リモート ホスト接続を確立するかを使用して<xref:System.Net.Sockets.Socket.Accept%2A>着信接続を受け入れるようにします。  
  
 使用する必要があります複数の異なるホストにデータを送信する、コネクションレスのプロトコルとプランを使用している場合、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドです。 使用しない場合、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドを呼び出す必要が<xref:System.Net.Sockets.Socket.Connect%2A>への各呼び出しの前に<xref:System.Net.Sockets.Socket.Send%2A>です。 使用することができます<xref:System.Net.Sockets.Socket.SendTo%2A>で既定のリモート ホストを確立した後でも<xref:System.Net.Sockets.Socket.Connect%2A>です。 呼び出しの前に既定のリモート ホストを変更することもできます。<xref:System.Net.Sockets.Socket.Send%2A>を別の呼び出しを行って<xref:System.Net.Sockets.Socket.Connect%2A>です。  
  
 接続指向のプロトコルを使用している場合<xref:System.Net.Sockets.Socket.Send%2A>を使用して、タイムアウトが設定されていない限り、すべてのバッファー内のバイトを送信するまでブロックされます<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>です。 タイムアウト値を超えている場合、<xref:System.Net.Sockets.Socket.Send%2A>呼び出しがスローされます、<xref:System.Net.Sockets.SocketException>です。 モードでは非ブロッキング、<xref:System.Net.Sockets.Socket.Send%2A>送信バッファー内のバイト数より小さい場合でも正常に完了場合があります。 送信されたバイト数を追跡して、アプリケーションが、バッファー内のバイトを送信するまで、操作を再試行する、アプリケーションの責任です。 また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに基になるシステムは大量の送信データが収集されるまでに伝送を遅れる可能性があります。 正常に完了する、<xref:System.Net.Sockets.Socket.Send%2A>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されることは示しません。 転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されている場合を除きがブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> が空です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">データの送信を開始する位置を示すデータ バッファー内の位置。</param>
        <param name="size">送信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>指定したオフセットから開始し、指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用して、指定したバイト数のデータを接続された <see cref="T:System.Net.Sockets.Socket" /> に送信します。</summary>
        <returns>送信されたバイト数、<see cref="T:System.Net.Sockets.Socket" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A>指定されたリモート ホストにデータを同期的に送信、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドを正常に送信したバイト数を返します。 <xref:System.Net.Sockets.Socket.Send%2A>接続指向とコネクションレス プロトコルの両方を使用できます。  
  
 指定した場合、オーバー ロードでは、<xref:System.Net.Sockets.SocketFlags.DontRoute>としてフラグを設定、`socketflags`パラメーターに、データを送信すると、ルーティングされません。  
  
 コネクションレスのプロトコルを使用している場合を呼び出す必要があります<xref:System.Net.Sockets.Socket.Connect%2A>このメソッドを呼び出す前に、または<xref:System.Net.Sockets.Socket.Send%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 いずれかを使用する必要があります、接続指向プロトコルを使用している場合<xref:System.Net.Sockets.Socket.Connect%2A>リモート ホスト接続を確立するかを使用して<xref:System.Net.Sockets.Socket.Accept%2A>着信接続を受け入れるようにします。  
  
 使用する必要があります複数の異なるホストにデータを送信する、コネクションレスのプロトコルとプランを使用している場合<xref:System.Net.Sockets.Socket.SendTo%2A>です。 使用しない場合<xref:System.Net.Sockets.Socket.SendTo%2A>を呼び出す必要が<xref:System.Net.Sockets.Socket.Connect%2A>への各呼び出しの前に<xref:System.Net.Sockets.Socket.Send%2A>です。 使用することが<xref:System.Net.Sockets.Socket.SendTo%2A>で既定のリモート ホストを確立した後でも<xref:System.Net.Sockets.Socket.Connect%2A>です。 呼び出しの前に既定のリモート ホストを変更することもできます。<xref:System.Net.Sockets.Socket.Send%2A>を別の呼び出しを行って<xref:System.Net.Sockets.Socket.Connect%2A>です。  
  
 サイズが、基になるサービス プロバイダーのパケットの最大サイズを超えていないことを確認するもあります。 場合は、データグラムが送信されず<xref:System.Net.Sockets.Socket.Send%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。  
  
 接続指向のプロトコルを使用している場合<xref:System.Net.Sockets.Socket.Send%2A>を使用して、タイムアウトが設定されていない限り、要求されたバイト数を送信するまでブロックされます<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>です。 タイムアウト値を超えている場合、<xref:System.Net.Sockets.Socket.Send%2A>呼び出しがスローされます、<xref:System.Net.Sockets.SocketException>です。 モードでは非ブロッキング、<xref:System.Net.Sockets.Socket.Send%2A>送信を要求したバイト数よりも少ない場合でも正常に完了場合があります。 送信されたバイト数を追跡して、アプリケーションが要求されたバイト数を送信するまで、操作を再試行する、アプリケーションの責任です。 また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに基になるシステムは大量の送信データが収集されるまでに伝送を遅れる可能性があります。 正常に完了する、<xref:System.Net.Sockets.Socket.Send%2A>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されることは示しません。 転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されている場合を除きがブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例は、データ バッファー、オフセット、サイズを指定します。 および<xref:System.Net.Sockets.SocketFlags>に接続されたデータを送信するため<xref:System.Net.Sockets.Socket>です。  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> が 0 未満です。  
  
 または  
  
 <paramref name="offset" />長さより大きい<paramref name="buffer" />です。  
  
 または  
  
 <paramref name="size" /> が 0 未満です。  
  
 または  
  
 <paramref name="size" />長さより大きい<paramref name="buffer" />負の値、<paramref name="offset" />パラメーター。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" />値の有効な組み合わせではありません。  
  
 または  
  
 <see cref="T:System.Net.Sockets.Socket" /> にアクセス中にオペレーティング システム エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">データの送信を開始する位置を示すデータ バッファー内の位置。</param>
        <param name="size">送信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="errorCode">A<see cref="T:System.Net.Sockets.SocketError" />ソケット エラーを格納するオブジェクト。</param>
        <summary>指定したデータのバイト数に、接続されている送信<see cref="T:System.Net.Sockets.Socket" />指定したオフセットで開始し、指定して、<see cref="T:System.Net.Sockets.SocketFlags" /></summary>
        <returns>送信されたバイト数、<see cref="T:System.Net.Sockets.Socket" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A>指定されたリモート ホストにデータを同期的に送信、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドを正常に送信したバイト数を返します。 <xref:System.Net.Sockets.Socket.Send%2A>接続指向とコネクションレス プロトコルの両方を使用できます。  
  
 指定した場合、オーバー ロードでは、<xref:System.Net.Sockets.SocketFlags.DontRoute>としてフラグを設定、`socketflags`パラメーターに、データを送信すると、ルーティングされません。  
  
 コネクションレスのプロトコルを使用している場合を呼び出す必要があります<xref:System.Net.Sockets.Socket.Connect%2A>このメソッドを呼び出す前に、または<xref:System.Net.Sockets.Socket.Send%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 いずれかを使用する必要があります、接続指向プロトコルを使用している場合<xref:System.Net.Sockets.Socket.Connect%2A>リモート ホスト接続を確立するかを使用して<xref:System.Net.Sockets.Socket.Accept%2A>着信接続を受け入れるようにします。  
  
 使用する必要があります複数の異なるホストにデータを送信する、コネクションレスのプロトコルとプランを使用している場合<xref:System.Net.Sockets.Socket.SendTo%2A>です。 使用しない場合<xref:System.Net.Sockets.Socket.SendTo%2A>を呼び出す必要が<xref:System.Net.Sockets.Socket.Connect%2A>への各呼び出しの前に<xref:System.Net.Sockets.Socket.Send%2A>です。 使用することが<xref:System.Net.Sockets.Socket.SendTo%2A>で既定のリモート ホストを確立した後でも<xref:System.Net.Sockets.Socket.Connect%2A>です。 呼び出しの前に既定のリモート ホストを変更することもできます。<xref:System.Net.Sockets.Socket.Send%2A>を別の呼び出しを行って<xref:System.Net.Sockets.Socket.Connect%2A>です。  
  
 サイズが、基になるサービス プロバイダーのパケットの最大サイズを超えていないことを確認するもあります。 場合は、データグラムが送信されず<xref:System.Net.Sockets.Socket.Send%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。  
  
 接続指向のプロトコルを使用している場合<xref:System.Net.Sockets.Socket.Send%2A>を使用して、タイムアウトが設定されていない限り、要求されたバイト数を送信するまでブロックされます<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>です。 タイムアウト値を超えている場合、<xref:System.Net.Sockets.Socket.Send%2A>呼び出しがスローされます、<xref:System.Net.Sockets.SocketException>です。 モードでは非ブロッキング、<xref:System.Net.Sockets.Socket.Send%2A>送信を要求したバイト数よりも少ない場合でも正常に完了場合があります。 送信されたバイト数を追跡して、アプリケーションが要求されたバイト数を送信するまで、操作を再試行する、アプリケーションの責任です。 また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに基になるシステムは大量の送信データが収集されるまでに伝送を遅れる可能性があります。 正常に完了する、<xref:System.Net.Sockets.Socket.Send%2A>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されることは示しません。 転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されている場合を除きがブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例は、データ バッファー、オフセット、サイズを指定します。 および<xref:System.Net.Sockets.SocketFlags>に接続されたデータを送信するため<xref:System.Net.Sockets.Socket>です。  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> が 0 未満です。  
  
 または  
  
 <paramref name="offset" />長さより大きい<paramref name="buffer" />です。  
  
 または  
  
 <paramref name="size" /> が 0 未満です。  
  
 または  
  
 <paramref name="size" />長さより大きい<paramref name="buffer" />負の値、<paramref name="offset" />パラメーター。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" />値の有効な組み合わせではありません。  
  
 または  
  
 <see cref="T:System.Net.Sockets.Socket" /> にアクセス中にオペレーティング システム エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public bool SendAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />この非同期ソケット操作に使用するオブジェクト。</param>
        <summary>接続されたデータを非同期的に送信<see cref="T:System.Net.Sockets.Socket" />オブジェクト。</summary>
        <returns>返します<see langword="true" />I/O 操作が保留中の場合。 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />でイベントを<paramref name="e" />パラメーターが操作の完了時に発生します。  
  
 返します<see langword="false" />場合は、I/O 操作が同期的に完了します。 ここで、<see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />でイベントを<paramref name="e" />パラメーターは発生しません。 と<paramref name="e" />操作の結果を取得するメソッドの呼び出しが戻った後にすぐに、パラメーターを調べることがありますとして渡されたオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SendAsync%2A>メソッドを使用して、接続指向のソケットで 1 つ以上のバッファーの送信データを書き込みます。 このメソッドこともできます、ただし、コネクションレス型のソケット接続操作でリモート ホストが指定されています。  
  
 <xref:System.Net.Sockets.Socket.SendAsync%2A>メソッドで確立されているリモート ホストへの非同期送信操作を開始、 <xref:System.Net.Sockets.Socket.Accept%2A>、 <xref:System.Net.Sockets.Socket.AcceptAsync%2A>、 <xref:System.Net.Sockets.Socket.BeginAccept%2A>、 <xref:System.Net.Sockets.Socket.BeginConnect%2A>、 <xref:System.Net.Sockets.Socket.Connect%2A>、または<xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッドです。  
  
 次のプロパティとイベントを<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>オブジェクトが正常にこのメソッドを呼び出す必要があります。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> または <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>場合<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>設定されています。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>場合<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>設定されています。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 呼び出し元の設定、<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>を呼び出す前に必要なすべてのユーザー状態オブジェクトのプロパティ、<xref:System.Net.Sockets.Socket.SendAsync%2A>メソッド情報をコールバック メソッドで取得できるようにします。 コールバックは、1 つのオブジェクトより多くの情報を必要とする場合は、メンバーとして他の必要な状態情報を保持するために、小さいクラスを作成できます。  
  
 <xref:System.Net.Sockets.Socket.SendAsync%2A>メソッドが例外をスロー最初に呼び出す必要はありません<xref:System.Net.Sockets.Socket.Accept%2A>、 <xref:System.Net.Sockets.Socket.AcceptAsync%2A>、 <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A>、 <xref:System.Net.Sockets.Socket.Connect%2A>、または<xref:System.Net.Sockets.Socket.ConnectAsync%2A>です。  
  
 呼び出す、<xref:System.Net.Sockets.Socket.SendAsync%2A>メソッドは、個別の実行スレッド内でデータを送信する機能を提供します。  
  
 メッセージ指向のソケットでは、基になる Windows sockets サービス プロバイダーのメッセージの最大サイズを超えないようにしないでください。 データが長すぎて、基になるサービス プロバイダーの場合は、データは送信されず<xref:System.Net.Sockets.Socket.SendAsync%2A>メソッドがスローされます、<xref:System.Net.Sockets.SocketException>で、<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>ネイティブ Winsock WSAEMSGSIZE エラー コード (10040) に設定します。  
  
 なおが正常に完了、<xref:System.Net.Sockets.Socket.SendAsync%2A>メソッドは、データが正常に送信されたことを指定していません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />または<see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />プロパティを<paramref name="e" />パラメーターが有効なバッファーを参照する必要があります。 セットが、同時に両方のいずれか、またはこれらのプロパティの他の可能性があります。</exception>
        <exception cref="T:System.InvalidOperationException">ソケット操作が既に進行中の使用中、<see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />で指定されたオブジェクト、<paramref name="e" />パラメーター。</exception>
        <exception cref="T:System.NotSupportedException">Windows XP 以降はこのメソッドに必要です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><see cref="T:System.Net.Sockets.Socket" />がまだ接続されていないかを使用して取得されませんでした、 <see cref="M:System.Net.Sockets.Socket.Accept" />、 <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />、または<see cref="Overload:System.Net.Sockets.Socket.BeginAccept" />、メソッドです。</exception>
      </Docs>
    </Member>
    <Member MemberName="SendBufferSize">
      <MemberSignature Language="C#" Value="public int SendBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定の送信バッファーのサイズを指定する値、<see cref="T:System.Net.Sockets.Socket" />です。</summary>
        <value><see cref="T:System.Int32" />送信バッファーのバイト単位のサイズを格納します。 既定値は 8192 です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 大きなバッファー サイズは、接続に関する問題を認識に遅れる可能性があります。 大きなファイルを転送するか、高帯域幅、待機時間の長い接続 (サテライト ブロード バンド プロバイダーなどです。) を使用している場合は、バッファー サイズを増やすことを検討してください。  
  
   
  
## Examples  
 使用を次のコード例に示します、<xref:System.Net.Sockets.Socket.SendBufferSize%2A>プロパティです。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">設定操作に指定された値が 0 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">送信されるファイルのパスと名前を含む <see cref="T:System.String" />。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <summary>ファイル送信<paramref name="fileName" />に接続された<see cref="T:System.Net.Sockets.Socket" />オブジェクトを<see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" />フラグを送信します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードは、そのファイルを送信`fileName`接続されたソケットにします。 `flags`パラメーターの既定値<xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread>(0)、および`preBuffer`と`postBuffer`パラメーターに既定の`null`します。 場合`fileName`されますが、ローカルのディレクトリでファイルの名前だけで識別可能性があります。 それ以外の場合、完全なパスとファイルの名前を指定する必要があります。 ワイルドカード ("..\\\myfile.txt") と UNC 共有名 ("\\\\\\\shared ディレクトリ\\\myfile.txt") はサポートされています。 ファイルが見つからない場合、例外<xref:System.IO.FileNotFoundException>がスローされます。  
  
 このメソッドを使用して、 `TransmitFile` Windows Sockets 2 API である関数。 詳細については、`TransmitFile`関数およびそのフラグは、MSDN ライブラリの Windows Sockets ドキュメントを参照してください。  
  
 <xref:System.Net.Sockets.Socket.SendFile%2A>指定されたリモート ホストにファイルを同期的に送信、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドです。 <xref:System.Net.Sockets.Socket.SendFile%2A>接続指向両方とコネクションレスのプロトコルを使用できます。  
  
 コネクションレスのプロトコルを使用している場合を呼び出す必要があります<xref:System.Net.Sockets.Socket.Connect%2A>それ以外の場合、このメソッドを呼び出す前に<xref:System.Net.Sockets.Socket.SendFile%2A>スロー、<xref:System.Net.Sockets.SocketException>例外。 いずれかを使用する必要があります、接続指向プロトコルを使用している場合<xref:System.Net.Sockets.Socket.Connect%2A>リモート ホスト接続を確立するかを使用して<xref:System.Net.Sockets.Socket.Accept%2A>着信接続を受け入れるようにします。  
  
 接続指向のプロトコルを使用している場合<xref:System.Net.Sockets.Socket.SendFile%2A>ファイルを送信するまでブロックします。 モードでは非ブロッキング、<xref:System.Net.Sockets.Socket.SendFile%2A>ファイル全体が送信される前に正常に完了場合があります。 送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに基になるシステムは大量の送信データが収集されるまでに伝送を遅れる可能性があります。 正常に完了する、<xref:System.Net.Sockets.Socket.SendFile%2A>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例は、作成しソケットを接続し、リモート ホストにファイルを送信します。 ファイル"test.txt"は、ローカル コンピューターのルート ディレクトリにあります。  
  
 [!code-cpp[NCLSocketEnhancements#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#3)]
 [!code-csharp[NCLSocketEnhancements#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">ソケットがリモート ホストに接続されていません。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />オブジェクトが閉じられました。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトはブロック モードではなく、この同期呼び出しを受け付けることができません。</exception>
        <exception cref="T:System.IO.FileNotFoundException">ファイル <paramref name="fileName" /> が見つかりませんでした。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="preBuffer" Type="System.Byte[]" />
        <Parameter Name="postBuffer" Type="System.Byte[]" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" />
      </Parameters>
      <Docs>
        <param name="fileName">送信されるファイルのパスと名前を含む <see cref="T:System.String" />。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <param name="preBuffer">A<see cref="T:System.Byte" />ファイルが送信される前に送信するデータを含む配列。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <param name="postBuffer">A<see cref="T:System.Byte" />ファイルが送信された後に送信するデータを格納する配列。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <param name="flags">1 つ以上の <see cref="T:System.Net.Sockets.TransmitFileOptions" /> 値。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.TransmitFileOptions" /> 値を使用して、接続された <see cref="T:System.Net.Sockets.Socket" /> オブジェクトにファイル <paramref name="fileName" /> およびデータのバッファーを送信します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードには、送信するファイルとビットごとの組み合わせの名が必要です。<xref:System.Net.Sockets.TransmitFileOptions>値。 `preBuffer`パラメーターには、ファイルの前にすべてのデータが含まれています。 `postBuffer`ファイルを使用するデータが含まれています。 場合`fileName`されますが、現在の作業ディレクトリでファイルの名前だけで識別可能性があります。 それ以外の場合、完全なパスとファイルの名前を指定する必要があります。 ワイルドカード ("..\\\myfile.txt") と UNC 共有名 ("\\\\\\\shared ディレクトリ\\\myfile.txt") はサポートされています。  
  
 `flags`パラメーターは、ファイルの転送に関する追加情報がウィンドウのソケット サービス プロバイダーを提供します。 このパラメーターを使用する方法の詳細については、次を参照してください。<xref:System.Net.Sockets.TransmitFileOptions>です。  
  
 このメソッドを使用して、 `TransmitFile` Windows Sockets 2 API である関数。 詳細については、`TransmitFile`関数およびそのフラグは、MSDN ライブラリの Windows Sockets ドキュメントを参照してください。  
  
 <xref:System.Net.Sockets.Socket.SendFile%2A>指定されたリモート ホストにファイルを同期的に送信、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドです。 <xref:System.Net.Sockets.Socket.SendFile%2A>接続指向両方とコネクションレスのプロトコルを使用できます。  
  
 コネクションレスのプロトコルを使用している場合を呼び出す必要があります<xref:System.Net.Sockets.Socket.Connect%2A>です。 このメソッドを呼び出す前にそれ以外の場合<xref:System.Net.Sockets.Socket.SendFile%2A>スロー、<xref:System.Net.Sockets.SocketException>です。 いずれかを使用する必要があります、接続指向プロトコルを使用している場合<xref:System.Net.Sockets.Socket.Connect%2A>リモート ホスト接続を確立するかを使用して<xref:System.Net.Sockets.Socket.Accept%2A>着信接続を受け入れるようにします。  
  
 接続指向のプロトコルを使用している場合<xref:System.Net.Sockets.Socket.SendFile%2A>ファイル全体を送信するまでブロックします。 モードでは非ブロッキング、<xref:System.Net.Sockets.Socket.SendFile%2A>ファイル全体が送信される前に正常に完了場合があります。 送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに基になるシステムは大量の送信データが収集されるまでに伝送を遅れる可能性があります。 正常に完了する、<xref:System.Net.Sockets.Socket.SendFile%2A>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例では、作成し、ソケットを接続します。 ファイル"test.txt"は、ローカル コンピューターのルート ディレクトリにあります。 この例では事前バッファリングと事後バッファリングのデータを作成し、ファイルのあるリモート ホストに送信します。 既定値<xref:System.Net.Sockets.TransmitFileOptions>使用されます。  
  
 [!code-cpp[NCLSocketEnhancements#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#4)]
 [!code-csharp[NCLSocketEnhancements#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">オペレーティング システムが Windows NT 以降です。  
  
 \- または  
  
 ソケットがリモート ホストに接続されていません。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />オブジェクトが閉じられました。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトはブロック モードではなく、この同期呼び出しを受け付けることができません。</exception>
        <exception cref="T:System.IO.FileNotFoundException">ファイル <paramref name="fileName" /> が見つかりませんでした。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="SendPacketsAsync">
      <MemberSignature Language="C#" Value="public bool SendPacketsAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendPacketsAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />この非同期ソケット操作に使用するオブジェクト。</param>
        <summary>接続にメモリ内、またはファイルのコレクションのデータ バッファーを非同期に送信<see cref="T:System.Net.Sockets.Socket" />オブジェクト。</summary>
        <returns>返します<see langword="true" />I/O 操作が保留中の場合。 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />でイベントを<paramref name="e" />パラメーターが操作の完了時に発生します。  
  
 返します<see langword="false" />場合は、I/O 操作が同期的に完了します。 ここで、<see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />でイベントを<paramref name="e" />パラメーターは発生しません。 と<paramref name="e" />操作の結果を取得するメソッドの呼び出しが戻った後にすぐに、パラメーターを調べることがありますとして渡されたオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>リモート ホストにデータ バッファーをメモリ内、またはファイルのコレクションに送信するメソッドを使用します。 <xref:System.Net.Sockets.Socket>リモート ホストに既に接続されている必要があります。  
  
 場合、<xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType>作業ディレクトリでファイルを参照、ファイルの名前だけで識別できること以外の場合はそれ以外の場合、完全なパスとファイルの名前を指定する必要があります。 ワイルドカードおよび UNC 共有名がサポートされています。 ファイルが見つからない場合<xref:System.IO.FileNotFoundException>がスローされます。  
  
 完了の通知、イベント ハンドラーを実装するコールバック メソッドを作成する必要があります\<SocketAsyncEventArgs > を委任し、アタッチするためのコールバック、<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>イベント。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType>プロパティを`e`パラメーターは、ファイルの転送に関する追加情報がウィンドウのソケット サービス プロバイダーを提供します。 このパラメーターを使用する方法の詳細については、次を参照してください。<xref:System.Net.Sockets.TransmitFileOptions>です。  
  
 次のプロパティとイベントを<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>オブジェクトが正常にこのメソッドを呼び出す必要があります。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 呼び出し元の設定、<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>を呼び出す前に必要なすべてのユーザー状態オブジェクトのプロパティ、<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>メソッド情報をコールバック メソッドで取得できるようにします。 コールバックは、1 つのオブジェクトより多くの情報を必要とする場合は、メンバーとして他の必要な状態情報を保持するために、小さいクラスを作成できます。  
  
 このメソッドは、Windows ソケット 2 API で見つかった TransmitPackets 関数を使用します。 TransmitPackets 関数およびそのフラグの詳細については、MSDN ライブラリの Windows Sockets ドキュメントを参照してください。  
  
 接続指向プロトコルでは、意図したものが、<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>メソッドに対しても機能コネクションレスのプロトコルを最初に呼び出すこと、 <xref:System.Net.Sockets.Socket.BeginConnect%2A>、 <xref:System.Net.Sockets.Socket.Connect%2A>、または<xref:System.Net.Sockets.Socket.ConnectAsync%2A>既定のリモート ホストを構築する方法です。 コネクションレスのプロトコルを使用している場合は、ファイルのサイズが、基になるサービス プロバイダーのパケットの最大サイズを超えていないことを確認する必要もあります。 場合は、データグラムが送信されず<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>スロー、<xref:System.Net.Sockets.SocketException>例外。  
  
 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>が使用されるオペレーティング システムに従ってメソッドを最適化します。 Windows server のエディションで、<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>メソッドは高パフォーマンスを最適化します。  
  
 Windows クライアントの各エディションで、<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>メソッドが最低限のメモリとリソース使用率を最適化します。  
  
 使用、<xref:System.Net.Sockets.TransmitFileOptions?displayProperty=nameWithType>フラグ、<xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType>プロパティを`e`パラメーターは、大幅なパフォーマンス上の利点を提供できます。 場合、スレッドを開始する、<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>大量の計算には、メソッドの呼び出しを使用している、可能であればもわずかながら、Apc が起動できない可能性があることもできます。 カーネルとユーザー モードの Apc の違いがあることに注意してください。 スレッドが待機状態には、カーネル Apc が起動します。 ユーザー モード Apc スレッドは、アラートの待機状態での起動します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">指定されたファイル、<see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" />プロパティが見つかりませんでした。</exception>
        <exception cref="T:System.InvalidOperationException">ソケット操作が既に進行中の使用中、<see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />で指定されたオブジェクト、<paramref name="e" />パラメーター。</exception>
        <exception cref="T:System.NotSupportedException">Windows XP 以降はこのメソッドに必要です。 この例外は、場合にも発生、<see cref="T:System.Net.Sockets.Socket" />リモート ホストに接続されていません。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">コネクションレス<see cref="T:System.Net.Sockets.Socket" />が使用されていると、ファイル送信されている、基になるトランスポートのパケットの最大サイズを超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="SendTimeout">
      <MemberSignature Language="C#" Value="public int SendTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>これまでの時間を指定する値の設定を取得または同期<see cref="Overload:System.Net.Sockets.Socket.Send" />呼び出しがタイムアウトします。</summary>
        <value>タイムアウト値 (ミリ秒)。 1 ~ 499 で値を持つプロパティを設定した場合、値が 500 に変更されます。 既定値は 0、無限のタイムアウト期間を示します。 -1 を指定するには、無限のタイムアウト期間も示します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオプションを適用する同期<xref:System.Net.Sockets.Socket.Send%2A>呼び出しのみです。 タイムアウト期間を超えた場合、<xref:System.Net.Sockets.Socket.Send%2A>メソッドがスローされます、<xref:System.Net.Sockets.SocketException>です。  
  
   
  
## Examples  
 使用を次のコード例に示します、<xref:System.Net.Sockets.Socket.SendTimeout%2A>プロパティです。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">設定操作に指定された値は、-1 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" />データの変換先を表すです。</param>
        <summary>データを指定されたエンドポイントに送信します。</summary>
        <returns>送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードでは、バッファーのオフセットの既定値は 0 の場合のサイズに既定値を送信するバイトの数、`buffer`パラメーター、および<xref:System.Net.Sockets.SocketFlags>値の既定値は 0 です。  
  
 コネクションレスのプロトコルを使用している場合は既定のリモート ホストとの確立する必要はありません、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドを呼び出す前に<xref:System.Net.Sockets.Socket.SendTo%2A>です。 この呼び出しをする場合にだけ、<xref:System.Net.Sockets.Socket.Send%2A>メソッドです。 呼び出す場合、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドを呼び出す前に<xref:System.Net.Sockets.Socket.SendTo%2A>、`remoteEP`パラメーターは、操作のみを送信するため、指定された既定のリモート ホストに上書きされます。 必要はありませんを呼び出して、<xref:System.Net.Sockets.Socket.Bind%2A>メソッド、基になるサービス プロバイダーが最も適切なローカル ネットワーク アドレスとポート番号を割り当てるためです。 使用することができます、割り当てられているローカル ネットワーク アドレスとポート番号を識別する必要がある場合、<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>後プロパティ、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドが正常に完了するとします。  
  
 コネクションレス プロトコルは、意図したものが<xref:System.Net.Sockets.Socket.SendTo%2A>接続指向プロトコルでも動作します。 呼び出してリモート ホスト接続を確立する必要がありますまず接続指向のプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.Connect%2A>メソッド、着信要求を使用して接続を受け入れるか、<xref:System.Net.Sockets.Socket.Accept%2A>メソッドです。 確立したり、リモート ホスト接続を許可しない場合<xref:System.Net.Sockets.Socket.SendTo%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 呼び出しの前にコネクションレスのプロトコルの既定のリモート ホストを確立することも、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドです。 このような場合は、のいずれかで<xref:System.Net.Sockets.Socket.SendTo%2A>は無視されます、`remoteEP`パラメーターとのみデータを送信する、接続または既定のリモート ホストします。  
  
 ブロッキング ソケットは、すべてのバッファー内のバイトが送信されるまでブロックされます。 非ブロッキング<xref:System.Net.Sockets.Socket>が完了する、すぐにその可能性がありますいないすべての送信内のバイト、`buffer`です。 送信されたバイト数を追跡して、アプリケーションでは、すべてのバイトを送信するまで、操作を再試行する、アプリケーションの責任である、`buffer`です。 また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに基になるシステムは大量の送信データが収集されるまでに伝送を遅れる可能性があります。 正常に完了する、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
 ブロッキング モードは、コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.SendTo%2A>データグラムが送信されるまでブロックされます。 ブロードキャスト アドレスにデータを送信する場合は、最初に呼び出す必要があります、<xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッドと set ソケット オプションを<xref:System.Net.Sockets.SocketOptionName?displayProperty=nameWithType>です。 送信されたバイト数が、基になるサービス プロバイダーのパケットの最大サイズを超えていないことを確認するもあります。 場合は、データグラムが送信されず<xref:System.Net.Sockets.Socket.SendTo%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例は、指定したリモート ホストにコネクションレス データグラムを送信します。  
  
 [!code-cpp[Socket_Sync_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Sync_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Sync_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="remoteEP" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" />データの移行先の場所を表すです。</param>
        <summary>データを指定して特定のエンドポイントに送信<see cref="T:System.Net.Sockets.SocketFlags" />です。</summary>
        <returns>送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードでは、バッファーのオフセットの既定値は 0、およびのサイズに既定値を送信するバイト数、`buffer`です。 指定した場合、<xref:System.Net.Sockets.SocketFlags.DontRoute>としてフラグを設定、`socketflags`パラメーターに、データを送信すると、ルーティングされません。  
  
 コネクションレスのプロトコルを使用している場合は既定のリモート ホストとの確立する必要はありません、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドを呼び出す前に<xref:System.Net.Sockets.Socket.SendTo%2A>です。 この呼び出しをする場合にだけ、<xref:System.Net.Sockets.Socket.Send%2A>メソッドです。 呼び出す場合、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドを呼び出す前に<xref:System.Net.Sockets.Socket.SendTo%2A>、`remoteEP`パラメーターは、操作のみを送信するため、指定された既定のリモート ホストに上書きされます。 必要はありませんを呼び出して、<xref:System.Net.Sockets.Socket.Bind%2A>メソッド、基になるサービス プロバイダーが最も適切なローカル ネットワーク アドレスとポート番号を割り当てるためです。 使用することができます、割り当てられているローカル ネットワーク アドレスとポート番号を識別する必要がある場合、<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>後プロパティ、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドが正常に完了するとします。  
  
 コネクションレス プロトコルは、意図したものが<xref:System.Net.Sockets.Socket.SendTo%2A>接続指向プロトコルでも動作します。 呼び出してリモート ホスト接続を確立する必要がありますまず接続指向のプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.Connect%2A>メソッド、着信要求を使用して接続を受け入れるか、<xref:System.Net.Sockets.Socket.Accept%2A>メソッドです。 確立したり、リモート ホスト接続を許可しない場合<xref:System.Net.Sockets.Socket.SendTo%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 呼び出しの前にコネクションレスのプロトコルの既定のリモート ホストを確立することも、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドです。 このような場合は、のいずれかで<xref:System.Net.Sockets.Socket.SendTo%2A>は無視されます、`remoteEP`パラメーターとのみデータを送信する、接続または既定のリモート ホストします。  
  
 ブロッキング ソケットはブロックされるまで、要求されたすべてのバイト数の`buffer`送信されます。 非ブロッキング<xref:System.Net.Sockets.Socket>が完了する、すぐにその可能性がありますいないすべての送信内のバイト、`buffer`です。 送信されたバイト数を追跡して、アプリケーションでは、すべてのバイトを送信するまで、操作を再試行する、アプリケーションの責任である、`buffer`です。 また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに基になるシステムは大量の発信データが収集されるまで転送を遅れる可能性があります。 正常に完了する、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
 ブロッキング モードは、コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.SendTo%2A>データグラムが送信されるまでブロックされます。 ブロードキャスト アドレスにデータを送信する場合は、最初に呼び出す必要があります、<xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッドと set ソケット オプションを<xref:System.Net.Sockets.SocketOptionName?displayProperty=nameWithType>です。 送信されたバイト数が、基になるサービス プロバイダーのパケットの最大サイズを超えていないことを確認するもあります。 場合は、データグラムが送信されず<xref:System.Net.Sockets.Socket.SendTo%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例は、指定したリモート ホストにコネクションレス データグラムを送信します。 <xref:System.Net.Sockets.SocketFlags>渡される、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドです。  
  
 [!code-cpp[Socket_Sync_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Sync_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Sync_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="remoteEP" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="size">送信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" />データの移行先の場所を表すです。</param>
        <summary>指定したデータのバイト数を指定して、指定されたエンドポイントに送信<see cref="T:System.Net.Sockets.SocketFlags" />です。</summary>
        <returns>送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードでは、バッファーは、既定値は 0 をオフセットします。 指定した場合、<xref:System.Net.Sockets.SocketFlags.DontRoute>としてフラグを設定、`socketflags`パラメーターに、データを送信すると、ルーティングされません。  
  
 コネクションレスのプロトコルを使用している場合は既定のリモート ホストとの確立する必要はありません、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドを呼び出す前に<xref:System.Net.Sockets.Socket.SendTo%2A>です。 この呼び出しをする場合にだけ、<xref:System.Net.Sockets.Socket.Send%2A>メソッドです。 呼び出す場合、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドを呼び出す前に<xref:System.Net.Sockets.Socket.SendTo%2A>、`remoteEP`パラメーターは、操作のみを送信するため、指定された既定のリモート ホストに上書きされます。 必要はありませんを呼び出して、<xref:System.Net.Sockets.Socket.Bind%2A>メソッド、基になるサービス プロバイダーが最も適切なローカル ネットワーク アドレスとポート番号を割り当てるためです。 使用することができます、割り当てられているローカル ネットワーク アドレスとポート番号を識別する必要がある場合、<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>後プロパティ、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドが正常に完了するとします。  
  
 コネクションレス プロトコルは、意図したものが<xref:System.Net.Sockets.Socket.SendTo%2A>接続指向プロトコルでも動作します。 呼び出してリモート ホスト接続を確立する必要がありますまず接続指向のプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.Connect%2A>メソッド、着信要求を使用して接続を受け入れるか、<xref:System.Net.Sockets.Socket.Accept%2A>メソッドです。 確立したり、リモート ホスト接続を許可しない場合<xref:System.Net.Sockets.Socket.SendTo%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 呼び出しの前にコネクションレスのプロトコルの既定のリモート ホストを確立することも、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドです。 このような場合は、のいずれかで<xref:System.Net.Sockets.Socket.SendTo%2A>は無視されます、`remoteEP`パラメーターとのみデータを送信する、接続または既定のリモート ホストします。  
  
 ブロッキング ソケットは、要求されたバイト数が送信されるまでブロックされます。 非ブロッキング<xref:System.Net.Sockets.Socket>完了いない送信すべて単一の操作で要求されたバイトの可能性がありますが、すぐにします。 送信されたバイト数を追跡して、アプリケーションが要求されたバイト数を送信するまで、操作を再試行する、アプリケーションの責任です。 また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに基になるシステムは大量の発信データが収集されるまで転送を遅れる可能性があります。 正常に完了する、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
 ブロッキング モードは、コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.SendTo%2A>データグラムが送信されるまでブロックされます。 ブロードキャスト アドレスにデータを送信する場合は、最初に呼び出す必要があります、<xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッドと set ソケット オプションを<xref:System.Net.Sockets.SocketOptionName?displayProperty=nameWithType>です。 送信されたバイト数が、基になるサービス プロバイダーのパケットの最大サイズを超えていないことを確認するもあります。 場合は、データグラムが送信されず<xref:System.Net.Sockets.Socket.SendTo%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例は、指定したリモート ホストにコネクションレス データグラムを送信します。 サイズと<xref:System.Net.Sockets.SocketFlags>に渡される、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドです。  
  
 [!code-cpp[Socket_Sync_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Sync_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Sync_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="remoteEP" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">指定した<paramref name="size" />のサイズを超える<paramref name="buffer" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">データの送信を開始する位置を示すデータ バッファー内の位置。</param>
        <param name="size">送信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" />データの移行先の場所を表すです。</param>
        <summary>指定したデータのバイト数をバッファー内の指定位置から開始し、指定されたを使用して、指定されたエンドポイントに送信<see cref="T:System.Net.Sockets.SocketFlags" />です。</summary>
        <returns>送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定した場合、オーバー ロードでは、<xref:System.Net.Sockets.SocketFlags.DontRoute>としてフラグを設定、`socketflags`パラメーターに、データを送信すると、ルーティングされません。  
  
 コネクションレスのプロトコルを使用している場合は既定のリモート ホストとの確立する必要はありません、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドを呼び出す前に<xref:System.Net.Sockets.Socket.SendTo%2A>です。 この呼び出しをする場合にだけ、<xref:System.Net.Sockets.Socket.Send%2A>メソッドです。 呼び出す場合、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドを呼び出す前に<xref:System.Net.Sockets.Socket.SendTo%2A>、`remoteEP`パラメーターは、操作のみを送信するため、指定された既定のリモート ホストに上書きされます。 必要はありませんを呼び出して、<xref:System.Net.Sockets.Socket.Bind%2A>メソッド、基になるサービス プロバイダーが最も適切なローカル ネットワーク アドレスとポート番号を割り当てるためです。 使用することができます、割り当てられているローカル ネットワーク アドレスとポート番号を識別する必要がある場合、<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>後プロパティ、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドが正常に完了するとします。  
  
 コネクションレス プロトコルは、意図したものが<xref:System.Net.Sockets.Socket.SendTo%2A>接続指向プロトコルでも動作します。 呼び出してリモート ホスト接続を確立する必要がありますまず接続指向のプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.Connect%2A>メソッド、着信要求を使用して接続を受け入れるか、<xref:System.Net.Sockets.Socket.Accept%2A>メソッドです。 確立したり、リモート ホスト接続を許可しない場合<xref:System.Net.Sockets.Socket.SendTo%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 呼び出しの前にコネクションレスのプロトコルの既定のリモート ホストを確立することも、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドです。 このような場合は、のいずれかで<xref:System.Net.Sockets.Socket.SendTo%2A>は無視されます、`remoteEP`パラメーターとのみデータを送信する、接続または既定のリモート ホストします。  
  
 ブロッキング ソケットは、要求されたバイト数が送信されるまでブロックされます。 非ブロッキング以降<xref:System.Net.Sockets.Socket>完了いない送信すべて単一の操作で要求されたバイトの可能性がありますが、すぐにします。 アプリケーション送信されたバイト数を追跡して、アプリケーションが要求されたバイト数を送信するまで、操作を再試行してください。 また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに基になるシステムは大量の発信データが収集されるまで転送を遅れる可能性があります。 正常に完了する、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
 ブロッキング モードは、コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.SendTo%2A>データグラムが送信されるまでブロックされます。 ブロードキャスト アドレスにデータを送信する場合は、最初に呼び出す必要があります、<xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッドと set ソケット オプションを<xref:System.Net.Sockets.SocketOptionName?displayProperty=nameWithType>です。 サイズが、基になるサービス プロバイダーのパケットの最大サイズを超えていないことを確認するもあります。 場合は、データグラムが送信されず<xref:System.Net.Sockets.Socket.SendTo%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例は、指定したリモート ホストにコネクションレス データグラムを送信します。 オフセット、サイズ、および<xref:System.Net.Sockets.SocketFlags>に渡される、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドです。  
  
 [!code-cpp[Socket_Sync_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Sync_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Sync_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="remoteEP" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> が 0 未満です。  
  
 または  
  
 <paramref name="offset" />長さより大きい<paramref name="buffer" />です。  
  
 または  
  
 <paramref name="size" /> が 0 未満です。  
  
 または  
  
 <paramref name="size" />長さより大きい<paramref name="buffer" />負の値、<paramref name="offset" />パラメーター。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" />値の有効な組み合わせではありません。  
  
 または  
  
 <see cref="T:System.Net.Sockets.Socket" /> にアクセス中にオペレーティング システム エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し履歴内の呼び出し元には、必要なアクセス許可がありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="SendToAsync">
      <MemberSignature Language="C#" Value="public bool SendToAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendToAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />この非同期ソケット操作に使用するオブジェクト。</param>
        <summary>特定のリモート ホストにデータを非同期的に送信します。</summary>
        <returns>返します<see langword="true" />I/O 操作が保留中の場合。 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />でイベントを<paramref name="e" />パラメーターが操作の完了時に発生します。  
  
 返します<see langword="false" />場合は、I/O 操作が同期的に完了します。 ここで、<see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />でイベントを<paramref name="e" />パラメーターは発生しません。 と<paramref name="e" />操作の結果を取得するメソッドの呼び出しが戻った後にすぐに、パラメーターを調べることがありますとして渡されたオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SendToAsync%2A>メソッドで指定されたリモート ホストへの非同期送信操作を開始、<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>のプロパティ、`e`パラメーター。 呼び出す、<xref:System.Net.Sockets.Socket.SendToAsync%2A>メソッドは、個別の実行スレッド内でデータを送信する機能を提供します。 このメソッドはコネクションレスのプロトコルのものが<xref:System.Net.Sockets.Socket.SendToAsync%2A>コネクションレス型との接続指向プロトコルの両方で動作します。  
  
 完了の通知、イベント ハンドラーを実装するコールバック メソッドを作成する必要があります\<SocketAsyncEventArgs > を委任し、アタッチするためのコールバック、<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>イベント。  
  
 次のプロパティとイベントを<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>オブジェクトが正常にこのメソッドを呼び出す必要があります。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 呼び出し元の設定、<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>を呼び出す前に必要なすべてのユーザー状態オブジェクトのプロパティ、<xref:System.Net.Sockets.Socket.SendToAsync%2A>メソッド情報をコールバック メソッドで取得できるようにします。 コールバックは、1 つのオブジェクトより多くの情報を必要とする場合は、メンバーとして他の必要な状態情報を保持するために、小さいクラスを作成できます。  
  
 最初に呼び出す必要がある接続指向のプロトコルを使用している場合、 <xref:System.Net.Sockets.Socket.Accept%2A>、 <xref:System.Net.Sockets.Socket.AcceptAsync%2A>、 <xref:System.Net.Sockets.Socket.BeginAccept%2A>、 <xref:System.Net.Sockets.Socket.BeginConnect%2A>、 <xref:System.Net.Sockets.Socket.Connect%2A>、または<xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッドです。 それ以外の場合<xref:System.Net.Sockets.Socket.SendToAsync%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 接続指向のプロトコルを使用する場合、<xref:System.Net.Sockets.Socket.SendToAsync%2A>メソッドは無視されます、<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>プロパティと送信のデータを<xref:System.Net.EndPoint?displayProperty=nameWithType>で確立されている、 <xref:System.Net.Sockets.Socket.Accept%2A>、 <xref:System.Net.Sockets.Socket.AcceptAsync%2A>、 <xref:System.Net.Sockets.Socket.BeginAccept%2A>、 <xref:System.Net.Sockets.Socket.BeginConnect%2A>、 <xref:System.Net.Sockets.Socket.Connect%2A>、または<xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッドです。  
  
 コネクションレスのプロトコルを使用している場合は既定のリモート ホストとの確立する必要はありません、 <xref:System.Net.Sockets.Socket.BeginConnect%2A>、 <xref:System.Net.Sockets.Socket.Connect%2A>、または<xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッドを呼び出す前に<xref:System.Net.Sockets.Socket.SendToAsync%2A>です。 この呼び出しをする場合にだけ、<xref:System.Net.Sockets.Socket.BeginSend%2A>または<xref:System.Net.Sockets.Socket.SendAsync%2A>メソッドです。 呼び出す場合、 <xref:System.Net.Sockets.Socket.BeginConnect%2A>、 <xref:System.Net.Sockets.Socket.Connect%2A>、または<xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッドを呼び出す前に<xref:System.Net.Sockets.Socket.SendToAsync%2A>、<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>操作のみを送信するのプロパティで指定された既定のリモート ホストは無効です。 必要はありませんを呼び出して、<xref:System.Net.Sockets.Socket.Bind%2A>メソッドです。 この場合、基になるサービス プロバイダーは、最も適切なローカル ネットワーク IP アドレスとポート番号を割り当てます。 基になるサービス プロバイダーは、空いているポートを選択する場合は、ゼロのポート番号を使用します。 使用することができます、割り当てられているローカル ネットワーク IP アドレスとポート番号を識別する必要がある場合、<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>後プロパティ、<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>イベントがシグナル状態にし、関連付けられているデリゲートが呼び出されます。  
  
 ブロードキャスト アドレスにデータを送信する場合は、最初に呼び出す必要があります、<xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッドと set ソケット オプションを<xref:System.Net.Sockets.SocketOptionName?displayProperty=nameWithType>true に設定します。 バッファーのサイズが、基になるサービス プロバイダーのパケットの最大サイズを超えていないことを確認するもあります。 場合は、データグラムが送信されず<xref:System.Net.Sockets.Socket.SendToAsync%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。  
  
 DontRoute フラグを指定する場合、<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType>プロパティに、データを送信すると、ルーティングされません。  
  
 メッセージ指向のソケットでは、基になるトランスポートのメッセージの最大サイズを超えないように注意する必要があります。 バッファーのサイズは、基になるサービス プロバイダーのパケットの最大サイズを超えている場合、データグラムが送信されず、<xref:System.Net.Sockets.Socket.SendToAsync%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 正常に完了、<xref:System.Net.Sockets.Socket.SendToAsync%2A>メソッドは、データが正常に送信されたことを指定していません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> Null にすることはできません。</exception>
        <exception cref="T:System.InvalidOperationException">ソケット操作が既に進行中の使用中、<see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />で指定されたオブジェクト、<paramref name="e" />パラメーター。</exception>
        <exception cref="T:System.NotSupportedException">Windows XP 以降はこのメソッドに必要です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">指定されたプロトコルは、接続指向ですが、<see cref="T:System.Net.Sockets.Socket" />がまだ接続されていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetIPProtectionLevel">
      <MemberSignature Language="C#" Value="public void SetIPProtectionLevel (System.Net.Sockets.IPProtectionLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetIPProtectionLevel(valuetype System.Net.Sockets.IPProtectionLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Net.Sockets.IPProtectionLevel" />
      </Parameters>
      <Docs>
        <param name="level">このソケットで設定する IP 保護レベル。</param>
        <summary>ソケットでは、IP 保護レベルを設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A>メソッドにより、制限、IPv6、または IP ソケット アドレスと同じローカル リンクまたはサイト ローカル プレフィックスなど、特定のスコープをリッスンするようにします。 このソケット オプションでは、IPv6、または IP ソケットにアクセス制限を設定するアプリケーションを使用します。 この制限により、プライベート LAN で実行されるアプリケーションを外部からの攻撃に対して簡単かつ堅牢に強化できます。 このソケット オプションは、アクセスの制限を削除する場合にも使用できます、`level`にパラメーターが設定されている<xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>です。 このソケット オプションで待機中のソケットのスコープを変更して、適切な場合はパブリック ユーザーおよびプライベート ユーザーからの無制限のアクセスを許可したり、必要に応じて同じサイトへのアクセスのみに制限したりできます。  
  
 このソケット オプションには、<xref:System.Net.Sockets.IPProtectionLevel> 列挙型で指定されている定義済みの保護レベルが設定されています。  
  
 <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A>メソッドを使用を有効または無効のように、ネットワーク アドレス トラバーサル (NAT) を<xref:System.Net.Sockets.Socket>インスタンス。 NAT トラバーサルを指定するには、Teredo、6to4、または ISATAP トンネルを使用します。  
  
 ときに、`level`にパラメーターが設定されている<xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>、または<xref:System.Net.Sockets.IPProtectionLevel.Restricted>、NAT トラバーサルが明示的に無効になります、<xref:System.Net.Sockets.Socket>インスタンス。  
  
 ときに、`level`にパラメーターが設定されている<xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>、NAT トラバーサルを許可するこの可能性があります、<xref:System.Net.Sockets.Socket>によっては、システム上でファイアウォール規則です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="level" /> パラメーターとして <see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" /> を使用することはできません。 IP の保護レベルは、指定されていないに設定することはできません。</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Net.Sockets.AddressFamily" />ソケットの必要がありますか<see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />または<see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, bool optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 値のいずれか。</param>
        <param name="optionName"><see cref="T:System.Net.Sockets.SocketOptionName" /> 値のいずれか。</param>
        <param name="optionValue">として表される、オプションの値、<see cref="T:System.Boolean" />です。</param>
        <summary>指定した設定<see cref="T:System.Net.Sockets.Socket" />を指定したオプション<see cref="T:System.Boolean" />値。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>オプションは、現在の動作を決定<xref:System.Net.Sockets.Socket>です。 設定`optionValue`に`true`オプションを有効にまたは`false`オプションを無効にします。  
  
 <xref:System.Net.Sockets.Socket>オプションは、プロトコルのサポートのレベルでグループ化されます。  
  
 次のとおり、さまざまな<xref:System.Net.Sockets.Socket>オプションをこのオーバー ロードを使用して設定できます。 これらのオプションが適切にグループ化<xref:System.Net.Sockets.SocketOptionLevel>値。 これらのオプションのいずれかを設定する場合は、必ず使用して、適切な<xref:System.Net.Sockets.SocketOptionLevel>値を`optionLevel`パラメーター。 設定を選択するオプションを指定する必要があります、`optionName`パラメーター。 記載されているオプションのいずれかの現在の値を取得するには、使用する場合、<xref:System.Net.Sockets.Socket.GetSocketOption%2A>メソッドです。  
  
 <xref:System.Net.Sockets.SocketOptionLevel?displayProperty=nameWithType>このオーバー ロードを使用して設定できるオプションです。  
  
-   <xref:System.Net.Sockets.SocketOptionName.AcceptConnection>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
 <xref:System.Net.Sockets.SocketOptionLevel?displayProperty=nameWithType>このオーバー ロードを使用して設定できるオプションです。  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <xref:System.Net.Sockets.SocketOptionLevel?displayProperty=nameWithType>このオーバー ロードを使用して設定できるオプションです。  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <xref:System.Net.Sockets.SocketOptionLevel?displayProperty=nameWithType>このオーバー ロードを使用して設定できるオプションです。  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 これらのオプションの詳細についてを参照してください、<xref:System.Net.Sockets.SocketOptionName>列挙します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>例外を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
   
  
## Examples  
 ソケットを開き、により、次のコード例、`DontLinger`と`OutOfBandInline`ソケット オプション。  
  
 [!code-cpp[NCLSocketEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#5)]
 [!code-csharp[NCLSocketEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />オブジェクトが閉じられました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 値のいずれか。</param>
        <param name="optionName"><see cref="T:System.Net.Sockets.SocketOptionName" /> 値のいずれか。</param>
        <param name="optionValue">型の配列<see cref="T:System.Byte" />オプションの値を表すです。</param>
        <summary>指定した設定<see cref="T:System.Net.Sockets.Socket" />オプションをバイト配列として表される、指定した値にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>オプションは、現在の動作を決定<xref:System.Net.Sockets.Socket>です。 このオーバー ロードを使用して、それらを設定する<xref:System.Net.Sockets.Socket>オプションの値としてバイト配列を必要とするオプションです。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例のセット、<xref:System.Net.Sockets.LingerOption>と<xref:System.Net.Sockets.Socket.Send%2A>タイムアウト値。  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 値のいずれか。</param>
        <param name="optionName"><see cref="T:System.Net.Sockets.SocketOptionName" /> 値のいずれか。</param>
        <param name="optionValue">オプションの値です。</param>
        <summary>指定した設定<see cref="T:System.Net.Sockets.Socket" />オプションを指定した整数値にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>オプションは、現在の動作を決定<xref:System.Net.Sockets.Socket>です。 オプションである場合の<xref:System.Boolean>0 以外の値をこのオプションを有効にして、オプションを無効にゼロ値を指定、データ型します。 整数データ型のオプションでは、適切な値を指定します。 <xref:System.Net.Sockets.Socket>オプションは、プロトコルのサポートのレベルでグループ化されます。  
  
 次のとおり、さまざまな<xref:System.Net.Sockets.Socket>オプションをこのオーバー ロードを使用して設定できます。 これらのオプションが適切にグループ化<xref:System.Net.Sockets.SocketOptionLevel>です。 これらのオプションのいずれかを設定する場合は、必ず使用して、適切な<xref:System.Net.Sockets.SocketOptionLevel>の`optionLevel`パラメーター。 設定を選択するオプションを指定する必要があります、`optionName`パラメーター。 記載されているオプションのいずれかの現在の値を取得するには、使用する場合、<xref:System.Net.Sockets.Socket.GetSocketOption%2A>メソッドです。  
  
 <xref:System.Net.Sockets.SocketOptionLevel?displayProperty=nameWithType>このオーバー ロードを使用して設定できるオプションです。  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Error>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Type>  
  
 <xref:System.Net.Sockets.SocketOptionLevel?displayProperty=nameWithType>このオーバー ロードを使用して設定できるオプションです。  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IPOptions>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IpTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastInterface>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.TypeOfService>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <xref:System.Net.Sockets.SocketOptionLevel?displayProperty=nameWithType>このオーバー ロードを使用して設定できるオプションです。  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <xref:System.Net.Sockets.SocketOptionLevel?displayProperty=nameWithType>このオーバー ロードを使用して設定できるオプションです。  
  
-   <xref:System.Net.Sockets.SocketOptionName.ChecksumCoverage>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 <xref:System.Net.Sockets.SocketOptionLevel?displayProperty=nameWithType>このオーバー ロードを使用して設定できるオプションです。  
  
-   <xref:System.Net.Sockets.SocketOptionName.HopLimit>  
  
 これらのオプションの詳細についてを参照してください、<xref:System.Net.Sockets.SocketOptionName>列挙します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例のセット、<xref:System.Net.Sockets.LingerOption>と<xref:System.Net.Sockets.Socket.Send%2A>タイムアウト値。  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, object optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, object optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 値のいずれか。</param>
        <param name="optionName"><see cref="T:System.Net.Sockets.SocketOptionName" /> 値のいずれか。</param>
        <param name="optionValue">A<see cref="T:System.Net.Sockets.LingerOption" />または<see cref="T:System.Net.Sockets.MulticastOption" />オプションの値を格納します。</param>
        <summary>指定した設定<see cref="T:System.Net.Sockets.Socket" />オプションをオブジェクトとして表される、指定した値にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>オプションは、現在の動作を決定<xref:System.Net.Sockets.Socket>です。 このオーバー ロードを使用して、設定、 <xref:System.Net.Sockets.SocketOptionName.Linger>、 <xref:System.Net.Sockets.SocketOptionName.AddMembership>、および<xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket>オプション。 <xref:System.Net.Sockets.SocketOptionName.Linger>オプションを使用して<xref:System.Net.Sockets.Socket>の`optionLevel`パラメーター。 <xref:System.Net.Sockets.SocketOptionName.AddMembership>と<xref:System.Net.Sockets.SocketOptionName.DropMembership>を使用して<xref:System.Net.Sockets.SocketOptionLevel.IP>です。 上記のオプションのいずれかの現在の値を取得するには、使用する場合、<xref:System.Net.Sockets.Socket.GetSocketOption%2A>メソッドです。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
   
  
## Examples  
 次のコード例のセット、<xref:System.Net.Sockets.LingerOption>と<xref:System.Net.Sockets.Socket.Send%2A>のタイムアウト値。  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="optionValue" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (System.Net.Sockets.SocketShutdown how);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(valuetype System.Net.Sockets.SocketShutdown how) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="how" Type="System.Net.Sockets.SocketShutdown" />
      </Parameters>
      <Docs>
        <param name="how">1 つ、<see cref="T:System.Net.Sockets.SocketShutdown" />が不要になった許可される操作を指定する値。</param>
        <summary>送信を無効にしでの受信、<see cref="T:System.Net.Sockets.Socket" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向の使用時に<xref:System.Net.Sockets.Socket>、常に呼び出し、<xref:System.Net.Sockets.Socket.Shutdown%2A>閉じる前にメソッド、<xref:System.Net.Sockets.Socket>です。 これにより、すべてのデータが送信されが閉じる前に、接続されたソケットで受信したことです。  
  
 呼び出す、<xref:System.Net.Sockets.Socket.Close%2A>マネージし、アンマネージに関連付けられているリソースのすべてを解放するメソッド、<xref:System.Net.Sockets.Socket>です。 再利用しないで、<xref:System.Net.Sockets.Socket>終了後にします。  
  
 次の表に、<xref:System.Net.Sockets.SocketShutdown>に対して有効な列挙値、`how`パラメーター。  
  
|値|説明|  
|-----------|-----------------|  
|送信|この送信は無効に<xref:System.Net.Sockets.Socket>です。|  
|Receive|この受信を無効にする<xref:System.Net.Sockets.Socket>です。|  
|両方|両方の送受信にこれを無効にする<xref:System.Net.Sockets.Socket>です。|  
  
 設定`how`に<xref:System.Net.Sockets.SocketShutdown.Send>後続のことを指定するために呼び出す<xref:System.Net.Sockets.Socket.Send%2A>は許可されていません。 場合は、コネクションレス型を使用している<xref:System.Net.Sockets.Socket>を指定して、<xref:System.Net.Sockets.SocketShutdown.Send>効果はありません。  
  
 設定`how`に<xref:System.Net.Sockets.SocketShutdown.Receive>後続のことを指定するために呼び出す<xref:System.Net.Sockets.Socket.Receive%2A>は許可されていません。 下位のプロトコル層への影響はありません。 接続指向のプロトコルを使用している呼び出しの後に、次の条件のいずれかが存在する場合、接続が終了<xref:System.Net.Sockets.Socket.Shutdown%2A>:  
  
-   データは受信を待機しているネットワークの着信バッファーです。  
  
-   多くのデータが到着しました。  
  
 コネクションレスのプロトコルを使用している場合は、データグラムが受け入れてし、キューに置かれました。 ただし、追加の受信データグラムの使用可能なバッファー領域がない場合は破棄され、送信者にエラーが返されません。 使用して<xref:System.Net.Sockets.Socket.Shutdown%2A>、コネクションレスで<xref:System.Net.Sockets.Socket>はお勧めしません。  
  
 設定`how`に<xref:System.Net.Sockets.SocketShutdown.Both>両方の送信を無効にし、前述のように受信します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を呼び出すときに、<xref:System.Net.Sockets.Socket.Shutdown%2A>メソッドを使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例では<xref:System.Net.Sockets.Socket.Shutdown%2A>を無効にする、<xref:System.Net.Sockets.Socket>です。  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="SocketType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketType SocketType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.SocketType SocketType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SocketType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> の型を取得します。</summary>
        <value><see cref="T:System.Net.Sockets.SocketType" /> 値のいずれか。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SocketType%2A>読み取り専用と設定されているときに、<xref:System.Net.Sockets.Socket>を作成します。  
  
   
  
## Examples  
 次のコード例では表示、 <xref:System.Net.Sockets.AddressFamily>、 <xref:System.Net.Sockets.SocketType>、および<xref:System.Net.Sockets.ProtocolType>コンソールにします。  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use OSSupportsIPv4 instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>IPv4 のサポートが利用可能で、現在のホストで有効になっているかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" />現在のホストには、IPv4 プロトコルがサポートされている場合それ以外の場合、<see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 オペレーティング システムでは、IPv4 と IPv6 の両方のプロトコルをサポート可能性があります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use OSSupportsIPv6 instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フレームワークが特定の古い形式の IPv6 をサポートするかどうかを示す値を取得<see cref="T:System.Net.Dns" />メンバー。</summary>
        <value>
          <see langword="true" />特定のフレームワークに IPv6 がサポートされている場合は、旧式<see cref="T:System.Net.Dns" />メソッド以外の場合、<see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 オペレーティング システムでは、IPv4 と IPv6 の両方のプロトコルをサポート可能性があります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ttl">
      <MemberSignature Language="C#" Value="public short Ttl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 Ttl" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Ttl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定が送信するインターネット プロトコル (IP) パケットの Time To Live (TTL) 値を指定する値、<see cref="T:System.Net.Sockets.Socket" />です。</summary>
        <value>TTL 値です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 TTL 値は、ルーターはパケットとインターネット制御メッセージ プロトコル (ICMP) の"TTL を超えています"を破棄する前に、パケットが走査できるルーターの最大数を示すエラー メッセージが送信者に返されます。  
  
 TTL 値は、0 255 からの値に設定可能性があります。 このプロパティが設定されていないときに、ソケットの既定の TTL 値は 32 です。  
  
 伝送制御プロトコル (TCP) ソケットでこのプロパティの設定は無視されますスタックによって、TCP/IP ソケットを使用して正常な接続が確立された場合。  
  
 表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
   
  
## Examples  
 使用を次のコード例に示します、<xref:System.Net.Sockets.Socket.Ttl%2A>プロパティです。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">TTL 値は、負の数を設定できません。</exception>
        <exception cref="T:System.NotSupportedException">内のソケットに対してのみこのプロパティを設定することができます、<see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />または<see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />ファミリ。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 このエラーは、TTL を 255 より大きい値に設定しようとしたときにも返されます。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="UseOnlyOverlappedIO">
      <MemberSignature Language="C#" Value="public bool UseOnlyOverlappedIO { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseOnlyOverlappedIO" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("This doesn't do anything on Mono yet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ソケットがオーバー ラップされた I/O モードを使用するのみかどうかを指定します。</summary>
        <value>
          <see langword="true" />場合、<see cref="T:System.Net.Sockets.Socket" />オーバー ラップ I/O だけを使用して、それ以外の<see langword="false" />します。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを設定`true`の<xref:System.Net.Sockets.Socket>を呼び出そうと<xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>です。 それ以外の場合、フレームワークは、ソケットは、の使用を禁止するように、完了ポートを割り当てることが<xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">ソケットが完了ポートにバインドされました。</exception>
      </Docs>
    </Member>
  </Members>
</Type>
