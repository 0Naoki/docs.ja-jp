<Type Name="Enumerable" FullName="System.Linq.Enumerable">
  <TypeSignature Language="C#" Value="public static class Enumerable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Enumerable extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Linq.Enumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Linq</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>一連の提供<see langword="static" />(<see langword="Shared" /> Visual Basic で) を実装するオブジェクトをクエリするためメソッド<see cref="T:System.Collections.Generic.IEnumerable`1" />です。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このクラスのメソッドが実装するソース データを照会するため、標準クエリ演算子の実装を提供<xref:System.Collections.Generic.IEnumerable%601>です。 標準クエリ演算子は、次の汎用のメソッド、[!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)]パターンし、使用すると、いずれかでデータを走査、フィルター、およびプロジェクション操作を高速です。NET ベースのプログラミング言語です。  
  
 このクラスのメソッドの大部分が拡張機能を拡張するメソッドとして定義されている<xref:System.Collections.Generic.IEnumerable%601>です。 つまりを実装する任意のオブジェクトのインスタンス メソッドと同様に呼び出すことができる<xref:System.Collections.Generic.IEnumerable%601>です。  
  
 値のシーケンスを返すクエリで使用されるメソッドは、クエリ オブジェクトが列挙されるまで、ターゲット データを消費しません。 これは、遅延実行と呼ばれます。 シングルトン値を返すクエリで使用するメソッドを実行し、対象のデータをすぐに使用します。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Aggregate&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Aggregate&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TSource,TSource&gt; func);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Aggregate&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, !!TSource, !!TSource&gt; func) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Aggregate``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="func" Type="System.Func&lt;TSource,TSource,TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source"><see cref="T:System.Collections.Generic.IEnumerable`1" />集計にします。</param>
        <param name="func">各要素に対して呼び出すアキュムレータ関数。</param>
        <summary>シーケンスにアキュムレータ関数を適用します。</summary>
        <returns>最終的なアキュムレータ値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Aggregate%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%600%2C%60%600%7D%29>メソッドを簡単に一連の値に対して計算を実行します。 このメソッドを呼び出すことによって動作`func`の各要素に対して 1 回`source`最初の 1 つを除きます。 毎回`func`が呼び出されると、<xref:System.Linq.Enumerable.Aggregate%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%600%2C%60%600%7D%29>と集計値のシーケンスから要素の両方を渡します (1 番目の引数として`func`)。 最初の要素`source`は最初の集計値として使用します。 結果`func`以前の集計値が置き換えられます。 <xref:System.Linq.Enumerable.Aggregate%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%600%2C%60%600%7D%29>最終的な結果を返します`func`です。  
  
 このオーバー ロード、<xref:System.Linq.Enumerable.Aggregate%2A>の最初の要素を使用しているために、メソッドは常に適した`source`最初の集計値として。 戻り値の要素のみを含める必要がある場合は、別のオーバー ロードを選択する必要があります`source`特定の条件に一致します。 たとえば、このオーバー ロードが偶数の数値の合計を計算する場合、信頼されていない`source`です。 結果は最初の要素は奇数の代わりにも正しくなります。  
  
 一般的な集計操作を簡略化、標準クエリ演算子も含める汎用カウント メソッドでは、 <xref:System.Linq.Enumerable.Count%2A>、および 4 つの数値の集計方法、つまり<xref:System.Linq.Enumerable.Min%2A>、 <xref:System.Linq.Enumerable.Max%2A>、<xref:System.Linq.Enumerable.Sum%2A>と<xref:System.Linq.Enumerable.Average%2A>です。  
  
   
  
## Examples  
 次のコード例を使用して、文字列内の単語の順序を反転<xref:System.Linq.Enumerable.Aggregate%2A>です。  
  
 [!code-csharp[System.Linq.Enumerable#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#1)]
 [!code-vb[System.Linq.Enumerable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="func" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />要素は含まれません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Aggregate&lt;TSource,TAccumulate&gt;">
      <MemberSignature Language="C#" Value="public static TAccumulate Aggregate&lt;TSource,TAccumulate&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TAccumulate seed, Func&lt;TAccumulate,TSource,TAccumulate&gt; func);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TAccumulate Aggregate&lt;TSource, TAccumulate&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TAccumulate seed, class System.Func`3&lt;!!TAccumulate, !!TSource, !!TAccumulate&gt; func) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Aggregate``2(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TAccumulate</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TAccumulate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="seed" Type="TAccumulate" />
        <Parameter Name="func" Type="System.Func&lt;TAccumulate,TSource,TAccumulate&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <typeparam name="TAccumulate">アキュムレータ値の型。</typeparam>
        <param name="source"><see cref="T:System.Collections.Generic.IEnumerable`1" />集計にします。</param>
        <param name="seed">最初のアキュムレータ値。</param>
        <param name="func">各要素に対して呼び出すアキュムレータ関数。</param>
        <summary>シーケンスにアキュムレータ関数を適用します。 指定されたシード値が最初のアキュムレータ値として使用されます。</summary>
        <returns>最終的なアキュムレータ値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Aggregate%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%601%2CSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%29>メソッドを簡単に一連の値に対して計算を実行します。 このメソッドを呼び出すことによって動作`func`の各要素に対して 1 回`source`です。 毎回`func`が呼び出されると、<xref:System.Linq.Enumerable.Aggregate%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%601%2CSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%29>と集計値のシーケンスから要素の両方を渡します (1 番目の引数として`func`)。 値、`seed`パラメーターは、最初の集計値として使用します。 結果`func`以前の集計値が置き換えられます。 <xref:System.Linq.Enumerable.Aggregate%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%601%2CSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%29>最終的な結果を返します`func`です。  
  
 一般的な集計操作を簡略化、標準クエリ演算子も含める汎用カウント メソッドでは、 <xref:System.Linq.Enumerable.Count%2A>、および 4 つの数値の集計方法、つまり<xref:System.Linq.Enumerable.Min%2A>、 <xref:System.Linq.Enumerable.Max%2A>、<xref:System.Linq.Enumerable.Sum%2A>と<xref:System.Linq.Enumerable.Average%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Aggregate%2A>をアキュムレータ関数を適用し、シード値を使用します。  
  
 [!code-csharp[System.Linq.Enumerable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#2)]
 [!code-vb[System.Linq.Enumerable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="func" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Aggregate&lt;TSource,TAccumulate,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Aggregate&lt;TSource,TAccumulate,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TAccumulate seed, Func&lt;TAccumulate,TSource,TAccumulate&gt; func, Func&lt;TAccumulate,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Aggregate&lt;TSource, TAccumulate, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TAccumulate seed, class System.Func`3&lt;!!TAccumulate, !!TSource, !!TAccumulate&gt; func, class System.Func`2&lt;!!TAccumulate, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Aggregate``3(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TAccumulate" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="seed" Type="TAccumulate" />
        <Parameter Name="func" Type="System.Func&lt;TAccumulate,TSource,TAccumulate&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TAccumulate,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <typeparam name="TAccumulate">アキュムレータ値の型。</typeparam>
        <typeparam name="TResult">結果の値の型。</typeparam>
        <param name="source"><see cref="T:System.Collections.Generic.IEnumerable`1" />集計にします。</param>
        <param name="seed">最初のアキュムレータ値。</param>
        <param name="func">各要素に対して呼び出すアキュムレータ関数。</param>
        <param name="resultSelector">最終的なアキュムレータ値を結果値に変換する関数。</param>
        <summary>シーケンスにアキュムレータ関数を適用します。 指定したシード値は最初のアキュムレータ値として使用され、指定した関数は結果値の選択に使用されます。</summary>
        <returns>変換された最終的なアキュムレータ値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Aggregate%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%601%2CSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2C%60%602%7D%29>メソッドを簡単に一連の値に対して計算を実行します。 このメソッドを呼び出すことによって動作`func`の各要素に対して 1 回`source`です。 毎回`func`が呼び出されると、<xref:System.Linq.Enumerable.Aggregate%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%601%2CSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2C%60%602%7D%29>と集計値のシーケンスから要素の両方を渡します (1 番目の引数として`func`)。 値、`seed`パラメーターは、最初の集計値として使用します。 結果`func`以前の集計値が置き換えられます。 最終結果`func`に渡される`resultSelector`の最終的な結果を得る<xref:System.Linq.Enumerable.Aggregate%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%601%2CSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2C%60%602%7D%29>です。  
  
 一般的な集計操作を簡略化、標準クエリ演算子も含める汎用カウント メソッドでは、 <xref:System.Linq.Enumerable.Count%2A>、および 4 つの数値の集計方法、つまり<xref:System.Linq.Enumerable.Min%2A>、 <xref:System.Linq.Enumerable.Max%2A>、<xref:System.Linq.Enumerable.Sum%2A>と<xref:System.Linq.Enumerable.Average%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Aggregate%2A>アキュムレータ関数と結果のセレクターを適用します。  
  
 [!code-csharp[System.Linq.Enumerable#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#3)]
 [!code-vb[System.Linq.Enumerable#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />、<paramref name="func" />、または <paramref name="resultSelector" /> は、<see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="All&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool All&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool All&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.All``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source"><see cref="T:System.Collections.Generic.IEnumerable`1" />述語を適用する要素を格納しています。</param>
        <param name="predicate">各要素が条件を満たしているかどうかをテストする関数。</param>
        <summary>シーケンスのすべての要素が条件を満たすかどうかを判断します。</summary>
        <returns>
          <see langword="true" />ソース シーケンスのすべての要素が、指定された述語でテストを渡す場合、または、シーケンスが空です。それ以外の場合、<see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  このメソッドは、コレクションのすべての要素を返しません。 代わりに、コレクションのすべての要素が条件を満たすかどうかを判断します。  
  
 列挙体`source`結果を特定するとすぐに停止します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into All()`の呼び出しに変換される句<xref:System.Linq.Enumerable.All%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.All%2A>をシーケンス内のすべての要素が条件を満たすかどうかを判断します。 変数`allStartWithB`は true、すべてのペットの名前が"B"で起動または場合、`pets`配列が空です。  
  
 [!code-csharp[System.Linq.Enumerable#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#4)]
 [!code-vb[System.Linq.Enumerable#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#4)]  
  
 ブール値を<xref:System.Linq.Enumerable.All%2A>メソッドでは、通常の述語では使用を返します、`where`句 (`Where`句[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) またはへの直接呼び出し、<xref:System.Linq.Enumerable.Where%2A>メソッドです。 次の例では、このように使用する、`All`メソッドです。  
  
 [!code-csharp[System.Linq.Enumerable#129](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#129)]
 [!code-vb[System.Linq.Enumerable#129](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#129)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="predicate" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Any&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Any&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Any&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Any``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source"><see cref="T:System.Collections.Generic.IEnumerable`1" />空かを確認します。</param>
        <summary>シーケンスがすべての要素を含めるかどうかを判断します。</summary>
        <returns>
          <see langword="true" />ソース シーケンスには、すべての要素が含まれている場合それ以外の場合、<see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  このメソッドは、コレクションの要素のいずれかを返しません。 代わりに、すべての要素がコレクションに含まれているかどうかを判断します。  
  
 列挙体`source`結果を特定するとすぐに停止します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Any()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Any%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Any%2A>を任意の要素を格納するシーケンスがサポートされるかどうかを判断します。  
  
 [!code-csharp[System.Linq.Enumerable#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#5)]
 [!code-vb[System.Linq.Enumerable#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#5)]  
  
 ブール値を<xref:System.Linq.Enumerable.Any%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>メソッドでは、通常の述語では使用を返します、`where`句 (`Where`句[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) またはへの直接呼び出し、<xref:System.Linq.Enumerable.Where%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>メソッドです。 次の例では、このように使用する、`Any`メソッドです。  
  
 [!code-csharp[System.Linq.Enumerable#130](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#130)]
 [!code-vb[System.Linq.Enumerable#130](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#130)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Any&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Any&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Any&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Any``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source"><see cref="T:System.Collections.Generic.IEnumerable`1" />述語を適用する要素を格納します。</param>
        <param name="predicate">各要素が条件を満たしているかどうかをテストする関数。</param>
        <summary>シーケンスのいずれかの要素が条件を満たすかどうかを判断します。</summary>
        <returns>
          <see langword="true" />ソース シーケンス内にある要素では、テストを指定した述語に渡す場合それ以外の場合、<see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  このメソッドは、コレクションの要素のいずれかを返しません。 代わりに、コレクションのすべての要素が条件を満たすかどうかを判断します。  
  
 列挙体`source`結果を特定するとすぐに停止します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Any()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Any%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Any%2A>をシーケンス内の要素が条件を満たすかどうかを判断します。  
  
 [!code-csharp[System.Linq.Enumerable#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#6)]
 [!code-vb[System.Linq.Enumerable#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="predicate" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Append&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Append&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TSource element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Append&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TSource element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Append``1(System.Collections.Generic.IEnumerable{``0},``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="element" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><paramref name="source" /> の要素の型。</typeparam>
        <param name="source">値のシーケンス。</param>
        <param name="element"><paramref name="source" /> に追加する値。</param>
        <summary>シーケンスの末尾に値を追加します。</summary>
        <returns><paramref name="element" /> で終わる新しいシーケンス。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="AsEnumerable&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; AsEnumerable&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; AsEnumerable&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.AsEnumerable``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">入力シーケンス<see cref="T:System.Collections.Generic.IEnumerable`1" />です。</param>
        <summary><see cref="T:System.Collections.Generic.IEnumerable`1" /> として型指定された入力を返します。</summary>
        <returns>として型指定された入力シーケンス<see cref="T:System.Collections.Generic.IEnumerable`1" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.AsEnumerable%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>メソッドも何も起こりません以外の場合のコンパイル時の型を変更する`source`を実装する型から<xref:System.Collections.Generic.IEnumerable%601>に<xref:System.Collections.Generic.IEnumerable%601>自体です。  
  
 <xref:System.Linq.Enumerable.AsEnumerable%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>シーケンスを実装すると、クエリの実装の間での選択に使用できる<xref:System.Collections.Generic.IEnumerable%601>も使用可能なパブリック クエリ メソッドの別のセットを持ちます。 たとえば、ジェネリック クラスを指定`Table`を実装する<xref:System.Collections.Generic.IEnumerable%601>、独自のメソッドのように`Where`、 `Select`、および`SelectMany`への呼び出し`Where`はパブリックなを起動`Where`のメソッド`Table`です。 A`Table`をデータベース テーブルを表す型がある可能性があります、`Where`メソッドを述語の引数を式ツリーを受け取り、ツリーがリモート実行 SQL に変換します。 リモート実行が必要ない場合、たとえば、述語には、ローカルのメソッドが呼び出されて、<xref:System.Linq.Enumerable.AsEnumerable%2A>カスタム メソッドを非表示にし、代わりに、標準クエリ演算子を使用するメソッドを使用できます。  
  
   
  
## Examples  
 次のコード例は、使用する方法を示します<xref:System.Linq.Enumerable.AsEnumerable%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>の型を非表示にするカスタム`Where`標準クエリ演算子の実装が必要なメソッドです。  
  
 [!code-csharp[System.Linq.Enumerable#108](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#108)]
 [!code-vb[System.Linq.Enumerable#108](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#108)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static decimal Average (this System.Collections.Generic.IEnumerable&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Average(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Decimal})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">一連の<see cref="T:System.Decimal" />値の平均を計算します。</param>
        <summary>シーケンスの平均を計算<see cref="T:System.Decimal" />値。</summary>
        <returns>値のシーケンスの平均値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Average()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Average%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29>を一連の値の平均を計算します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#8)]
 [!code-vb[System.Linq.Enumerable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />要素は含まれません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static double Average (this System.Collections.Generic.IEnumerable&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average(class System.Collections.Generic.IEnumerable`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Double})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">一連の<see cref="T:System.Double" />値の平均を計算します。</param>
        <summary>シーケンスの平均を計算<see cref="T:System.Double" />値。</summary>
        <returns>値のシーケンスの平均値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要素の合計が大きすぎてとして表すかどうか、 <xref:System.Double>、このメソッドは、正または負の無限大を返します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Average()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Average%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29>平均を計算します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#8)]
 [!code-vb[System.Linq.Enumerable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />要素は含まれません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static double Average (this System.Collections.Generic.IEnumerable&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average(class System.Collections.Generic.IEnumerable`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Int32})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">一連の<see cref="T:System.Int32" />値の平均を計算します。</param>
        <summary>シーケンスの平均を計算<see cref="T:System.Int32" />値。</summary>
        <returns>値のシーケンスの平均値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Average()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Average%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29>平均を計算します。  
  
 [!code-csharp[System.Linq.Enumerable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#8)]
 [!code-vb[System.Linq.Enumerable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />要素は含まれません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static double Average (this System.Collections.Generic.IEnumerable&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average(class System.Collections.Generic.IEnumerable`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Int64})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">一連の<see cref="T:System.Int64" />値の平均を計算します。</param>
        <summary>シーケンスの平均を計算<see cref="T:System.Int64" />値。</summary>
        <returns>値のシーケンスの平均値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Average()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Average%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29>平均を計算します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#8)]
 [!code-vb[System.Linq.Enumerable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />要素は含まれません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Average (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Average(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">平均を計算する Null 許容型の <see cref="T:System.Decimal" /> 値のシーケンス。</param>
        <summary>Null 許容型の <see cref="T:System.Decimal" /> 値のシーケンスの平均を計算します。</summary>
        <returns>値のシーケンスの平均値、または、ソース シーケンスが空または <see langword="null" /> である値のみを含む場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Average()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Average%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29>平均を計算します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#12)]
 [!code-vb[System.Linq.Enumerable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.OverflowException">シーケンス内の要素の合計は <see cref="F:System.Decimal.MaxValue" /> を超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">平均を計算する Null 許容型の <see cref="T:System.Double" /> 値のシーケンス。</param>
        <summary>Null 許容型の <see cref="T:System.Double" /> 値のシーケンスの平均を計算します。</summary>
        <returns>値のシーケンスの平均値、または、ソース シーケンスが空または <see langword="null" /> である値のみを含む場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要素の合計が大きすぎてとして表すかどうか、 <xref:System.Double>、このメソッドは、正または負の無限大を返します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Average()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Average%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29>平均を計算します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#12)]
 [!code-vb[System.Linq.Enumerable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">平均を計算する Null 許容型の <see cref="T:System.Int32" /> 値のシーケンス。</param>
        <summary>Null 許容型の <see cref="T:System.Int32" /> 値のシーケンスの平均を計算します。</summary>
        <returns>値のシーケンスの平均値、または、ソース シーケンスが空または <see langword="null" /> である値のみを含む場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Average()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Average%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29>平均を計算します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#12)]
 [!code-vb[System.Linq.Enumerable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.OverflowException">シーケンス内の要素の合計は <see cref="F:System.Int64.MaxValue" /> を超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">平均を計算する Null 許容型の <see cref="T:System.Int64" /> 値のシーケンス。</param>
        <summary>Null 許容型の <see cref="T:System.Int64" /> 値のシーケンスの平均を計算します。</summary>
        <returns>値のシーケンスの平均値、または、ソース シーケンスが空または <see langword="null" /> である値のみを含む場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Average()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Average%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29>平均を計算します。  
  
 [!code-csharp[System.Linq.Enumerable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#12)]
 [!code-vb[System.Linq.Enumerable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.OverflowException">シーケンス内の要素の合計は <see cref="F:System.Int64.MaxValue" /> を超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Average (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Average(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">平均を計算する Null 許容型の <see cref="T:System.Single" /> 値のシーケンス。</param>
        <summary>Null 許容型の <see cref="T:System.Single" /> 値のシーケンスの平均を計算します。</summary>
        <returns>値のシーケンスの平均値、または、ソース シーケンスが空または <see langword="null" /> である値のみを含む場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Average()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Average%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29>平均を計算します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#12)]
 [!code-vb[System.Linq.Enumerable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static float Average (this System.Collections.Generic.IEnumerable&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Average(class System.Collections.Generic.IEnumerable`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Single})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">一連の<see cref="T:System.Single" />値の平均を計算します。</param>
        <summary>シーケンスの平均を計算<see cref="T:System.Single" />値。</summary>
        <returns>値のシーケンスの平均値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Average()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Average%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29>平均を計算します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#8)]
 [!code-vb[System.Linq.Enumerable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />要素は含まれません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,decimal&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Decimal})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Decimal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">平均値の計算に使用される値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの平均を計算<see cref="T:System.Decimal" />入力シーケンスの各要素に対して変換関数を呼び出すことによって取得される値。</summary>
        <returns>値のシーケンスの平均値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Average()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Average%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29>平均を計算します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#16)]
 [!code-vb[System.Linq.Enumerable#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />要素は含まれません。</exception>
        <exception cref="T:System.OverflowException">シーケンス内の要素の合計は <see cref="F:System.Decimal.MaxValue" /> を超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,double&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Double&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">平均を計算する値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの平均を計算<see cref="T:System.Double" />入力シーケンスの各要素に対して変換関数を呼び出すことによって取得される値。</summary>
        <returns>値のシーケンスの平均値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Average()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Average%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29>平均を計算します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#16)]
 [!code-vb[System.Linq.Enumerable#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />要素は含まれません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">平均を計算する値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの平均を計算<see cref="T:System.Int32" />入力シーケンスの各要素に対して変換関数を呼び出すことによって取得される値。</summary>
        <returns>値のシーケンスの平均値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Average()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Average%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>平均を計算します。  
  
 [!code-csharp[System.Linq.Enumerable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#18)]
 [!code-vb[System.Linq.Enumerable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />要素は含まれません。</exception>
        <exception cref="T:System.OverflowException">シーケンス内の要素の合計は <see cref="F:System.Int64.MaxValue" /> を超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,long&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int64})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">source の要素の型。</typeparam>
        <param name="source">平均を計算する値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの平均を計算<see cref="T:System.Int64" />入力シーケンスの各要素に対して変換関数を呼び出すことによって取得される値。</summary>
        <returns>値のシーケンスの平均値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Average()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Average%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29>平均を計算します。  
  
 [!code-csharp[System.Linq.Enumerable#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#16)]
 [!code-vb[System.Linq.Enumerable#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />要素は含まれません。</exception>
        <exception cref="T:System.OverflowException">シーケンス内の要素の合計は <see cref="F:System.Int64.MaxValue" /> を超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">平均を計算する値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>Null 許容のシーケンスの平均を計算<see cref="T:System.Decimal" />入力シーケンスの各要素に対して変換関数を呼び出すことによって取得される値。</summary>
        <returns>値のシーケンスの平均値、または、ソース シーケンスが空または <see langword="null" /> である値のみを含む場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Average()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Average%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29>平均を計算します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#16)]
 [!code-vb[System.Linq.Enumerable#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.OverflowException">シーケンス内の要素の合計は <see cref="F:System.Decimal.MaxValue" /> を超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">平均を計算する値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>Null 許容のシーケンスの平均を計算<see cref="T:System.Double" />入力シーケンスの各要素に対して変換関数を呼び出すことによって取得される値。</summary>
        <returns>値のシーケンスの平均値、または、ソース シーケンスが空または <see langword="null" /> である値のみを含む場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Average()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Average%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29>平均を計算します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#16)]
 [!code-vb[System.Linq.Enumerable#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">平均を計算する値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>Null 許容のシーケンスの平均を計算<see cref="T:System.Int32" />入力シーケンスの各要素に対して変換関数を呼び出すことによって取得される値。</summary>
        <returns>値のシーケンスの平均値、または、ソース シーケンスが空または <see langword="null" /> である値のみを含む場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Average()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Average%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>平均を計算します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#18)]
 [!code-vb[System.Linq.Enumerable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.OverflowException">シーケンス内の要素の合計は <see cref="F:System.Int64.MaxValue" /> を超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">平均を計算する値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>Null 許容のシーケンスの平均を計算<see cref="T:System.Int64" />入力シーケンスの各要素に対して変換関数を呼び出すことによって取得される値。</summary>
        <returns>値のシーケンスの平均値、または、ソース シーケンスが空または <see langword="null" /> である値のみを含む場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Average()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Average%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29>平均を計算します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#16)]
 [!code-vb[System.Linq.Enumerable#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">平均を計算する値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>Null 許容のシーケンスの平均を計算<see cref="T:System.Single" />入力シーケンスの各要素に対して変換関数を呼び出すことによって取得される値。</summary>
        <returns>値のシーケンスの平均値、または、ソース シーケンスが空または <see langword="null" /> である値のみを含む場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Average()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Average%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>平均を計算します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#18)]
 [!code-vb[System.Linq.Enumerable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,float&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Single&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">平均を計算する値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの平均を計算<see cref="T:System.Single" />入力シーケンスの各要素に対して変換関数を呼び出すことによって取得される値。</summary>
        <returns>値のシーケンスの平均値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Average()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Average%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>平均を計算します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#18)]
 [!code-vb[System.Linq.Enumerable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />要素は含まれません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Cast&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Cast&lt;TResult&gt; (this System.Collections.IEnumerable source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Cast&lt;TResult&gt;(class System.Collections.IEnumerable source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Cast``1(System.Collections.IEnumerable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.IEnumerable" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">型の要素をキャストする<c>ソース</c>にします。</typeparam>
        <param name="source"><see cref="T:System.Collections.IEnumerable" />型にキャストする要素を含む<c>TResult</c>です。</param>
        <summary>要素をキャスト、<see cref="T:System.Collections.IEnumerable" />指定された型にします。</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerable`1" />指定された型にキャスト ソース シーケンスの各要素を格納しています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは遅延実行を使用して実装されます。 即時の戻り値は、操作を実行するために必要なすべての情報を格納するオブジェクトです。 オブジェクトのいずれかを呼び出したが列挙されるまで、このメソッドで表されるクエリが実行されていませんが、`GetEnumerator`メソッド直接、またはを使用して`foreach`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`For Each`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 <xref:System.Linq.Enumerable.Cast%60%601%28System.Collections.IEnumerable%29>メソッドが必要な型情報を指定することによって、非ジェネリック コレクションで呼び出される標準クエリ演算子を使用します。 たとえば、<xref:System.Collections.ArrayList>を実装していません<xref:System.Collections.Generic.IEnumerable%601>が呼び出すことによって<xref:System.Linq.Enumerable.Cast%60%601%28System.Collections.IEnumerable%29>上、<xref:System.Collections.ArrayList>オブジェクト、標準クエリ演算子のシーケンスをクエリに使用できます。  
  
 要素型にキャストできない場合`TResult`、このメソッドは例外をスローします。 型にキャスト可能な要素のみを取得する`TResult`を使用して、<xref:System.Linq.Enumerable.OfType%2A>メソッドの代わりに<xref:System.Linq.Enumerable.Cast%60%601%28System.Collections.IEnumerable%29>です。  
  
 クエリ式では、明示的に型指定された繰り返し変数に変換を呼び出す<xref:System.Linq.Enumerable.Cast%60%601%28System.Collections.IEnumerable%29>です。 この例では、明示的に型指定された範囲変数の構文を使用します。  
  
```csharp  
from int i in objects  
```  
  
```vb  
From i As Integer In objects  
```  
  
   
  
## Examples  
 次のコード例は、使用する方法を示します<xref:System.Linq.Enumerable.Cast%60%601%28System.Collections.IEnumerable%29>で標準クエリ演算子の使用を有効にする、<xref:System.Collections.ArrayList>です。  
  
 [!code-csharp[System.Linq.Enumerable#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#19)]
 [!code-vb[System.Linq.Enumerable#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidCastException">シーケンス内の要素を型にキャストすることはできません<paramref name="TResult" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Concat&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Concat&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Concat``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">入力シーケンスの要素の型。</typeparam>
        <param name="first">連結する最初のシーケンス。</param>
        <param name="second">最初のシーケンスに連結するシーケンス。</param>
        <summary>2 つのシーケンスを連結します。</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerable`1" /> 2 つの入力シーケンスの連結された要素を格納します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは遅延実行を使用して実装されます。 即時の戻り値は、操作を実行するために必要なすべての情報を格納するオブジェクトです。 オブジェクトのいずれかを呼び出したが列挙されるまで、このメソッドで表されるクエリが実行されていませんが、`GetEnumerator`メソッド直接、またはを使用して`foreach`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`For Each`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 <xref:System.Linq.Enumerable.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29>メソッドとは異なります、<xref:System.Linq.Enumerable.Union%2A>メソッドのため、<xref:System.Linq.Enumerable.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29>メソッドは、入力シーケンスの元のすべての要素を返します。 <xref:System.Linq.Enumerable.Union%2A>メソッドは、一意の要素のみを返します。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29>を 2 つのシーケンスを連結します。  
  
 [!code-csharp[System.Linq.Enumerable#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#20)]
 [!code-vb[System.Linq.Enumerable#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#20)]  
  
 たとえば、配列のコレクションのシーケンスを構築し、適用する 2 つのシーケンスを連結する方法も、 <xref:System.Linq.Enumerable.SelectMany%2A> identity セレクター関数を引数としてメソッドです。 次の例では、このように使用する<xref:System.Linq.Enumerable.SelectMany%2A>です。  
  
 [!code-csharp[System.Linq.Enumerable#112](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#112)]
 [!code-vb[System.Linq.Enumerable#112](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#112)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> または <paramref name="second" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Contains&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TSource value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Contains&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TSource value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Contains``1(System.Collections.Generic.IEnumerable{``0},``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="value" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">値の検索対象となるシーケンス。</param>
        <param name="value">シーケンス内で検索する値。</param>
        <summary>シーケンスが既定の等値比較子を使用して、指定された要素を含むかどうかを判断します。</summary>
        <returns>
          <see langword="true" />ソース シーケンスには、指定した値を持つ要素が含まれている場合それ以外の場合、<see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合の種類`source`実装<xref:System.Collections.Generic.ICollection%601>、`Contains`結果を取得するその実装でメソッドが呼び出されます。 それ以外の場合、このメソッドを判断するかどうか`source`指定した要素が含まれています。  
  
 列挙は、一致する要素が見つかるとすぐに終了します。  
  
 要素が既定の等値比較子を使用して、指定した値と比較して<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Contains%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29>を配列に特定の要素が含まれて かどうかを判断します。  
  
 [!code-csharp[System.Linq.Enumerable#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#21)]
 [!code-vb[System.Linq.Enumerable#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Contains&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TSource value, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Contains&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TSource value, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Contains``1(System.Collections.Generic.IEnumerable{``0},``0,System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="value" Type="TSource" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">値の検索対象となるシーケンス。</param>
        <param name="value">シーケンス内で検索する値。</param>
        <param name="comparer">値を比較する等値比較子。</param>
        <summary>シーケンスが、指定されたを使用して、指定された要素を含めるかどうかを判断<see cref="T:System.Collections.Generic.IEqualityComparer`1" />です。</summary>
        <returns>
          <see langword="true" />ソース シーケンスには、指定した値を持つ要素が含まれている場合それ以外の場合、<see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 列挙は、一致する要素が見つかるとすぐに終了します。  
  
 場合`comparer`は`null`、既定の等値比較子<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>、指定された値の要素を比較するために使用します。  
  
   
  
## Examples  
 次の例で使用できる等値比較子を実装する方法を示しています、<xref:System.Linq.Enumerable.Contains%2A>メソッドです。  
  
 [!code-csharp[CSLINQCustomComparer#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#1)]
 [!code-vb[CSLINQCustomComparer#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#1)]  
  
 この比較演算子を実装すると後のシーケンスを使用することができます`Product`内のオブジェクト、<xref:System.Linq.Enumerable.Contains%2A>メソッドを次の例で示すようにします。  
  
 [!code-csharp[CSLINQCustomComparer#6](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#6)]
 [!code-vb[CSLINQCustomComparer#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Count&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Count&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Count&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Count``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">カウントする要素が格納されているシーケンス。</param>
        <summary>シーケンス内の要素の数を返します。</summary>
        <returns>入力シーケンス内の要素数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合の種類`source`実装<xref:System.Collections.Generic.ICollection%601>、その実装を使用して要素の数を取得します。 それ以外の場合、このメソッドは、数を決定します。  
  
 使用して、<xref:System.Linq.Enumerable.LongCount%2A>メソッドよりも長くなるように結果を許可するしているときに<xref:System.Int32.MaxValue>です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Count()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Count%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>を配列内の要素をカウントします。  
  
 [!code-csharp[System.Linq.Enumerable#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#22)]
 [!code-vb[System.Linq.Enumerable#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.OverflowException">内の要素の数<paramref name="source" />よりも大きい<see cref="F:System.Int32.MaxValue" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Count&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Count&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Count&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Count``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">テストおよびカウントする要素が格納されているシーケンス。</param>
        <param name="predicate">各要素が条件を満たしているかどうかをテストする関数。</param>
        <summary>条件を満たす指定されたシーケンス内の数の要素を表す数値を返します。</summary>
        <returns>述語関数の条件を満たす、シーケンス内の要素数を表す数値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合の種類`source`実装<xref:System.Collections.Generic.ICollection%601>、その実装を使用して要素の数を取得します。 それ以外の場合、このメソッドは、数を決定します。  
  
 使用する必要があります、<xref:System.Linq.Enumerable.LongCount%2A>メソッドよりも長くなるように結果を許可するしているときに<xref:System.Int32.MaxValue>です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Count()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Count%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>条件を満たす、配列内の要素をカウントします。  
  
 [!code-csharp[System.Linq.Enumerable#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#23)]
 [!code-vb[System.Linq.Enumerable#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="predicate" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.OverflowException">内の要素の数<paramref name="source" />よりも大きい<see cref="F:System.Int32.MaxValue" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultIfEmpty&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; DefaultIfEmpty&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; DefaultIfEmpty&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.DefaultIfEmpty``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">シーケンスが空の場合に、既定値を返すシーケンス。</param>
        <summary>シーケンスが空の場合はシングルトン コレクションに指定されたシーケンスまたは型パラメーターの既定値の要素を返します。</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerable`1" />の既定値を格納しているオブジェクト、<paramref name="TSource" />入力<paramref name="source" />が空であるそれ以外の場合、<paramref name="source" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは遅延実行を使用して実装されます。 即時の戻り値は、操作を実行するために必要なすべての情報を格納するオブジェクトです。 オブジェクトのいずれかを呼び出したが列挙されるまで、このメソッドで表されるクエリが実行されていませんが、`GetEnumerator`メソッド直接、またはを使用して`foreach`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`For Each`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 参照および null 許容型の既定値は`null`します。  
  
 このメソッドと組み合わされますが、左外部結合を生成するために使用できます、 <xref:System.Linq.Enumerable.GroupJoin%2A>) メソッドです。  
  
   
  
## Examples  
 次のコード例を使用する方法を示します<xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>ソース シーケンスが空である場合に、既定値を指定します。  
  
 この例では、空のシーケンスを使用します。  
  
 [!code-csharp[System.Linq.Enumerable#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#24)]
 [!code-vb[System.Linq.Enumerable#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#24)]  
  
 この例では、空のシーケンスを使用します。  
  
 [!code-csharp[System.Linq.Enumerable#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#25)]
 [!code-vb[System.Linq.Enumerable#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultIfEmpty&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; DefaultIfEmpty&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TSource defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; DefaultIfEmpty&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TSource defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.DefaultIfEmpty``1(System.Collections.Generic.IEnumerable{``0},``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="defaultValue" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">シーケンスが空の場合に、指定された値を返すシーケンス。</param>
        <param name="defaultValue">シーケンスが空の場合に返す値。</param>
        <summary>シーケンスが空の場合はシングルトン コレクションに指定されたシーケンスまたは指定された値の要素を返します。</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerable`1" />を格納している<paramref name="defaultValue" />場合<paramref name="source" />が空であるそれ以外の場合、<paramref name="source" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは遅延実行を使用して実装されます。 即時の戻り値は、操作を実行するために必要なすべての情報を格納するオブジェクトです。 オブジェクトのいずれかを呼び出したが列挙されるまで、このメソッドで表されるクエリが実行されていませんが、`GetEnumerator`メソッド直接、またはを使用して`foreach`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`For Each`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 このメソッドと組み合わされますが、左外部結合を生成するために使用できます、 <xref:System.Linq.Enumerable.GroupJoin%2A>) メソッドです。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています、<xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29>メソッド、既定値を指定します。 最初のシーケンスが空でないと、2 番目のシーケンスが空です。  
  
 [!code-csharp[System.Linq.Enumerable#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#26)]
 [!code-vb[System.Linq.Enumerable#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#26)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Distinct&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>シーケンスから一意の要素を返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 結果のシーケンスが順序付けられたです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Distinct&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Distinct&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Distinct&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Distinct``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">重複する要素を削除する対象となるシーケンス。</param>
        <summary>値を比較する既定の等値比較子を使用して、シーケンスから一意の要素を返します。</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerable`1" />ソース シーケンスの一意の要素を格納しています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは遅延実行を使用して実装されます。 即時の戻り値は、操作を実行するために必要なすべての情報を格納するオブジェクトです。 オブジェクトのいずれかを呼び出したが列挙されるまで、このメソッドで表されるクエリが実行されていませんが、`GetEnumerator`メソッド直接、またはを使用して`foreach`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`For Each`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 <xref:System.Linq.Enumerable.Distinct%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>メソッドは、順序なしのシーケンスが含まれていない重複する値を返します。 既定の等値比較子を使用して<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>値を比較します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Distinct`の呼び出しに変換される句<xref:System.Linq.Enumerable.Distinct%2A>です。  
  
 既定の等値比較子<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>、実装する型の値を比較するために使用、<xref:System.IEquatable%601>ジェネリック インターフェイス。 カスタム データ型を比較する必要がありますをこのインターフェイスを実装し、独自<xref:System.Object.GetHashCode%2A>と<xref:System.Object.Equals%2A>の型のメソッドです。  
  
 使用する例については<xref:System.Collections.Generic.IEqualityComparer%601>カスタム比較子を定義するのを参照してください。<xref:System.Linq.Enumerable.Distinct%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Distinct%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>を整数のシーケンスから一意の要素を返します。  
  
 [!code-csharp[System.Linq.Enumerable#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#27)]
 [!code-vb[System.Linq.Enumerable#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#27)]  
  
 実装する必要があるいくつかのカスタム データ型のオブジェクトのシーケンスから一意の要素を返す場合は、<xref:System.IEquatable%601>クラスのジェネリック インターフェイス。 次のコード例は、カスタム データ型でこのインターフェイスを実装して提供する方法を示しています。<xref:System.Object.GetHashCode%2A>と<xref:System.Object.Equals%2A>メソッドです。  
  
 [!code-csharp[CSLINQEncapsulatedComparer#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#1)]
 [!code-vb[CSLINQEncapsulatedComparer#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#1)]  
  
 このインターフェイスを実装した後のシーケンスを使用することができます`Product`内のオブジェクト、<xref:System.Linq.Enumerable.Distinct%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>メソッドを次の例で示すようにします。  
  
 [!code-csharp[CSLINQEncapsulatedComparer#5](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#5)]
 [!code-vb[CSLINQEncapsulatedComparer#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Distinct&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Distinct&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Distinct&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Distinct``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">重複する要素を削除する対象となるシーケンス。</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IEqualityComparer`1" />値を比較します。</param>
        <summary>指定されたを使用してシーケンスから一意の要素を返します<see cref="T:System.Collections.Generic.IEqualityComparer`1" />値を比較します。</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerable`1" />ソース シーケンスの一意の要素を格納しています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは遅延実行を使用して実装されます。 即時の戻り値は、操作を実行するために必要なすべての情報を格納するオブジェクトです。 オブジェクトのいずれかを呼び出したが列挙されるまで、このメソッドで表されるクエリが実行されていませんが、`GetEnumerator`メソッド直接、またはを使用して`foreach`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`For Each`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 <xref:System.Linq.Enumerable.Distinct%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29>メソッドは、順序なしのシーケンスが含まれていない重複する値を返します。 C 場合`omparer`は`null`、既定の等値比較子<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>値を比較するために使用します。  
  
   
  
## Examples  
 次の例で使用できる等値比較子を実装する方法を示しています、<xref:System.Linq.Enumerable.Distinct%2A>メソッドです。  
  
 [!code-csharp[CSLINQCustomComparer#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#1)]
 [!code-vb[CSLINQCustomComparer#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#1)]  
  
 この比較演算子を実装すると後のシーケンスを使用することができます`Product`内のオブジェクト、<xref:System.Linq.Enumerable.Distinct%2A>メソッドを次の例で示すようにします。  
  
 [!code-csharp[CSLINQCustomComparer#5](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#5)]
 [!code-vb[CSLINQCustomComparer#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ElementAt&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource ElementAt&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource ElementAt&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ElementAt``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source"><see cref="T:System.Collections.Generic.IEnumerable`1" />から要素を返します。</param>
        <param name="index">取得する要素の、0 から始まるインデックス。</param>
        <summary>シーケンスの指定したインデックス位置にある要素を返します。</summary>
        <returns>ソース シーケンス内の指定された位置にある要素。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合の種類`source`実装<xref:System.Collections.Generic.IList%601>、その実装を使用して、指定したインデックス位置にある要素を取得します。 それ以外の場合、このメソッドは、指定した要素を取得します。  
  
 このメソッドは例外をスロー`index`が範囲外です。 指定したインデックスが範囲外のときに、既定値を返すを使用して、<xref:System.Linq.Enumerable.ElementAtOrDefault%2A>メソッドです。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.ElementAt%2A>を特定の位置に要素を返します。  
  
 [!code-csharp[System.Linq.Enumerable#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#28)]
 [!code-vb[System.Linq.Enumerable#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />小さい 0 より大きいまたは内の要素の数と等しく<paramref name="source" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ElementAtOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource ElementAtOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource ElementAtOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ElementAtOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source"><see cref="T:System.Collections.Generic.IEnumerable`1" />から要素を返します。</param>
        <param name="index">取得する要素の、0 から始まるインデックス。</param>
        <summary>シーケンス内の指定したインデックス位置にある要素を返します。インデックスが範囲外の場合は既定値を返します。</summary>
        <returns>
          <see langword="default" />(<paramref name="TSource" />) インデックスがソース シーケンスの境界の外側にある場合、それ以外の場合、ソース シーケンスの指定した位置にある要素。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合の種類`source`実装<xref:System.Collections.Generic.IList%601>、その実装を使用して、指定したインデックス位置にある要素を取得します。 それ以外の場合、このメソッドは、指定した要素を取得します。  
  
 参照および null 許容型の既定値は`null`します。  
  
   
  
## Examples  
 <xref:System.Linq.Enumerable.ElementAtOrDefault%2A> を使用する方法を次のコード例に示します。 この例では、配列の境界外にあるインデックスを使用します。  
  
 [!code-csharp[System.Linq.Enumerable#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#29)]
 [!code-vb[System.Linq.Enumerable#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Empty&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Empty&lt;TResult&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Empty&lt;TResult&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Empty``1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="TResult">返されるジェネリック型パラメーターに割り当てる型<see cref="T:System.Collections.Generic.IEnumerable`1" />です。</typeparam>
        <summary>空白を返します<see cref="T:System.Collections.Generic.IEnumerable`1" />を持つ指定した型引数。</summary>
        <returns>空<see cref="T:System.Collections.Generic.IEnumerable`1" />、型引数が<paramref name="TResult" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Empty%60%601>メソッド型の空のシーケンスはキャッシュ`TResult`です。 返されるオブジェクトを列挙すると、要素は生成されません。  
  
 場合によっては、このメソッドに便利受け取るユーザー定義メソッドに空のシーケンスを渡す、<xref:System.Collections.Generic.IEnumerable%601>です。 メソッドに対して中立的な要素を生成するように使用することもできます<xref:System.Linq.Enumerable.Union%2A>です。 この使用例については例を参照してください<xref:System.Linq.Enumerable.Empty%60%601>です。  
  
   
  
## Examples  
 次のコード例は、使用する方法を示します<xref:System.Linq.Enumerable.Empty%60%601>、空を生成する<xref:System.Collections.Generic.IEnumerable%601>です。  
  
 [!code-csharp[System.Linq.Enumerable#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#30)]
 [!code-vb[System.Linq.Enumerable#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#30)]  
  
 次のコード例に示しますの可能性のあるアプリケーション、<xref:System.Linq.Enumerable.Empty%60%601>メソッドです。 <xref:System.Linq.Enumerable.Aggregate%2A>メソッドを文字列配列のコレクションに適用します。 コレクション内の各配列の要素をその結果に追加<xref:System.Collections.Generic.IEnumerable%601>その配列には、次の 4 つまたは複数の要素が含まれている場合のみです。 <xref:System.Linq.Enumerable.Empty%2A>シード値を生成するために使用<xref:System.Linq.Enumerable.Aggregate%2A>空のシーケンスだけが返される場合は、コレクション内の配列に 4 つ以上の要素が存在しないためです。  
  
 [!code-csharp[System.Linq.Enumerable#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#31)]
 [!code-vb[System.Linq.Enumerable#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Except&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Except&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Except&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Except``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">入力シーケンスの要素の型。</typeparam>
        <param name="first"><see cref="T:System.Collections.Generic.IEnumerable`1" />もに含まれていない要素を持つ<c>2 番目</c>が返されます。</param>
        <param name="second"><see cref="T:System.Collections.Generic.IEnumerable`1" />最初のシーケンスにも発生する要素が返されるシーケンスから削除する要素になります。</param>
        <summary>値を比較する既定の等値比較子を使用して、2 つのシーケンスの差集合を生成します。</summary>
        <returns>2 つのシーケンスの要素の差集合が格納されているシーケンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは遅延実行を使用して実装されます。 即時の戻り値は、操作を実行するために必要なすべての情報を格納するオブジェクトです。 オブジェクトのいずれかを呼び出したが列挙されるまで、このメソッドで表されるクエリが実行されていませんが、`GetEnumerator`メソッド直接、またはを使用して`foreach`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`For Each`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 2 つのセットの差集合は、2 番目のセットに表示されない最初のセットのメンバーとして定義されます。  
  
> [!NOTE]
>  このメソッドは、該当する要素を返します`first`に含まれていない`second`です。 該当する要素も返されません`second`に含まれていない`first`です。  
  
 既定の等値比較子<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>、実装する型の値を比較するために使用、<xref:System.Collections.Generic.IEqualityComparer%601>ジェネリック インターフェイス。 カスタム データ型を比較する必要がありますをこのインターフェイスを実装し、独自<xref:System.Object.GetHashCode%2A>と<xref:System.Object.Equals%2A>の型のメソッドです。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています、<xref:System.Linq.Enumerable.Except%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29>を 2 つの数値のシーケンスを比較し、要素を返すメソッドが最初のシーケンスにのみ表示されます。  
  
 [!code-csharp[System.Linq.Enumerable#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#34)]
 [!code-vb[System.Linq.Enumerable#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#34)]  
  
 実装する必要があるいくつかのカスタム データ型のオブジェクトのシーケンスを比較する場合は、 <xref:System.Collections.Generic.IEqualityComparer%601> helperclass のジェネリック インターフェイス。 次のコード例は、カスタム データ型でこのインターフェイスを実装して提供する方法を示しています。<xref:System.Object.GetHashCode%2A>と<xref:System.Object.Equals%2A>メソッドです。  
  
 [!code-csharp[CSLINQEncapsulatedComparer#9](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#9)]  
  
 このインターフェイスを実装した後のシーケンスを使用することができます`ProductA`内のオブジェクト、<xref:System.Linq.Enumerable.Except%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29>メソッドを次の例で示すようにします。  
  
 [!code-csharp[CSLINQEncapsulatedComparer#7](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#7)]
 [!code-vb[CSLINQEncapsulatedComparer#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> または <paramref name="second" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Except&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Except&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Except&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Except``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">入力シーケンスの要素の型。</typeparam>
        <param name="first"><see cref="T:System.Collections.Generic.IEnumerable`1" />もに含まれていない要素を持つ<c>2 番目</c>が返されます。</param>
        <param name="second"><see cref="T:System.Collections.Generic.IEnumerable`1" />最初のシーケンスにも発生する要素が返されるシーケンスから削除する要素になります。</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IEqualityComparer`1" />値を比較します。</param>
        <summary>指定されたを使用して 2 つのシーケンスの差集合を生成<see cref="T:System.Collections.Generic.IEqualityComparer`1" />値を比較します。</summary>
        <returns>2 つのシーケンスの要素の差集合が格納されているシーケンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 C 場合`omparer`は`null`、既定の等値比較子<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>値を比較するために使用します。  
  
   
  
## Examples  
 次の例で使用できる等値比較子を実装する方法を示しています、<xref:System.Linq.Enumerable.Except%2A>メソッドです。  
  
 [!code-csharp[CSLINQCustomComparer#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#1)]
 [!code-vb[CSLINQCustomComparer#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#1)]  
  
 この比較演算子を実装すると後のシーケンスを使用することができます`Product`内のオブジェクト、<xref:System.Linq.Enumerable.Except%2A>メソッドを次の例で示すようにします。  
  
 [!code-csharp[CSLINQCustomComparer#7](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#7)]
 [!code-vb[CSLINQCustomComparer#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> または <paramref name="second" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="First&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource First&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource First&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.First``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source"><see cref="T:System.Collections.Generic.IEnumerable`1" />の最初の要素を返します。</param>
        <summary>シーケンスの最初の要素を返します。</summary>
        <returns>指定されたシーケンスの最初の要素。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>場合、メソッドが例外をスロー`source`要素が含まれていません。 代わりに、ソース シーケンスが空の場合は、既定値を返すを使用して、<xref:System.Linq.Enumerable.FirstOrDefault%2A>メソッドです。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>を配列の最初の要素を返します。  
  
 [!code-csharp[System.Linq.Enumerable#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#35)]
 [!code-vb[System.Linq.Enumerable#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">ソース シーケンスが空です。</exception>
      </Docs>
    </Member>
    <Member MemberName="First&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource First&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource First&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.First``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source"><see cref="T:System.Collections.Generic.IEnumerable`1" />から要素を返します。</param>
        <param name="predicate">各要素が条件を満たしているかどうかをテストする関数。</param>
        <summary>指定された条件を満たす、シーケンスの最初の要素を返します。</summary>
        <returns>指定された述語関数でテストに合格する、シーケンスの最初の要素。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>で一致する要素が見つからない場合、メソッドが例外をスロー`source`です。 一致する要素が存在しない場合に、既定値を返すを使用して、<xref:System.Linq.Enumerable.FirstOrDefault%2A>メソッドです。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>を条件を満たす、配列の最初の要素を返します。  
  
 [!code-csharp[System.Linq.Enumerable#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#36)]
 [!code-vb[System.Linq.Enumerable#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#36)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="predicate" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="predicate" /> の条件を満たす要素はありません。  
  
 または  
  
 ソース シーケンスが空です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FirstOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource FirstOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource FirstOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source"><see cref="T:System.Collections.Generic.IEnumerable`1" />の最初の要素を返します。</param>
        <summary>シーケンスの最初の要素を返します。シーケンスに要素が含まれていない場合は既定値を返します。</summary>
        <returns>
          <see langword="default" />(<paramref name="TSource" />) 場合<paramref name="source" />が空であるそれ以外の場合、最初の要素<paramref name="source" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 参照および null 許容型の既定値は`null`します。  
  
 <xref:System.Linq.Enumerable.FirstOrDefault%2A>メソッドは、既定値を指定する方法を提供していません。 以外の場合、既定値を指定する場合は、`default(TSource)`を使用して、<xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29>例」のセクションで説明するメソッド。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.FirstOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>で空の配列。  
  
 [!code-csharp[System.Linq.Enumerable#37](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#37)]
 [!code-vb[System.Linq.Enumerable#37](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#37)]  
  
 値も`default(TSource)`コレクションに要素が含まれていない場合に使用する既定値ではありません。 不要な既定値の場合、結果を確認してから、必要な場合、代わりに使用することができます、<xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29>コレクションが空の場合に使用する既定値を指定します。 次に、呼び出す<xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>を最初の要素を取得します。 次のコード例では、両方の手法を使用して、月を表す数値のコレクションが空の場合は、1 の既定値を取得します。 整数の既定値は 0 で、任意の月に対応していない、既定値必要がありますとして指定する 1 代わりにします。 クエリの実行が完了した後、不要な既定値の最初の結果変数がチェックされます。 使用して、2 つ目の結果変数が取得された<xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29>を既定値は 1 を指定します。  
  
 [!code-csharp[System.Linq.Enumerable#126](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#126)]
 [!code-vb[System.Linq.Enumerable#126](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#126)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FirstOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource FirstOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource FirstOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source"><see cref="T:System.Collections.Generic.IEnumerable`1" />から要素を返します。</param>
        <param name="predicate">各要素が条件を満たしているかどうかをテストする関数。</param>
        <summary>条件を満たす、シーケンスの最初の要素を返します。このような要素が見つからない場合は既定値を返します。</summary>
        <returns>
          <see langword="default" />(<paramref name="TSource" />) 場合<paramref name="source" />空、または要素がで指定されたテストを通過しないかどうかは、 <paramref name="predicate" />、それ以外の最初の要素<paramref name="source" />で指定されたテストに合格した<paramref name="predicate" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 参照および null 許容型の既定値は`null`します。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.FirstOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>述語に渡すことで。 メソッドに 2 つ目の呼び出しで要素がない、条件を満たす、配列にします。  
  
 [!code-csharp[System.Linq.Enumerable#38](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#38)]
 [!code-vb[System.Linq.Enumerable#38](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="predicate" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt; GroupBy&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TSource&gt;&gt; GroupBy&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <typeparam name="TKey">によって返されるキーの種類<c>keySelector</c>です。</typeparam>
        <param name="source"><see cref="T:System.Collections.Generic.IEnumerable`1" />をグループ化する要素を格納します。</param>
        <param name="keySelector">各要素のキーを抽出する関数。</param>
        <summary>指定されたキー セレクター関数に従ってシーケンスの要素をグループ化します。</summary>
        <returns><c>IEnumerable&lt;IGrouping&lt;TKey, TSource&gt; &gt; </c> (C#) または<c>IEnumerable (Of (Of TKey、TSource) IGrouping)</c>で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]場所各<see cref="T:System.Linq.IGrouping`2" />オブジェクトには、オブジェクトとキーのシーケンスが含まれています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは遅延実行を使用して実装されます。 即時の戻り値は、操作を実行するために必要なすべての情報を格納するオブジェクトです。 オブジェクトのいずれかを呼び出したが列挙されるまで、このメソッドで表されるクエリが実行されていませんが、`GetEnumerator`メソッド直接、またはを使用して`foreach`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`For Each`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
> [!NOTE]
>  例については`GroupBy`、次のトピックを参照してください。  
>   
>  -   <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29>  
> -   <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%29>  
> -   <xref:System.Linq.Enumerable.GroupBy%60%604%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%29>  
  
 <xref:System.Linq.Enumerable.GroupBy%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29>メソッドのコレクションを返します<xref:System.Linq.IGrouping%602>オブジェクト、発生した個別のキーごとに 1 つです。 <xref:System.Linq.IGrouping%602>は、<xref:System.Collections.Generic.IEnumerable%601>その要素に関連付けられたキーを持ちます。  
  
 <xref:System.Linq.IGrouping%602>オブジェクトは内の要素の順序に基づいて注文で返されます`source`それぞれの最初のキーを生成する<xref:System.Linq.IGrouping%602>です。 グループ内の要素に現れる順序で返されます`source`です。  
  
 既定の等値比較子<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>キーを比較するために使用します。  
  
 クエリ式の構文では、 `group by` ([!INCLUDE[csprcs](~/includes/csprcs-md.md)]) または`Group By Into`([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) の呼び出しに変換される句<xref:System.Linq.Enumerable.GroupBy%2A>です。 詳細と使用状況の例については、次を参照してください。 [group 句](~/docs/csharp/language-reference/keywords/group-clause.md)と[グループ By 句](~/docs/visual-basic/language-reference/queries/group-by-clause.md)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="keySelector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt; GroupBy&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TSource&gt;&gt; GroupBy&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <typeparam name="TKey">によって返されるキーの種類<c>keySelector</c>です。</typeparam>
        <param name="source"><see cref="T:System.Collections.Generic.IEnumerable`1" />をグループ化する要素を格納します。</param>
        <param name="keySelector">各要素のキーを抽出する関数。</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IEqualityComparer`1" />キーを比較します。</param>
        <summary>指定された比較子を使用してキーを比較して、指定されたキー セレクター関数に従ってシーケンスの要素をグループ化します。</summary>
        <returns><c>IEnumerable&lt;IGrouping&lt;TKey, TSource&gt; &gt; </c> (C#) または<c>IEnumerable (Of (Of TKey、TSource) IGrouping)</c>で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]場所各<see cref="T:System.Linq.IGrouping`2" />オブジェクトがオブジェクトとキーのコレクションを格納します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは遅延実行を使用して実装されます。 即時の戻り値は、操作を実行するために必要なすべての情報を格納するオブジェクトです。 オブジェクトのいずれかを呼び出したが列挙されるまで、このメソッドで表されるクエリが実行されていませんが、`GetEnumerator`メソッド直接、またはを使用して`foreach`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`For Each`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
> [!NOTE]
>  例については`GroupBy`、次のトピックを参照してください。  
>   
>  -   <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29>  
> -   <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%29>  
> -   <xref:System.Linq.Enumerable.GroupBy%60%604%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%29>  
  
 <xref:System.Linq.Enumerable.GroupBy%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29>メソッドのコレクションを返します<xref:System.Linq.IGrouping%602>オブジェクト、発生した個別のキーごとに 1 つです。 <xref:System.Linq.IGrouping%602>は、<xref:System.Collections.Generic.IEnumerable%601>その要素に関連付けられたキーを持ちます。  
  
 <xref:System.Linq.IGrouping%602>オブジェクトは内の要素の順序に基づいて注文で返されます`source`それぞれの最初のキーを生成する<xref:System.Linq.IGrouping%602>です。 グループ内の要素に現れる順序で返されます`source`です。  
  
 場合`comparer`は`null`、既定の等値比較子<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>キーを比較するために使用します。  
  
 2 つのキーによると等しいと見なされた場合`comparer`、最初のキーがそのグループ化キーとして選択します。  
  
 クエリ式の構文では、 `group by` ([!INCLUDE[csprcs](~/includes/csprcs-md.md)]) または`Group By Into`([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) の呼び出しに変換される句<xref:System.Linq.Enumerable.GroupBy%2A>です。 詳細と使用状況の例については、次を参照してください。 [group 句](~/docs/csharp/language-reference/keywords/group-clause.md)と[グループ By 句](~/docs/visual-basic/language-reference/queries/group-by-clause.md)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="keySelector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt; GroupBy&lt;TSource,TKey,TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TElement&gt;&gt; GroupBy&lt;TSource, TKey, TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <typeparam name="TKey">によって返されるキーの種類<c>keySelector</c>です。</typeparam>
        <typeparam name="TElement"><see cref="T:System.Linq.IGrouping`2" /> 内の要素の型。</typeparam>
        <param name="source"><see cref="T:System.Collections.Generic.IEnumerable`1" />をグループ化する要素を格納します。</param>
        <param name="keySelector">各要素のキーを抽出する関数。</param>
        <param name="elementSelector">各ソース要素を内の要素にマップする関数、<see cref="T:System.Linq.IGrouping`2" />です。</param>
        <summary>指定されたキー セレクター関数と、指定された関数を使用して各グループの要素を射影に従ってシーケンスの要素をグループ化します。</summary>
        <returns><c>IEnumerable&lt;IGrouping&lt;TKey, TElement&gt; &gt; </c> (C#) または<c>IEnumerable (Of (Of TKey、TElement) IGrouping)</c>で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]ここで各<see cref="T:System.Linq.IGrouping`2" />オブジェクトには、型のオブジェクトのコレクションが含まれています。<paramref name="TElement" />とキー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは遅延実行を使用して実装されます。 即時の戻り値は、操作を実行するために必要なすべての情報を格納するオブジェクトです。 オブジェクトのいずれかを呼び出したが列挙されるまで、このメソッドで表されるクエリが実行されていませんが、`GetEnumerator`メソッド直接、またはを使用して`foreach`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`For Each`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29>メソッドのコレクションを返します<xref:System.Linq.IGrouping%602>オブジェクト、発生した個別のキーごとに 1 つです。 <xref:System.Linq.IGrouping%602>は、<xref:System.Collections.Generic.IEnumerable%601>その要素に関連付けられたキーを持ちます。  
  
 <xref:System.Linq.IGrouping%602>オブジェクトは内の要素の順序に基づいて注文で返されます`source`それぞれの最初のキーを生成する<xref:System.Linq.IGrouping%602>です。 グループ内の要素が作成した要素に表示される順序で返されます`source`です。  
  
 既定の等値比較子<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>キーを比較するために使用します。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29>シーケンスの要素をグループ化します。  
  
 [!code-csharp[System.Linq.Enumerable#39](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#39)]
 [!code-vb[System.Linq.Enumerable#39](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#39)]  
  
 クエリ式の構文では、 `group by` ([!INCLUDE[csprcs](~/includes/csprcs-md.md)]) または`Group By Into`([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) の呼び出しに変換される句<xref:System.Linq.Enumerable.GroupBy%2A>です。 次の例では、クエリ式の変換は、上記の例のクエリと同等です。  
  
 [!code-csharp[System.Linq.Enumerable#122](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#122)]
 [!code-vb[System.Linq.Enumerable#122](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#122)]  
  
> [!NOTE]
>  [!INCLUDE[csprcs](~/includes/csprcs-md.md)]または[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]への呼び出しでそれらの引数位置から発生する逆の順序でのクエリ式、要素、およびキーの選択式、<xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29>メソッドです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />、<paramref name="keySelector" />、または <paramref name="elementSelector" /> は、<see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt; GroupBy&lt;TSource,TKey,TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TElement&gt;&gt; GroupBy&lt;TSource, TKey, TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <typeparam name="TKey">によって返されるキーの種類<c>keySelector</c>です。</typeparam>
        <typeparam name="TElement"><see cref="T:System.Linq.IGrouping`2" /> 内の要素の型。</typeparam>
        <param name="source"><see cref="T:System.Collections.Generic.IEnumerable`1" />をグループ化する要素を格納します。</param>
        <param name="keySelector">各要素のキーを抽出する関数。</param>
        <param name="elementSelector">各ソース要素を内の要素にマップする関数、<see cref="T:System.Linq.IGrouping`2" />です。</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IEqualityComparer`1" />キーを比較します。</param>
        <summary>キー セレクター関数に従ってシーケンスの要素をグループ化します。 キーの比較には、比較子を使用し、各グループの要素の射影には、指定された関数を使用します。</summary>
        <returns><c>IEnumerable&lt;IGrouping&lt;TKey, TElement&gt; &gt; </c> (C#) または<c>IEnumerable (Of (Of TKey、TElement) IGrouping)</c>で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]ここで各<see cref="T:System.Linq.IGrouping`2" />オブジェクトには、型のオブジェクトのコレクションが含まれています。<paramref name="TElement" />とキー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは遅延実行を使用して実装されます。 即時の戻り値は、操作を実行するために必要なすべての情報を格納するオブジェクトです。 オブジェクトのいずれかを呼び出したが列挙されるまで、このメソッドで表されるクエリが実行されていませんが、`GetEnumerator`メソッド直接、またはを使用して`foreach`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`For Each`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
> [!NOTE]
>  例については`GroupBy`、次のトピックを参照してください。  
>   
>  -   <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29>  
> -   <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%29>  
> -   <xref:System.Linq.Enumerable.GroupBy%60%604%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%29>  
  
 <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29>メソッドのコレクションを返します<xref:System.Linq.IGrouping%602>オブジェクト、発生した個別のキーごとに 1 つです。 <xref:System.Linq.IGrouping%602>は、<xref:System.Collections.Generic.IEnumerable%601>その要素に関連付けられたキーを持ちます。  
  
 <xref:System.Linq.IGrouping%602>オブジェクトは内の要素の順序に基づいて注文で返されます`source`それぞれの最初のキーを生成する<xref:System.Linq.IGrouping%602>です。 グループ内の要素が作成した要素に表示される順序で返されます`source`です。  
  
 場合`comparer`は`null`、既定の等値比較子<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>キーを比較するために使用します。  
  
 2 つのキーによると等しいと見なされた場合`comparer`、最初のキーがそのグループ化キーとして選択します。  
  
 クエリ式の構文では、 `group by` ([!INCLUDE[csprcs](~/includes/csprcs-md.md)]) または`Group By Into`([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) の呼び出しに変換される句<xref:System.Linq.Enumerable.GroupBy%2A>です。 詳細と使用状況の例については、次を参照してください。 [group 句](~/docs/csharp/language-reference/keywords/group-clause.md)と[グループ By 句](~/docs/visual-basic/language-reference/queries/group-by-clause.md)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />、<paramref name="keySelector" />、または <paramref name="elementSelector" /> は、<see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt;, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <typeparam name="TKey">によって返されるキーの種類<c>keySelector</c>です。</typeparam>
        <typeparam name="TResult">によって返される結果の値の型<c>ある resultSelector</c>です。</typeparam>
        <param name="source"><see cref="T:System.Collections.Generic.IEnumerable`1" />をグループ化する要素を格納します。</param>
        <param name="keySelector">各要素のキーを抽出する関数。</param>
        <param name="resultSelector">各グループから結果値を作成する関数。</param>
        <summary>指定されたキー セレクター関数に従ってシーケンスの要素をグループ化し、各グループとそのキーから結果値を作成します。</summary>
        <returns>型の要素のコレクション<paramref name="TResult" />グループとそのキー上の各要素が投影法を表します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 クエリ式の構文では、 `group by` ([!INCLUDE[csprcs](~/includes/csprcs-md.md)]) または`Group By Into`([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) の呼び出しに変換される句<xref:System.Linq.Enumerable.GroupBy%2A>です。  
  
   
  
## Examples  
 次のコード例は、使用する方法を示します<xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%29>シーケンスの要素をグループ化し、プロジェクトの種類の結果のシーケンス`TResult`です。  
  
 [!code-csharp[System.Linq.Enumerable#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#15)]
 [!code-vb[System.Linq.Enumerable#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt;, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <typeparam name="TKey">によって返されるキーの種類<c>keySelector</c>です。</typeparam>
        <typeparam name="TResult">によって返される結果の値の型<c>ある resultSelector</c>です。</typeparam>
        <param name="source"><see cref="T:System.Collections.Generic.IEnumerable`1" />をグループ化する要素を格納します。</param>
        <param name="keySelector">各要素のキーを抽出する関数。</param>
        <param name="resultSelector">各グループから結果値を作成する関数。</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IEqualityComparer`1" />でキーを比較します。</param>
        <summary>指定されたキー セレクター関数に従ってシーケンスの要素をグループ化し、各グループとそのキーから結果値を作成します。 キーの比較には、指定された比較子を使用します。</summary>
        <returns>型の要素のコレクション<paramref name="TResult" />グループとそのキー上の各要素が投影法を表します。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TElement,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TElement, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TElement&gt;, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``4(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <typeparam name="TKey">によって返されるキーの種類<c>keySelector</c>です。</typeparam>
        <typeparam name="TElement">各要素の型<see cref="T:System.Linq.IGrouping`2" />です。</typeparam>
        <typeparam name="TResult">によって返される結果の値の型<c>ある resultSelector</c>です。</typeparam>
        <param name="source"><see cref="T:System.Collections.Generic.IEnumerable`1" />をグループ化する要素を格納します。</param>
        <param name="keySelector">各要素のキーを抽出する関数。</param>
        <param name="elementSelector">各ソース要素を内の要素にマップする関数、<see cref="T:System.Linq.IGrouping`2" />です。</param>
        <param name="resultSelector">各グループから結果値を作成する関数。</param>
        <summary>指定されたキー セレクター関数に従ってシーケンスの要素をグループ化し、各グループとそのキーから結果値を作成します。 各グループの要素は、指定された関数を使用して射影されます。</summary>
        <returns>型の要素のコレクション<paramref name="TResult" />グループとそのキー上の各要素が投影法を表します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 クエリ式の構文では、 `group by` ([!INCLUDE[csprcs](~/includes/csprcs-md.md)]) または`Group By Into`([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) の呼び出しに変換される句<xref:System.Linq.Enumerable.GroupBy%2A>です。  
  
   
  
## Examples  
 次のコード例は、使用する方法を示します<xref:System.Linq.Enumerable.GroupBy%60%604%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%29>シーケンスの射影された要素をグループ化し、型の結果のシーケンスをプロジェクトに`TResult`です。  
  
 [!code-csharp[System.Linq.Enumerable#125](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#125)]
 [!code-vb[System.Linq.Enumerable#125](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#125)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TElement,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TElement, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TElement&gt;, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``4(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <typeparam name="TKey">によって返されるキーの種類<c>keySelector</c>です。</typeparam>
        <typeparam name="TElement">各要素の型<see cref="T:System.Linq.IGrouping`2" />です。</typeparam>
        <typeparam name="TResult">によって返される結果の値の型<c>ある resultSelector</c>です。</typeparam>
        <param name="source"><see cref="T:System.Collections.Generic.IEnumerable`1" />をグループ化する要素を格納します。</param>
        <param name="keySelector">各要素のキーを抽出する関数。</param>
        <param name="elementSelector">各ソース要素を内の要素にマップする関数、<see cref="T:System.Linq.IGrouping`2" />です。</param>
        <param name="resultSelector">各グループから結果値を作成する関数。</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IEqualityComparer`1" />でキーを比較します。</param>
        <summary>指定されたキー セレクター関数に従ってシーケンスの要素をグループ化し、各グループとそのキーから結果値を作成します。 キー値の比較には、指定された比較子を使用し、各グループの要素の射影には、指定された関数を使用します。</summary>
        <returns>型の要素のコレクション<paramref name="TResult" />グループとそのキー上の各要素が投影法を表します。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; GroupJoin&lt;TOuter,TInner,TKey,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; GroupJoin&lt;TOuter, TInner, TKey, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt;, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupJoin``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Collections.Generic.IEnumerable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">最初のシーケンスの要素の型。</typeparam>
        <typeparam name="TInner">2 番目のシーケンスの要素の型。</typeparam>
        <typeparam name="TKey">キー セレクター関数によって返されるキーの型。</typeparam>
        <typeparam name="TResult">結果の要素の型。</typeparam>
        <param name="outer">結合する最初のシーケンス。</param>
        <param name="inner">最初のシーケンスに結合するシーケンス。</param>
        <param name="outerKeySelector">最初のシーケンスの各要素から結合キーを抽出する関数。</param>
        <param name="innerKeySelector">2 番目のシーケンスの各要素から結合キーを抽出する関数。</param>
        <param name="resultSelector">最初のシーケンスの要素と、2 番目のシーケンスの一致する要素のコレクションから結果の要素を作成する関数。</param>
        <summary>結果をグループ化キーの等値に基づいて 2 つのシーケンスの要素を関連付けます。 キーの比較には既定の等値比較子が使用されます。</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerable`1" />型の要素を格納している<paramref name="TResult" />2 つのシーケンスをグループ化結合を実行することによって取得したものです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは遅延実行を使用して実装されます。 即時の戻り値は、操作を実行するために必要なすべての情報を格納するオブジェクトです。 オブジェクトのいずれかを呼び出したが列挙されるまで、このメソッドで表されるクエリが実行されていませんが、`GetEnumerator`メソッド直接、またはを使用して`foreach`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`For Each`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 既定の等値比較子<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>、ハッシュし、キーの比較に使用されます。  
  
 <xref:System.Linq.Enumerable.GroupJoin%2A>つまり生成階層的な結果から要素`outer`一致する要素のコレクションと組み合わされ、`inner`です。 `GroupJoin`使用すると、基に、結果の各要素に対して一致する項目のセット全体`outer`です。  
  
> [!NOTE]
>  相関関係を持つ要素が存在しない場合`inner`の指定された要素の`outer`、その要素の一致結果のシーケンスが空になりますが、結果に引き続き表示されます。  
  
 `resultSelector`関数には、それぞれの 1 つだけの時間が呼び出される`outer`要素のすべてのコレクションと、`inner`と一致する要素、`outer`要素。 これとは異なります、<xref:System.Linq.Enumerable.Join%2A>から 1 つの要素を含む組を指定する結果のセレクター関数が呼び出されたメソッド`outer`と 1 つの要素から`inner`です。  
  
 `GroupJoin`要素の順序が保持されます`outer`との各要素に対して`outer`からの一致する要素の順序`inner`です。  
  
 <xref:System.Linq.Enumerable.GroupJoin%2A>従来のリレーショナル データベース用語で同等の軸を持ちません。 ただし、このメソッドは、内部結合、左外部結合のスーパー セットを実装します。 グループ化結合では、これらの操作の両方を記述できます。 参照してください[結合操作](http://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107)です。  
  
 クエリ式の構文では、 `join … into` ([!INCLUDE[csprcs](~/includes/csprcs-md.md)]) または`Group Join`([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) の呼び出しに変換される句<xref:System.Linq.Enumerable.GroupJoin%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.GroupJoin%60%604%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Func%7B%60%601%2C%60%602%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2C%60%603%7D%29>を 2 つのシーケンスでグループ化結合を実行します。  
  
 [!code-csharp[System.Linq.Enumerable#40](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#40)]
 [!code-vb[System.Linq.Enumerable#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#40)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="outer" />or <paramref name="inner" /> or <paramref name="outerKeySelector" /> or <paramref name="innerKeySelector" /> or <paramref name="resultSelector" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; GroupJoin&lt;TOuter,TInner,TKey,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; GroupJoin&lt;TOuter, TInner, TKey, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt;, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupJoin``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3},System.Collections.Generic.IEqualityComparer{``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Collections.Generic.IEnumerable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">最初のシーケンスの要素の型。</typeparam>
        <typeparam name="TInner">2 番目のシーケンスの要素の型。</typeparam>
        <typeparam name="TKey">キー セレクター関数によって返されるキーの型。</typeparam>
        <typeparam name="TResult">結果の要素の型。</typeparam>
        <param name="outer">結合する最初のシーケンス。</param>
        <param name="inner">最初のシーケンスに結合するシーケンス。</param>
        <param name="outerKeySelector">最初のシーケンスの各要素から結合キーを抽出する関数。</param>
        <param name="innerKeySelector">2 番目のシーケンスの各要素から結合キーを抽出する関数。</param>
        <param name="resultSelector">最初のシーケンスの要素と、2 番目のシーケンスの一致する要素のコレクションから結果の要素を作成する関数。</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IEqualityComparer`1" />ハッシュとキーを比較します。</param>
        <summary>結果をグループ化キーの等値に基づいて 2 つのシーケンスの要素を関連付けます。 指定した<see cref="T:System.Collections.Generic.IEqualityComparer`1" />キーを比較するために使用します。</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerable`1" />型の要素を格納している<paramref name="TResult" />2 つのシーケンスをグループ化結合を実行することによって取得したものです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは遅延実行を使用して実装されます。 即時の戻り値は、操作を実行するために必要なすべての情報を格納するオブジェクトです。 オブジェクトのいずれかを呼び出したが列挙されるまで、このメソッドで表されるクエリが実行されていませんが、`GetEnumerator`メソッド直接、またはを使用して`foreach`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`For Each`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 C 場合`omparer`は`null`、既定の等値比較子<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>、ハッシュし、キーの比較に使用されます。  
  
 <xref:System.Linq.Enumerable.GroupJoin%2A>つまり生成階層的な結果から要素`outer`一致する要素のコレクションと組み合わされ、`inner`です。 `GroupJoin`使用すると、基に、結果の各要素に対して一致する項目のセット全体`outer`です。  
  
> [!NOTE]
>  相関関係を持つ要素が存在しない場合`inner`の指定された要素の`outer`、その要素の一致結果のシーケンスが空になりますが、結果に引き続き表示されます。  
  
 `resultSelector`関数には、それぞれの 1 つだけの時間が呼び出される`outer`要素のすべてのコレクションと、`inner`と一致する要素、`outer`要素。 これとは異なります、<xref:System.Linq.Enumerable.Join%2A>メソッドから 1 つの要素のペアの結果のセレクター関数が呼び出される`outer`と 1 つの要素から`inner`です。  
  
 `GroupJoin`要素の順序が保持されます`outer`との各要素に対して`outer`からの一致する要素の順序`inner`です。  
  
 <xref:System.Linq.Enumerable.GroupJoin%2A>従来のリレーショナル データベース用語で同等の軸を持ちません。 ただし、このメソッドは、内部結合、左外部結合のスーパー セットを実装します。 グループ化結合では、これらの操作の両方を記述できます。 参照してください[結合操作](http://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="outer" />or <paramref name="inner" /> or <paramref name="outerKeySelector" /> or <paramref name="innerKeySelector" /> or <paramref name="resultSelector" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Intersect&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Intersect&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Intersect&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Intersect``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">入力シーケンスの要素の型。</typeparam>
        <param name="first"><see cref="T:System.Collections.Generic.IEnumerable`1" />にも表示される一意の要素を持つ<c>2 番目</c>が返されます。</param>
        <param name="second"><see cref="T:System.Collections.Generic.IEnumerable`1" />最初のシーケンスにも表示される一意の要素が返されます。</param>
        <summary>値を比較する既定の等値比較子を使用して、2 つのシーケンスの積集合を生成します。</summary>
        <returns>2 つのシーケンスの積集合を構成する要素が格納されているシーケンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは遅延実行を使用して実装されます。 即時の戻り値は、操作を実行するために必要なすべての情報を格納するオブジェクトです。 オブジェクトのいずれかを呼び出したが列挙されるまで、このメソッドで表されるクエリが実行されていませんが、`GetEnumerator`メソッド直接、またはを使用して`foreach`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`For Each`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 2 つのセット A と B の積集合は、A、B にも表示されるのすべての要素ではないその他の要素を含むセットとして定義されます。  
  
 このメソッドによって返されるオブジェクトを列挙すると、<xref:System.Linq.Enumerable.Intersect%2A>に現れる順序で両方のシーケンスで発生する一意の要素を生成`first`です。  
  
 既定の等値比較子<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>、実装する型の値を比較するために使用、<xref:System.Collections.Generic.IEqualityComparer%601>ジェネリック インターフェイス。 カスタム データ型を比較する必要がありますをこのインターフェイスを実装し、独自<xref:System.Object.GetHashCode%2A>と<xref:System.Object.Equals%2A>の型のメソッドです。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Intersect%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29>を整数の 2 つのシーケンスの各で表示される要素を返します。  
  
 [!code-csharp[System.Linq.Enumerable#41](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#41)]
 [!code-vb[System.Linq.Enumerable#41](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#41)]  
  
 カスタム データ型のオブジェクトのシーケンスを比較する場合を実装する必要がある、<xref:System.Collections.Generic.IEqualityComparer%601>ヘルパー クラスでジェネリック インターフェイス。 次のコード例は、カスタム データ型でこのインターフェイスを実装して提供する方法を示しています。<xref:System.Object.GetHashCode%2A>と<xref:System.Object.Equals%2A>メソッドです。  
  
 [!code-csharp[CSLINQEncapsulatedComparer#9](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#9)]  
  
 このインターフェイスを実装した後のシーケンスを使用することができます`ProductA`内のオブジェクト、<xref:System.Linq.Enumerable.Intersect%2A>メソッドを次の例で示すようにします。  
  
 [!code-csharp[CSLINQEncapsulatedComparer#10](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#10)]  
[!code-csharp[CSLINQEncapsulatedComparer#3](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#3)]
[!code-vb[CSLINQEncapsulatedComparer#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> または <paramref name="second" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Intersect&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Intersect&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Intersect&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Intersect``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">入力シーケンスの要素の型。</typeparam>
        <param name="first"><see cref="T:System.Collections.Generic.IEnumerable`1" />にも表示される一意の要素を持つ<c>2 番目</c>が返されます。</param>
        <param name="second"><see cref="T:System.Collections.Generic.IEnumerable`1" />最初のシーケンスにも表示される一意の要素が返されます。</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IEqualityComparer`1" />値を比較します。</param>
        <summary>指定されたを使用して 2 つのシーケンスの積集合を生成<see cref="T:System.Collections.Generic.IEqualityComparer`1" />値を比較します。</summary>
        <returns>2 つのシーケンスの積集合を構成する要素が格納されているシーケンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは遅延実行を使用して実装されます。 即時の戻り値は、操作を実行するために必要なすべての情報を格納するオブジェクトです。 オブジェクトのいずれかを呼び出したが列挙されるまで、このメソッドで表されるクエリが実行されていませんが、`GetEnumerator`メソッド直接、またはを使用して`foreach`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`For Each`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 2 つのセット A と B の積集合は、A、B にも表示されるのすべての要素ではないその他の要素を含むセットとして定義されます。  
  
 このメソッドによって返されるオブジェクトを列挙すると、<xref:System.Linq.Enumerable.Intersect%2A>に現れる順序で両方のシーケンスで発生する一意の要素を生成`first`です。  
  
 場合`comparer`は`null`、既定の等値比較子<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>値を比較するために使用します。  
  
   
  
## Examples  
 次の例で使用できる等値比較子を実装する方法を示しています、<xref:System.Linq.Enumerable.Intersect%2A>メソッドです。  
  
 [!code-csharp[CSLINQCustomComparer#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#1)]
 [!code-vb[CSLINQCustomComparer#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#1)]  
  
 この比較演算子を実装すると後のシーケンスを使用することができます`Product`内のオブジェクト、<xref:System.Linq.Enumerable.Intersect%2A>メソッドを次の例で示すようにします。  
  
 [!code-csharp[CSLINQCustomComparer#2](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#2)]
 [!code-vb[CSLINQCustomComparer#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#2)]  
[!code-csharp[CSLINQCustomComparer#3](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#3)]
[!code-vb[CSLINQCustomComparer#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> または <paramref name="second" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Join&lt;TOuter,TInner,TKey,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,TInner,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Join&lt;TOuter, TInner, TKey, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, !!TInner, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Join``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Collections.Generic.IEnumerable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,TInner,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">最初のシーケンスの要素の型。</typeparam>
        <typeparam name="TInner">2 番目のシーケンスの要素の型。</typeparam>
        <typeparam name="TKey">キー セレクター関数によって返されるキーの型。</typeparam>
        <typeparam name="TResult">結果の要素の型。</typeparam>
        <param name="outer">結合する最初のシーケンス。</param>
        <param name="inner">最初のシーケンスに結合するシーケンス。</param>
        <param name="outerKeySelector">最初のシーケンスの各要素から結合キーを抽出する関数。</param>
        <param name="innerKeySelector">2 番目のシーケンスの各要素から結合キーを抽出する関数。</param>
        <param name="resultSelector">一致する 2 つの要素から結果の要素を作成する関数。</param>
        <summary>一致するキーに基づいて 2 つのシーケンスの要素を関連付けます。 キーの比較には既定の等値比較子が使用されます。</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerable`1" />型の要素を持つ<paramref name="TResult" />2 つのシーケンスでは内部結合を実行することによって取得したものです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは遅延実行を使用して実装されます。 即時の戻り値は、操作を実行するために必要なすべての情報を格納するオブジェクトです。 オブジェクトのいずれかを呼び出したが列挙されるまで、このメソッドで表されるクエリが実行されていませんが、`GetEnumerator`メソッド直接、またはを使用して`foreach`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`For Each`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 既定の等値比較子<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>、ハッシュし、キーの比較に使用されます。  
  
 結合は、共通のキーに基づいた情報の 2 つのソースの要素を相互に関連付けるの操作を参照します。 <xref:System.Linq.Enumerable.Join%2A>2 つの情報ソースと、一致している同時に 1 つのメソッドの呼び出しでキーが表示されます。 これの使用とは異なります`SelectMany`、1 つ以上のメソッドの呼び出し、同じ操作を実行する必要があります。  
  
 <xref:System.Linq.Enumerable.Join%2A>要素の順序が保持されます`outer`、およびこれらの要素の順序の一致する要素の各`inner`です。  
  
 クエリ式の構文では、 `join` ([!INCLUDE[csprcs](~/includes/csprcs-md.md)]) または`Join`([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) の呼び出しに変換される句<xref:System.Linq.Enumerable.Join%2A>です。  
  
 リレーショナル データベース用語で、<xref:System.Linq.Enumerable.Join%2A>メソッドは内部の等結合を実装します。 '内部' は、その他のシーケンスに一致する要素だけが結果に含まれることを意味します。 '等結合' 結合は、等しいかどうか比較されるキーにします。 左外部結合の操作なし専用の標準クエリ演算子を持つことができますが、使用して実行する、<xref:System.Linq.Enumerable.GroupJoin%2A>メソッドです。 参照してください[結合操作](http://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107)です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Join%60%604%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Func%7B%60%601%2C%60%602%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%603%7D%29>を共通のキーに基づいて 2 つのシーケンスの内部結合を実行します。  
  
 [!code-csharp[System.Linq.Enumerable#42](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#42)]
 [!code-vb[System.Linq.Enumerable#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="outer" />or <paramref name="inner" /> or <paramref name="outerKeySelector" /> or <paramref name="innerKeySelector" /> or <paramref name="resultSelector" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Join&lt;TOuter,TInner,TKey,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,TInner,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Join&lt;TOuter, TInner, TKey, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, !!TInner, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Join``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3},System.Collections.Generic.IEqualityComparer{``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Collections.Generic.IEnumerable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,TInner,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">最初のシーケンスの要素の型。</typeparam>
        <typeparam name="TInner">2 番目のシーケンスの要素の型。</typeparam>
        <typeparam name="TKey">キー セレクター関数によって返されるキーの型。</typeparam>
        <typeparam name="TResult">結果の要素の型。</typeparam>
        <param name="outer">結合する最初のシーケンス。</param>
        <param name="inner">最初のシーケンスに結合するシーケンス。</param>
        <param name="outerKeySelector">最初のシーケンスの各要素から結合キーを抽出する関数。</param>
        <param name="innerKeySelector">2 番目のシーケンスの各要素から結合キーを抽出する関数。</param>
        <param name="resultSelector">一致する 2 つの要素から結果の要素を作成する関数。</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IEqualityComparer`1" />ハッシュとキーを比較します。</param>
        <summary>一致するキーに基づいて 2 つのシーケンスの要素を関連付けます。 指定した<see cref="T:System.Collections.Generic.IEqualityComparer`1" />キーを比較するために使用します。</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerable`1" />型の要素を持つ<paramref name="TResult" />2 つのシーケンスでは内部結合を実行することによって取得したものです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは遅延実行を使用して実装されます。 即時の戻り値は、操作を実行するために必要なすべての情報を格納するオブジェクトです。 オブジェクトのいずれかを呼び出したが列挙されるまで、このメソッドで表されるクエリが実行されていませんが、`GetEnumerator`メソッド直接、またはを使用して`foreach`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`For Each`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 C 場合`omparer`は`null`、既定の等値比較子<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>、ハッシュし、キーの比較に使用されます。  
  
 結合は、共通のキーに基づいた情報の 2 つのソースの要素を相互に関連付けるの操作を参照します。 <xref:System.Linq.Enumerable.Join%2A>2 つの情報ソースと、一致している同時に 1 つのメソッドの呼び出しでキーが表示されます。 これの使用とは異なります`SelectMany`、1 つ以上のメソッドの呼び出し、同じ操作を実行する必要があります。  
  
 <xref:System.Linq.Enumerable.Join%2A>要素の順序が保持されます`outer`、およびこれらの要素の順序の一致する要素の各`inner`です。  
  
 リレーショナル データベース用語で、<xref:System.Linq.Enumerable.Join%2A>メソッドは内部の等結合を実装します。 '内部' は、その他のシーケンスに一致する要素だけが結果に含まれることを意味します。 '等結合' 結合は、等しいかどうか比較されるキーにします。 左外部結合の操作なし専用の標準クエリ演算子を持つことができますが、使用して実行する、<xref:System.Linq.Enumerable.GroupJoin%2A>メソッドです。 参照してください[結合操作](http://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="outer" />or <paramref name="inner" /> or <paramref name="outerKeySelector" /> or <paramref name="innerKeySelector" /> or <paramref name="resultSelector" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Last&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Last&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Last&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Last``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source"><see cref="T:System.Collections.Generic.IEnumerable`1" />の最後の要素を返します。</param>
        <summary>シーケンスの最後の要素を返します。</summary>
        <returns>ソース シーケンスの最後の位置にある値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Last%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>場合、メソッドが例外をスロー`source`要素が含まれていません。 代わりに、ソース シーケンスが空の場合は、既定値を返すを使用して、<xref:System.Linq.Enumerable.LastOrDefault%2A>メソッドです。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Last%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>を配列の最後の要素を返します。  
  
 [!code-csharp[System.Linq.Enumerable#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#43)]
 [!code-vb[System.Linq.Enumerable#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#43)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">ソース シーケンスが空です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Last&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Last&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Last&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Last``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source"><see cref="T:System.Collections.Generic.IEnumerable`1" />から要素を返します。</param>
        <param name="predicate">各要素が条件を満たしているかどうかをテストする関数。</param>
        <summary>指定された条件を満たす、シーケンスの最後の要素を返します。</summary>
        <returns>指定された述語関数でテストに合格する、シーケンスの最後の要素。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Last%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>で一致する要素が見つからない場合、メソッドが例外をスロー`source`です。 一致する要素が存在しない場合に、既定値を返すを使用して、<xref:System.Linq.Enumerable.LastOrDefault%2A>メソッドです。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Last%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>を条件を満たす、配列の最後の要素を返します。  
  
 [!code-csharp[System.Linq.Enumerable#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#44)]
 [!code-vb[System.Linq.Enumerable#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#44)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="predicate" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="predicate" /> の条件を満たす要素はありません。  
  
 または  
  
 ソース シーケンスが空です。</exception>
      </Docs>
    </Member>
    <Member MemberName="LastOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource LastOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource LastOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.LastOrDefault``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source"><see cref="T:System.Collections.Generic.IEnumerable`1" />の最後の要素を返します。</param>
        <summary>シーケンスの最後の要素を返します。シーケンスに要素が含まれていない場合は既定値を返します。</summary>
        <returns>
          <see langword="default" />(<paramref name="TSource" />) ソース シーケンスが空、それ以外の場合の最後の要素、<see cref="T:System.Collections.Generic.IEnumerable`1" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 参照および null 許容型の既定値は`null`します。  
  
 <xref:System.Linq.Enumerable.LastOrDefault%2A>メソッドは、既定値を指定する方法を提供していません。 以外の場合、既定値を指定する場合は、`default(TSource)`を使用して、<xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29>例」のセクションで説明するメソッド。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.LastOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>で空の配列。  
  
 [!code-csharp[System.Linq.Enumerable#45](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#45)]
 [!code-vb[System.Linq.Enumerable#45](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#45)]  
  
 値も`default(TSource)`コレクションに要素が含まれていない場合に使用する既定値ではありません。 不要な既定値の場合、結果を確認してから、必要な場合、代わりに使用することができます、<xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29>コレクションが空の場合に使用する既定値を指定します。 次に、呼び出す<xref:System.Linq.Enumerable.Last%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>を最後の要素を取得します。 次のコード例では、両方の手法を使用して、月の日数を数値のコレクションが空の場合は、1 の既定値を取得します。 整数の既定値は 0 で、月の日に対応していない、既定値必要がありますとして指定する 1 代わりにします。 クエリの実行が完了した後、不要な既定値の最初の結果変数がチェックされます。 使用して、2 つ目の結果変数が取得された<xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29>を既定値は 1 を指定します。  
  
 [!code-csharp[System.Linq.Enumerable#127](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#127)]
 [!code-vb[System.Linq.Enumerable#127](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#127)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="LastOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource LastOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource LastOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.LastOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source"><see cref="T:System.Collections.Generic.IEnumerable`1" />から要素を返します。</param>
        <param name="predicate">各要素が条件を満たしているかどうかをテストする関数。</param>
        <summary>条件を満たす、シーケンスの最後の要素を返します。このような要素が見つからない場合は既定値を返します。</summary>
        <returns>
          <see langword="default" />(<paramref name="TSource" />)、シーケンスが空か、要素なしでテストに合格述語関数の場合それ以外の場合、最後の要素をテストに合格述語関数の場合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 参照および null 許容型の既定値は`null`します。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.LastOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>述語に渡すことで。 メソッドに 2 つ目の呼び出しではありません要素が条件を満たす、シーケンス内です。  
  
 [!code-csharp[System.Linq.Enumerable#46](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#46)]
 [!code-vb[System.Linq.Enumerable#46](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#46)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="predicate" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="LongCount&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long LongCount&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 LongCount&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.LongCount``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source"><see cref="T:System.Collections.Generic.IEnumerable`1" />をカウントする要素を格納します。</param>
        <summary>返します、<see cref="T:System.Int64" />シーケンス内の要素の合計数を表すです。</summary>
        <returns>ソース シーケンス内の要素の数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用してなく<xref:System.Linq.Enumerable.Count%2A>よりも長くなるように結果を予期したタイミング<xref:System.Int32.MaxValue>です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into LongCount()`の呼び出しに変換される句<xref:System.Linq.Enumerable.LongCount%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.LongCount%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>を配列内の要素をカウントします。  
  
 [!code-csharp[System.Linq.Enumerable#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#47)]
 [!code-vb[System.Linq.Enumerable#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#47)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.OverflowException">要素の数を超える<see cref="F:System.Int64.MaxValue" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="LongCount&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long LongCount&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 LongCount&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.LongCount``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source"><see cref="T:System.Collections.Generic.IEnumerable`1" />をカウントする要素を格納します。</param>
        <param name="predicate">各要素が条件を満たしているかどうかをテストする関数。</param>
        <summary>返します、<see cref="T:System.Int64" />条件を満たす、シーケンス内の要素の数を表すです。</summary>
        <returns>述語関数の条件を満たす、シーケンス内の要素数を表す数値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用してなく<xref:System.Linq.Enumerable.Count%2A>よりも長くなるように結果を予期したタイミング<xref:System.Int32.MaxValue>です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into LongCount()`の呼び出しに変換される句<xref:System.Linq.Enumerable.LongCount%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.LongCount%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>条件を満たす、配列内の要素をカウントします。  
  
 [!code-csharp[System.Linq.Enumerable#48](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#48)]
 [!code-vb[System.Linq.Enumerable#48](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#48)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="predicate" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.OverflowException">一致する要素の数を超える<see cref="F:System.Int64.MaxValue" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static decimal Max (this System.Collections.Generic.IEnumerable&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Max(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Decimal})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">一連の<see cref="T:System.Decimal" />の最大値を確認します。</param>
        <summary>シーケンスの最大値を返します<see cref="T:System.Decimal" />値。</summary>
        <returns>シーケンスの最大値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Decimal%7D%29>メソッドを使用、<xref:System.Decimal>の実装<xref:System.IComparable%601>値を比較します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Max()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Max%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29>をシーケンスの最大値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#52](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#52)]
 [!code-vb[System.Linq.Enumerable#52](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />要素は含まれません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static double Max (this System.Collections.Generic.IEnumerable&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Max(class System.Collections.Generic.IEnumerable`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Double})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">一連の<see cref="T:System.Double" />の最大値を確認します。</param>
        <summary>シーケンスの最大値を返します<see cref="T:System.Double" />値。</summary>
        <returns>シーケンスの最大値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29>メソッドを使用、<xref:System.Double>の実装<xref:System.IComparable%601>値を比較します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Max()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Max%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29>をシーケンスの最大値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#52](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#52)]
 [!code-vb[System.Linq.Enumerable#52](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />要素は含まれません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static int Max (this System.Collections.Generic.IEnumerable&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Max(class System.Collections.Generic.IEnumerable`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Int32})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">一連の<see cref="T:System.Int32" />の最大値を確認します。</param>
        <summary>シーケンスの最大値を返します<see cref="T:System.Int32" />値。</summary>
        <returns>シーケンスの最大値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29>メソッドを使用、<xref:System.Int32>の実装<xref:System.IComparable%601>値を比較します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Max()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Max%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29>をシーケンスの最大値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#52](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#52)]
 [!code-vb[System.Linq.Enumerable#52](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />要素は含まれません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static long Max (this System.Collections.Generic.IEnumerable&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Max(class System.Collections.Generic.IEnumerable`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Int64})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">一連の<see cref="T:System.Int64" />の最大値を確認します。</param>
        <summary>シーケンスの最大値を返します<see cref="T:System.Int64" />値。</summary>
        <returns>シーケンスの最大値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29>メソッドを使用、<xref:System.Int64>の実装<xref:System.IComparable%601>値を比較します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Max()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Max%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29>をシーケンスの最大値を決定します。  
  
 [!code-csharp[System.Linq.Enumerable#52](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#52)]
 [!code-vb[System.Linq.Enumerable#52](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />要素は含まれません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Max (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Max(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Null 許容のシーケンス<see cref="T:System.Decimal" />の最大値を確認します。</param>
        <summary>Null 許容のシーケンスの最大値を返します<see cref="T:System.Decimal" />値。</summary>
        <returns>型の値<c>Nullable&lt;Decimal&gt; </c> (C#) または<c>Nullable (の 10 進数)</c>で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]シーケンス内の最大値に対応します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Decimal%7D%7D%29>メソッドを使用、<xref:System.Decimal>の実装<xref:System.IComparable%601>値を比較します。  
  
 ソース シーケンスが空かは値のみを含むかどうか`null`、この関数を返します`null`です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Max()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Max%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29>をシーケンスの最大値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#54](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#54)]
 [!code-vb[System.Linq.Enumerable#54](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#54)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Max (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Max(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Null 許容のシーケンス<see cref="T:System.Double" />の最大値を確認します。</param>
        <summary>Null 許容のシーケンスの最大値を返します<see cref="T:System.Double" />値。</summary>
        <returns>型の値<c>Nullable&lt;二重&gt;</c> (C#) または<c>Nullable (の二重)</c>で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]シーケンス内の最大値に対応します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29>メソッドを使用、<xref:System.Double>の実装<xref:System.IComparable%601>値を比較します。  
  
 ソース シーケンスが空かは値のみを含むかどうか`null`、この関数を返します`null`です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Max()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Max%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29>をシーケンスの最大値を決定します。  
  
 [!code-csharp[System.Linq.Enumerable#54](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#54)]
 [!code-vb[System.Linq.Enumerable#54](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#54)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Max (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Max(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Null 許容のシーケンス<see cref="T:System.Int32" />の最大値を確認します。</param>
        <summary>Null 許容のシーケンスの最大値を返します<see cref="T:System.Int32" />値。</summary>
        <returns>型の値<c>Nullable&lt;Int32&gt; </c> (C#) または<c>Nullable (の Int32)</c>で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]シーケンス内の最大値に対応します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29>メソッドを使用、<xref:System.Int32>の実装<xref:System.IComparable%601>値を比較します。  
  
 ソース シーケンスが空かは値のみを含むかどうか`null`、この関数を返します`null`です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Max()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Max%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29>をシーケンスの最大値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#54](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#54)]
 [!code-vb[System.Linq.Enumerable#54](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#54)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Max (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Max(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Null 許容のシーケンス<see cref="T:System.Int64" />の最大値を確認します。</param>
        <summary>Null 許容のシーケンスの最大値を返します<see cref="T:System.Int64" />値。</summary>
        <returns>型の値<c>Nullable&lt;Int64&gt; </c> (C#) または<c>Nullable (Int64 の)</c>で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]シーケンス内の最大値に対応します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29>メソッドを使用、<xref:System.Int64>の実装<xref:System.IComparable%601>値を比較します。  
  
 ソース シーケンスが空かは値のみを含むかどうか`null`、この関数を返します`null`です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Max()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Max%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29>をシーケンスの最大値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#54](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#54)]
 [!code-vb[System.Linq.Enumerable#54](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#54)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Max (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Max(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Null 許容のシーケンス<see cref="T:System.Single" />の最大値を確認します。</param>
        <summary>Null 許容のシーケンスの最大値を返します<see cref="T:System.Single" />値。</summary>
        <returns>型の値<c>Nullable&lt;単一&gt;</c> (C#) または<c>Nullable (の 1 つ)</c>で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]シーケンス内の最大値に対応します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29>メソッドを使用、<xref:System.Single>の実装<xref:System.IComparable%601>値を比較します。  
  
 ソース シーケンスが空かは値のみを含むかどうか`null`、この関数を返します`null`です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Max()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Max%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29>をシーケンスの最大値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#54](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#54)]
 [!code-vb[System.Linq.Enumerable#54](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#54)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static float Max (this System.Collections.Generic.IEnumerable&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Max(class System.Collections.Generic.IEnumerable`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Single})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">一連の<see cref="T:System.Single" />の最大値を確認します。</param>
        <summary>シーケンスの最大値を返します<see cref="T:System.Single" />値。</summary>
        <returns>シーケンスの最大値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29>メソッドを使用、<xref:System.Single>の実装<xref:System.IComparable%601>値を比較します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Max()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Max%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29>をシーケンスの最大値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#52](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#52)]
 [!code-vb[System.Linq.Enumerable#52](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />要素は含まれません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">最大値を確認する対象となる値のシーケンス。</param>
        <summary>ジェネリック シーケンスの最大値を返します。</summary>
        <returns>シーケンスの最大値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合型`TSource`実装<xref:System.IComparable%601>、<xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>メソッドでは、その実装を使用して値を比較します。 それ以外の場合型`TSource`実装<xref:System.IComparable>、その実装を使用して値を比較します。  
  
 場合`TSource`は参照型であり、ソース シーケンスが空かされる値のみが含まれています`null`、このメソッドが戻る`null`です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Max()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Max%2A>です。  
  
   
  
## Examples  
 次のコード例は、使用する方法を示します<xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>のシーケンスの最大値を決定する<xref:System.IComparable%601>オブジェクト。  
  
 [!code-csharp[System.Linq.Enumerable#57](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#57)]
 [!code-vb[System.Linq.Enumerable#57](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#57)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,decimal&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Decimal})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Decimal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">最大値を確認する対象となる値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの各要素に対して変換関数を呼び出し、最大値を返します<see cref="T:System.Decimal" />値。</summary>
        <returns>シーケンスの最大値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Decimal%7D%29>メソッドを使用、<xref:System.Decimal>の実装<xref:System.IComparable%601>値を比較します。  
  
 関数を提供する場合、任意の値のシーケンスにこのメソッドを適用することができます`selector`のメンバーを射影する`source`、数値型に特に<xref:System.Decimal>です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Max()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Max%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>射影された値のシーケンスの最大値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />要素は含まれません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,double&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Double&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">最大値を確認する対象となる値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの各要素に対して変換関数を呼び出し、最大値を返します<see cref="T:System.Double" />値。</summary>
        <returns>シーケンスの最大値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29>メソッドを使用、<xref:System.Double>の実装<xref:System.IComparable%601>値を比較します。  
  
 関数を提供する場合、任意の値のシーケンスにこのメソッドを適用することができます`selector`のメンバーを射影する`source`、数値型に特に<xref:System.Double>です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Max()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Max%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>射影された値のシーケンスの最大値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />要素は含まれません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">最大値を確認する対象となる値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの各要素に対して変換関数を呼び出し、最大値を返します<see cref="T:System.Int32" />値。</summary>
        <returns>シーケンスの最大値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>メソッドを使用、<xref:System.Int32>の実装<xref:System.IComparable%601>値を比較します。  
  
 関数を提供する場合、任意の値のシーケンスにこのメソッドを適用することができます`selector`のメンバーを射影する`source`、数値型に特に<xref:System.Int32>です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Max()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Max%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>射影された値のシーケンスの最大値を決定します。  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />要素は含まれません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,long&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int64})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">最大値を確認する対象となる値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの各要素に対して変換関数を呼び出し、最大値を返します<see cref="T:System.Int64" />値。</summary>
        <returns>シーケンスの最大値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29>メソッドを使用、<xref:System.Int64>の実装<xref:System.IComparable%601>値を比較します。  
  
 関数を提供する場合、任意の値のシーケンスにこのメソッドを適用することができます`selector`のメンバーを射影する`source`、数値型に特に<xref:System.Int64>です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Max()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Max%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>射影された値のシーケンスの最大値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />要素は含まれません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">最大値を確認する対象となる値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの各要素に対して変換関数を呼び出すし、null 許容最大値を返します<see cref="T:System.Decimal" />値。</summary>
        <returns>型の値<c>Nullable&lt;Decimal&gt; </c> (C#) または<c>Nullable (の 10 進数)</c>で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]シーケンス内の最大値に対応します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Decimal%7D%7D%29>メソッドを使用、<xref:System.Decimal>の実装<xref:System.IComparable%601>値を比較します。  
  
 関数を提供する場合は、任意の値のシーケンスにこのメソッドを適用できます`selector`のメンバーを射影する`source`、数値型に具体的には`Nullable<Decimal>`(C#) または`Nullable(Of Decimal)`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Max()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Max%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>射影された値のシーケンスの最大値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">最大値を確認する対象となる値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの各要素に対して変換関数を呼び出すし、null 許容最大値を返します<see cref="T:System.Double" />値。</summary>
        <returns>型の値<c>Nullable&lt;二重&gt;</c> (C#) または<c>Nullable (の二重)</c>で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]シーケンス内の最大値に対応します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Double%7D%7D%29>メソッドを使用、<xref:System.Double>の実装<xref:System.IComparable%601>値を比較します。  
  
 関数を提供する場合は、任意の値のシーケンスにこのメソッドを適用できます`selector`のメンバーを射影する`source`、数値型に具体的には`Nullable<Double>`(C#) または`Nullable(Of Double)`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Max()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Max%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>射影された値のシーケンスの最大値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">最大値を確認する対象となる値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの各要素に対して変換関数を呼び出すし、null 許容最大値を返します<see cref="T:System.Int32" />値。</summary>
        <returns>型の値<c>Nullable&lt;Int32&gt; </c> (C#) または<c>Nullable (の Int32)</c>で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]シーケンス内の最大値に対応します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int32%7D%7D%29>メソッドを使用、<xref:System.Int32>の実装<xref:System.IComparable%601>値を比較します。  
  
 関数を提供する場合は、任意の値のシーケンスにこのメソッドを適用できます`selector`のメンバーを射影する`source`、数値型に具体的には`Nullable<Int32>`(C#) または`Nullable(Of Int32)`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Max()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Max%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>射影された値のシーケンスの最大値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">最大値を確認する対象となる値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの各要素に対して変換関数を呼び出すし、null 許容最大値を返します<see cref="T:System.Int64" />値。</summary>
        <returns>型の値<c>Nullable&lt;Int64&gt; </c> (C#) または<c>Nullable (Int64 の)</c>で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]シーケンス内の最大値に対応します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int64%7D%7D%29>メソッドを使用、<xref:System.Int64>の実装<xref:System.IComparable%601>値を比較します。  
  
 関数を提供する場合は、任意の値のシーケンスにこのメソッドを適用できます`selector`のメンバーを射影する`source`、数値型に具体的には`Nullable<Int64>`(C#) または`Nullable(Of Int64)`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Max()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Max%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>射影された値のシーケンスの最大値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">最大値を確認する対象となる値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの各要素に対して変換関数を呼び出すし、null 許容最大値を返します<see cref="T:System.Single" />値。</summary>
        <returns>型の値<c>Nullable&lt;単一&gt;</c> (C#) または<c>Nullable (の 1 つ)</c>で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]シーケンス内の最大値に対応します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Single%7D%7D%29>メソッドを使用、<xref:System.Single>の実装<xref:System.IComparable%601>値を比較します。  
  
 関数を提供する場合は、任意の値のシーケンスにこのメソッドを適用できます`selector`のメンバーを射影する`source`、数値型に具体的には`Nullable<Single>`(C#) または`Nullable(Of Single)`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Max()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Max%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>射影された値のシーケンスの最大値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,float&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Single&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">最大値を確認する対象となる値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの各要素に対して変換関数を呼び出し、最大値を返します<see cref="T:System.Single" />値。</summary>
        <returns>シーケンスの最大値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Single%7D%29>メソッドを使用、<xref:System.Single>の実装<xref:System.IComparable%601>値を比較します。  
  
 関数を提供する場合、任意の値のシーケンスにこのメソッドを適用することができます`selector`のメンバーを射影する`source`、数値型に特に<xref:System.Single>です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Max()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Max%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>射影された値のシーケンスの最大値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />要素は含まれません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Max&lt;TSource,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TResult&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Max&lt;TSource, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TResult&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <typeparam name="TResult">によって返される値の型<c>セレクター</c>です。</typeparam>
        <param name="source">最大値を確認する対象となる値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>ジェネリック シーケンスの各要素に対して変換関数を呼び出すし、結果の最大値を返します。</summary>
        <returns>シーケンスの最大値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合型`TResult`実装<xref:System.IComparable%601>、このメソッドでは、その実装を使用して、値を比較します。 それ以外の場合型`TResult`実装<xref:System.IComparable>、その実装を使用して値を比較します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Max()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Max%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>射影された値のシーケンスの最大値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static decimal Min (this System.Collections.Generic.IEnumerable&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Min(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Decimal})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">一連の<see cref="T:System.Decimal" />の最小値を確認します。</param>
        <summary>シーケンスの最小値を返します<see cref="T:System.Decimal" />値。</summary>
        <returns>シーケンスの最小値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Decimal%7D%29>メソッドを使用、<xref:System.Decimal>の実装<xref:System.IComparable%601>値を比較します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Min()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Min%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29>シーケンス内の最小値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#60](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#60)]
 [!code-vb[System.Linq.Enumerable#60](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />要素は含まれません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static double Min (this System.Collections.Generic.IEnumerable&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Min(class System.Collections.Generic.IEnumerable`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Double})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">一連の<see cref="T:System.Double" />の最小値を確認します。</param>
        <summary>シーケンスの最小値を返します<see cref="T:System.Double" />値。</summary>
        <returns>シーケンスの最小値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29>メソッドを使用、<xref:System.Double>の実装<xref:System.IComparable%601>値を比較します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Min()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Min%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29>シーケンス内の最小値を決定します。  
  
 [!code-csharp[System.Linq.Enumerable#60](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#60)]
 [!code-vb[System.Linq.Enumerable#60](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />要素は含まれません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static int Min (this System.Collections.Generic.IEnumerable&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Min(class System.Collections.Generic.IEnumerable`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Int32})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">一連の<see cref="T:System.Int32" />の最小値を確認します。</param>
        <summary>シーケンスの最小値を返します<see cref="T:System.Int32" />値。</summary>
        <returns>シーケンスの最小値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29>メソッドを使用、<xref:System.Int32>の実装<xref:System.IComparable%601>値を比較します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Min()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Min%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29>シーケンス内の最小値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#60](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#60)]
 [!code-vb[System.Linq.Enumerable#60](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />要素は含まれません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static long Min (this System.Collections.Generic.IEnumerable&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Min(class System.Collections.Generic.IEnumerable`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Int64})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">一連の<see cref="T:System.Int64" />の最小値を確認します。</param>
        <summary>シーケンスの最小値を返します<see cref="T:System.Int64" />値。</summary>
        <returns>シーケンスの最小値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29>メソッドを使用、<xref:System.Int64>の実装<xref:System.IComparable%601>値を比較します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Min()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Min%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29>シーケンス内の最小値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#60](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#60)]
 [!code-vb[System.Linq.Enumerable#60](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />要素は含まれません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Min (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Min(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Null 許容のシーケンス<see cref="T:System.Decimal" />の最小値を確認します。</param>
        <summary>Null 許容のシーケンスの最小値を返します<see cref="T:System.Decimal" />値。</summary>
        <returns>型の値<c>Nullable&lt;Decimal&gt; </c> (C#) または<c>Nullable (の 10 進数)</c>で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]シーケンス内の最小値に対応します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Decimal%7D%7D%29>メソッドを使用、<xref:System.Decimal>の実装<xref:System.IComparable%601>値を比較します。  
  
 ソース シーケンスが空かは値のみを含むかどうか`null`、この関数を返します`null`です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Min()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Min%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29>シーケンス内の最小値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#63](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#63)]
 [!code-vb[System.Linq.Enumerable#63](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#63)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Min (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Min(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Null 許容のシーケンス<see cref="T:System.Double" />の最小値を確認します。</param>
        <summary>Null 許容のシーケンスの最小値を返します<see cref="T:System.Double" />値。</summary>
        <returns>型の値<c>Nullable&lt;二重&gt;</c> (C#) または<c>Nullable (の二重)</c>で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]シーケンス内の最小値に対応します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29>メソッドを使用、<xref:System.Double>の実装<xref:System.IComparable%601>値を比較します。  
  
 ソース シーケンスが空かは値のみを含むかどうか`null`、この関数を返します`null`です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Min()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Min%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29>シーケンス内の最小値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#63](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#63)]
 [!code-vb[System.Linq.Enumerable#63](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#63)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Min (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Min(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Null 許容のシーケンス<see cref="T:System.Int32" />の最小値を確認します。</param>
        <summary>Null 許容のシーケンスの最小値を返します<see cref="T:System.Int32" />値。</summary>
        <returns>型の値<c>Nullable&lt;Int32&gt; </c> (C#) または<c>Nullable (の Int32)</c>で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]シーケンス内の最小値に対応します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29>メソッドを使用、<xref:System.Int32>の実装<xref:System.IComparable%601>値を比較します。  
  
 ソース シーケンスが空かは値のみを含むかどうか`null`、この関数を返します`null`です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Min()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Min%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29>シーケンス内の最小値を決定します。  
  
 [!code-csharp[System.Linq.Enumerable#63](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#63)]
 [!code-vb[System.Linq.Enumerable#63](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#63)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Min (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Min(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Null 許容のシーケンス<see cref="T:System.Int64" />の最小値を確認します。</param>
        <summary>Null 許容のシーケンスの最小値を返します<see cref="T:System.Int64" />値。</summary>
        <returns>型の値<c>Nullable&lt;Int64&gt; </c> (C#) または<c>Nullable (Int64 の)</c>で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]シーケンス内の最小値に対応します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29>メソッドを使用、<xref:System.Int64>の実装<xref:System.IComparable%601>値を比較します。  
  
 ソース シーケンスが空かは値のみを含むかどうか`null`、この関数を返します`null`です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Min()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Min%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29>シーケンス内の最小値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#63](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#63)]
 [!code-vb[System.Linq.Enumerable#63](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#63)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Min (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Min(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Null 許容のシーケンス<see cref="T:System.Single" />の最小値を確認します。</param>
        <summary>Null 許容のシーケンスの最小値を返します<see cref="T:System.Single" />値。</summary>
        <returns>型の値<c>Nullable&lt;単一&gt;</c> (C#) または<c>Nullable (の 1 つ)</c>で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]シーケンス内の最小値に対応します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29>メソッドを使用、<xref:System.Single>の実装<xref:System.IComparable%601>値を比較します。  
  
 ソース シーケンスが空かは値のみを含むかどうか`null`、この関数を返します`null`です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Min()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Min%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29>シーケンス内の最小値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#63](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#63)]
 [!code-vb[System.Linq.Enumerable#63](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#63)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static float Min (this System.Collections.Generic.IEnumerable&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Min(class System.Collections.Generic.IEnumerable`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Single})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">一連の<see cref="T:System.Single" />の最小値を確認します。</param>
        <summary>シーケンスの最小値を返します<see cref="T:System.Single" />値。</summary>
        <returns>シーケンスの最小値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29>メソッドを使用、<xref:System.Single>の実装<xref:System.IComparable%601>値を比較します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Min()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Min%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29>シーケンス内の最小値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#60](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#60)]
 [!code-vb[System.Linq.Enumerable#60](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />要素は含まれません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">最小値を確認する対象となる値のシーケンス。</param>
        <summary>ジェネリック シーケンスの最小値を返します。</summary>
        <returns>シーケンスの最小値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合型`TSource`実装<xref:System.IComparable%601>、このメソッドでは、その実装を使用して、値を比較します。 それ以外の場合型`TSource`実装<xref:System.IComparable>、その実装を使用して値を比較します。  
  
 場合`TSource`は参照型であり、ソース シーケンスが空かされる値のみが含まれています`null`、この関数を返します`null`です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Min()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Min%2A>です。  
  
   
  
## Examples  
 次のコード例は、使用する方法を示します<xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>のシーケンスの最小値を決定する<xref:System.IComparable%601>オブジェクト。  
  
 [!code-csharp[System.Linq.Enumerable#67](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#67)]
 [!code-vb[System.Linq.Enumerable#67](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#67)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,decimal&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Decimal})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Decimal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">最小値を確認する対象となる値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの各要素に対して変換関数を呼び出し、最小値を返します<see cref="T:System.Decimal" />値。</summary>
        <returns>シーケンスの最小値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Decimal%7D%29>メソッドを使用、<xref:System.Decimal>の実装<xref:System.IComparable%601>値を比較します。  
  
 関数を提供する場合、任意の値のシーケンスにこのメソッドを適用することができます`selector`のメンバーを射影する`source`、数値型に特に<xref:System.Decimal>です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Min()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Min%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>予測される値のシーケンス内の最小値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />要素は含まれません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,double&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Double&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">最小値を確認する対象となる値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの各要素に対して変換関数を呼び出し、最小値を返します<see cref="T:System.Double" />値。</summary>
        <returns>シーケンスの最小値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29>メソッドを使用、<xref:System.Double>の実装<xref:System.IComparable%601>値を比較します。  
  
 関数を提供する場合、任意の値のシーケンスにこのメソッドを適用することができます`selector`のメンバーを射影する`source`、数値型に特に<xref:System.Double>です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Min()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Min%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>予測される値のシーケンス内の最小値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />要素は含まれません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">最小値を確認する対象となる値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの各要素に対して変換関数を呼び出し、最小値を返します<see cref="T:System.Int32" />値。</summary>
        <returns>シーケンスの最小値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>メソッドを使用、<xref:System.Int32>の実装<xref:System.IComparable%601>値を比較します。  
  
 関数を提供する場合、任意の値のシーケンスにこのメソッドを適用することができます`selector`のメンバーを射影する`source`、数値型に特に<xref:System.Int32>です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Min()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Min%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>予測される値のシーケンス内の最小値を決定します。  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />要素は含まれません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,long&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int64})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">最小値を確認する対象となる値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの各要素に対して変換関数を呼び出し、最小値を返します<see cref="T:System.Int64" />値。</summary>
        <returns>シーケンスの最小値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29>メソッドを使用、<xref:System.Int64>の実装<xref:System.IComparable%601>値を比較します。  
  
 関数を提供する場合、任意の値のシーケンスにこのメソッドを適用することができます`selector`のメンバーを射影する`source`、数値型に特に<xref:System.Int64>です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Min()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Min%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>予測される値のシーケンス内の最小値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />要素は含まれません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">最小値を確認する対象となる値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの各要素に対して変換関数を呼び出すし、null 許容最小値を返します<see cref="T:System.Decimal" />値。</summary>
        <returns>型の値<c>Nullable&lt;Decimal&gt; </c> (C#) または<c>Nullable (の 10 進数)</c>で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]シーケンス内の最小値に対応します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Decimal%7D%7D%29>メソッドを使用、<xref:System.Decimal>の実装<xref:System.IComparable%601>値を比較します。  
  
 関数を提供する場合は、任意の値のシーケンスにこのメソッドを適用できます`selector`のメンバーを射影する`source`、数値型に具体的には`Nullable<Decimal>`(C#) または`Nullable(Of Decimal)`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Min()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Min%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>予測される値のシーケンス内の最小値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">最小値を確認する対象となる値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの各要素に対して変換関数を呼び出すし、null 許容最小値を返します<see cref="T:System.Double" />値。</summary>
        <returns>型の値<c>Nullable&lt;二重&gt;</c> (C#) または<c>Nullable (の二重)</c>で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]シーケンス内の最小値に対応します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Double%7D%7D%29>メソッドを使用、<xref:System.Double>の実装<xref:System.IComparable%601>値を比較します。  
  
 関数を提供する場合は、任意の値のシーケンスにこのメソッドを適用できます`selector`のメンバーを射影する`source`、数値型に具体的には`Nullable<Double>`(C#) または`Nullable(Of Double)`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Min()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Min%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>予測される値のシーケンス内の最小値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">最小値を確認する対象となる値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの各要素に対して変換関数を呼び出すし、null 許容最小値を返します<see cref="T:System.Int32" />値。</summary>
        <returns>型の値<c>Nullable&lt;Int32&gt; </c> (C#) または<c>Nullable (の Int32)</c>で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]シーケンス内の最小値に対応します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int32%7D%7D%29>メソッドを使用、<xref:System.Int32>の実装<xref:System.IComparable%601>値を比較します。  
  
 関数を提供する場合は、任意の値のシーケンスにこのメソッドを適用できます`selector`、具体的には、数値型にソースのメンバーを射影する`Nullable<Int32>`(C#) または`Nullable(Of Int32)`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Min()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Min%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>予測される値のシーケンス内の最小値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">最小値を確認する対象となる値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの各要素に対して変換関数を呼び出すし、null 許容最小値を返します<see cref="T:System.Int64" />値。</summary>
        <returns>型の値<c>Nullable&lt;Int64&gt; </c> (C#) または<c>Nullable (Int64 の)</c>で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]シーケンス内の最小値に対応します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int64%7D%7D%29>メソッドを使用、<xref:System.Int64>の実装<xref:System.IComparable%601>値を比較します。  
  
 関数を提供する場合は、任意の値のシーケンスにこのメソッドを適用できます`selector`のメンバーを射影する`source`、数値型に具体的には`Nullable<Int64>`(C#) または`Nullable(Of Int64)`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Min()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Min%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>予測される値のシーケンス内の最小値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">最小値を確認する対象となる値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの各要素に対して変換関数を呼び出すし、null 許容最小値を返します<see cref="T:System.Single" />値。</summary>
        <returns>型の値<c>Nullable&lt;単一&gt;</c> (C#) または<c>Nullable (の 1 つ)</c>で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]シーケンス内の最小値に対応します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Single%7D%7D%29>メソッドを使用、<xref:System.Single>の実装<xref:System.IComparable%601>値を比較します。  
  
 関数を提供する場合は、任意の値のシーケンスにこのメソッドを適用できます`selector`のメンバーを射影する`source`、数値型に具体的には`Nullable<Single>`(C#) または`Nullable(Of Single)`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Min()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Min%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>予測される値のシーケンス内の最小値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,float&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Single&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">最小値を確認する対象となる値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの各要素に対して変換関数を呼び出し、最小値を返します<see cref="T:System.Single" />値。</summary>
        <returns>シーケンスの最小値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Single%7D%29>メソッドを使用、<xref:System.Single>の実装<xref:System.IComparable%601>値を比較します。  
  
 関数を提供する場合、任意の値のシーケンスにこのメソッドを適用することができます`selector`のメンバーを射影する`source`、数値型に特に<xref:System.Single>です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Min()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Min%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>予測される値のシーケンス内の最小値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />要素は含まれません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Min&lt;TSource,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TResult&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Min&lt;TSource, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TResult&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <typeparam name="TResult">によって返される値の型<c>セレクター</c>です。</typeparam>
        <param name="source">最小値を確認する対象となる値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>ジェネリック シーケンスの各要素に対して変換関数を呼び出すし、結果の最小値を返します。</summary>
        <returns>シーケンスの最小値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合型`TResult`実装<xref:System.IComparable%601>、このメソッドでは、その実装を使用して、値を比較します。 それ以外の場合型`TResult`実装<xref:System.IComparable>、その実装を使用して値を比較します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Min()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Min%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>予測される値のシーケンス内の最小値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="OfType&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; OfType&lt;TResult&gt; (this System.Collections.IEnumerable source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; OfType&lt;TResult&gt;(class System.Collections.IEnumerable source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.OfType``1(System.Collections.IEnumerable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.IEnumerable" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">シーケンスの要素をフィルター処理する型。</typeparam>
        <param name="source"><see cref="T:System.Collections.IEnumerable" />フィルターを適用する要素を格納します。</param>
        <summary>要素をフィルター処理、<see cref="T:System.Collections.IEnumerable" />指定した型に基づいています。</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerable`1" />型の入力シーケンスから要素を含む<paramref name="TResult" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは遅延実行を使用して実装されます。 即時の戻り値は、操作を実行するために必要なすべての情報を格納するオブジェクトです。 オブジェクトのいずれかを呼び出したが列挙されるまで、このメソッドで表されるクエリが実行されていませんが、`GetEnumerator`メソッド直接、またはを使用して`foreach`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`For Each`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 <xref:System.Linq.Enumerable.OfType%60%601%28System.Collections.IEnumerable%29>の要素のみを返します`source`型にキャストできる`TResult`です。 代わりに要素を型にキャストできない場合に例外を発生させる`TResult`を使用して<xref:System.Linq.Enumerable.Cast%60%601%28System.Collections.IEnumerable%29>です。  
  
 このメソッドは、型を持つパラメーターのないなど、コレクションに適用できるいくつかの標準クエリ演算子メソッドの 1 つ、<xref:System.Collections.ArrayList>です。 これは、ため<xref:System.Linq.Enumerable.OfType%2A>型を拡張<xref:System.Collections.IEnumerable>です。 <xref:System.Linq.Enumerable.OfType%2A>基づいているコレクションにのみ適用することはできません、パラメーター化された <xref:System.Collections.Generic.IEnumerable%601>型でありは、非パラメーター化に基づいているコレクション<xref:System.Collections.IEnumerable>も入力します。  
  
 適用することによって<xref:System.Linq.Enumerable.OfType%2A>を実装するコレクションに<xref:System.Collections.IEnumerable>、標準クエリ演算子を使用して、コレクションを照会することができます。 などの型引数を指定する<xref:System.Object>に<xref:System.Linq.Enumerable.OfType%2A>型のオブジェクトを返すよう`IEnumerable<Object>`(C#) または`IEnumerable(Of Object)`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]、標準クエリ演算子を適用できます。  
  
   
  
## Examples  
 次のコード例は、使用する方法を示します<xref:System.Linq.Enumerable.OfType%2A>の要素をフィルター処理する、<xref:System.Collections.IEnumerable>です。  
  
 [!code-csharp[System.Linq.Enumerable#69](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#69)]
 [!code-vb[System.Linq.Enumerable#69](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="OrderBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; OrderBy&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; OrderBy&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <typeparam name="TKey">によって返されるキーの種類<c>keySelector</c>です。</typeparam>
        <param name="source">順序付ける値のシーケンス。</param>
        <param name="keySelector">要素からキーを抽出する関数。</param>
        <summary>キーに従って昇順のシーケンスの要素を並べ替えます。</summary>
        <returns><see cref="T:System.Linq.IOrderedEnumerable`1" />要素がキーに従って並べ替えられています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは遅延実行を使用して実装されます。 即時の戻り値は、操作を実行するために必要なすべての情報を格納するオブジェクトです。 オブジェクトのいずれかを呼び出したが列挙されるまで、このメソッドで表されるクエリが実行されていませんが、`GetEnumerator`メソッド直接、またはを使用して`foreach`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`For Each`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 要素自体の値によって、シーケンスの順序するには、identity 関数を指定 (`x => x`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`Function(x) x`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) の`keySelector`します。  
  
 2 つのメソッドを定義して型を拡張する<xref:System.Linq.IOrderedEnumerable%601>、これは、このメソッドの戻り値の型。 これら 2 つのメソッド、つまり`ThenBy`と`ThenByDescending`を使用してシーケンスを並べ替えるには、追加の並べ替え条件を指定します。 `ThenBy`および`ThenByDescending`を返すことも、 <xref:System.Linq.IOrderedEnumerable%601>、つまり、任意の数を連続して呼び出すの`ThenBy`または`ThenByDescending`行んだことができます。  
  
> [!NOTE]
>  <xref:System.Linq.IOrderedEnumerable%601>から継承<xref:System.Collections.Generic.IEnumerable%601>、呼び出すことができます<xref:System.Linq.Enumerable.OrderBy%2A>または<xref:System.Linq.Enumerable.OrderByDescending%2A>への呼び出しの結果に<xref:System.Linq.Enumerable.OrderBy%2A>、 <xref:System.Linq.Enumerable.OrderByDescending%2A>、<xref:System.Linq.Enumerable.ThenBy%2A>または<xref:System.Linq.Enumerable.ThenByDescending%2A>です。 これを行うには、新しいプライマリの順序、以前に確立された順序を無視するが導入されています。  
  
 このメソッドは、既定の比較子を使用してキーを比較して<xref:System.Collections.Generic.Comparer%601.Default%2A>です。  
  
 このメソッドは、安定した並べ替えを実行します。つまり、2 つの要素のキーが等しい場合は、要素の順序が保持されます。 これに対し、不安定な並べ替えでは、同じキーを持つ要素の順序は保持されません。  
  
 クエリ式の構文では、 `orderby` ([!INCLUDE[csprcs](~/includes/csprcs-md.md)]) または`Order By`([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) の呼び出しに変換される句<xref:System.Linq.Enumerable.OrderBy%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.OrderBy%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29>シーケンスの要素の並べ替えにします。  
  
 [!code-csharp[System.Linq.Enumerable#70](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#70)]
 [!code-vb[System.Linq.Enumerable#70](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#70)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="keySelector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="OrderBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; OrderBy&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; OrderBy&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <typeparam name="TKey">によって返されるキーの種類<c>keySelector</c>です。</typeparam>
        <param name="source">順序付ける値のシーケンス。</param>
        <param name="keySelector">要素からキーを抽出する関数。</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IComparer`1" />キーを比較します。</param>
        <summary>指定された比較子を使用して、昇順のシーケンスの要素を並べ替えます。</summary>
        <returns><see cref="T:System.Linq.IOrderedEnumerable`1" />要素がキーに従って並べ替えられています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは遅延実行を使用して実装されます。 即時の戻り値は、操作を実行するために必要なすべての情報を格納するオブジェクトです。 オブジェクトのいずれかを呼び出したが列挙されるまで、このメソッドで表されるクエリが実行されていませんが、`GetEnumerator`メソッド直接、またはを使用して`foreach`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`For Each`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 要素自体の値によって、シーケンスの順序するには、identity 関数を指定 (`x => x`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`Function(x) x`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) の`keySelector`します。  
  
 2 つのメソッドを定義して型を拡張する<xref:System.Linq.IOrderedEnumerable%601>、これは、このメソッドの戻り値の型。 これら 2 つのメソッド、つまり`ThenBy`と`ThenByDescending`を使用してシーケンスを並べ替えるには、追加の並べ替え条件を指定します。 `ThenBy`および`ThenByDescending`を返すことも、 <xref:System.Linq.IOrderedEnumerable%601>、つまり、任意の数を連続して呼び出すの`ThenBy`または`ThenByDescending`行んだことができます。  
  
> [!NOTE]
>  <xref:System.Linq.IOrderedEnumerable%601>から継承<xref:System.Collections.Generic.IEnumerable%601>、呼び出すことができます<xref:System.Linq.Enumerable.OrderBy%2A>または<xref:System.Linq.Enumerable.OrderByDescending%2A>への呼び出しの結果に<xref:System.Linq.Enumerable.OrderBy%2A>、 <xref:System.Linq.Enumerable.OrderByDescending%2A>、<xref:System.Linq.Enumerable.ThenBy%2A>または<xref:System.Linq.Enumerable.ThenByDescending%2A>です。 これを行うには、新しいプライマリの順序、以前に確立された順序を無視するが導入されています。  
  
 場合`comparer`は`null`、既定の比較子<xref:System.Collections.Generic.Comparer%601.Default%2A>キーを比較するために使用します。  
  
 このメソッドは、安定した並べ替えを実行します。つまり、2 つの要素のキーが等しい場合は、要素の順序が保持されます。 これに対し、不安定な並べ替えでは、同じキーを持つ要素の順序は保持されません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="keySelector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="OrderByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; OrderByDescending&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; OrderByDescending&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <typeparam name="TKey">によって返されるキーの種類<c>keySelector</c>です。</typeparam>
        <param name="source">順序付ける値のシーケンス。</param>
        <param name="keySelector">要素からキーを抽出する関数。</param>
        <summary>キーに従って降順のシーケンスの要素を並べ替えます。</summary>
        <returns><see cref="T:System.Linq.IOrderedEnumerable`1" />要素がキーに従って降順に並べ替えられています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは遅延実行を使用して実装されます。 即時の戻り値は、操作を実行するために必要なすべての情報を格納するオブジェクトです。 オブジェクトのいずれかを呼び出したが列挙されるまで、このメソッドで表されるクエリが実行されていませんが、`GetEnumerator`メソッド直接、またはを使用して`foreach`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`For Each`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 要素自体の値によって、シーケンスの順序するには、identity 関数を指定 (`x => x`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`Function(x) x`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) の`keySelector`します。  
  
 このメソッドの例は、次を参照してください。<xref:System.Linq.Enumerable.OrderByDescending%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29>です。  
  
 2 つのメソッドを定義して型を拡張する<xref:System.Linq.IOrderedEnumerable%601>、これは、このメソッドの戻り値の型。 これら 2 つのメソッド、つまり`ThenBy`と`ThenByDescending`を使用してシーケンスを並べ替えるには、追加の並べ替え条件を指定します。 `ThenBy`および`ThenByDescending`を返すことも、 <xref:System.Linq.IOrderedEnumerable%601>、つまり、任意の数を連続して呼び出すの`ThenBy`または`ThenByDescending`行んだことができます。  
  
> [!NOTE]
>  <xref:System.Linq.IOrderedEnumerable%601>から継承<xref:System.Collections.Generic.IEnumerable%601>、呼び出すことができます<xref:System.Linq.Enumerable.OrderBy%2A>または<xref:System.Linq.Enumerable.OrderByDescending%2A>への呼び出しの結果に<xref:System.Linq.Enumerable.OrderBy%2A>、 <xref:System.Linq.Enumerable.OrderByDescending%2A>、<xref:System.Linq.Enumerable.ThenBy%2A>または<xref:System.Linq.Enumerable.ThenByDescending%2A>です。 これを行うには、新しいプライマリの順序、以前に確立された順序を無視するが導入されています。  
  
 このメソッドは、既定の比較子を使用してキーを比較して<xref:System.Collections.Generic.Comparer%601.Default%2A>です。  
  
 このメソッドは、安定した並べ替えを実行します。つまり、2 つの要素のキーが等しい場合は、要素の順序が保持されます。 これに対し、不安定な並べ替えでは、同じキーを持つ要素の順序は保持されません。  
  
 クエリ式の構文では、 `orderby descending` ([!INCLUDE[csprcs](~/includes/csprcs-md.md)]) または`Order By Descending`([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) の呼び出しに変換される句<xref:System.Linq.Enumerable.OrderByDescending%2A>です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="keySelector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="OrderByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; OrderByDescending&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; OrderByDescending&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <typeparam name="TKey">によって返されるキーの種類<c>keySelector</c>です。</typeparam>
        <param name="source">順序付ける値のシーケンス。</param>
        <param name="keySelector">要素からキーを抽出する関数。</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IComparer`1" />キーを比較します。</param>
        <summary>指定された比較子を使用してシーケンスの要素を降順に並べ替えます。</summary>
        <returns><see cref="T:System.Linq.IOrderedEnumerable`1" />要素がキーに従って降順に並べ替えられています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは遅延実行を使用して実装されます。 即時の戻り値は、操作を実行するために必要なすべての情報を格納するオブジェクトです。 オブジェクトのいずれかを呼び出したが列挙されるまで、このメソッドで表されるクエリが実行されていませんが、`GetEnumerator`メソッド直接、またはを使用して`foreach`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`For Each`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 要素自体の値によって、シーケンスの順序するには、identity 関数を指定 (`x => x`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`Function(x) x`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) の`keySelector`します。  
  
 2 つのメソッドを定義して型を拡張する<xref:System.Linq.IOrderedEnumerable%601>、これは、このメソッドの戻り値の型。 これら 2 つのメソッド、つまり`ThenBy`と`ThenByDescending`を使用してシーケンスを並べ替えるには、追加の並べ替え条件を指定します。 `ThenBy`および`ThenByDescending`を返すことも、 <xref:System.Linq.IOrderedEnumerable%601>、つまり、任意の数を連続して呼び出すの`ThenBy`または`ThenByDescending`行んだことができます。  
  
> [!NOTE]
>  <xref:System.Linq.IOrderedEnumerable%601>から継承<xref:System.Collections.Generic.IEnumerable%601>、呼び出すことができます<xref:System.Linq.Enumerable.OrderBy%2A>または<xref:System.Linq.Enumerable.OrderByDescending%2A>への呼び出しの結果に<xref:System.Linq.Enumerable.OrderBy%2A>、 <xref:System.Linq.Enumerable.OrderByDescending%2A>、<xref:System.Linq.Enumerable.ThenBy%2A>または<xref:System.Linq.Enumerable.ThenByDescending%2A>です。 これを行うには、新しいプライマリの順序、以前に確立された順序を無視するが導入されています。  
  
 場合`comparer`は`null`、既定の比較子<xref:System.Collections.Generic.Comparer%601.Default%2A>キーを比較するために使用します。  
  
 このメソッドは、安定した並べ替えを実行します。つまり、2 つの要素のキーが等しい場合は、要素の順序が保持されます。 これに対し、不安定な並べ替えでは、同じキーを持つ要素の順序は保持されません。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.OrderByDescending%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29>変換関数とカスタムの比較演算子を使用して別に降順のシーケンスの要素を並べ替える。  
  
 [!code-csharp[System.Linq.Enumerable#71](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#71)]
 [!code-vb[System.Linq.Enumerable#71](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#71)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="keySelector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Prepend&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Prepend&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TSource element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Prepend&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TSource element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Prepend``1(System.Collections.Generic.IEnumerable{``0},``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="element" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><paramref name="source" /> の要素の型。</typeparam>
        <param name="source">値のシーケンス。</param>
        <param name="element"><paramref name="source" /> に追加する値。</param>
        <summary>シーケンスの先頭に値を追加します。</summary>
        <returns><paramref name="element" /> で始まる新しいシーケンス。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>        
      </Docs>
    </Member>
    <Member MemberName="Range">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;int&gt; Range (int start, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;int32&gt; Range(int32 start, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Range(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">シーケンス内の最初の整数の値。</param>
        <param name="count">生成する連続した整数の数。</param>
        <summary>指定された範囲内の整数のシーケンスを生成します。</summary>
        <returns><c>IEnumerable&lt;Int32&gt; </c> (C#) または<c>IEnumerable (Of Int32)</c>で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]連続した整数の範囲を格納しています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは遅延実行を使用して実装されます。 即時の戻り値は、操作を実行するために必要なすべての情報を格納するオブジェクトです。 オブジェクトのいずれかを呼び出したが列挙されるまで、このメソッドで表されるクエリが実行されていませんが、`GetEnumerator`メソッド直接、またはを使用して`foreach`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`For Each`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Range%2A>値のシーケンスを生成します。  
  
 [!code-csharp[System.Linq.Enumerable#72](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#72)]
 [!code-vb[System.Linq.Enumerable#72](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#72)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> が 0 未満です。  
  
 または  
  
 <paramref name="start" /> + <paramref name="count" />-1 がよりも大きい<see cref="F:System.Int32.MaxValue" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Repeat&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Repeat&lt;TResult&gt; (TResult element, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Repeat&lt;TResult&gt;(!!TResult element, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Repeat``1(``0,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="element" Type="TResult" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">結果のシーケンスで繰り返される値の型。</typeparam>
        <param name="element">繰り返される値。</param>
        <param name="count">生成されたシーケンスで値を繰り返す回数。</param>
        <summary>繰り返される 1 つの値を格納しているシーケンスを生成します。</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerable`1" />繰り返される値を格納します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは遅延実行を使用して実装されます。 即時の戻り値は、操作を実行するために必要なすべての情報を格納するオブジェクトです。 オブジェクトのいずれかを呼び出したが列挙されるまで、このメソッドで表されるクエリが実行されていませんが、`GetEnumerator`メソッド直接、またはを使用して`foreach`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`For Each`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Repeat%2A>繰り返される値のシーケンスを生成します。  
  
 [!code-csharp[System.Linq.Enumerable#73](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#73)]
 [!code-vb[System.Linq.Enumerable#73](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#73)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> が 0 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Reverse&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Reverse&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Reverse``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">反転させる値のシーケンス。</param>
        <summary>シーケンス内の要素の順序を反転します。</summary>
        <returns>要素が入力シーケンスの要素に逆順で対応しているシーケンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは遅延実行を使用して実装されます。 即時の戻り値は、操作を実行するために必要なすべての情報を格納するオブジェクトです。 オブジェクトのいずれかを呼び出したが列挙されるまで、このメソッドで表されるクエリが実行されていませんが、`GetEnumerator`メソッド直接、またはを使用して`foreach`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`For Each`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 異なり<xref:System.Linq.Enumerable.OrderBy%2A>、このメソッドを並べ替え順序が決定自体実際の値は考慮されません。 代わりに、それだけを返します要素は生成元となる逆の順序で、基になるソースによって。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Reverse%2A>配列内の要素の順序を逆にします。  
  
 [!code-csharp[System.Linq.Enumerable#74](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#74)]
 [!code-vb[System.Linq.Enumerable#74](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#74)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Select&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Select&lt;TSource,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int,TResult&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Select&lt;TSource, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, !!TResult&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <typeparam name="TResult">によって返される値の型<c>セレクター</c>です。</typeparam>
        <param name="source">変換関数を呼び出す対象となる値のシーケンス。</param>
        <param name="selector">各ソース要素に適用する変換関数。この関数の 2 つ目のパラメーターは、ソース要素のインデックスを表します。</param>
        <summary>要素のインデックスを組み込むことにより、新しいフォームにシーケンスの各要素を射影します。</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerable`1" />要素の各要素に対して変換関数の呼び出しの結果は、<paramref name="source" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは遅延実行を使用して実装されます。 即時の戻り値は、操作を実行するために必要なすべての情報を格納するオブジェクトです。 オブジェクトのいずれかを呼び出したが列挙されるまで、このメソッドで表されるクエリが実行されていませんが、`GetEnumerator`メソッド直接、またはを使用して`foreach`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`For Each`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 1 番目の引数`selector`を処理する要素を表します。 2 番目の引数`selector`ソース シーケンス内の要素の 0 から始まるインデックスを表します。 既知の順序に要素があり、たとえば特定のインデックス位置にある要素で何かを実行する場合、これは役立つあります。 1 つまたは複数の要素のインデックスを取得する場合に役立ちますできます。  
  
 このプロジェクション メソッドは変換関数を必要と`selector`、ソース シーケンス内の各値の 1 つの値を生成する`source`です。 場合`selector`自体がコレクションを値を返します、し、サブシーケンスを手動で走査するコンシューマーの責任です。 このような状況では、値の 1 つのまとめられたシーケンスを返すようにクエリの方がよい場合があります。 これを実現するを使用して、<xref:System.Linq.Enumerable.SelectMany%2A>メソッドの代わりに<xref:System.Linq.Enumerable.Select%2A>です。 `SelectMany`と同じように動作`Select`、変換関数でを展開し、コレクションを返します点が異なります`SelectMany`に返されます。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Select%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2C%60%601%7D%29>とを射影値のシーケンスの各要素のインデックスを使用します。  
  
 [!code-csharp[System.Linq.Enumerable#76](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#76)]
 [!code-vb[System.Linq.Enumerable#76](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#76)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Select&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Select&lt;TSource,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TResult&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Select&lt;TSource, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TResult&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <typeparam name="TResult">によって返される値の型<c>セレクター</c>です。</typeparam>
        <param name="source">変換関数を呼び出す対象となる値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの各要素を新しいフォームに射影します。</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerable`1" />要素の各要素に対して変換関数の呼び出しの結果は、<paramref name="source" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは遅延実行を使用して実装されます。 即時の戻り値は、操作を実行するために必要なすべての情報を格納するオブジェクトです。 オブジェクトのいずれかを呼び出したが列挙されるまで、このメソッドで表されるクエリが実行されていませんが、`GetEnumerator`メソッド直接、またはを使用して`foreach`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`For Each`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 このプロジェクション メソッドは変換関数を必要と`selector`、ソース シーケンス内の各値の 1 つの値を生成する`source`です。 場合`selector`自体がコレクションを値を返します、し、サブシーケンスを手動で走査するコンシューマーの責任です。 このような状況では、値の 1 つのまとめられたシーケンスを返すようにクエリの方がよい場合があります。 これを実現するを使用して、<xref:System.Linq.Enumerable.SelectMany%2A>メソッドの代わりに<xref:System.Linq.Enumerable.Select%2A>です。 `SelectMany`と同じように動作`Select`、変換関数でを展開し、コレクションを返します点が異なります`SelectMany`に返されます。  
  
 クエリ式の構文では、 `select` ([!INCLUDE[csprcs](~/includes/csprcs-md.md)]) または`Select`([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) の呼び出しに変換される句<xref:System.Linq.Enumerable.Select%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Select%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29>値のシーケンスをプロジェクトにします。  
  
 [!code-csharp[System.Linq.Enumerable#75](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#75)]
 [!code-vb[System.Linq.Enumerable#75](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#75)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; SelectMany&lt;TSource,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <typeparam name="TResult">によって返されるシーケンスの要素の型<c>セレクター</c>です。</typeparam>
        <param name="source">射影する値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの各要素、<see cref="T:System.Collections.Generic.IEnumerable`1" />結果のシーケンスを 1 つのシーケンスにフラット化します。</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerable`1" />要素は、入力シーケンスの各要素に対して一対多の変換関数の呼び出しの結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは遅延実行を使用して実装されます。 即時の戻り値は、操作を実行するために必要なすべての情報を格納するオブジェクトです。 オブジェクトのいずれかを呼び出したが列挙されるまで、このメソッドで表されるクエリが実行されていませんが、`GetEnumerator`メソッド直接、またはを使用して`foreach`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`For Each`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29>メソッドの入力シーケンスを列挙、各要素にマップする変換関数を使用して、 <xref:System.Collections.Generic.IEnumerable%601>、列挙して、これらの各要素が生成されます<xref:System.Collections.Generic.IEnumerable%601>オブジェクト。 つまりの各要素に対して`source`、`selector`が呼び出されると値のシーケンスが返されます。 <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29>このコレクションを 1 次元の 2 次元のコレクションを平坦化する、<xref:System.Collections.Generic.IEnumerable%601>しそれを取得します。 たとえば、次のクエリで使用される<xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29>の注文を取得する (型の`Order`) 型の結果は、データベース内の各顧客の`IEnumerable<Order>`(C#) または`IEnumerable(Of Order)`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。 クエリの代わりに使用する場合<xref:System.Linq.Enumerable.Select%2A>の注文を取得するには、注文のコレクションのコレクションを組み合わせることはできませんし、結果は型の`IEnumerable<List<Order>>`(C#) または`IEnumerable(Of List(Of Order))`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 クエリ式の構文では各`from`句 ([!INCLUDE[csprcs](~/includes/csprcs-md.md)]) または`From`句 ([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) の呼び出しに 1 つは変換の頭文字の後<xref:System.Linq.Enumerable.SelectMany%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29>配列に対する一対多の射影を実行します。  
  
 [!code-csharp[System.Linq.Enumerable#77](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#77)]
 [!code-vb[System.Linq.Enumerable#77](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#77)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; SelectMany&lt;TSource,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <typeparam name="TResult">によって返されるシーケンスの要素の型<c>セレクター</c>です。</typeparam>
        <param name="source">射影する値のシーケンス。</param>
        <param name="selector">各ソース要素に適用する変換関数。この関数の 2 つ目のパラメーターは、ソース要素のインデックスを表します。</param>
        <summary>シーケンスの各要素、 <see cref="T:System.Collections.Generic.IEnumerable`1" />、結果のシーケンスを 1 つのシーケンスにフラット化します。 各ソース要素のインデックスは、その要素の射影されたフォームで使用されます。</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerable`1" />要素は、入力シーケンスの各要素に対して一対多の変換関数の呼び出しの結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは遅延実行を使用して実装されます。 即時の戻り値は、操作を実行するために必要なすべての情報を格納するオブジェクトです。 オブジェクトのいずれかを呼び出したが列挙されるまで、このメソッドで表されるクエリが実行されていませんが、`GetEnumerator`メソッド直接、またはを使用して`foreach`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`For Each`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29>メソッドの入力シーケンスを列挙、各要素にマップする変換関数を使用して、 <xref:System.Collections.Generic.IEnumerable%601>、列挙して、これらの各要素が生成されます<xref:System.Collections.Generic.IEnumerable%601>オブジェクト。 つまりの各要素に対して`source`、`selector`が呼び出されると値のシーケンスが返されます。 <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29>このコレクションを 1 次元の 2 次元のコレクションを平坦化する、<xref:System.Collections.Generic.IEnumerable%601>しそれを取得します。 たとえば、次のクエリで使用される<xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29>の注文を取得する (型の`Order`) 型の結果は、データベース内の各顧客の`IEnumerable<Order>`(C#) または`IEnumerable(Of Order)`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。 クエリの代わりに使用する場合<xref:System.Linq.Enumerable.Select%2A>の注文を取得するには、注文のコレクションのコレクションを組み合わせることはできませんし、結果は型の`IEnumerable<List<Order>>`(C#) または`IEnumerable(Of List(Of Order))`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 1 番目の引数`selector`を処理する要素を表します。 2 番目の引数`selector`ソース シーケンス内の要素の 0 から始まるインデックスを表します。 既知の順序に要素があり、たとえば特定のインデックス位置にある要素で何かを実行する場合、これは役立つあります。 1 つまたは複数の要素のインデックスを取得する場合に役立ちますできます。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29>を配列の一対多の射影を実行し、外部の各要素のインデックスを使用します。  
  
 [!code-csharp[System.Linq.Enumerable#78](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#78)]
 [!code-vb[System.Linq.Enumerable#78](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#78)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TCollection,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; SelectMany&lt;TSource,TCollection,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt; collectionSelector, Func&lt;TSource,TCollection,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TCollection, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, class System.Collections.Generic.IEnumerable`1&lt;!!TCollection&gt;&gt; collectionSelector, class System.Func`3&lt;!!TSource, !!TCollection, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SelectMany``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TCollection" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="collectionSelector" Type="System.Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TSource,TCollection,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <typeparam name="TCollection">中間の要素の型がによって収集された<c>collectionSelector</c>です。</typeparam>
        <typeparam name="TResult">結果のシーケンスの要素の型。</typeparam>
        <param name="source">射影する値のシーケンス。</param>
        <param name="collectionSelector">入力シーケンスの各要素に適用する変換関数。</param>
        <param name="resultSelector">中間のシーケンスの各要素に適用する変換関数。</param>
        <summary>シーケンスの各要素、 <see cref="T:System.Collections.Generic.IEnumerable`1" />、結果のシーケンスに 1 つのシーケンスを平坦化して、そこに各要素に対して結果セレクター関数を呼び出します。</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerable`1" />要素は、一対多の変換関数を呼び出した結果<paramref name="collectionSelector" />の各要素に対して<paramref name="source" />し、それらのシーケンスの要素とその対応するソース要素の各要素にマップする結果とします。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは遅延実行を使用して実装されます。 即時の戻り値は、操作を実行するために必要なすべての情報を格納するオブジェクトです。 オブジェクトのいずれかを呼び出したが列挙されるまで、このメソッドで表されるクエリが実行されていませんが、`GetEnumerator`メソッド直接、またはを使用して`foreach`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`For Each`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 <xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29>メソッドは、の要素を保持する必要がある場合に役立ちます`source`への呼び出し後に発生するクエリ ロジックのスコープで<xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29>です。 コード例については、「使用例」のセクションを参照してください。 型のオブジェクト間で双方向のリレーションシップがあるかどうかは`TSource`と型のオブジェクト`TCollection`、つまり、型のオブジェクト`TCollection`取得するプロパティを提供、`TSource`を生成したオブジェクトのこのオーバー ロードする必要はありません<xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29>です。 使用する代わりに、<xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29>に戻ると、`TSource`オブジェクトを介して、`TCollection`オブジェクト。  
  
 クエリ式の構文では各`from`句 ([!INCLUDE[csprcs](~/includes/csprcs-md.md)]) または`From`句 ([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) の呼び出しに 1 つは変換の頭文字の後<xref:System.Linq.Enumerable.SelectMany%2A>です。  
  
   
  
## Examples  
 次のコード例は、使用する方法を示します<xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29>を配列の一対多の射影を実行し、結果のセレクター関数を使用して、それぞれ対応する要素をソース シーケンスの最後の呼び出しのスコープ内から`Select`です。  
  
 [!code-csharp[System.Linq.Enumerable#124](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#124)]
 [!code-vb[System.Linq.Enumerable#124](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#124)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />、<paramref name="collectionSelector" />、または <paramref name="resultSelector" /> は、<see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TCollection,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; SelectMany&lt;TSource,TCollection,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt; collectionSelector, Func&lt;TSource,TCollection,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TCollection, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, class System.Collections.Generic.IEnumerable`1&lt;!!TCollection&gt;&gt; collectionSelector, class System.Func`3&lt;!!TSource, !!TCollection, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SelectMany``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TCollection" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="collectionSelector" Type="System.Func&lt;TSource,System.Int32,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TSource,TCollection,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <typeparam name="TCollection">中間の要素の型がによって収集された<c>collectionSelector</c>です。</typeparam>
        <typeparam name="TResult">結果のシーケンスの要素の型。</typeparam>
        <param name="source">射影する値のシーケンス。</param>
        <param name="collectionSelector">各ソース要素に適用する変換関数。この関数の 2 つ目のパラメーターは、ソース要素のインデックスを表します。</param>
        <param name="resultSelector">中間のシーケンスの各要素に適用する変換関数。</param>
        <summary>シーケンスの各要素、 <see cref="T:System.Collections.Generic.IEnumerable`1" />、結果のシーケンスに 1 つのシーケンスを平坦化して、そこに各要素に対して結果セレクター関数を呼び出します。 各ソース要素のインデックスは、その要素の中間の射影されたフォームで使用されます。</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerable`1" />要素は、一対多の変換関数を呼び出した結果<paramref name="collectionSelector" />の各要素に対して<paramref name="source" />し、それらのシーケンスの要素とその対応するソース要素の各要素にマップする結果とします。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは遅延実行を使用して実装されます。 即時の戻り値は、操作を実行するために必要なすべての情報を格納するオブジェクトです。 オブジェクトのいずれかを呼び出したが列挙されるまで、このメソッドで表されるクエリが実行されていませんが、`GetEnumerator`メソッド直接、またはを使用して`foreach`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`For Each`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 <xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29>メソッドは、の要素を保持する必要がある場合に役立ちます`source`への呼び出し後に発生するクエリ ロジックのスコープで<xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29>です。 コード例については、「使用例」のセクションを参照してください。 型のオブジェクト間で双方向のリレーションシップがあるかどうかは`TSource`と型のオブジェクト`TCollection`、つまり、型のオブジェクト`TCollection`取得するプロパティを提供、`TSource`を生成したオブジェクトのこのオーバー ロードする必要はありません<xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29>です。 使用する代わりに、<xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29>に戻ると、`TSource`オブジェクトを介して、`TCollection`オブジェクト。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />、<paramref name="collectionSelector" />、または <paramref name="resultSelector" /> は、<see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="SequenceEqual&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SequenceEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">入力シーケンスの要素の型。</typeparam>
        <param name="first"><see cref="T:System.Collections.Generic.IEnumerable`1" />と比較する<c>2 番目</c>です。</param>
        <param name="second"><see cref="T:System.Collections.Generic.IEnumerable`1" />と比較する最初のシーケンス。</param>
        <summary>その型の既定の等値比較子を使用して要素を比較することによって、2 つのシーケンスが等しいかどうかを判断します。</summary>
        <returns>
          <see langword="true" />2 つのソース シーケンスは、同じ長さの対応する要素です。 その型の既定の等値比較子に従って等しい場合それ以外の場合、<see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.SequenceEqual%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29>メソッドが 2 つのソース シーケンスを並列を列挙し、対応する要素を比較するには、既定の等値比較子を使用して`TSource`、<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>です。 既定の等値比較子<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>、実装する型の値を比較するために使用、<xref:System.Collections.Generic.IEqualityComparer%601>ジェネリック インターフェイス。 カスタム データ型を比較する必要がありますをこのインターフェイスを実装し、独自<xref:System.Object.GetHashCode%2A>と<xref:System.Object.Equals%2A>の型のメソッドです。  
  
   
  
## Examples  
 次のコード例を使用する方法を示します<xref:System.Linq.Enumerable.SequenceEqual%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29>を 2 つのシーケンスが等しいかどうかを判断します。 最初の 2 つの例では、メソッドは、比較対象のシーケンスが同じオブジェクトへの参照を含めるかどうかを判断します。 3 番目と 4 番目の例では、メソッドは、シーケンス内のオブジェクトの実際のデータを比較します。  
  
 この例では、シーケンスが等しいです。  
  
 [!code-csharp[System.Linq.Enumerable#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#32)]
 [!code-vb[System.Linq.Enumerable#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#32)]  
  
 次のコード例では、等しくない 2 つのシーケンスを比較します。 シーケンスが同一のデータを含むが、そこに含まれるオブジェクトに別の参照があるため、シーケンスは考慮されませんと等しいことに注意してください。  
  
 [!code-csharp[System.Linq.Enumerable#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#33)]
 [!code-vb[System.Linq.Enumerable#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#33)]  
  
 実装する必要の参照を比較するだけではなく、シーケンス内のオブジェクトの実際のデータを比較する場合、<xref:System.Collections.Generic.IEqualityComparer%601>クラスのジェネリック インターフェイス。 次のコード例は、ヘルパー クラスでこのインターフェイスを実装して、提供する方法を示しています。<xref:System.Object.GetHashCode%2A>と<xref:System.Object.Equals%2A>メソッドです。  
  
 [!code-csharp[CSLINQEncapsulatedComparer#9](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#9)]  
  
 このインターフェイスを実装した後のシーケンスを使用することができます`ProductA`内のオブジェクト、<xref:System.Linq.Enumerable.SequenceEqual%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29>メソッドを次の例で示すようにします。  
  
 [!code-csharp[CSLINQEncapsulatedComparer#8](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#8)]
 [!code-vb[CSLINQEncapsulatedComparer#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> または <paramref name="second" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="SequenceEqual&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SequenceEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">入力シーケンスの要素の型。</typeparam>
        <param name="first"><see cref="T:System.Collections.Generic.IEnumerable`1" />と比較する<c>2 番目</c>です。</param>
        <param name="second"><see cref="T:System.Collections.Generic.IEnumerable`1" />と比較する最初のシーケンス。</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IEqualityComparer`1" />を使用して要素を比較します。</param>
        <summary>指定されたを使用してその要素を比較することによって 2 つのシーケンスが等しいかどうかを判断<see cref="T:System.Collections.Generic.IEqualityComparer`1" />です。</summary>
        <returns>
          <see langword="true" />同じ長さの 2 つのソース シーケンスがあり、対応する要素を比較によると等しい<paramref name="comparer" />、それ以外の<see langword="false" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.SequenceEqual%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29>メソッドは、2 つのソース シーケンスを並列を列挙し、対応する要素を比較するには、指定して<xref:System.Collections.Generic.IEqualityComparer%601>です。 C 場合`omparer`は`null`、既定の等値比較子<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>要素を比較するために使用します。  
  
   
  
## Examples  
 次の例で使用できる等値比較子を実装する方法を示しています、<xref:System.Linq.Enumerable.SequenceEqual%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29>メソッドです。  
  
 [!code-csharp[CSLINQCustomComparer#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#1)]
 [!code-vb[CSLINQCustomComparer#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#1)]  
  
 この比較演算子を実装すると後のシーケンスを使用することができます`Product`内のオブジェクト、<xref:System.Linq.Enumerable.SequenceEqual%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29>メソッドを次の例で示すようにします。  
  
 [!code-csharp[CSLINQCustomComparer#8](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#8)]
 [!code-vb[CSLINQCustomComparer#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> または <paramref name="second" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Single&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Single&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Single&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Single``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source"><see cref="T:System.Collections.Generic.IEnumerable`1" />の 1 つの要素を返します。</param>
        <summary>シーケンスの唯一の要素を返し、シーケンス内の要素が 1 つだけでない場合は例外をスローします。</summary>
        <returns>入力シーケンスの 1 つの要素。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>入力シーケンスが空の場合、メソッドが例外をスローします。 代わりに返される`null`入力シーケンスが空の場合を使用して<xref:System.Linq.Enumerable.SingleOrDefault%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>を配列の唯一の要素を選択します。  
  
 [!code-csharp[System.Linq.Enumerable#79](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#79)]
 [!code-vb[System.Linq.Enumerable#79](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#79)]  
  
 次のコード例では、ことを示します<xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>シーケンスに 1 つの要素が含まれていない場合は例外をスローします。  
  
 [!code-csharp[System.Linq.Enumerable#80](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#80)]
 [!code-vb[System.Linq.Enumerable#80](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#80)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">入力シーケンスには、複数の要素が含まれています。  
  
 または  
  
 入力シーケンスが空です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Single&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Single&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Single&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Single``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source"><see cref="T:System.Collections.Generic.IEnumerable`1" />から 1 つの要素を返します。</param>
        <param name="predicate">要素が条件を満たしているかどうかをテストする関数。</param>
        <summary>指定された条件を満たす、シーケンスの唯一の要素を返し、そのような要素が複数存在する場合は例外をスローします。</summary>
        <returns>条件を満たす、入力シーケンスの 1 つの要素。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>入力シーケンスに一致する要素が含まれていない場合、メソッドが例外をスローします。 代わりに返される`null`一致する要素が見つからないときに使用<xref:System.Linq.Enumerable.SingleOrDefault%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>条件を満たす、配列の唯一の要素を選択します。  
  
 [!code-csharp[System.Linq.Enumerable#81](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#81)]
 [!code-vb[System.Linq.Enumerable#81](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#81)]  
  
 次のコード例では、ことを示します<xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>シーケンスに条件を満たす要素が 1 つだけが含まれていない場合は例外をスローします。  
  
 [!code-csharp[System.Linq.Enumerable#82](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#82)]
 [!code-vb[System.Linq.Enumerable#82](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="predicate" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="predicate" /> の条件を満たす要素はありません。  
  
 または  
  
 1 つ以上の要素の条件を満たす<paramref name="predicate" />です。  
  
 または  
  
 ソース シーケンスが空です。</exception>
      </Docs>
    </Member>
    <Member MemberName="SingleOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource SingleOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource SingleOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SingleOrDefault``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source"><see cref="T:System.Collections.Generic.IEnumerable`1" />の 1 つの要素を返します。</param>
        <summary>シーケンスが空である場合は、シーケンス、または既定値の唯一の要素を返しますこのメソッドは、シーケンス内に複数の要素がある場合に例外をスローします。</summary>
        <returns>入力シーケンスの 1 つの要素または<see langword="default" />(<paramref name="TSource" />) 場合は、シーケンスに要素が含まれていません。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 参照および null 許容型の既定値は`null`します。  
  
 <xref:System.Linq.Enumerable.SingleOrDefault%2A>メソッドは、既定値を指定する方法を提供していません。 以外の場合、既定値を指定する場合は、`default(TSource)`を使用して、<xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29>例」のセクションで説明するメソッド。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.SingleOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>を配列の唯一の要素を選択します。  
  
 [!code-csharp[System.Linq.Enumerable#83](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#83)]
 [!code-vb[System.Linq.Enumerable#83](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#83)]  
  
 次のコード例では、ことを示します<xref:System.Linq.Enumerable.SingleOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>シーケンスに 1 つの要素が含まれていない場合、既定値を返します。  
  
 [!code-csharp[System.Linq.Enumerable#84](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#84)]
 [!code-vb[System.Linq.Enumerable#84](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#84)]  
  
 値も`default(TSource)`コレクションに要素が含まれていない場合に使用する既定値ではありません。 不要な既定値の場合、結果を確認してから、必要な場合、代わりに使用することができます、<xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29>コレクションが空の場合に使用する既定値を指定します。 その後、呼び出す<xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>要素を取得します。 次のコード例では、両方の手法を使用して、ページ番号のコレクションが空の場合は、1 の既定値を取得します。 整数の既定値は 0 が通常有効なページ数でないため、既定値必要があります 1 として代わりに指定します。 クエリの実行が完了した後、不要な既定値の最初の結果変数がチェックされます。 使用して、2 つ目の結果変数が取得された<xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29>を既定値は 1 を指定します。  
  
 [!code-csharp[System.Linq.Enumerable#128](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#128)]
 [!code-vb[System.Linq.Enumerable#128](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#128)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">入力シーケンスには、複数の要素が含まれています。</exception>
      </Docs>
    </Member>
    <Member MemberName="SingleOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource SingleOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource SingleOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SingleOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source"><see cref="T:System.Collections.Generic.IEnumerable`1" />から 1 つの要素を返します。</param>
        <param name="predicate">要素が条件を満たしているかどうかをテストする関数。</param>
        <summary>指定された条件を満たすシーケンスの唯一の要素、またはそのような要素がない場合は既定値を返します。このメソッドは、複数の要素が条件を満たす場合に例外をスローします。</summary>
        <returns>条件を満たす入力シーケンスの 1 つの要素または<see langword="default" />(<paramref name="TSource" />) このような要素が存在しない場合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 参照および null 許容型の既定値は`null`します。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.SingleOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>条件を満たす、配列の唯一の要素を選択します。  
  
 [!code-csharp[System.Linq.Enumerable#85](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#85)]
 [!code-vb[System.Linq.Enumerable#85](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#85)]  
  
 次のコード例では、ことを示します<xref:System.Linq.Enumerable.SingleOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>シーケンスに条件を満たす要素が 1 つだけが含まれていない場合、既定値を返します。  
  
 [!code-csharp[System.Linq.Enumerable#86](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#86)]
 [!code-vb[System.Linq.Enumerable#86](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#86)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="predicate" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Skip&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Skip&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Skip&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Skip``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source"><see cref="T:System.Collections.Generic.IEnumerable`1" />要素を返す。</param>
        <param name="count">残りの要素を返す前にスキップする要素の数。</param>
        <summary>指定された数のシーケンス内の要素をバイパスし、残りの要素を返します。</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerable`1" />入力シーケンスで指定したインデックスの後に出現する要素を格納しています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは遅延実行を使用して実装されます。 即時の戻り値は、操作を実行するために必要なすべての情報を格納するオブジェクトです。 オブジェクトのいずれかを呼び出したが列挙されるまで、このメソッドで表されるクエリが実行されていませんが、`GetEnumerator`メソッド直接、またはを使用して`foreach`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`For Each`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 場合`source`未満`count`要素、空<xref:System.Collections.Generic.IEnumerable%601>が返されます。 場合`count`がゼロのすべての要素に小さい`source`が生成されます。  
  
 <xref:System.Linq.Enumerable.Take%2A>と<xref:System.Linq.Enumerable.Skip%2A>メソッドは、機能を補完します。 シーケンスを指定された`coll`および整数`n`の結果を連結する`coll.Take(n)`と`coll.Skip(n)`と同じシーケンスを生成`coll`です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Skip`の呼び出しに変換される句<xref:System.Linq.Enumerable.Skip%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Skip%2A>を並べ替えられた配列の要素の指定した数をスキップし、残りの要素を返します。  
  
 [!code-csharp[System.Linq.Enumerable#87](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#87)]
 [!code-vb[System.Linq.Enumerable#87](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="SkipLast&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; SkipLast&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; SkipLast&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SkipLast``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="source">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SkipWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; SkipWhile&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; SkipWhile&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SkipWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source"><see cref="T:System.Collections.Generic.IEnumerable`1" />要素を返す。</param>
        <param name="predicate">各要素が条件を満たしているかどうかをテストする関数。</param>
        <summary>指定した条件が true であり、残りの要素を返します限りは、シーケンス内の要素をバイパスします。</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerable`1" />で指定されたテストに合格しなかった線系列の最初の要素を起点として入力シーケンスから要素を含む<paramref name="predicate" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.SkipWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>メソッドは遅延実行を使用して実装します。 即時の戻り値は、操作を実行するために必要なすべての情報を格納するオブジェクトです。 オブジェクトのいずれかを呼び出したが列挙されるまで、このメソッドで表されるクエリが実行されていませんが、`GetEnumerator`メソッド直接、またはを使用して`foreach`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`For Each`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 このメソッドはテストの各要素`source`を使用して`predicate`し、結果がの場合、要素はスキップ`true`です。 述語の関数から制御が戻た後`false`要素、およびその要素の残りの要素の`source`が生成のない複数の呼び出しがあると`predicate`です。  
  
 場合`predicate`返します`true`シーケンス、空のすべての要素の<xref:System.Collections.Generic.IEnumerable%601>が返されます。  
  
 <xref:System.Linq.Enumerable.TakeWhile%2A>と<xref:System.Linq.Enumerable.SkipWhile%2A>メソッドは、機能を補完します。 シーケンスを指定`coll`と関数を純粋な`p`の結果を連結する`coll.TakeWhile(p)`と`coll.SkipWhile(p)`と同じシーケンスを生成`coll`です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Skip While`の呼び出しに変換される句<xref:System.Linq.Enumerable.SkipWhile%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.SkipWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>条件が true の場合に限り、配列の要素をスキップします。  
  
 [!code-csharp[System.Linq.Enumerable#88](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#88)]
 [!code-vb[System.Linq.Enumerable#88](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#88)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="predicate" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="SkipWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; SkipWhile&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; SkipWhile&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SkipWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Int32,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source"><see cref="T:System.Collections.Generic.IEnumerable`1" />要素を返す。</param>
        <param name="predicate">各ソース要素が条件に当てはまるかどうかをテストする関数。この関数の 2 つ目のパラメーターは、ソース要素のインデックスを表します。</param>
        <summary>指定した条件が true であり、残りの要素を返します限りは、シーケンス内の要素をバイパスします。 要素のインデックスは、述語関数のロジックで使用されます。</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerable`1" />で指定されたテストに合格しなかった線系列の最初の要素を起点として入力シーケンスから要素を含む<paramref name="predicate" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは遅延実行を使用して実装されます。 即時の戻り値は、操作を実行するために必要なすべての情報を格納するオブジェクトです。 オブジェクトのいずれかを呼び出したが列挙されるまで、このメソッドで表されるクエリが実行されていませんが、`GetEnumerator`メソッド直接、またはを使用して`foreach`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`For Each`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 <xref:System.Linq.Enumerable.SkipWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%29>メソッドの各要素はテスト`source`を使用して`predicate`し、結果がの場合、要素はスキップ`true`です。 述語の関数から制御が戻た後`false`要素、およびその要素の残りの要素の`source`が生成のない複数の呼び出しがあると`predicate`です。  
  
 場合`predicate`返します`true`シーケンス、空のすべての要素の<xref:System.Collections.Generic.IEnumerable%601>が返されます。  
  
 最初の引数`predicate`をテストする要素を表します。 2 番目の引数内の要素の 0 から始まるインデックスを表す`source`です。  
  
 <xref:System.Linq.Enumerable.TakeWhile%2A>と<xref:System.Linq.Enumerable.SkipWhile%2A>メソッドは、機能を補完します。 シーケンスを指定`coll`と関数を純粋な`p`の結果を連結する`coll.TakeWhile(p)`と`coll.SkipWhile(p)`と同じシーケンスを生成`coll`です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Skip While`の呼び出しに変換される句<xref:System.Linq.Enumerable.SkipWhile%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.SkipWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%29>要素のインデックスに依存している条件が true の場合に限り、配列の要素をスキップします。  
  
 [!code-csharp[System.Linq.Enumerable#89](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#89)]
 [!code-vb[System.Linq.Enumerable#89](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#89)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="predicate" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static decimal Sum (this System.Collections.Generic.IEnumerable&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Sum(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Decimal})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">一連の<see cref="T:System.Decimal" />値の合計を計算します。</param>
        <summary>シーケンスの合計を計算<see cref="T:System.Decimal" />値。</summary>
        <returns>シーケンス内の値の合計です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Decimal%7D%29>場合は 0 を返します`source`要素が含まれていません。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Sum()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Sum%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29>シーケンスの値を合計します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#120)]
 [!code-vb[System.Linq.Enumerable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.OverflowException">合計が <see cref="F:System.Decimal.MaxValue" /> を超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static double Sum (this System.Collections.Generic.IEnumerable&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sum(class System.Collections.Generic.IEnumerable`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Double})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">一連の<see cref="T:System.Double" />値の合計を計算します。</param>
        <summary>シーケンスの合計を計算<see cref="T:System.Double" />値。</summary>
        <returns>シーケンス内の値の合計です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドが戻る場合は 0`source`要素が含まれていません。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Sum()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Sum%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29>シーケンスの値を合計します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#120)]
 [!code-vb[System.Linq.Enumerable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static int Sum (this System.Collections.Generic.IEnumerable&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sum(class System.Collections.Generic.IEnumerable`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Int32})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">一連の<see cref="T:System.Int32" />値の合計を計算します。</param>
        <summary>シーケンスの合計を計算<see cref="T:System.Int32" />値。</summary>
        <returns>シーケンス内の値の合計です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドが戻る場合は 0`source`要素が含まれていません。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Sum()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Sum%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29>シーケンスの値を合計します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#120)]
 [!code-vb[System.Linq.Enumerable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.OverflowException">合計が <see cref="F:System.Int32.MaxValue" /> を超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static long Sum (this System.Collections.Generic.IEnumerable&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Sum(class System.Collections.Generic.IEnumerable`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Int64})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">一連の<see cref="T:System.Int64" />値の合計を計算します。</param>
        <summary>シーケンスの合計を計算<see cref="T:System.Int64" />値。</summary>
        <returns>シーケンス内の値の合計です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドが戻る場合は 0`source`要素が含まれていません。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Sum()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Sum%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29>シーケンスの値を合計します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#120)]
 [!code-vb[System.Linq.Enumerable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.OverflowException">合計が <see cref="F:System.Int64.MaxValue" /> を超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Sum (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Sum(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Null 許容のシーケンス<see cref="T:System.Decimal" />値の合計を計算します。</param>
        <summary>Null 許容のシーケンスの合計を計算<see cref="T:System.Decimal" />値。</summary>
        <returns>シーケンス内の値の合計です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドが戻る場合は 0`source`要素が含まれていません。  
  
 結果はには、値が含まれます`null`です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Sum()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Sum%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29>シーケンスの値を合計します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#121)]
 [!code-vb[System.Linq.Enumerable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.OverflowException">合計が <see cref="F:System.Decimal.MaxValue" /> を超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Sum (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Sum(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Null 許容のシーケンス<see cref="T:System.Double" />値の合計を計算します。</param>
        <summary>Null 許容のシーケンスの合計を計算<see cref="T:System.Double" />値。</summary>
        <returns>シーケンス内の値の合計です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドが戻る場合は 0`source`要素が含まれていません。  
  
 結果が値を含まない`null`です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Sum()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Sum%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29>シーケンスの値を合計します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#121)]
 [!code-vb[System.Linq.Enumerable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Sum (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Sum(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Null 許容のシーケンス<see cref="T:System.Int32" />値の合計を計算します。</param>
        <summary>Null 許容のシーケンスの合計を計算<see cref="T:System.Int32" />値。</summary>
        <returns>シーケンス内の値の合計です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドが戻る場合は 0`source`要素が含まれていません。  
  
 結果が値を含まない`null`です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Sum()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Sum%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29>シーケンスの値を合計します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#121)]
 [!code-vb[System.Linq.Enumerable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.OverflowException">合計が <see cref="F:System.Int32.MaxValue" /> を超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Sum (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Sum(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Null 許容のシーケンス<see cref="T:System.Int64" />値の合計を計算します。</param>
        <summary>Null 許容のシーケンスの合計を計算<see cref="T:System.Int64" />値。</summary>
        <returns>シーケンス内の値の合計です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドが戻る場合は 0`source`要素が含まれていません。  
  
 結果が値を含まない`null`です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Sum()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Sum%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29>シーケンスの値を合計します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#121)]
 [!code-vb[System.Linq.Enumerable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.OverflowException">合計が <see cref="F:System.Int64.MaxValue" /> を超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Sum (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Sum(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Null 許容のシーケンス<see cref="T:System.Single" />値の合計を計算します。</param>
        <summary>Null 許容のシーケンスの合計を計算<see cref="T:System.Single" />値。</summary>
        <returns>シーケンス内の値の合計です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドが戻る場合は 0`source`要素が含まれていません。  
  
 結果が値を含まない`null`です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Sum()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Sum%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29>シーケンスの値を合計します。  
  
 [!code-csharp[System.Linq.Enumerable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#121)]
 [!code-vb[System.Linq.Enumerable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static float Sum (this System.Collections.Generic.IEnumerable&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Sum(class System.Collections.Generic.IEnumerable`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Single})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">一連の<see cref="T:System.Single" />値の合計を計算します。</param>
        <summary>シーケンスの合計を計算<see cref="T:System.Single" />値。</summary>
        <returns>シーケンス内の値の合計です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドが戻る場合は 0`source`要素が含まれていません。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Sum()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Sum%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29>シーケンスの値を合計します。  
  
 [!code-csharp[System.Linq.Enumerable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#120)]
 [!code-vb[System.Linq.Enumerable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,decimal&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Decimal})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Decimal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">合計を計算に使用される値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの合計を計算<see cref="T:System.Decimal" />入力シーケンスの各要素に対して変換関数を呼び出すことによって取得される値。</summary>
        <returns>予測される値の合計。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドが戻る場合は 0`source`要素が含まれていません。  
  
 関数を提供する場合、任意の値のシーケンスにこのメソッドを適用することができます`selector`のメンバーを射影する`source`、数値型に特に<xref:System.Decimal>です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Sum()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Sum%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29>シーケンスの予測される値を合計します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.OverflowException">合計が <see cref="F:System.Decimal.MaxValue" /> を超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,double&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Double&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">合計を計算に使用される値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの合計を計算<see cref="T:System.Double" />入力シーケンスの各要素に対して変換関数を呼び出すことによって取得される値。</summary>
        <returns>予測される値の合計。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドが戻る場合は 0`source`要素が含まれていません。  
  
 関数を提供する場合、任意の値のシーケンスにこのメソッドを適用することができます`selector`のメンバーを射影する`source`、数値型に特に<xref:System.Double>です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Sum()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Sum%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29>シーケンスの予測される値を合計します。  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">合計を計算に使用される値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの合計を計算<see cref="T:System.Int32" />入力シーケンスの各要素に対して変換関数を呼び出すことによって取得される値。</summary>
        <returns>予測される値の合計。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドが戻る場合は 0`source`要素が含まれていません。  
  
 関数を提供する場合、任意の値のシーケンスにこのメソッドを適用することができます`selector`のメンバーを射影する`source`、数値型に特に<xref:System.Int32>です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Sum()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Sum%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29>シーケンスの予測される値を合計します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.OverflowException">合計が <see cref="F:System.Int32.MaxValue" /> を超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,long&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int64})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">合計を計算に使用される値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの合計を計算<see cref="T:System.Int64" />入力シーケンスの各要素に対して変換関数を呼び出すことによって取得される値。</summary>
        <returns>予測される値の合計。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドが戻る場合は 0`source`要素が含まれていません。  
  
 関数を提供する場合、任意の値のシーケンスにこのメソッドを適用することができます`selector`のメンバーを射影する`source`、数値型に特に<xref:System.Int64>です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Sum()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Sum%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29>シーケンスの予測される値を合計します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.OverflowException">合計が <see cref="F:System.Int64.MaxValue" /> を超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">合計を計算に使用される値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>Null 許容のシーケンスの合計を計算<see cref="T:System.Decimal" />入力シーケンスの各要素に対して変換関数を呼び出すことによって取得される値。</summary>
        <returns>予測される値の合計。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドが戻る場合は 0`source`要素が含まれていません。  
  
 結果には、値が含まれていない`null`です。  
  
 関数を提供する場合は、任意の値のシーケンスにこのメソッドを適用できます`selector`のメンバーを射影する`source`、数値型に具体的には`Nullable<Decimal>`(C#) または`Nullable(Of Decimal)`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Sum()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Sum%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29>シーケンスの予測される値を合計します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.OverflowException">合計が <see cref="F:System.Decimal.MaxValue" /> を超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">合計を計算に使用される値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>Null 許容のシーケンスの合計を計算<see cref="T:System.Double" />入力シーケンスの各要素に対して変換関数を呼び出すことによって取得される値。</summary>
        <returns>予測される値の合計。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドが戻る場合は 0`source`要素が含まれていません。  
  
 結果が値を含まない`null`です。  
  
 関数を提供する場合は、任意の値のシーケンスにこのメソッドを適用できます`selector`のメンバーを射影する`source`、数値型に具体的には`Nullable<Double>`(C#) または`Nullable(Of Double)`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Sum()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Sum%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29>シーケンスの予測される値を合計します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">合計を計算に使用される値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>Null 許容のシーケンスの合計を計算<see cref="T:System.Int32" />入力シーケンスの各要素に対して変換関数を呼び出すことによって取得される値。</summary>
        <returns>予測される値の合計。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドが戻る場合は 0`source`要素が含まれていません。  
  
 結果が値を含まない`null`です。  
  
 関数を提供する場合は、任意の値のシーケンスにこのメソッドを適用できます`selector`のメンバーを射影する`source`、数値型に具体的には`Nullable<Int32>`(C#) または`Nullable(Of Int32)`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Sum()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Sum%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29>シーケンスの予測される値を合計します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.OverflowException">合計が <see cref="F:System.Int32.MaxValue" /> を超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">合計を計算に使用される値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>Null 許容のシーケンスの合計を計算<see cref="T:System.Int64" />入力シーケンスの各要素に対して変換関数を呼び出すことによって取得される値。</summary>
        <returns>予測される値の合計。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドが戻る場合は 0`source`要素が含まれていません。  
  
 結果が値を含まない`null`です。  
  
 関数を提供する場合は、任意の値のシーケンスにこのメソッドを適用できます`selector`のメンバーを射影する`source`、数値型に具体的には`Nullable<Int64>`(C#) または`Nullable(Of Int64)`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Sum()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Sum%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29>シーケンスの予測される値を合計します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.OverflowException">合計が <see cref="F:System.Int64.MaxValue" /> を超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">合計を計算に使用される値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>Null 許容のシーケンスの合計を計算<see cref="T:System.Single" />入力シーケンスの各要素に対して変換関数を呼び出すことによって取得される値。</summary>
        <returns>予測される値の合計。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドが戻る場合は 0`source`要素が含まれていません。  
  
 結果が値を含まない`null`です。  
  
 関数を提供する場合は、任意の値のシーケンスにこのメソッドを適用できます`selector`のメンバーを射影する`source`、数値型に具体的には`Nullable<Single>`(C#) または`Nullable(Of Single)`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Sum()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Sum%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29>シーケンスの予測される値を合計します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,float&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Single&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">合計を計算に使用される値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの合計を計算<see cref="T:System.Single" />入力シーケンスの各要素に対して変換関数を呼び出すことによって取得される値。</summary>
        <returns>予測される値の合計。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Single%7D%29>場合は 0 を返します`source`要素が含まれていません。  
  
 関数を提供する場合、任意の値のシーケンスにこのメソッドを適用することができます`selector`のメンバーを射影する`source`、数値型に特に<xref:System.Single>です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into Sum()`の呼び出しに変換される句<xref:System.Linq.Enumerable.Sum%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29>シーケンスの予測される値を合計します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Take&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Take&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Take&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Take``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">要素を返すシーケンス。</param>
        <param name="count">返す要素数。</param>
        <summary>シーケンスの先頭から指定した数の連続する要素を返します。</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerable`1" />指定の数の入力シーケンスの先頭から要素を格納しています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは遅延実行を使用して実装されます。 即時の戻り値は、操作を実行するために必要なすべての情報を格納するオブジェクトです。 オブジェクトのいずれかを呼び出したが列挙されるまで、このメソッドで表されるクエリが実行されていませんが、`GetEnumerator`メソッド直接、またはを使用して`foreach`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`For Each`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 <xref:System.Linq.Enumerable.Take%2A>列挙`source`までの要素を生成し、`count`要素が生成されてまたは`source`ありません以上の要素が含まれています。 場合`count`内の要素の数を超えています`source`のすべての要素`source`が返されます。  
  
 場合`count`が 0 未満`source`列挙かつ空ではありません<xref:System.Collections.Generic.IEnumerable%601>が返されます。  
  
 <xref:System.Linq.Enumerable.Take%2A>と<xref:System.Linq.Enumerable.Skip%2A>メソッドは、機能を補完します。 シーケンスを指定された`coll`および整数`n`の結果を連結する`coll.Take(n)`と`coll.Skip(n)`と同じシーケンスを生成`coll`です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Take`の呼び出しに変換される句<xref:System.Linq.Enumerable.Take%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Take%2A>をシーケンスの先頭から要素を返します。  
  
 [!code-csharp[System.Linq.Enumerable#99](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#99)]
 [!code-vb[System.Linq.Enumerable#99](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#99)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="TakeLast&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; TakeLast&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; TakeLast&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.TakeLast``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="source">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TakeWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; TakeWhile&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; TakeWhile&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.TakeWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">要素を返すシーケンス。</param>
        <param name="predicate">各要素が条件を満たしているかどうかをテストする関数。</param>
        <summary>指定された条件が true の場合に限り、シーケンスから要素を返します。</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerable`1" />テストに合格不要になった要素の前に出現する入力シーケンスから要素を格納しています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは遅延実行を使用して実装されます。 即時の戻り値は、操作を実行するために必要なすべての情報を格納するオブジェクトです。 オブジェクトのいずれかを呼び出したが列挙されるまで、このメソッドで表されるクエリが実行されていませんが、`GetEnumerator`メソッド直接、またはを使用して`foreach`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`For Each`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 <xref:System.Linq.Enumerable.TakeWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>メソッドの各要素はテスト`source`を使用して`predicate`場合は、結果は要素を生成および`true`です。 述語関数が戻るときに、列挙が停止する`false`要素または`source`ありません以上の要素が含まれています。  
  
 <xref:System.Linq.Enumerable.TakeWhile%2A>と<xref:System.Linq.Enumerable.SkipWhile%2A>メソッドは、機能を補完します。 シーケンスを指定`coll`と関数を純粋な`p`の結果を連結する`coll.TakeWhile(p)`と`coll.SkipWhile(p)`と同じシーケンスを生成`coll`です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Take While`の呼び出しに変換される句<xref:System.Linq.Enumerable.TakeWhile%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.TakeWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>条件が true の場合に限り、シーケンスの先頭から要素を返す。  
  
 [!code-csharp[System.Linq.Enumerable#100](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#100)]
 [!code-vb[System.Linq.Enumerable#100](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#100)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="predicate" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="TakeWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; TakeWhile&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; TakeWhile&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.TakeWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Int32,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source">要素を返すシーケンス。</param>
        <param name="predicate">各ソース要素が条件に当てはまるかどうかをテストする関数。この関数の 2 つ目のパラメーターは、ソース要素のインデックスを表します。</param>
        <summary>指定された条件が true の場合に限り、シーケンスから要素を返します。 要素のインデックスは、述語関数のロジックで使用されます。</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerable`1" />テストに合格不要になった要素の前に出現する入力シーケンスから要素を格納しています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは遅延実行を使用して実装されます。 即時の戻り値は、操作を実行するために必要なすべての情報を格納するオブジェクトです。 オブジェクトのいずれかを呼び出したが列挙されるまで、このメソッドで表されるクエリが実行されていませんが、`GetEnumerator`メソッド直接、またはを使用して`foreach`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`For Each`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 <xref:System.Linq.Enumerable.TakeWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%29>メソッドの各要素はテスト`source`を使用して`predicate`場合は、結果は要素を生成および`true`です。 述語関数が戻るときに、列挙が停止する`false`要素または`source`ありません以上の要素が含まれています。  
  
 最初の引数`predicate`をテストする要素を表します。 2 番目の引数内の要素の 0 から始まるインデックスを表す`source`です。  
  
 <xref:System.Linq.Enumerable.TakeWhile%2A>と<xref:System.Linq.Enumerable.SkipWhile%2A>メソッドは、機能を補完します。 シーケンスを指定`coll`と関数を純粋な`p`の結果を連結する`coll.TakeWhile(p)`と`coll.SkipWhile(p)`と同じシーケンスを生成`coll`です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Take While`の呼び出しに変換される句<xref:System.Linq.Enumerable.TakeWhile%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.TakeWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%29>を要素のインデックスを使用する条件が真である限り、シーケンスの先頭から要素を返します。  
  
 [!code-csharp[System.Linq.Enumerable#101](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#101)]
 [!code-vb[System.Linq.Enumerable#101](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#101)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="predicate" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ThenBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; ThenBy&lt;TSource,TKey&gt; (this System.Linq.IOrderedEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; ThenBy&lt;TSource, TKey&gt;(class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ThenBy``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <typeparam name="TKey">によって返されるキーの種類<c>keySelector</c>です。</typeparam>
        <param name="source"><see cref="T:System.Linq.IOrderedEnumerable`1" />を並べ替える要素を格納します。</param>
        <param name="keySelector">各要素からキーを抽出する関数。</param>
        <summary>キーに従って昇順のシーケンス内の要素の後続の並べ替えを実行します。</summary>
        <returns><see cref="T:System.Linq.IOrderedEnumerable`1" />要素がキーに従って並べ替えられています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは遅延実行を使用して実装されます。 即時の戻り値は、操作を実行するために必要なすべての情報を格納するオブジェクトです。 オブジェクトのいずれかを呼び出したが列挙されるまで、このメソッドで表されるクエリが実行されていませんが、`GetEnumerator`メソッド直接、またはを使用して`foreach`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`For Each`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 要素自体の値によって、シーケンスの順序するには、identity 関数を指定 (`x => x`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`Function(x) x`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) の`keySelector`します。  
  
 <xref:System.Linq.Enumerable.ThenBy%2A>および<xref:System.Linq.Enumerable.ThenByDescending%2A>型を拡張する定義<xref:System.Linq.IOrderedEnumerable%601>、またはこれらのメソッドの戻り値の型。 この設計では、任意の数を適用することで複数の並べ替えの条件を指定できます。<xref:System.Linq.Enumerable.ThenBy%2A>または<xref:System.Linq.Enumerable.ThenByDescending%2A>メソッドです。  
  
> [!NOTE]
>  <xref:System.Linq.IOrderedEnumerable%601>から継承<xref:System.Collections.Generic.IEnumerable%601>、呼び出すことができます<xref:System.Linq.Enumerable.OrderBy%2A>または<xref:System.Linq.Enumerable.OrderByDescending%2A>への呼び出しの結果に<xref:System.Linq.Enumerable.OrderBy%2A>、 <xref:System.Linq.Enumerable.OrderByDescending%2A>、<xref:System.Linq.Enumerable.ThenBy%2A>または<xref:System.Linq.Enumerable.ThenByDescending%2A>です。 これを行うには、新しいプライマリの順序、以前に確立された順序を無視するが導入されています。  
  
 このメソッドは、既定の比較子を使用してキーを比較して<xref:System.Collections.Generic.Comparer%601.Default%2A>です。  
  
 このメソッドは、安定した並べ替えを実行します。つまり、2 つの要素のキーが等しい場合は、要素の順序が保持されます。 これに対し、不安定な並べ替えでは、同じキーを持つ要素の順序は保持されません。  
  
 クエリ式の構文では、 `orderby [first criterion], [second criterion]` ([!INCLUDE[csprcs](~/includes/csprcs-md.md)]) または`Order By [first criterion], [second criterion]`([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) の呼び出しに変換される句<xref:System.Linq.Enumerable.ThenBy%2A>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.ThenBy%60%602%28System.Linq.IOrderedEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29>シーケンス内の要素の順序付けセカンダリを実行します。  
  
 [!code-csharp[System.Linq.Enumerable#102](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#102)]
 [!code-vb[System.Linq.Enumerable#102](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#102)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="keySelector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ThenBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; ThenBy&lt;TSource,TKey&gt; (this System.Linq.IOrderedEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; ThenBy&lt;TSource, TKey&gt;(class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ThenBy``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <typeparam name="TKey">によって返されるキーの種類<c>keySelector</c>です。</typeparam>
        <param name="source"><see cref="T:System.Linq.IOrderedEnumerable`1" />を並べ替える要素を格納します。</param>
        <param name="keySelector">各要素からキーを抽出する関数。</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IComparer`1" />キーを比較します。</param>
        <summary>指定された比較子を使用して、昇順のシーケンス内の要素の後続の並べ替えを実行します。</summary>
        <returns><see cref="T:System.Linq.IOrderedEnumerable`1" />要素がキーに従って並べ替えられています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは遅延実行を使用して実装されます。 即時の戻り値は、操作を実行するために必要なすべての情報を格納するオブジェクトです。 オブジェクトのいずれかを呼び出したが列挙されるまで、このメソッドで表されるクエリが実行されていませんが、`GetEnumerator`メソッド直接、またはを使用して`foreach`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`For Each`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 要素自体の値によって、シーケンスの順序するには、identity 関数を指定 (`x => x`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`Function(x) x`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) の`keySelector`します。  
  
 <xref:System.Linq.Enumerable.ThenBy%2A>および<xref:System.Linq.Enumerable.ThenByDescending%2A>型を拡張する定義<xref:System.Linq.IOrderedEnumerable%601>、またはこれらのメソッドの戻り値の型。 この設計では、任意の数を適用することで複数の並べ替えの条件を指定できます。<xref:System.Linq.Enumerable.ThenBy%2A>または<xref:System.Linq.Enumerable.ThenByDescending%2A>メソッドです。  
  
> [!NOTE]
>  <xref:System.Linq.IOrderedEnumerable%601>から継承<xref:System.Collections.Generic.IEnumerable%601>、呼び出すことができます<xref:System.Linq.Enumerable.OrderBy%2A>または<xref:System.Linq.Enumerable.OrderByDescending%2A>への呼び出しの結果に<xref:System.Linq.Enumerable.OrderBy%2A>、 <xref:System.Linq.Enumerable.OrderByDescending%2A>、<xref:System.Linq.Enumerable.ThenBy%2A>または<xref:System.Linq.Enumerable.ThenByDescending%2A>です。 これを行うには、新しいプライマリの順序、以前に確立された順序を無視するが導入されています。  
  
 場合`comparer`は`null`、既定の比較子<xref:System.Collections.Generic.Comparer%601.Default%2A>キーを比較するために使用します。  
  
 このメソッドは、安定した並べ替えを実行します。つまり、2 つの要素のキーが等しい場合は、要素の順序が保持されます。 これに対し、不安定な並べ替えでは、同じキーを持つ要素の順序は保持されません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="keySelector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ThenByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; ThenByDescending&lt;TSource,TKey&gt; (this System.Linq.IOrderedEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; ThenByDescending&lt;TSource, TKey&gt;(class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ThenByDescending``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <typeparam name="TKey">によって返されるキーの種類<c>keySelector</c>です。</typeparam>
        <param name="source"><see cref="T:System.Linq.IOrderedEnumerable`1" />を並べ替える要素を格納します。</param>
        <param name="keySelector">各要素からキーを抽出する関数。</param>
        <summary>キーに従って降順に並べ替え、シーケンス内の要素の後続の並べ替えを実行します。</summary>
        <returns><see cref="T:System.Linq.IOrderedEnumerable`1" />要素がキーに従って降順に並べ替えられています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは遅延実行を使用して実装されます。 即時の戻り値は、操作を実行するために必要なすべての情報を格納するオブジェクトです。 オブジェクトのいずれかを呼び出したが列挙されるまで、このメソッドで表されるクエリが実行されていませんが、`GetEnumerator`メソッド直接、またはを使用して`foreach`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`For Each`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 要素自体の値によって、シーケンスの順序するには、identity 関数を指定 (`x => x`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`Function(x) x`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) の`keySelector`します。  
  
 <xref:System.Linq.Enumerable.ThenBy%2A>および<xref:System.Linq.Enumerable.ThenByDescending%2A>型を拡張する定義<xref:System.Linq.IOrderedEnumerable%601>、またはこれらのメソッドの戻り値の型。 この設計では、任意の数を適用することで複数の並べ替えの条件を指定できます。<xref:System.Linq.Enumerable.ThenBy%2A>または<xref:System.Linq.Enumerable.ThenByDescending%2A>メソッドです。  
  
> [!NOTE]
>  <xref:System.Linq.IOrderedEnumerable%601>から継承<xref:System.Collections.Generic.IEnumerable%601>、呼び出すことができます<xref:System.Linq.Enumerable.OrderBy%2A>または<xref:System.Linq.Enumerable.OrderByDescending%2A>への呼び出しの結果に<xref:System.Linq.Enumerable.OrderBy%2A>、 <xref:System.Linq.Enumerable.OrderByDescending%2A>、<xref:System.Linq.Enumerable.ThenBy%2A>または<xref:System.Linq.Enumerable.ThenByDescending%2A>です。 これを行うには、新しいプライマリの順序、以前に確立された順序を無視するが導入されています。  
  
 この並べ替えメソッドは、既定の比較子を使用してキーを比較して<xref:System.Collections.Generic.Comparer%601.Default%2A>です。  
  
 このメソッドは、安定した並べ替えを実行します。つまり、2 つの要素のキーが等しい場合は、要素の順序が保持されます。 これに対し、不安定な並べ替えでは、同じキーを持つ要素の順序は保持されません。  
  
 [!INCLUDE[csprcs](~/includes/csprcs-md.md)]クエリ式の構文、`orderby [first criterion], [second criterion] descending`の呼び出しに変換される句<xref:System.Linq.Enumerable.ThenByDescending%2A>です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Order By [first criterion], [second criterion] Descending`の呼び出しに変換される句<xref:System.Linq.Enumerable.ThenByDescending%2A>です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="keySelector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ThenByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; ThenByDescending&lt;TSource,TKey&gt; (this System.Linq.IOrderedEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; ThenByDescending&lt;TSource, TKey&gt;(class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ThenByDescending``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <typeparam name="TKey">によって返されるキーの種類<c>keySelector</c>です。</typeparam>
        <param name="source"><see cref="T:System.Linq.IOrderedEnumerable`1" />を並べ替える要素を格納します。</param>
        <param name="keySelector">各要素からキーを抽出する関数。</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IComparer`1" />キーを比較します。</param>
        <summary>指定された比較子を使用して、降順のシーケンス内の要素の後続の並べ替えを実行します。</summary>
        <returns><see cref="T:System.Linq.IOrderedEnumerable`1" />要素がキーに従って降順に並べ替えられています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは遅延実行を使用して実装されます。 即時の戻り値は、操作を実行するために必要なすべての情報を格納するオブジェクトです。 オブジェクトのいずれかを呼び出したが列挙されるまで、このメソッドで表されるクエリが実行されていませんが、`GetEnumerator`メソッド直接、またはを使用して`foreach`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`For Each`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 要素自体の値によって、シーケンスの順序するには、identity 関数を指定 (`x => x`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`Function(x) x`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) の`keySelector`します。  
  
 <xref:System.Linq.Enumerable.ThenBy%2A>および<xref:System.Linq.Enumerable.ThenByDescending%2A>型を拡張する定義<xref:System.Linq.IOrderedEnumerable%601>、またはこれらのメソッドの戻り値の型。 この設計では、任意の数を適用することで複数の並べ替えの条件を指定できます。<xref:System.Linq.Enumerable.ThenBy%2A>または<xref:System.Linq.Enumerable.ThenByDescending%2A>メソッドです。  
  
> [!NOTE]
>  <xref:System.Linq.IOrderedEnumerable%601>から継承<xref:System.Collections.Generic.IEnumerable%601>、呼び出すことができます<xref:System.Linq.Enumerable.OrderBy%2A>または<xref:System.Linq.Enumerable.OrderByDescending%2A>への呼び出しの結果に<xref:System.Linq.Enumerable.OrderBy%2A>、 <xref:System.Linq.Enumerable.OrderByDescending%2A>、<xref:System.Linq.Enumerable.ThenBy%2A>または<xref:System.Linq.Enumerable.ThenByDescending%2A>です。 これを行うには、新しいプライマリの順序、以前に確立された順序を無視するが導入されています。  
  
 場合`comparer`は`null`、既定の比較子<xref:System.Collections.Generic.Comparer%601.Default%2A>キーを比較するために使用します。  
  
 このメソッドは、安定した並べ替えを実行します。つまり、2 つの要素のキーが等しい場合は、要素の順序が保持されます。 これに対し、不安定な並べ替えでは、同じキーを持つ要素の順序は保持されません。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.ThenByDescending%60%602%28System.Linq.IOrderedEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29>を降順にカスタムの比較演算子を使用して、シーケンス内の要素の順序付けセカンダリを実行します。  
  
 [!code-csharp[System.Linq.Enumerable#103](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#103)]
 [!code-vb[System.Linq.Enumerable#103](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#103)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="keySelector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToArray&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource[] ToArray&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource[] ToArray&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToArray``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source"><see cref="T:System.Collections.Generic.IEnumerable`1" />から配列を作成します。</param>
        <summary>配列を作成、<see cref="T:System.Collections.Generic.IEnumerable`1" />です。</summary>
        <returns>入力シーケンスの要素を含む配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.ToArray%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>メソッドが強制的に即時のクエリの評価し、クエリの結果を格納する配列を返します。 このメソッドは、クエリの結果のキャッシュされたコピーを取得するために、クエリに追加できます。  
  
 <xref:System.Linq.Enumerable.ToList%2A>同様の動作を返しますが、<xref:System.Collections.Generic.List%601>配列の代わりにします。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.ToArray%2A>を強制的にクエリの即時評価し、結果の配列を返します。  
  
 [!code-csharp[System.Linq.Enumerable#104](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#104)]
 [!code-vb[System.Linq.Enumerable#104](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#104)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDictionary&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.Dictionary&lt;TKey,TSource&gt; ToDictionary&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.Dictionary`2&lt;!!TKey, !!TSource&gt; ToDictionary&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToDictionary``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <typeparam name="TKey">によって返されるキーの種類<c>keySelector</c>です。</typeparam>
        <param name="source"><see cref="T:System.Collections.Generic.IEnumerable`1" />を作成する、<see cref="T:System.Collections.Generic.Dictionary`2" />からです。</param>
        <param name="keySelector">各要素からキーを抽出する関数。</param>
        <summary>作成、<see cref="T:System.Collections.Generic.Dictionary`2" />から、<see cref="T:System.Collections.Generic.IEnumerable`1" />指定されたキー セレクター関数に従ってします。</summary>
        <returns>A<see cref="T:System.Collections.Generic.Dictionary`2" />キーと値を格納しています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.ToDictionary%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29>メソッドは、既定の等値比較子を使用して<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>キーを比較します。  
  
   
  
## Examples  
 次のコード例は、使用する方法を示します<xref:System.Linq.Enumerable.ToDictionary%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29>を作成する、<xref:System.Collections.Generic.Dictionary%602>されたキー セレクターを使用しています。  
  
 [!code-csharp[System.Linq.Enumerable#105](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#105)]
 [!code-vb[System.Linq.Enumerable#105](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#105)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="keySelector" /> が <see langword="null" /> です。  
  
 または  
  
 <paramref name="keySelector" />キーを生成する<see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keySelector" />生成するには、2 つの要素のキーが重複しています。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDictionary&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.Dictionary&lt;TKey,TSource&gt; ToDictionary&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.Dictionary`2&lt;!!TKey, !!TSource&gt; ToDictionary&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToDictionary``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <typeparam name="TKey">によって返されるキーの種類<c>keySelector</c>です。</typeparam>
        <param name="source"><see cref="T:System.Collections.Generic.IEnumerable`1" />を作成する、<see cref="T:System.Collections.Generic.Dictionary`2" />からです。</param>
        <param name="keySelector">各要素からキーを抽出する関数。</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IEqualityComparer`1" />キーを比較します。</param>
        <summary>作成、<see cref="T:System.Collections.Generic.Dictionary`2" />から、<see cref="T:System.Collections.Generic.IEnumerable`1" />指定されたキー セレクター関数とキーの比較子に従ってします。</summary>
        <returns>A<see cref="T:System.Collections.Generic.Dictionary`2" />キーと値を格納しています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`comparer`は`null`、既定の等値比較子<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>キーを比較するために使用します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="keySelector" /> が <see langword="null" /> です。  
  
 または  
  
 <paramref name="keySelector" />キーを生成する<see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keySelector" />生成するには、2 つの要素のキーが重複しています。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDictionary&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.Dictionary&lt;TKey,TElement&gt; ToDictionary&lt;TSource,TKey,TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.Dictionary`2&lt;!!TKey, !!TElement&gt; ToDictionary&lt;TSource, TKey, TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToDictionary``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <typeparam name="TKey">によって返されるキーの種類<c>keySelector</c>です。</typeparam>
        <typeparam name="TElement">によって返される値の型<c>に対して</c>です。</typeparam>
        <param name="source"><see cref="T:System.Collections.Generic.IEnumerable`1" />を作成する、<see cref="T:System.Collections.Generic.Dictionary`2" />からです。</param>
        <param name="keySelector">各要素からキーを抽出する関数。</param>
        <param name="elementSelector">各要素から結果の要素値を生成する変換関数。</param>
        <summary>作成、<see cref="T:System.Collections.Generic.Dictionary`2" />から、<see cref="T:System.Collections.Generic.IEnumerable`1" />指定されたキー セレクターと要素セレクター関数に従ってします。</summary>
        <returns>A<see cref="T:System.Collections.Generic.Dictionary`2" />型の値を含む<paramref name="TElement" />入力シーケンスから選択します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.ToDictionary%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29>メソッドは、既定の等値比較子を使用して<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>キーを比較します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />、<paramref name="keySelector" />、または <paramref name="elementSelector" /> は、<see langword="null" /> です。  
  
 または  
  
 <paramref name="keySelector" />キーを生成する<see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keySelector" />生成するには、2 つの要素のキーが重複しています。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDictionary&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.Dictionary&lt;TKey,TElement&gt; ToDictionary&lt;TSource,TKey,TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.Dictionary`2&lt;!!TKey, !!TElement&gt; ToDictionary&lt;TSource, TKey, TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToDictionary``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <typeparam name="TKey">によって返されるキーの種類<c>keySelector</c>です。</typeparam>
        <typeparam name="TElement">によって返される値の型<c>に対して</c>です。</typeparam>
        <param name="source"><see cref="T:System.Collections.Generic.IEnumerable`1" />を作成する、<see cref="T:System.Collections.Generic.Dictionary`2" />からです。</param>
        <param name="keySelector">各要素からキーを抽出する関数。</param>
        <param name="elementSelector">各要素から結果の要素値を生成する変換関数。</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IEqualityComparer`1" />キーを比較します。</param>
        <summary>作成、<see cref="T:System.Collections.Generic.Dictionary`2" />から、<see cref="T:System.Collections.Generic.IEnumerable`1" />指定されたキー セレクター関数、比較演算子、および要素セレクター関数に従ってします。</summary>
        <returns>A<see cref="T:System.Collections.Generic.Dictionary`2" />型の値を含む<paramref name="TElement" />入力シーケンスから選択します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`comparer`は`null`、既定の等値比較子<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>キーを比較するために使用します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />、<paramref name="keySelector" />、または <paramref name="elementSelector" /> は、<see langword="null" /> です。  
  
 または  
  
 <paramref name="keySelector" />キーを生成する<see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keySelector" />生成するには、2 つの要素のキーが重複しています。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToHashSet&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.HashSet&lt;TSource&gt; ToHashSet&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.HashSet`1&lt;!!TSource&gt; ToHashSet&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToHashSet``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.HashSet&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="source">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToHashSet&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.HashSet&lt;TSource&gt; ToHashSet&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.HashSet`1&lt;!!TSource&gt; ToHashSet&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToHashSet``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.HashSet&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="source">To be added.</param>
        <param name="comparer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToList&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.List&lt;TSource&gt; ToList&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.List`1&lt;!!TSource&gt; ToList&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToList``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source"><see cref="T:System.Collections.Generic.IEnumerable`1" />を作成する、<see cref="T:System.Collections.Generic.List`1" />からです。</param>
        <summary>作成、<see cref="T:System.Collections.Generic.List`1" />から、<see cref="T:System.Collections.Generic.IEnumerable`1" />です。</summary>
        <returns>A<see cref="T:System.Collections.Generic.List`1" />入力シーケンスから要素を格納します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.ToList%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>メソッドが強制的に即時のクエリの評価を返します、<xref:System.Collections.Generic.List%601>クエリの結果を格納しています。 このメソッドは、クエリの結果のキャッシュされたコピーを取得するために、クエリに追加できます。  
  
 <xref:System.Linq.Enumerable.ToArray%2A>同様の動作の代わりに、配列を返しますが、<xref:System.Collections.Generic.List%601>です。  
  
   
  
## Examples  
 次のコード例は、使用する方法を示します<xref:System.Linq.Enumerable.ToList%2A>を強制的にクエリの即時評価し、返す、<xref:System.Collections.Generic.List%601>クエリの結果を格納しています。  
  
 [!code-csharp[System.Linq.Enumerable#106](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#106)]
 [!code-vb[System.Linq.Enumerable#106](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#106)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToLookup&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ILookup&lt;TKey,TSource&gt; ToLookup&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ILookup`2&lt;!!TKey, !!TSource&gt; ToLookup&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToLookup``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ILookup&lt;TKey,TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <typeparam name="TKey">によって返されるキーの種類<c>keySelector</c>です。</typeparam>
        <param name="source"><see cref="T:System.Collections.Generic.IEnumerable`1" />を作成する、<see cref="T:System.Linq.Lookup`2" />からです。</param>
        <param name="keySelector">各要素からキーを抽出する関数。</param>
        <summary>作成、<see cref="T:System.Linq.Lookup`2" />から、<see cref="T:System.Collections.Generic.IEnumerable`1" />指定されたキー セレクター関数に従ってします。</summary>
        <returns>A<see cref="T:System.Linq.Lookup`2" />キーと値を格納しています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.ToLookup%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29>メソッドを返します、<xref:System.Linq.Lookup%602>値のコレクションにキーをマップする一対多のディクショナリ。 A<xref:System.Linq.Lookup%602>とは異なります、 <xref:System.Collections.Generic.Dictionary%602>、単一の値をキーの一対一のマッピングを実行します。  
  
 既定の等値比較子<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>キーを比較するために使用します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="keySelector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToLookup&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ILookup&lt;TKey,TSource&gt; ToLookup&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ILookup`2&lt;!!TKey, !!TSource&gt; ToLookup&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToLookup``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ILookup&lt;TKey,TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <typeparam name="TKey">によって返されるキーの種類<c>keySelector</c>です。</typeparam>
        <param name="source"><see cref="T:System.Collections.Generic.IEnumerable`1" />を作成する、<see cref="T:System.Linq.Lookup`2" />からです。</param>
        <param name="keySelector">各要素からキーを抽出する関数。</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IEqualityComparer`1" />キーを比較します。</param>
        <summary>作成、<see cref="T:System.Linq.Lookup`2" />から、<see cref="T:System.Collections.Generic.IEnumerable`1" />指定されたキー セレクター関数とキーの比較子に従ってします。</summary>
        <returns>A<see cref="T:System.Linq.Lookup`2" />キーと値を格納しています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.ToLookup%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29>メソッドを返します、<xref:System.Linq.Lookup%602>値のコレクションにキーをマップする一対多のディクショナリ。 A<xref:System.Linq.Lookup%602>異なりますが、 <xref:System.Collections.Generic.Dictionary%602>、単一の値をキーの一対一のマッピングを実行します。  
  
 場合`comparer`は`null`、既定の等値比較子<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>キーを比較するために使用します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="keySelector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToLookup&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ILookup&lt;TKey,TElement&gt; ToLookup&lt;TSource,TKey,TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ILookup`2&lt;!!TKey, !!TElement&gt; ToLookup&lt;TSource, TKey, TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToLookup``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ILookup&lt;TKey,TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <typeparam name="TKey">によって返されるキーの種類<c>keySelector</c>です。</typeparam>
        <typeparam name="TElement">によって返される値の型<c>に対して</c>です。</typeparam>
        <param name="source"><see cref="T:System.Collections.Generic.IEnumerable`1" />を作成する、<see cref="T:System.Linq.Lookup`2" />からです。</param>
        <param name="keySelector">各要素からキーを抽出する関数。</param>
        <param name="elementSelector">各要素から結果の要素値を生成する変換関数。</param>
        <summary>作成、<see cref="T:System.Linq.Lookup`2" />から、<see cref="T:System.Collections.Generic.IEnumerable`1" />指定されたキー セレクターと要素セレクター関数に従ってします。</summary>
        <returns>A<see cref="T:System.Linq.Lookup`2" />型の値を含む<paramref name="TElement" />入力シーケンスから選択します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.ToLookup%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29>メソッドを返します、<xref:System.Linq.Lookup%602>値のコレクションにキーをマップする一対多のディクショナリ。 A<xref:System.Linq.Lookup%602>とは異なります、 <xref:System.Collections.Generic.Dictionary%602>、単一の値をキーの一対一のマッピングを実行します。  
  
 既定の等値比較子<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>キーを比較するために使用します。  
  
   
  
## Examples  
 次のコード例は、使用する方法を示します<xref:System.Linq.Enumerable.ToLookup%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29>を作成する、<xref:System.Linq.Lookup%602>キー セレクター関数と、要素セレクター関数を使用しています。  
  
 [!code-csharp[System.Linq.Enumerable#107](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#107)]
 [!code-vb[System.Linq.Enumerable#107](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#107)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />、<paramref name="keySelector" />、または <paramref name="elementSelector" /> は、<see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToLookup&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ILookup&lt;TKey,TElement&gt; ToLookup&lt;TSource,TKey,TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ILookup`2&lt;!!TKey, !!TElement&gt; ToLookup&lt;TSource, TKey, TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToLookup``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ILookup&lt;TKey,TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <typeparam name="TKey">によって返されるキーの種類<c>keySelector</c>です。</typeparam>
        <typeparam name="TElement">によって返される値の型<c>に対して</c>です。</typeparam>
        <param name="source"><see cref="T:System.Collections.Generic.IEnumerable`1" />を作成する、<see cref="T:System.Linq.Lookup`2" />からです。</param>
        <param name="keySelector">各要素からキーを抽出する関数。</param>
        <param name="elementSelector">各要素から結果の要素値を生成する変換関数。</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IEqualityComparer`1" />キーを比較します。</param>
        <summary>作成、<see cref="T:System.Linq.Lookup`2" />から、<see cref="T:System.Collections.Generic.IEnumerable`1" />指定されたキー セレクター関数、比較演算子と、要素セレクター関数に従ってします。</summary>
        <returns>A<see cref="T:System.Linq.Lookup`2" />型の値を含む<paramref name="TElement" />入力シーケンスから選択します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.ToLookup%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29>メソッドを返します、<xref:System.Linq.Lookup%602>値のコレクションにキーをマップする一対多のディクショナリ。 A<xref:System.Linq.Lookup%602>とは異なります、 <xref:System.Collections.Generic.Dictionary%602>、単一の値をキーの一対一のマッピングを実行します。  
  
 場合`comparer`は`null`、既定の等値比較子<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>キーを比較するために使用します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />、<paramref name="keySelector" />、または <paramref name="elementSelector" /> は、<see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Union&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Union&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Union&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Union``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">入力シーケンスの要素の型。</typeparam>
        <param name="first"><see cref="T:System.Collections.Generic.IEnumerable`1" />共用体の最初のセットを形成する異なる要素を格納します。</param>
        <param name="second"><see cref="T:System.Collections.Generic.IEnumerable`1" />和集合の 2 番目のセットを形成する異なる要素を格納します。</param>
        <summary>既定の等値比較子を使用して 2 つのシーケンスの和集合を生成します。</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerable`1" />重複部分を除く、両方の入力シーケンスから要素を格納します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは遅延実行を使用して実装されます。 即時の戻り値は、操作を実行するために必要なすべての情報を格納するオブジェクトです。 オブジェクトのいずれかを呼び出したが列挙されるまで、このメソッドで表されるクエリが実行されていませんが、`GetEnumerator`メソッド直接、またはを使用して`foreach`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`For Each`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 このメソッドは、返されるセットから重複部分を除外します。 これは、異なる動作を<xref:System.Linq.Enumerable.Concat%2A>メソッドで、重複も含めて、入力シーケンス内のすべての要素を返します。  
  
 既定の等値比較子<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>、実装する型の値を比較するために使用、<xref:System.Collections.Generic.IEqualityComparer%601>ジェネリック インターフェイス。 カスタム データ型を比較する必要がありますをこのインターフェイスを実装し、独自<xref:System.Object.GetHashCode%2A>と<xref:System.Object.Equals%2A>の型のメソッドです。  
  
 このメソッドによって返されるオブジェクトを列挙すると、<xref:System.Linq.Enumerable.Union%2A>列挙`first`と`second`をこの順序で既に生成されていない各要素を生成します。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Union%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29>を整数の 2 つのシーケンスの和集合を取得します。  
  
 [!code-csharp[System.Linq.Enumerable#109](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#109)]
 [!code-vb[System.Linq.Enumerable#109](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#109)]  
  
 カスタム データ型のオブジェクトのシーケンスを比較する場合を実装する必要がある、 <xref:System.Collections.Generic.IEqualityComparer%601> helperclass のジェネリック インターフェイス。 次のコード例は、カスタム データ型でこのインターフェイスを実装して提供する方法を示しています。<xref:System.Object.GetHashCode%2A>と<xref:System.Object.Equals%2A>メソッドです。  
  
 [!code-csharp[CSLINQEncapsulatedComparer#9](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#9)]  
  
 このインターフェイスを実装した後のシーケンスを使用することができます`ProductA`内のオブジェクト、<xref:System.Linq.Enumerable.Union%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29>メソッドを次の例で示すようにします。  
  
 [!code-csharp[CSLINQEncapsulatedComparer#10](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#10)]  
[!code-csharp[CSLINQEncapsulatedComparer#4](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#4)]
[!code-vb[CSLINQEncapsulatedComparer#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> または <paramref name="second" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Union&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Union&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Union&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Union``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">入力シーケンスの要素の型。</typeparam>
        <param name="first"><see cref="T:System.Collections.Generic.IEnumerable`1" />共用体の最初のセットを形成する異なる要素を格納します。</param>
        <param name="second"><see cref="T:System.Collections.Generic.IEnumerable`1" />和集合の 2 番目のセットを形成する異なる要素を格納します。</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IEqualityComparer`1" />値を比較します。</param>
        <summary>指定されたを使用して 2 つのシーケンスの和集合を生成<see cref="T:System.Collections.Generic.IEqualityComparer`1" />です。</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerable`1" />重複部分を除く、両方の入力シーケンスから要素を格納します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは遅延実行を使用して実装されます。 即時の戻り値は、操作を実行するために必要なすべての情報を格納するオブジェクトです。 オブジェクトのいずれかを呼び出したが列挙されるまで、このメソッドで表されるクエリが実行されていませんが、`GetEnumerator`メソッド直接、またはを使用して`foreach`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`For Each`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 C 場合`omparer`は`null`、既定の等値比較子<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>値を比較するために使用します。  
  
 このメソッドによって返されるオブジェクトを列挙すると、<xref:System.Linq.Enumerable.Union%2A>列挙`first`と`second`をこの順序で既に生成されていない各要素を生成します。  
  
 <xref:System.Linq.Enumerable.Concat%2A>メソッドとは異なります、<xref:System.Linq.Enumerable.Union%2A>メソッドのため、<xref:System.Linq.Enumerable.Concat%2A>メソッドは、一方、重複を含む入力シーケンスのすべての要素を返します<xref:System.Linq.Enumerable.Union%2A>一意の値のみを返します。  
  
   
  
## Examples  
 次の例で使用できる等値比較子を実装する方法を示しています、<xref:System.Linq.Enumerable.Union%2A>メソッドです。  
  
 [!code-csharp[CSLINQCustomComparer#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#1)]
 [!code-vb[CSLINQCustomComparer#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#1)]  
  
 この比較演算子を実装すると後のシーケンスを使用することができます`Product`内のオブジェクト、<xref:System.Linq.Enumerable.Union%2A>メソッドを次の例で示すようにします。  
  
 [!code-csharp[CSLINQCustomComparer#2](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#2)]
 [!code-vb[CSLINQCustomComparer#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#2)]  
[!code-csharp[CSLINQCustomComparer#4](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#4)]
[!code-vb[CSLINQCustomComparer#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> または <paramref name="second" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Where&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Where&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Where&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source"><see cref="T:System.Collections.Generic.IEnumerable`1" />をフィルター処理します。</param>
        <param name="predicate">各要素が条件を満たしているかどうかをテストする関数。</param>
        <summary>述語に基づいて値のシーケンスをフィルター処理します。</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerable`1" />条件を満たす入力シーケンスから要素を格納します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは遅延実行を使用して実装されます。 即時の戻り値は、操作を実行するために必要なすべての情報を格納するオブジェクトです。 オブジェクトのいずれかを呼び出したが列挙されるまで、このメソッドで表されるクエリが実行されていませんが、`GetEnumerator`メソッド直接、またはを使用して`foreach`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`For Each`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 クエリ式の構文では、 `where` ([!INCLUDE[csprcs](~/includes/csprcs-md.md)]) または`Where`([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) の呼び出しに変換される句<xref:System.Linq.Enumerable.Where%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Where%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>シーケンスをフィルター処理します。  
  
 [!code-csharp[System.Linq.Enumerable#110](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#110)]
 [!code-vb[System.Linq.Enumerable#110](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#110)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="predicate" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Where&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Where&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Where&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Int32,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型<c>ソース</c>です。</typeparam>
        <param name="source"><see cref="T:System.Collections.Generic.IEnumerable`1" />をフィルター処理します。</param>
        <param name="predicate">各ソース要素が条件に当てはまるかどうかをテストする関数。この関数の 2 つ目のパラメーターは、ソース要素のインデックスを表します。</param>
        <summary>述語に基づいて値のシーケンスをフィルター処理します。 各要素のインデックスは、述語関数のロジックで使用されます。</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerable`1" />条件を満たす入力シーケンスから要素を格納します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは遅延実行を使用して実装されます。 即時の戻り値は、操作を実行するために必要なすべての情報を格納するオブジェクトです。 オブジェクトのいずれかを呼び出したが列挙されるまで、このメソッドで表されるクエリが実行されていませんが、`GetEnumerator`メソッド直接、またはを使用して`foreach`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`For Each`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 最初の引数`predicate`をテストする要素を表します。 2 番目の引数内の要素の 0 から始まるインデックスを表す`source`です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Where%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%29>を各要素のインデックスを含む述語に基づいて、シーケンスをフィルター処理します。  
  
 [!code-csharp[System.Linq.Enumerable#111](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#111)]
 [!code-vb[System.Linq.Enumerable#111](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#111)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="predicate" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Zip&lt;TFirst,TSecond,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Zip&lt;TFirst,TSecond,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TFirst&gt; first, System.Collections.Generic.IEnumerable&lt;TSecond&gt; second, Func&lt;TFirst,TSecond,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Zip&lt;TFirst, TSecond, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TFirst&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSecond&gt; second, class System.Func`3&lt;!!TFirst, !!TSecond, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFirst" />
        <TypeParameter Name="TSecond" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TFirst&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSecond&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TFirst,TSecond,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TFirst">最初の入力シーケンスの要素の型。</typeparam>
        <typeparam name="TSecond">2 番目の入力シーケンスの要素の型。</typeparam>
        <typeparam name="TResult">結果のシーケンスの要素の型。</typeparam>
        <param name="first">マージする最初のシーケンス。</param>
        <param name="second">マージする 2 番目のシーケンス。</param>
        <param name="resultSelector">2 つのシーケンスから要素をマージする方法を指定する関数。</param>
        <summary>結果のシーケンスを生成する、2 つのシーケンスの対応する要素に指定された関数を適用します。</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerable`1" /> 2 つの入力シーケンスのマージされた要素を格納します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは遅延実行を使用して実装されます。 即時の戻り値は、操作を実行するために必要なすべての情報を格納するオブジェクトです。 オブジェクトのいずれかを呼び出したが列挙されるまで、このメソッドで表されるクエリが実行されていませんが、`GetEnumerator`メソッド直接、またはを使用して`foreach`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`For Each`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 メソッドは、最初のシーケンスの各要素を 2 番目のシーケンスで、同じインデックスを持つ要素とをマージします。 シーケンスには、同じ数の要素がないと、シーケンスは、それらのいずれかの末尾に達するまでに、メソッドによりマージします。 たとえば、1 つのシーケンスに 3 つの要素があり、ユーザーが 4 つが、もう 1 つは、結果のシーケンスがのみの 3 つの要素。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています、 <xref:System.Linq.Enumerable.Zip%2A> 2 つのシーケンスにマージするメソッド。  
  
 [!code-csharp[System.Linq.Enumerable#200](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#200)]
 [!code-vb[System.Linq.Enumerable#200](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#200)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> または <paramref name="second" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
  </Members>
</Type>
