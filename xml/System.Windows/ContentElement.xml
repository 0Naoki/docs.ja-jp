<Type Name="ContentElement" FullName="System.Windows.ContentElement">
  <TypeSignature Language="C#" Value="public class ContentElement : System.Windows.DependencyObject, System.Windows.IInputElement, System.Windows.Media.Animation.IAnimatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ContentElement extends System.Windows.DependencyObject implements class System.Windows.IInputElement, class System.Windows.Media.Animation.IAnimatable" />
  <TypeSignature Language="DocId" Value="T:System.Windows.ContentElement" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.IInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Media.Animation.IAnimatable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>コンテンツ要素に WPF コア レベルの基底クラスを提供します。 コンテンツ要素は、直感的なマークアップ指向レイアウト モデルと、意図的に単純なオブジェクト モデルを使用し、フロー スタイル プレゼンテーション用に設計されています。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement>次の一般的なコンテンツの特性を定義します。  
  
-   入力: すべて<xref:System.Windows.ContentElement>派生クラスは、キーボード、マウスをドラッグ アンド ドロップの操作、スタイラス コントロール、およびアクセラレータから基本的な入力のキャプチャのサポートを提供します。  
  
-   フォーカス: すべて<xref:System.Windows.ContentElement>派生クラスでは、フォーカスを設定できる可能性があります。 (ただしの既定のフォーカス可能な状態、<xref:System.Windows.ContentElement>基底クラスが`false`です。 作成する方法の詳細について、<xref:System.Windows.ContentElement>フォーカスを設定するを参照してください<xref:System.Windows.ContentElement.Focusable%2A>)。さらに、このクラスが含まれています[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]関連要素の間でフォーカスを移動するを使用することできます。  
  
-   イベント:<xref:System.Windows.ContentElement>イベントも含まれる入力とフォーカスに関連する以外の状態の変更のイベントも含まれています。 多くの場合、<xref:System.Windows.ContentElement>イベントは、ルーティングされたイベント。 場合によっては、ルーティングされたイベントはトンネリングとバブルの両方のルーティング方法、同じ状態または条件への応答で別々 のイベントとして発生があります。 また、<xref:System.Windows.ContentElement>定義[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]できます raise ルーティングされるイベントを追加したり、イベント ハンドラーを削除します。  
  
 <xref:System.Windows.ContentElement>多くの共通の共有[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]で<xref:System.Windows.UIElement>です。 これらの一般的な[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]共有クラスの継承を付属していません。 しかし一般的な名前付け、同様の動作と同様の内部実装の[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]クラスごとにします。 類似性があるため<xref:System.Windows.ContentElement>と<xref:System.Windows.UIElement>基本、要素である各クラスは、そのマークアップ オブジェクト モデルの動作にさまざまな意図を持つ各がします。  
  
 具体的には、<xref:System.Windows.UIElement>から下降<xref:System.Windows.Media.Visual>、下位のグラフィックのレンダリングのサポートを提供する、<xref:System.Windows.ContentElement>合成のウィンドウ内の四角形の領域に一方<xref:System.Windows.ContentElement>フロー、折り返しが設定など、ドキュメントのシナリオに一般的な概念がより簡単にサポートされているように、レンダリングを延期します。 これらの 2 つの関連クラスに共通のインターフェイスも実装<xref:System.Windows.IInputElement>と<xref:System.Windows.Media.Animation.IAnimatable>です。  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para><see cref="T:System.Windows.ContentElement" />クラスがまだフロー スタイル プレゼンテーションの完全なコンテンツ要素のすべての側面を定義します。 <see cref="T:System.Windows.FrameworkContentElement" />直後に派生クラスである<see cref="T:System.Windows.ContentElement" />です。 <see cref="T:System.Windows.FrameworkContentElement" />レンダリングをサポートするその他のメンバーのより完全なセットが含まれています、<see cref="T:System.Windows.FrameworkContentElement" />コンテンツ ホストと WPF フレームワーク レベルのレイアウト システムを使用します。</para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ContentElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Windows.ContentElement" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddHandler">
      <MemberSignature Language="C#" Value="public void AddHandler (System.Windows.RoutedEvent routedEvent, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="routedEvent">処理されるルーティング イベントの識別子。</param>
        <param name="handler">ハンドラーの実装に対する参照。</param>
        <summary>指定したルーティング イベントのルーティング イベント ハンドラーを追加します。このハンドラーは、現在の要素のハンドラー コレクションに追加されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 例外を発生させず、同じイベントのハンドラーは、同じ複数回を追加することができます。 ただし、ハンドラーには、イベントを処理するときに複数回が実際に呼び出されます。 そのため、この動作では次の方法で、ハンドラーの実装で考慮するべき副作用がある可能性がありますを検討してください。  
  
 通常、"add"アクセサーの実装を提供するこのメソッドを使用する、[!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)]カスタム ルーティング イベントのイベントのアクセス パターン。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddHandler">
      <MemberSignature Language="C#" Value="public void AddHandler (System.Windows.RoutedEvent routedEvent, Delegate handler, bool handledEventsToo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler, bool handledEventsToo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
        <Parameter Name="handledEventsToo" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="routedEvent">ハンドルするルーティング イベントの識別子。</param>
        <param name="handler">ハンドラーの実装に対する参照。</param>
        <param name="handledEventsToo">
          <see langword="true" />そのイベント データで処理されるルーティング イベントがマークされている場合でも呼び出されるようにハンドラーを登録するには<see langword="false" />ことがない既定の条件に、ハンドラーを登録するルーティング イベントは既に設定されて処理される場合に呼び出されます。  
  
 既定値は、<see langword="false" /> です。  
  
 ルーティング イベントの再処理を機械的に要求しないでください。</param>
        <summary>指定したルーティング イベントのルーティング イベント ハンドラーを追加します。このハンドラーは、現在の要素のハンドラー コレクションに追加されます。 指定<paramref name="handledEventsToo" />として<see langword="true" />イベント ルート上の別の要素によって処理されるように既にマークされているルーティング イベントのために呼び出される、指定したハンドラーがします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 複雑なタスクは、実用的な方法で低レベルの入力イベントを処理します。 多くのコントロールと、特定のイベントが処理される、マークされた、別のより直観的なイベントに置き換えの動作を実装します。 一般に、これを行うための設計上の意図がある場合を処理済みとして、コントロールは、プラットフォームの入力イベントをマークだけです。 特定のシナリオでこれらの設計上の意図できない可能性があります、特定の入力イベントの処理が必要です。 これらのシナリオを登録するハンドラーの`handledEventsToo`として`true`が適切です。 実行しないでこの日常的にします。 処理される場合でも、すべてのイベントに応答ハンドラーを呼び出すと、独自のアプリケーション イベントを処理ロジックが複雑になります。 ハンドラーのロジックは大きな場合は、パフォーマンスの低下を参照してください可能性があります。 ここで、検出済みの特定のコントロールは、アプリケーション ロジックで処理するイベントを処理は、開発プロセス中にある場合の処理済みのイベントのハンドラーをアタッチの使用を予約する必要があります。  
  
 クラスの処理を特定のイベントとコントロールの組み合わせの動作を回避するためのもう 1 つの方法では、そのイベントのプレビューの代替手段を使用します。 たとえば場合、<xref:System.Windows.ContentElement.MouseLeftButtonDown>処理済みとしてマークは、クラス処理によってことができますのハンドラーを追加する<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>代わりにします。  
  
 例外を発生させず、同じイベントのハンドラーは、同じ複数回を追加することができます。 ただし、ハンドラーには、イベントを処理するときに複数回が実際に呼び出されます。 そのため、この動作では次の方法で、ハンドラーの実装で考慮するべき副作用がある可能性がありますを検討してください。  
  
 通常、"add"アクセサーの実装を提供するこのメソッドを使用する、[!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)]カスタム ルーティング イベントのイベントのアクセス パターン。  
  
   
  
## Examples  
 次の例で呼び出されるハンドラーを実装する、<xref:System.Windows.FrameworkElement.Initialized>イベントを使用して、ページ上の名前付きの要素のいずれかに定義されているハンドラーをアタッチするページに`handledEventsToo``true`です。 このハンドラー経路上の別の要素が共有イベント データ、ルート上で処理中の要素に到達する前に処理済みとしてマークされている場合でも呼び出されます。  
  
 [!code-csharp[EventOvwSupport#AddHandlerHandledToo](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/page2.xaml.cs#addhandlerhandledtoo)]
 [!code-vb[EventOvwSupport#AddHandlerHandledToo](~/samples/snippets/visualbasic/VS_Snippets_Wpf/EventOvwSupport/visualbasic/page2.xaml.vb#addhandlerhandledtoo)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddToEventRoute">
      <MemberSignature Language="C#" Value="public void AddToEventRoute (System.Windows.EventRoute route, System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddToEventRoute(class System.Windows.EventRoute route, class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.AddToEventRoute(System.Windows.EventRoute,System.Windows.RoutedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="route" Type="System.Windows.EventRoute" />
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="route">イベント ルート ハンドラーに追加されます。</param>
        <param name="e">イベントのデータ ハンドラーを追加するために使用します。 このメソッドを使用して、<see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />ハンドラーを作成する引数のプロパティです。</param>
        <summary>指定したハンドラーを追加する<see cref="T:System.Windows.EventRoute" />現在の<see cref="T:System.Windows.ContentElement" />イベント ハンドラーのコレクション。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コンテンツ ホスト要素に対してこのメソッドを使用 (実装しているかどうかに関係なく<xref:System.Windows.IContentHost>) をホストに、コンテンツ ホストの子要素のハンドラーを追加するために<xref:System.Windows.EventRoute>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowDrop">
      <MemberSignature Language="C#" Value="public bool AllowDrop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowDrop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AllowDrop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素をドラッグ アンド ドロップ操作の対象として使用できるかどうかを示す値を取得または設定します。</summary>
        <value>
          この要素をドラッグアンドドロップ操作の対象として使用できる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は <see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ドラッグ アンド ドロップ操作が既定では、有効になっていないと設定して意図的に有効にする必要があります<xref:System.Windows.ContentElement.AllowDrop%2A>に`true`です。 この基本的な設定を超えるドラッグ アンド ドロップの動作は完全に特定の実装とで定義されていない<xref:System.Windows.ContentElement>またはその他の要素の基本クラスです。 たとえば、特定のコントロール<xref:System.Windows.Controls.RichTextBox>は、既定の動作はありませんが<xref:System.Windows.ContentElement>派生クラスがあるこのような動作です。 ドラッグ アンド ドロップの詳細については、次を参照してください。[ドラッグ アンド ドロップの概要](~/docs/framework/wpf/advanced/drag-and-drop-overview.md)です。  
  
 <xref:System.Windows.FrameworkContentElement>実装では、この依存関係プロパティのメタデータをオーバーライドします。 具体的には、<xref:System.Windows.FrameworkContentElement>このプロパティがプロパティ値の継承を使用することを指定 (<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>は`true`メタデータで)。 このコンテキストでプロパティ値の継承ことを意味のない他の値を含む子要素がある場合<xref:System.Windows.ContentElement.AllowDrop%2A>プロパティ システムによってすべての未使用の子要素をその親要素から値が割り当てられているし、ローカルの値またはスタイル、この値は割り当てられます (ここでものいずれか既定値、またはローカルの値、スタイル)、最も近い親要素の値を使用して割り当てます。 つまり、ルート要素でドロップ操作を許可して、すべてに値を反映するかどうかを指定できる<xref:System.Windows.FrameworkContentElement>が具体的には割り当てられていない値の子要素`false`です。  
  
<a name="dependencyPropertyInfo_AllowDrop"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.AllowDropProperty>|  
|メタデータ プロパティに設定します。`true`|なし|  
  
   
  
## Examples  
 次の例のセット<xref:System.Windows.ContentElement.AllowDrop%2A>で[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]です。  
  
 [!code-xaml[ContentElementsSmorgasbord#AllowDrop](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#allowdrop)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowDropProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AllowDropProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AllowDropProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AllowDropProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.ContentElement.AllowDrop" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyAnimationClock">
      <MemberSignature Language="C#" Value="public void ApplyAnimationClock (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationClock clock);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyAnimationClock(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationClock clock) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="clock" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="dp">アニメーション化するプロパティの識別子。</param>
        <param name="clock">アニメーションをコントロールして宣言するアニメーション クロック。</param>
        <summary>この要素の指定した依存関係プロパティにアニメーションを適用します。 既存のアニメーションは停止され、新しいアニメーションに置き換えられます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アニメーションのプロパティからを削除するには、そのプロパティの識別子を指定`dp`指定と`clock`として`null`です。 これは、アニメーションを切り取ってアニメーションのプロパティがその基本値に設定します。 ただし、最初に関連付けられているアニメーション クロックは停止されません。 その他のクロックに割り当てられているアニメーションを実行し続けます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyAnimationClock">
      <MemberSignature Language="C#" Value="public void ApplyAnimationClock (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationClock clock, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyAnimationClock(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationClock clock, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="clock" Type="System.Windows.Media.Animation.AnimationClock" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="dp">アニメーション化するプロパティ。</param>
        <param name="clock">アニメーションをコントロールして宣言するアニメーション クロック。</param>
        <param name="handoffBehavior">列挙体の値。 既定値は<see cref="F:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace" />、する既存のアニメーションを停止し、新しいものに置き換えます。</param>
        <summary>この要素で指定した依存関係プロパティをアニメーションを適用、対処方法を指定することはどうプロパティは既に実行中のアニメーション。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アニメーションのプロパティからを削除するには、そのプロパティの識別子を指定`dp`指定と`clock`として`null`です。 これは、アニメーションを切り取ってアニメーションのプロパティがその基本値に設定します。 ただし、最初に関連付けられているアニメーション クロックは停止されません。 その他のクロックに割り当てられているアニメーションを実行し続けます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCaptured">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AreAnyTouchesCaptured" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素に、少なくとも 1 つのタッチがキャプチャされるかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" />タッチを少なくとも 1 つがキャプチャされます。 この要素にそれ以外の場合、<see langword="false" />です。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AreAnyTouchesCapturedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.ContentElement.AreAnyTouchesCaptured" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedWithin">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesCapturedWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesCapturedWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AreAnyTouchesCapturedWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素またはそのビジュアル ツリー内のすべての子要素には、少なくとも 1 つのタッチがキャプチャされるかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" />少なくとも 1 つにタッチがキャプチャをこの要素またはそのビジュアル ツリー内のすべての子要素それ以外の場合、<see langword="false" />です。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesCapturedWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesCapturedWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AreAnyTouchesCapturedWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.ContentElement.AreAnyTouchesCapturedWithin" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesDirectlyOver">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AreAnyTouchesDirectlyOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上には、少なくとも 1 つのタッチが押されたかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" />この要素上には、少なくとも 1 つのタッチが押された場合それ以外の場合、<see langword="false" />です。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AreAnyTouchesDirectlyOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.ContentElement.AreAnyTouchesDirectlyOver" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesOver">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AreAnyTouchesOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素またはそのビジュアル ツリー内のすべての子要素の上には、少なくとも 1 つのタッチが押されたかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" />この要素またはそのビジュアル ツリー内のすべての子要素の上には、少なくとも 1 つのタッチが押された場合それ以外の場合、<see langword="false" />です。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AreAnyTouchesOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.ContentElement.AreAnyTouchesOver" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginAnimation">
      <MemberSignature Language="C#" Value="public void BeginAnimation (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationTimeline animation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginAnimation(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationTimeline animation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="animation" Type="System.Windows.Media.Animation.AnimationTimeline" />
      </Parameters>
      <Docs>
        <param name="dp">依存関係プロパティの識別子として指定する、アニメーション化するプロパティです。</param>
        <param name="animation">開始するアニメーションのタイムラインになります。</param>
        <summary>この要素で指定したプロパティのアニメーションを開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティをアニメーション化するかどうかをチェックするとしているアニメーションが開始されますと見なされるアニメーションをアニメーション化されていないの開始位置を超える最初のフレームがレンダリングされます。  
  
 場合、<xref:System.Windows.Media.Animation.Timeline.BeginTime%2A>の`animation`は`null`してから、現在のアニメーションは削除し、プロパティの現在の値が保持されています。  
  
 場合全体`animation`値は`null`、すべてのアニメーションがプロパティから削除され、プロパティ値がその基本値に戻ります。 ただし、最初に関連付けられているアニメーション タイムラインは停止されません。 タイムラインに割り当てられているその他のアニメーションを実行し続けます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginAnimation">
      <MemberSignature Language="C#" Value="public void BeginAnimation (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationTimeline animation, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginAnimation(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationTimeline animation, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="animation" Type="System.Windows.Media.Animation.AnimationTimeline" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="dp">依存関係プロパティの識別子として指定する、アニメーション化するプロパティです。</param>
        <param name="animation">適用されるアニメーションのタイムラインになります。</param>
        <param name="handoffBehavior">新しいアニメーションがプロパティの値が既に影響を受けている現在の (実行中) アニメーションとやり取りする方法を指定する列挙体の値です。</param>
        <summary>新機能を指定するオプションを使用して、この要素で指定したアニメーション化されたプロパティの特定のアニメーションの場合は、プロパティは既に実行中のアニメーションを開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティをアニメーション化するかどうかをチェックするとしているアニメーションが開始されますと見なされるアニメーションをアニメーション化されていないの開始位置を超える最初のフレームがレンダリングされます。  
  
 場合、<xref:System.Windows.Media.Animation.Timeline.BeginTime%2A>の`animation`は`null`してから、現在のアニメーションは削除し、プロパティの現在の値が保持されています。  
  
 場合全体`animation`値は`null`、すべてのアニメーションがプロパティから削除され、プロパティ値がその基本値に戻ります。 ただし、最初に関連付けられているアニメーション タイムラインは停止されません。 タイムラインに割り当てられているその他のアニメーションを実行し続けます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaptureMouse">
      <MemberSignature Language="C#" Value="public bool CaptureMouse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CaptureMouse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.CaptureMouse" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この要素にマウスのキャプチャを強制しようとしています。</summary>
        <returns>
          <see langword="true" />マウスが正常にキャプチャされた場合それ以外の場合、<see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キャプチャするのには、要素を有効にする必要があります。 確認するかどうか<xref:System.Windows.ContentElement.IsEnabled%2A>は`true`を呼び出す前に<xref:System.Windows.ContentElement.CaptureMouse%2A>です。  
  
 呼び出す場合<xref:System.Windows.ContentElement.CaptureMouse%2A>返します`true`、し<xref:System.Windows.ContentElement.IsMouseCaptured%2A>も`true`します。  
  
 呼び出す場合<xref:System.Windows.ContentElement.CaptureMouse%2A>を返します`true`、<xref:System.Windows.ContentElement.GotMouseCapture>と<xref:System.Windows.ContentElement.IsMouseCapturedChanged>イベントが発生すると<xref:System.Windows.RoutedEventArgs.Source%2A?displayProperty=nameWithType>要素としてデータを報告するイベントの場所、<xref:System.Windows.ContentElement.CaptureMouse%2A>メソッドが呼び出されます。 既存のキャプチャと干渉する可能性のキャプチャを強制した場合、特にのマウスでドラッグ アンド ドロップに関連するキャプチャします。  
  
 すべての要素からマウスのキャプチャをクリアする呼び出し<xref:System.Windows.Input.Mouse.Capture%2A?displayProperty=nameWithType>で、`element`として指定されたパラメーター`null`です。  
  
   
  
## Examples  
 次の例では、マウスをキャプチャまたは、マウスが要素によって既にキャプチャされているかどうかに基づいて、キャプチャを解放します。 見込みのキャプチャ対象の要素がこの例ではキャストことに注意してください、<xref:System.Windows.IInputElement>インターフェイス、および最初に呼び出したはこのため、<xref:System.Windows.IInputElement.CaptureMouse%2A?displayProperty=nameWithType>メソッドです。 キャストする<xref:System.Windows.IInputElement>手法がないことを確認するかどうか、要素をキャプチャする、マウス場合に便利ですが、<xref:System.Windows.UIElement>または<xref:System.Windows.ContentElement>です。 インターフェイスにキャストして、インターフェイス メソッド実装を呼び出すし、呼び出し、適切な型固有ことで内部的には、試用版のいずれかにキャストせず<xref:System.Windows.UIElement>または<xref:System.Windows.ContentElement>です。 これと同じキャスト方法が他のメンバーの動作を<xref:System.Windows.IInputElement>のインスタンスを多数定義、入力に関連するイベント、およびその他の入力に関連するメソッド。  
  
 [!code-csharp[ContentElementsSmorgasbord#IsMouseCaptured](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#ismousecaptured)]
 [!code-vb[ContentElementsSmorgasbord#IsMouseCaptured](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#ismousecaptured)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaptureStylus">
      <MemberSignature Language="C#" Value="public bool CaptureStylus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CaptureStylus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.CaptureStylus" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この要素にスタイラスのキャプチャを強制しようとしています。</summary>
        <returns>
          <see langword="true" />スタイラスが正常にキャプチャされた場合それ以外の場合、<see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定の実装を常に基になる既定のスタイラス デバイスに基づいて`true`です。 ただし、入力のシステムのデバイスの実装を提供する入力デバイスを拡張する場合は、異なる結果を返す可能性のある代替のスタイラス デバイスの実装と、システムを作成することです。  
  
 要素がスタイラスをキャプチャ、ときに、スタイラスが境界外にある場合でも、スタイラス入力を受け取ります。 スタイラスは通常、ドラッグ アンド ドロップ操作中にのみキャプチャされます。  
  
 このメソッドを呼び出す、基になる静的<xref:System.Windows.Input.Stylus>メソッド<xref:System.Windows.Input.Stylus.Capture%2A>です。 実際のキャプチャの動作は、アクティブなスタイラス デバイスの実装によって実装されます。  
  
 キャプチャするのには、要素を有効にする必要があります。 確認するかどうか<xref:System.Windows.ContentElement.IsEnabled%2A>は`true`を呼び出す前に返す<xref:System.Windows.ContentElement.CaptureStylus%2A>です。  
  
 呼び出す場合<xref:System.Windows.ContentElement.CaptureStylus%2A>返します`true`、<xref:System.Windows.ContentElement.IsStylusCaptured%2A>も`true`します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaptureTouch">
      <MemberSignature Language="C#" Value="public bool CaptureTouch (System.Windows.Input.TouchDevice touchDevice);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CaptureTouch(class System.Windows.Input.TouchDevice touchDevice) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.CaptureTouch(System.Windows.Input.TouchDevice)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="touchDevice" Type="System.Windows.Input.TouchDevice" />
      </Parameters>
      <Docs>
        <param name="touchDevice">キャプチャするデバイスです。</param>
        <summary>この要素に強制的にタッチをキャプチャしようとしています。</summary>
        <returns>
          <see langword="true" />この要素に指定したタッチがキャプチャされる場合それ以外の場合、<see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.CaptureTouch%2A>返されます`false`場合、<xref:System.Windows.Input.TouchDevice>別の要素に現在キャプチャされています。  
  
 場合<xref:System.Windows.ContentElement.CaptureTouch%2A>返します`true`、<xref:System.Windows.ContentElement.GotTouchCapture>イベントが発生します。  
  
 解放するにはこの要素から 1 つのタッチのキャプチャを使用して、<xref:System.Windows.ContentElement.ReleaseTouchCapture%2A>メソッドを解放する、タッチ デバイスを指定します。 解放するにはこの要素からすべての調整を使用して、<xref:System.Windows.ContentElement.ReleaseAllTouchCaptures%2A>メソッドです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="touchDevice" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="CommandBindings">
      <MemberSignature Language="C#" Value="public System.Windows.Input.CommandBindingCollection CommandBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.CommandBindingCollection CommandBindings" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.CommandBindings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.CommandBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コレクションを取得<see cref="T:System.Windows.Input.CommandBinding" />この要素に関連付けられているオブジェクト。</summary>
        <value>すべてのコレクション<see cref="T:System.Windows.Input.CommandBinding" />オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Windows.Input.CommandBinding>この要素の特定のコマンドのコマンドの処理を有効にし、コマンド、そのイベントでは、この要素にアタッチされているハンドラー間のリンケージが宣言されます。  
  
 別の一般的な方法を設定する、<xref:System.Windows.ContentElement.CommandBindings%2A>コレクションは、使用する<xref:System.Windows.Input.CommandManager>メソッド プログラムでします。  
  
<a name="xamlPropertyElementUsage_CommandBindings"></a>   
## <a name="xaml-property-element-usage"></a>XAML プロパティ要素の使用  
  
```  
<object>  
  <object.CommandBindings>  
    oneOrMoreCommandBindings  </object.CommandBindings>  
</object>  
```  
  
<a name="xamlValues_CommandBindings"></a>   
## <a name="xaml-values"></a>XAML 値  
 *oneOrMoreCommandBindings*  
 1 つまたは複数<xref:System.Windows.Input.CommandBinding>要素。 これらの各が必要、<xref:System.Windows.Input.CommandBinding.Command%2A>既知のコマンドに属性が設定され、に対して属性が設定、<xref:System.Windows.Input.CommandBinding.CanExecute>と<xref:System.Windows.Input.CommandBinding.Executed>ハンドラーの実装です。 詳細については、「<xref:System.Windows.Input.CommandBinding>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.DragEnter" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素をドラッグ先とする、基になるドラッグ イベントが入力システムによって報告されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.DragEnter?displayProperty=nameWithType>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.DragEnter>イベントが、基になるに関連付けられている<xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_DragEnter"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.DragEnterEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.DragEventHandler>|  
  
-   対応するトンネリング イベントが<xref:System.Windows.ContentElement.PreviewDragEnter>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnDragEnter%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.DragEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.DragEnter" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.DragLeave" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>入力システムが、この要素をドラッグ元とする、基になるドラッグ イベントを報告したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType>このクラスのイベントをアタッチできるように<xref:System.Windows.ContentElement.DragLeave?displayProperty=nameWithType>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素としては、継承です。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.DragLeave>イベントが、基になるに関連付けられている<xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_DragLeave"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.DragLeaveEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.DragEventHandler>|  
  
-   対応するトンネリング イベントが<xref:System.Windows.DragDrop.PreviewDragLeave>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnDragLeave%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.DragLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.DragLeave" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.DragOver" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がドロップ先となる可能性のある、基になるドラッグ イベントを入力システムが報告したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、要素の境界のドラッグを開始した場合でも発生します。 ドラッグ アンドが境界の外側を開始し、このイベントを発生すると、内側、移動だけでなく<xref:System.Windows.ContentElement.DragEnter>とプレビュー イベントを関連します。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType>このクラスのイベントをアタッチできるように<xref:System.Windows.ContentElement.DragOver?displayProperty=nameWithType>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素としては、継承です。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.DragOver>イベントが、基になるに関連付けられている<xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_DragOver"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.DragOverEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.DragEventHandler>|  
  
-   対応するトンネリング イベントが<xref:System.Windows.DragDrop.PreviewDragOver>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnDragOver%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragOverEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragOverEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragOverEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.DragOverEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.DragOver" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Drop">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler Drop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler Drop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.Drop" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>入力システムがこの要素をドロップ先とするドロップ イベントを報告したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType>このクラスのイベントをアタッチできるように<xref:System.Windows.ContentElement.Drop?displayProperty=nameWithType>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素としては、継承です。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.Drop>イベントが、基になるに関連付けられている<xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_Drop"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.DropEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.DragEventHandler>|  
  
-   対応するトンネリング イベントが<xref:System.Windows.ContentElement.PreviewDrop>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnDrop%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DropEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DropEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DropEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.DropEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.Drop" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public bool Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.Focus" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この要素にフォーカスを設定しようとしています。</summary>
        <returns>
          <see langword="true" />この要素にキーボード フォーカスを設定できなかった場合<see langword="false" />場合、このメソッドの呼び出しは、フォーカスを設定できませんでした。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 フォーカスを<xref:System.Windows.ContentElement.Focusable%2A>と<xref:System.Windows.ContentElement.IsEnabled%2A>両方`true`です。 なおほぼすべて<xref:System.Windows.ContentElement>派生クラスは、<xref:System.Windows.ContentElement.Focusable%2A>既定です。  
  
 場合でも、要素は、特定のツリー内でフォーカスを設定し、有効なイベント処理が、フォーカスがある、許可しないことによって、プレビューのフォーカス イベントに応答 (複合コントロールなど) ためこのメソッドは`false`します。  
  
 一般にフォーカスが 2 つの異なる概念によって拘束されます: キーボード フォーカスと論理フォーカスが常に一致しません。 このメソッドは、論理フォーカスを設定します。 プログラムです。 具体的にキーボード フォーカスを設定する手段はありません。キーボード フォーカスは、ユーザー入力によって決定されます。 詳細については、次を参照してください。[フォーカス概要](~/docs/framework/wpf/advanced/focus-overview.md)と[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。  
  
 呼び出す場合<xref:System.Windows.ContentElement.Focus%2A>返します`true`、<xref:System.Windows.ContentElement.IsKeyboardFocused%2A>と<xref:System.Windows.ContentElement.IsKeyboardFocusWithin%2A>も`true`します。  
  
 場合は、関連するプロパティは、既に`true`を呼び出すとき、 <xref:System.Windows.ContentElement.Focus%2A>、次の順序で発生するか、次のイベントの 1 つ以上: <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>、 <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> (ソースは、新しいフォーカス ターゲット)、 <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged>、 <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged>、 <xref:System.Windows.ContentElement.LostKeyboardFocus>、 <xref:System.Windows.ContentElement.GotKeyboardFocus> (ソースは、新しいフォーカス ターゲット)。  
  
   
  
## Examples  
 次の例では、文書内の段落をという名前を指定した検出されたページ読み込みイベントのハンドラーは、し、フォーカスを設定します。 段落が既定ではフォーカスを設定できません。この特定の段落が適用されるスタイル (非表示) を使用して、スタイル<xref:System.Windows.Setter>フォーカスを設定できるようにします。  
  
 [!code-csharp[ContentElementsSmorgasbord#Focus](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#focus)]
 [!code-vb[ContentElementsSmorgasbord#Focus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#focus)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Focusable">
      <MemberSignature Language="C#" Value="public bool Focusable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Focusable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.Focusable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素がフォーカスを得ることができるかどうかを示す値を取得または設定します。</summary>
        <value>
          <see langword="true" />要素がフォーカスを設定できる場合それ以外の場合<see langword="false" />です。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 フォーカスのある要素のみでは、キーボード入力を受け取ります。  
  
 特定の派生クラスは、派生クラスでは、既定でフォーカスを設定できるように、この依存関係プロパティのメタデータをオーバーライド可能性があります。  
  
 継承<xref:System.Windows.Documents.Hyperlink>またはその派生クラスでは、<xref:System.Windows.Documents.Hyperlink>この依存関係プロパティのメタデータをオーバーライドし、このプロパティの既定値を再定義`true`です。  
  
<a name="dependencyPropertyInfo_Focusable"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.FocusableProperty>|  
|メタデータ プロパティに設定します。`true`|なし|  
  
   
  
## Examples  
 次の例では、スタイルを<xref:System.Windows.Documents.Paragraph>既定でフォーカスを設定できるフォーカスを受け取るときに、視覚的な動作を付け、します。  
  
 [!code-xaml[ContentElementsSmorgasbord#Focusable](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#focusable)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生したときに<see cref="T:System.Windows.ContentElement" />要素にフォーカスを設定すると、既定ではないためフォーカスを設定するかどうかを検討してください。 要素にフォーカスを設定できる場合は、次のように、派生クラスの静的コンス トラクターでは、このプロパティのメタデータをオーバーライドします。  
  
 [!code-csharp[CorePseudocode#UIElementShortOverride](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#uielementshortoverride)]
 [!code-vb[CorePseudocode#UIElementShortOverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#uielementshortoverride)]  
  
 ここで<paramref name="myElement" />メタデータ値を上書きするのには、型のクラス名を指定します。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="FocusableChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler FocusableChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler FocusableChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.FocusableChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.ContentElement.Focusable" /> プロパティの値が変更された場合に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]イベントは、ルーティングされたイベントではありません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusableProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusableProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusableProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.FocusableProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.ContentElement.Focusable" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAnimationBaseValue">
      <MemberSignature Language="C#" Value="public object GetAnimationBaseValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetAnimationBaseValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.GetAnimationBaseValue(System.Windows.DependencyProperty)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">確認する依存関係プロパティ。</param>
        <summary>この要素の、指定したプロパティの基本プロパティ値を返します。実行中または停止済みのアニメーションでアニメーション化される値は無視されます。</summary>
        <returns>指定した依存関係プロパティにアニメーションが添付されていないような場合のプロパティ値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティのアニメーションが添付されていない場合、<xref:System.Windows.ContentElement.GetAnimationBaseValue%2A>に戻り値は常に、<xref:System.Windows.DependencyObject.GetValue%2A>値を返します。 添付されたアニメーションがある場合は、可能なすべてのアニメーションが開始を含む値を派生し、停止の値は無視され、プロパティの値はその他のすべての可能な入力に基づいて決定されます。 詳細については、「[依存関係プロパティ値の優先順位](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.GetUIParentCore" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスでオーバーライドされると、返す代わりに[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]ビジュアル親が存在しない場合、この要素の親です。</summary>
        <returns>派生クラスの実装がレポートに代替の親接続を持つ場合のオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドの既定の仮想実装`null`です。 <xref:System.Windows.FrameworkContentElement>実際の実装を提供します。  
  
 別の親は、できるように、そのイベントは、標準の親のビジュアル ツリーをルーティングの標準的なパターンから逸脱した方法でルーティングまたはプレビューのルーティング方法で下方向に要素が代替の親構造体を作成する場所の場合、イベントのルーティングに使用されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.GiveFeedbackEventHandler GiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.GiveFeedbackEventHandler GiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GiveFeedback" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>入力システムがこの要素を対象とするドラッグ アンド ドロップ イベントを報告したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.GiveFeedback>イベントにより、ドラッグ アンド ドロップ操作中にユーザーに視覚的フィードバックを提供するためにマウス ポインターの外観を変更するドラッグ イベントのソース。 視覚的なフィードバックは、ドラッグ アンド ドロップ操作が、プロセスを助けます。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType>このクラスのイベントをアタッチできるように<xref:System.Windows.ContentElement.GiveFeedback>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素としては、継承です。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.GiveFeedback>イベントが、基になるに関連付けられている<xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_GiveFeedback"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.GiveFeedbackEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.GiveFeedbackEventHandler>|  
  
-   対応するトンネリング イベントが<xref:System.Windows.ContentElement.PreviewGiveFeedback>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnGiveFeedback%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GiveFeedbackEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GiveFeedbackEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GiveFeedbackEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GiveFeedbackEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.GiveFeedback" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler GotFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler GotFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotFocus" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素が論理フォーカスを取得したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 フォーカスがメソッド呼び出しを使用して強制的に意図的には、直前のキーボード フォーカスが別のスコープに存在する場合、論理フォーカスはキーボード フォーカスとは異なります。 ここでは、要素にキーボード フォーカスが残り、このシナリオで場所、<xref:System.Windows.ContentElement.Focus%2A>メソッドが呼び出されたが論理フォーカスを取得します。  
  
 このイベントをより正確に解釈というものが発生したときの値、<xref:System.Windows.ContentElement.IsFocused%2A>からルート内の要素のプロパティが変更された`false`に`true`です。  
  
 このイベントは、バブル ルーティングを使用するため、フォーカスを受け取る要素は、イベント ハンドラーが実際に添付されている要素ではなく子要素である可能性があります。 チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>フォーカスを得られる実際の要素を特定のイベント データ。  
  
<a name="routedEventInfo_GotFocus"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.GotFocusEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.RoutedEventHandler>|  
  
-   対応するトンネリング イベントはありません。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnGotFocus%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.GotFocus" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler GotKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler GotKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotKeyboardFocus" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にキーボード フォーカスが移動したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged>類似するイベントです。 要素のフォーカス状態を保持するプロパティで状態の変更を追跡します。<xref:System.Windows.ContentElement.GotKeyboardFocus>イベントは、多くの同じ状況で発生します。  
  
 このイベントは、バブル ルーティングを使用するため、フォーカスを持つ要素は、イベント ハンドラーが実際に添付されている要素ではなく子要素である可能性があります。 チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>フォーカスのある実際の要素を特定のイベント データ。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType>このクラスのイベントをアタッチできるように<xref:System.Windows.ContentElement.GotKeyboardFocus>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素としては、継承です。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.GotKeyboardFocus>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_GotKeyboardFocus"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.GotKeyboardFocusEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   対応するトンネリング イベントが<xref:System.Windows.ContentElement.PreviewGotKeyboardFocus>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnGotKeyboardFocus%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.GotKeyboardFocus" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotMouseCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler GotMouseCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler GotMouseCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotMouseCapture" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がマウスをキャプチャしたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要素がマウスをキャプチャは、境界外にマウス ポインターがあってもマウス入力を受け取ります。 マウスでは、ドラッグ アンド ドロップ操作中にのみがキャプチャ通常され、ドラッグ アンド ドロップ操作の削除アクションが発生するまでにキャプチャされたままです。  
  
 このイベントは、バブル ルーティングを使用するため、キャプチャを持つ要素は、イベント ハンドラーが実際に添付されている要素ではなく子要素である可能性があります。 チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>マウスのある実際の要素を決定するデータのキャプチャのイベントです。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType>このクラスのイベントをアタッチできるように<xref:System.Windows.ContentElement.GotMouseCapture>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素としては、継承です。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.GotMouseCapture>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_GotMouseCapture"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.GotMouseCaptureEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   対応する定義済みのトンネリング イベントはありません。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnGotMouseCapture%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotMouseCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.GotMouseCapture" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotStylusCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler GotStylusCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler GotStylusCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotStylusCapture" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がスタイラスをキャプチャしたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要素がスタイラスをキャプチャ、ときに、ポインターが境界外にある場合でも、スタイラス入力を受け取ります。 スタイラスは、通常、ドラッグ アンド ドロップ操作中にのみキャプチャし、ドラッグ アンド ドロップ操作の削除アクションが発生するまでにキャプチャを保持します。  
  
 このイベントは、バブル ルーティングを使用するため、キャプチャを持つ要素は、イベント ハンドラーが実際に添付されている要素ではなく子要素である可能性があります。 チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>イベント データを実際のキャプチャを持つ要素を決定します。  
  
 このイベントは、このクラスの添付イベントのエイリアスを作成できるように<xref:System.Windows.ContentElement.GotStylusCapture>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.GotStylusCapture>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.GotStylusCapture?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_GotStylusCapture"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.GotStylusCaptureEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応する定義済みのトンネリング イベントはありません。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnGotStylusCapture%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotStylusCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotStylusCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotStylusCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotStylusCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.GotStylusCapture" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotTouchCapture">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; GotTouchCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; GotTouchCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotTouchCapture" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にタッチがキャプチャされるときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_GotTouchCapture"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.GotTouchCaptureEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.EventHandler%601>型の<xref:System.Windows.Input.TouchEventArgs>します。|  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnGotTouchCapture%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotTouchCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotTouchCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotTouchCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotTouchCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.GotTouchCapture" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasAnimatedProperties">
      <MemberSignature Language="C#" Value="public bool HasAnimatedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasAnimatedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.HasAnimatedProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がアニメーション化されたプロパティを持つかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" />この要素があるアニメーションのプロパティのいずれかに接続されている場合それ以外の場合、<see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを返します`true`(ロック、常に実行されている) の永続的なアニメーション用または特定のタイムラインのアニメーションのいずれか。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputBindings">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputBindingCollection InputBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputBindingCollection InputBindings" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.InputBindings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素に関連付けられている入力バインドのコレクションを取得します。</summary>
        <value>入力バインドのコレクション。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 入力バインディングは、コマンド入力デバイスへのバインディングをサポートします。 たとえば、<xref:System.Windows.Input.MouseBinding>入力マウス デバイスに固有のプロパティを含むバインドを実装します。  
  
 入力バインディングのコレクションには、型に関連する両方と、インスタンスで宣言されている入力バインドが含まれています。  
  
 関連するプロパティ、<xref:System.Windows.ContentElement.CommandBindings%2A>コマンドのショートカット キーのコレクションを保持します。 これらのバインディングは、入力バインドとは異なり、コマンドの処理 - これらの既知のコマンドとクラスに固有のハンドラーに関連付けられているアクションの下の次のレベルを表しています。  
  
<a name="xamlPropertyElementUsage_InputBindings"></a>   
## <a name="xaml-property-element-usage"></a>XAML プロパティ要素の使用  
  
```  
<object>  
  <object.InputBindings>  
    oneOrMoreInputBindings  </object.InputBindings>  
</object>  
```  
  
<a name="xamlValues_InputBindings"></a>   
## <a name="xaml-values"></a>XAML 値  
 *oneOrMoreInputBindings*  
 1 つまたは複数<xref:System.Windows.Input.InputBinding>要素 (通常、<xref:System.Windows.Input.KeyBinding>または<xref:System.Windows.Input.MouseBinding>派生クラス)。 これらの各が予期、<xref:System.Windows.Input.InputBinding.Command%2A>と<xref:System.Windows.Input.InputBinding.Gesture%2A>属性に設定します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public bool IsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定でこの要素が有効になっているかどうかを示す値、[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]です。</summary>
        <value>
          <see langword="true" />要素が有効である場合それ以外の場合、<see langword="false" />です。 既定値は <see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsEnabled"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.IsEnabledProperty>|  
|メタデータ プロパティに設定します。`true`|なし|  
  
   
  
## Examples  
 次の例をプロパティ set アクセス操作子、代替視覚的な動作を示すを含むスタイルを作成するときに、<xref:System.Windows.Documents.Hyperlink>に設定されている<xref:System.Windows.ContentElement.IsEnabled%2A>`false`です。  
  
 [!code-xaml[ContentElementsSmorgasbord#IsEnabledIsMouseOver](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#isenabledismouseover)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsEnabledChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsEnabledChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsEnabledChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発生したときの値、<see cref="P:System.Windows.ContentElement.IsEnabled" />プロパティをこの要素を変更します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]イベントは、ルーティングされたイベントではありません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledCore">
      <MemberSignature Language="C#" Value="protected virtual bool IsEnabledCore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabledCore" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsEnabledCore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>戻り値になる値を取得<see cref="P:System.Windows.ContentElement.IsEnabled" />派生クラス。</summary>
        <value>
          <see langword="true" />要素が有効である場合それ以外の場合、<see langword="false" />です。</value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>このプロパティの既定の実装では、値をキャッシュし、またこの要素の親要素が有効になっているかどうかを計算します。 (親が有効でない場合、子要素効果的に有効にできません実用的な[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)])。この実装をオーバーライドすることを確認する場合は、この動作を保持する基本実装を呼び出します。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsEnabledProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsEnabledProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsEnabledProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.ContentElement.IsEnabled" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFocused">
      <MemberSignature Language="C#" Value="public bool IsFocused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFocused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsFocused" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素に論理フォーカスがあるかどうかを判断する値を取得します。</summary>
        <value>
          <see langword="true" />この要素が論理フォーカスがある場合それ以外の場合、<see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アプリケーションは、複数のフォーカス区分をなど、メニューの内容と、アプリケーションの残りの部分の間に、論理フォーカスはキーボード フォーカスと異なる可能性があります。 このシナリオでは、アプリケーションの UI の 1 つの要素にキーボード フォーカスが設定できるだけ、ただし、他のフォーカス区分の特定の要素も保持したまま論理フォーカスします。 論理フォーカスの詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)と[フォーカス概要](~/docs/framework/wpf/advanced/focus-overview.md)です。  
  
<a name="dependencyPropertyInfo_IsFocused"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.IsFocusedProperty>|  
|メタデータ プロパティに設定します。`true`|なし|  
  
   
  
## Examples  
 次の例では、スタイルを<xref:System.Windows.Documents.Paragraph>既定でフォーカスを設定できるフォーカスを受け取るときに、視覚的な動作を付け、します。  
  
 [!code-xaml[ContentElementsSmorgasbord#Focusable](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#focusable)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFocusedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsFocusedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsFocusedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsFocusedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.ContentElement.IsFocused" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInputMethodEnabled">
      <MemberSignature Language="C#" Value="public bool IsInputMethodEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInputMethodEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsInputMethodEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>示す値を取得、入力方式システムかどうかなど、[!INCLUDE[TLA#tla_ime](~/includes/tlasharptla-ime-md.md)]がこの要素への入力を処理するために有効になっています。</summary>
        <value>
          <see langword="true" />入力方式がアクティブである場合それ以外の場合、<see langword="false" />です。 基になる添付プロパティの既定値は<see langword="true" />。 ただし、この値は実行時の入力方式の状態の影響を受けます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティが添付プロパティによって返される値を返します<xref:System.Windows.Input.InputMethod.IsInputMethodEnabled%2A?displayProperty=nameWithType>現在有効な入力メソッド (キーボード、音声、およびその他の入力デバイス) 用です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocused">
      <MemberSignature Language="C#" Value="public bool IsKeyboardFocused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsKeyboardFocused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsKeyboardFocused" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にキーボード フォーカスがあるかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" />この要素がキーボード フォーカスがある場合それ以外の場合、<see langword="false" />です。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsKeyboardFocused"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.IsKeyboardFocusedProperty>|  
|メタデータ プロパティに設定します。`true`|なし|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsKeyboardFocusedChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発生したときの値、<see cref="P:System.Windows.ContentElement.IsKeyboardFocused" />この要素でプロパティが変更されました。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]イベントは、ルーティングされたイベントではありません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsKeyboardFocusedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsKeyboardFocusedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsKeyboardFocusedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.ContentElement.IsKeyboardFocused" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithin">
      <MemberSignature Language="C#" Value="public bool IsKeyboardFocusWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsKeyboardFocusWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsKeyboardFocusWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キーボード フォーカスが要素または子要素内で任意の場所があるかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" />要素またはその子要素にキーボード フォーカスがある場合それ以外の場合、<see langword="false" />です。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティの値に変更が通常発生させる、<xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged>イベント、派生クラスがオーバーライドしない限り、<xref:System.Windows.ContentElement.OnIsKeyboardFocusWithinChanged%2A>を抑制する状況イベント。  
  
 このプロパティを直接設定しないが、要素にフォーカスを設定するには呼び出すことによって<xref:System.Windows.ContentElement.Focus%2A>、またはすることにより、<xref:System.Windows.ContentElement.MoveFocus%2A>要求します。 このプロパティの値を変更するこれらのメソッド呼び出しのいずれかの可能性があります。  
  
<a name="dependencyPropertyInfo_IsKeyboardFocusWithin"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.IsKeyboardFocusWithinProperty>|  
|メタデータ プロパティに設定します。`true`|なし|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発生したときの値、<see cref="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" />この要素でプロパティが変更されました。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]イベントは、ルーティングされたイベントではありません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsKeyboardFocusWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsKeyboardFocusWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsKeyboardFocusWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.ContentElement.IsKeyboardFocusWithin" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptured">
      <MemberSignature Language="C#" Value="public bool IsMouseCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsMouseCaptured" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にマウスがキャプチャされるかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" />要素がマウス キャプチャがある場合それ以外の場合、<see langword="false" />です。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 マウスのキャプチャ状態は、インプロセスのドラッグ アンド ドロップ操作に関連付けられます。  
  
<a name="dependencyPropertyInfo_IsMouseCaptured"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.IsMouseCapturedProperty>|  
|メタデータ プロパティに設定します。`true`|なし|  
  
   
  
## Examples  
 次の例マウスのキャプチャ状態を切り替えます、マウスが要素で既にキャプチャされているかどうかに基づいて。  
  
 [!code-csharp[ContentElementsSmorgasbord#IsMouseCaptured](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#ismousecaptured)]
 [!code-vb[ContentElementsSmorgasbord#IsMouseCaptured](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#ismousecaptured)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCapturedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseCapturedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseCapturedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsMouseCapturedChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発生したときの値、<see cref="P:System.Windows.ContentElement.IsMouseCaptured" />この要素でプロパティが変更されました。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]イベントは、ルーティングされたイベントではありません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsMouseCapturedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.ContentElement.IsMouseCaptured" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithin">
      <MemberSignature Language="C#" Value="public bool IsMouseCaptureWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseCaptureWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsMouseCaptureWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素または要素ツリー内の子要素にマウスのキャプチャを保持するかどうかを決定する値を取得します。</summary>
        <value>
          <see langword="true" />この要素または格納されている要素がマウス キャプチャを持つ場合それ以外の場合、<see langword="false" />です。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsMouseCaptureWithin"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.IsMouseCaptureWithinProperty>|  
|メタデータ プロパティに設定します。`true`|なし|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseCaptureWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseCaptureWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発生したときの値、<see cref="F:System.Windows.ContentElement.IsMouseCaptureWithinProperty" />この要素に変更します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]イベントは、ルーティングされたイベントではありません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseCaptureWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseCaptureWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsMouseCaptureWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.ContentElement.IsMouseCaptureWithin" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOver">
      <MemberSignature Language="C#" Value="public bool IsMouseDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsMouseDirectlyOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マウス ポインターの位置がヒット テストの結果は、要素の構成を考慮に対応しているかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" />マウス ポインターがヒット テストと同じ要素結果の上にある場合それ以外の場合、<see langword="false" />です。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 異なり<xref:System.Windows.ContentElement.IsMouseOver%2A>、のみ、このプロパティは`true`literal 要素上にマウス ポインターが場合などは、ヒット テストのです。 代わりに子要素の上にマウス ポインターが、具体的には要素のより深いテンプレートおよび複合の一部である要素をこのプロパティはするか`false`です。 コントロールは合成する方法がわかっていなければ (たとえば、プロパティを使用するこのカスタム コントロール テンプレートで定義したコントロールの)、このプロパティは、予期しない結果を返す可能性があります。 コントロールをいないオーサリングは、ほとんどのシナリオを使用して<xref:System.Windows.ContentElement.IsMouseOver%2A>代わりにします。  
  
 この要素にマウスがキャプチャされるかどうかと、このプロパティは、`true`のキャプチャ時に、このプロパティを返し続けます`true`までマウスのキャプチャが失われ、その境界上にポインターがありません。  
  
<a name="dependencyPropertyInfo_IsMouseDirectlyOver"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.IsMouseDirectlyOverProperty>|  
|メタデータ プロパティに設定します。`true`|なし|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOverChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseDirectlyOverChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseDirectlyOverChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsMouseDirectlyOverChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発生したときの値、<see cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" />この要素でプロパティが変更されました。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]イベントは、ルーティングされたイベントではありません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsMouseDirectlyOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseOver">
      <MemberSignature Language="C#" Value="public bool IsMouseOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsMouseOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マウス ポインターがこの要素 (visual の子要素、またはそのコントロールの複合を含む) 上にあるかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" />マウス ポインターが要素またはその子要素の上にある場合それ以外の場合、<see langword="false" />です。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 類似しています"IsMouseOverChanged"イベントが存在しないいくつかの類似イベントを行います。 たとえば、使用することができます<xref:System.Windows.ContentElement.MouseEnter>、 <xref:System.Windows.ContentElement.MouseMove>、および<xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged>です。  
  
 この要素がマウスをキャプチャする場合に、このプロパティが残ります`true`マウスのキャプチャが失われ、マウス ポインターが要素の境界を離れるまでです。  
  
<a name="dependencyPropertyInfo_IsMouseOver"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.IsMouseOverProperty>|  
|メタデータ プロパティに設定します。`true`|なし|  
  
   
  
## Examples  
 次の例をプロパティ set アクセス操作子、代替視覚的な動作を示すを含むスタイルを作成するときに、<xref:System.Windows.Documents.Hyperlink>レポート<xref:System.Windows.ContentElement.IsMouseOver%2A>`true`です。  
  
 [!code-xaml[ContentElementsSmorgasbord#IsEnabledIsMouseOver](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#isenabledismouseover)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsMouseOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.ContentElement.IsMouseOver" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptured">
      <MemberSignature Language="C#" Value="public bool IsStylusCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsStylusCaptured" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にスタイラスがキャプチャされるかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" />要素がスタイラス キャプチャを持つ場合それ以外の場合、<see langword="false" />です。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。  
  
<a name="dependencyPropertyInfo_IsStylusCaptured"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.IsStylusCapturedProperty>|  
|メタデータ プロパティに設定します。`true`|なし|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCapturedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusCapturedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusCapturedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsStylusCapturedChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発生したときの値、<see cref="P:System.Windows.ContentElement.IsStylusCaptured" />この要素でプロパティが変更されました。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]イベントは、ルーティングされたイベントではありません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsStylusCapturedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.ContentElement.IsStylusCaptured" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithin">
      <MemberSignature Language="C#" Value="public bool IsStylusCaptureWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusCaptureWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsStylusCaptureWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>子要素、およびコントロールの合成を含め、この要素によってスタイラスのキャプチャを保持するかどうかを決定する値を取得します。</summary>
        <value>
          <see langword="true" />スタイラスのキャプチャがこの要素内で保持されている場合それ以外の場合、<see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。  
  
<a name="dependencyPropertyInfo_IsStylusCaptureWithin"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.IsStylusCaptureWithinProperty>|  
|メタデータ プロパティに設定します。`true`|なし|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusCaptureWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusCaptureWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsStylusCaptureWithinChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発生したときの値、<see cref="P:System.Windows.ContentElement.IsStylusCaptureWithin" />この要素でプロパティが変更されました。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]イベントは、ルーティングされたイベントではありません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusCaptureWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusCaptureWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsStylusCaptureWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.ContentElement.IsStylusCaptureWithin" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOver">
      <MemberSignature Language="C#" Value="public bool IsStylusDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsStylusDirectlyOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタイラスの位置がヒット テストの結果は、要素の構成を考慮に対応しているかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" />ヒット テストと同じ要素上でスタイラスがある場合それ以外の場合、<see langword="false" />です。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 異なり<xref:System.Windows.ContentElement.IsStylusOver%2A>、のみ、このプロパティは`true`要素の上にスタイラスがある場合。 スタイラスが代わりに子要素上、または要素は要素のより深い複合の一部である場合、このプロパティはなって`false`です。  
  
 コントロールは合成する方法がわかっていなければ (たとえば、プロパティを使用するこのカスタム コントロール テンプレートで定義したコントロールの)、このプロパティは、予期しない結果を返す可能性があります。 コントロールをいないオーサリングは、ほとんどのシナリオを使用して<xref:System.Windows.ContentElement.IsStylusOver%2A>代わりにします。  
  
 この要素がスタイラス キャプチャを持つプロパティは、この場合`true`のキャプチャ時に、このプロパティの値`true`までスタイラスのキャプチャが失われ、その境界上にスタイラスがありません。  
  
 タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。  
  
<a name="dependencyPropertyInfo_IsStylusDirectlyOver"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.IsStylusDirectlyOverProperty>|  
|メタデータ プロパティに設定します。`true`|なし|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOverChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusDirectlyOverChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusDirectlyOverChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsStylusDirectlyOverChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発生したときの値、<see cref="P:System.Windows.ContentElement.IsStylusDirectlyOver" />この要素でプロパティが変更されました。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]イベントは、ルーティングされたイベントではありません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsStylusDirectlyOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.ContentElement.IsStylusDirectlyOver" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusOver">
      <MemberSignature Language="C#" Value="public bool IsStylusOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsStylusOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタイラスがこの要素 (子ビジュアル要素を含む) 上にあるかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" />スタイラスが要素またはその子要素の上にある場合それ以外の場合、<see langword="false" />です。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この要素にスタイラスのキャプチャがある場合は、このプロパティの値`true`スタイラスのキャプチャが失われ、ポインターがその範囲外になるまでです。  
  
 タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。  
  
<a name="dependencyPropertyInfo_IsStylusOver"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.IsStylusOverProperty>|  
|メタデータ プロパティに設定します。`true`|なし|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsStylusOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.ContentElement.IsStylusOver" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler KeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler KeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.KeyDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にフォーカスがある状態でキーが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キーの処理は、コマンド実行やテキストの合成などの他のプラットフォーム機能と対話します。 <xref:System.Windows.ContentElement.KeyDown>イベントは、下位レベルのテキスト入力イベントを特定のコントロールで期待どおりに動作しない可能性があります。 これは、一部のコントロールがコントロールの複合か、テキストの上位レベルのバージョンを提供するクラスの処理が処理を入力し、関連するイベントです。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType>このクラスのイベントをアタッチできるように<xref:System.Windows.ContentElement.KeyDown>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素としては、継承です。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.KeyDown>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_KeyDown"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.KeyDownEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   対応するトンネリング イベントが<xref:System.Windows.ContentElement.PreviewKeyDown>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnKeyDown%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent KeyDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent KeyDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.KeyDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.KeyDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler KeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler KeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.KeyUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にフォーカスがあるときにキーが離されると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType>このクラスのイベントをアタッチできるように<xref:System.Windows.ContentElement.KeyUp>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素としては、継承です。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.KeyUp>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_KeyUp"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.KeyUpEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   対応するトンネリング イベントが<xref:System.Windows.ContentElement.PreviewKeyUp>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnKeyUp%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent KeyUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent KeyUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.KeyUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.KeyUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler LostFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler LostFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostFocus" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素が論理フォーカスを失ったときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド呼び出しを使用して意図的にフォーカスを外しているにもかかわらず、直前のキーボード フォーカスが異なるスコープ内に存在する場合、論理フォーカスはキーボード フォーカスとは異なります。 ここでは、キーボード フォーカスは残りますが、および要素の位置、<xref:System.Windows.ContentElement.Focus%2A>メソッドが呼び出されたが論理フォーカスを取得します。  
  
 このイベントをより正確に解釈というものが発生したときの値、<xref:System.Windows.ContentElement.IsFocused%2A>からルート内の要素のプロパティが変更される`true`に`false`です。  
  
 このイベントは、バブル ルーティングを使用するため、フォーカスを失った要素は、イベント ハンドラーが実際に添付されている、要素ではなく子要素である可能性があります。 チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>フォーカスを得られる実際の要素を特定のイベント データ。  
  
<a name="routedEventInfo_LostFocus"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.LostFocusEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.RoutedEventHandler>|  
  
-   対応するトンネリング イベントはありません。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnLostFocus%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.LostFocus" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler LostKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler LostKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostKeyboardFocus" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素からキーボード フォーカスが離れたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、バブル ルーティングを使用するため、フォーカスを失った要素は、イベント ハンドラーが実際に添付されている、要素ではなく子要素である可能性があります。 チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>フォーカスが失われた実際の要素を特定のイベント データ。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.LostKeyboardFocus>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.LostKeyboardFocus>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_LostKeyboardFocus"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.LostKeyboardFocusEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   対応するトンネリング イベントが<xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnLostKeyboardFocus%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.LostKeyboardFocus" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostMouseCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler LostMouseCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler LostMouseCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostMouseCapture" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がマウス キャプチャを失ったときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要素がマウスをキャプチャは、境界外にポインターがあってもマウス入力を受け取ります。 マウスは通常、ドラッグ アンド ドロップ操作中にのみキャプチャされます。  
  
 このイベントは、バブル ルーティングを使用するため、キャプチャを失った要素は、イベント ハンドラーが実際に添付されている、要素ではなく子要素である可能性があります。 チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>キャプチャを失った実際の要素を特定のイベント データ。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.LostMouseCapture>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.LostMouseCapture>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_LostMouseCapture"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.LostMouseCaptureEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   対応する定義済みのトンネリング イベントはありません。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnLostMouseCapture%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostMouseCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.LostMouseCapture" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostStylusCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler LostStylusCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler LostStylusCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostStylusCapture" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がスタイラス キャプチャを失ったときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要素がスタイラスをキャプチャ、ときに、ポインターが境界外にある場合でも、スタイラス入力を受け取ります。 スタイラスは通常、ドラッグ アンド ドロップ操作中にのみキャプチャされます。  
  
 このイベントは、バブル ルーティングを使用するため、フォーカスを失った要素は、イベント ハンドラーが実際に添付されている、要素ではなく子要素である可能性があります。 チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>フォーカスが失われた実際の要素を特定のイベント データ。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.LostStylusCapture>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.LostStylusCapture>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_LostStylusCapture"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.LostStylusCaptureEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応する定義済みのトンネリング イベントはありません。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnLostStylusCapture%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostStylusCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostStylusCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostStylusCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostStylusCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.LostStylusCapture" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostTouchCapture">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; LostTouchCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; LostTouchCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostTouchCapture" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素は、タッチのキャプチャを失ったときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_LostTouchCapture"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.LostTouchCaptureEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.EventHandler%601>型の<xref:System.Windows.Input.TouchEventArgs>します。|  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnLostTouchCapture%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostTouchCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostTouchCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostTouchCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostTouchCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.LostTouchCapture" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にポインターがある状態でマウス ボタンが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.MouseDown>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.MouseDown>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
 <xref:System.Windows.ContentElement.MouseDown>イベントは、多くの場合、いずれかと共に<xref:System.Windows.ContentElement.MouseLeftButtonDown>または<xref:System.Windows.ContentElement.MouseRightButtonDown>、2 つの標準のマウス ボタンのいずれかのキーを押してに対応します。 <xref:System.Windows.ContentElement.MouseLeftButtonDown><xref:System.Windows.ContentElement.MouseRightButtonDown>も、ルーティング イベントをしています直接ルーティング イベントを適切なボタンに固有のイベントが発生したときに、<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>イベント イベント ルート上には、この要素に到達します。 「解説」を参照してください<xref:System.Windows.ContentElement.MouseLeftButtonDown>または<xref:System.Windows.ContentElement.MouseRightButtonDown>です。  
  
> [!IMPORTANT]
>  いくつか<xref:System.Windows.ContentElement>をたとえば、コントロールと同様の動作を持つクラスを派生<xref:System.Windows.Documents.Hyperlink>、本質的なイベントに対するクラス処理マウス ボタンがあります。 イベントをマウスの左ボタンは、クラス、コントロールで処理が最も可能性の高いイベントです。 多くの場合、処理するクラスは、基になるをマーク<xref:System.Windows.Input.Mouse>クラス イベントを処理します。 イベントが処理済みとマークされるとその要素に関連付けられている他のインスタンス ハンドラーは通常は発生しません。 その他のクラスまたはインスタンス ハンドラー、バブルに向かう方向 UI ツリーのルート内の要素に関連付けられている通常も発生します。  
  
 前の「重要」に示されている問題を解決でき、それでも<xref:System.Windows.ContentElement.MouseDown>マウスの左ボタンを押すイベントをこれらソリューションのいずれかを使用して処理するクラスを持つ派生クラスでイベント。  
  
-   ハンドラーのアタッチ、<xref:System.Windows.ContentElement.PreviewMouseDown>コントロールによって処理済みとしてマークされていないイベント。 これはプレビュー イベントであるため、ルート ルートから始まり、トンネルをコントロールに注意してください。  
  
-   コントロールのハンドラーを呼び出すことによって手続き登録<xref:System.Windows.ContentElement.AddHandler%2A>ハンドラーにルーティングされたイベント データの処理済みとしてマークされている場合でも、イベントをリッスンできる署名オプションを選択します。  
  
<a name="routedEventInfo_MouseDown"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.MouseDownEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   対応するトンネリング イベントが<xref:System.Windows.ContentElement.PreviewMouseDown>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnMouseDown%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.MouseDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseEnter" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マウス ポインターがこの要素の境界内に入ったときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.MouseEnter>[ルーティング イベントの概要](~/docs/framework/wpf/advanced/routed-events-overview.md)直接イベント ルーティング方法の処理を使用します。 ルート; 直接ルーティングされたイベントは発生しません代わりが処理される同じ要素では、発生します。 ただし、スタイルでのイベント トリガーなどのルーティング イベントの動作の他の側面を有効にする、操作を行います。  
  
 <xref:System.Windows.ContentElement.MouseEnter>マウス ポインターがこのイベントをさらに、要素の境界に入った時点を追跡するレポート文字どおり、<xref:System.Windows.ContentElement.IsMouseOver%2A>からプロパティ値が変更された`false`に`true`この要素上です。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.MouseEnter>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.MouseEnter>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_MouseEnter"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.MouseEnterEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnMouseEnter%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.MouseEnter" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseLeave" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マウス ポインターがこの要素の境界内から出たときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.MouseLeave>[ルーティング イベントの概要](~/docs/framework/wpf/advanced/routed-events-overview.md)直接イベント ルーティング方法の処理を使用します。 ルート; 直接ルーティングされたイベントは発生しません代わりが処理される同じ要素では、発生します。 ただし、スタイルでのイベント トリガーなどのルーティング イベントの動作の他の側面を有効にする、操作を行います。  
  
 <xref:System.Windows.ContentElement.MouseLeave>トラック マウスが要素をこのイベントの詳細を報告文字どおり、<xref:System.Windows.ContentElement.IsMouseOver%2A>からプロパティ値が変更された`true`に`false`この要素上です。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.MouseLeave>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.MouseLeave>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_MouseLeave"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.MouseLeaveEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnMouseLeave%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.MouseLeave" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseLeftButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseLeftButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseLeftButtonDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でマウスの左ボタンが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この[ルーティング イベントの概要](~/docs/framework/wpf/advanced/routed-events-overview.md)、要素ツリーを通じてバブルのルートに従うように見えますが発生し、各によって、要素ツリーに沿って reraised を直接ルーティング イベントを実際には<xref:System.Windows.ContentElement>します。  
  
 このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの 1 つ<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>イベント ルート上の各要素によって処理される添付イベントがイベント。  
  
 このイベントの引数を公開、基になる引数<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>イベント。 そのイベントがイベント ルート上処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります<xref:System.Windows.ContentElement.AddHandler%2A>、処理済みとしてマークされているイベントを処理する、イベント リスナーをするために、オプションを使用します。  
  
 概念的には、このイベントの待ち時間 (やその他のマウス ボタンのイベントに<xref:System.Windows.ContentElement>) マウス「サービス」である (によって提供される、サービス定義で、<xref:System.Windows.Input.Mouse>クラス)。 イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 (左から右に、アップダウン) を確認する必要はないの利便性を追加します。 非標準のボタンの状態のチェックなどの高度なシナリオを使用する必要があります、[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上、<xref:System.Windows.Input.Mouse>ものではなくクラスに対する<xref:System.Windows.ContentElement>です。  
  
> [!IMPORTANT]
>  いくつか<xref:System.Windows.ContentElement>をたとえば、コントロールと同様の動作を持つクラスを派生<xref:System.Windows.Documents.Hyperlink>、本質的なイベントに対するクラス処理マウス ボタンがあります。 イベントをマウスの左ボタンは、クラス、コントロールで処理が最も可能性の高いイベントです。 多くの場合、処理するクラスは、基になるをマーク<xref:System.Windows.Input.Mouse>クラス イベントを処理します。 イベントが処理済みとマークされるとその要素に関連付けられている他のインスタンス ハンドラーは通常は発生しません。 その他のクラスまたはインスタンス ハンドラー、バブルに向かう方向 UI ツリーのルート内の要素に関連付けられている通常も発生します。  
  
 前の「重要」に示されている問題を解決でき、それでも<xref:System.Windows.ContentElement.MouseLeftButtonDown>マウスの左ボタンを押すイベントをこれらソリューションのいずれかを使用して処理するクラスを持つ派生クラスでイベント。  
  
-   ハンドラーのアタッチ、<xref:System.Windows.ContentElement.PreviewMouseDown>コントロールによって処理済みとしてマークされていないイベント。 これはプレビュー イベントであるため、ルート ルートから始まり、トンネルをコントロールに注意してください。  
  
-   コントロールのハンドラーを呼び出すことによって手続き登録<xref:System.Windows.ContentElement.AddHandler%2A>ハンドラーにルーティングされたイベント データの処理済みとしてマークされている場合でも、イベントをリッスンできる署名オプションを選択します。  
  
<a name="routedEventInfo_MouseLeftButtonDown"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.MouseLeftButtonDownEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeftButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeftButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseLeftButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.MouseLeftButtonDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseLeftButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseLeftButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseLeftButtonUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でマウスの左ボタンが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この[ルーティング イベントの概要](~/docs/framework/wpf/advanced/routed-events-overview.md)、要素ツリーを通じてバブルのルートに従うように見えますが発生し、各によって、要素ツリーに沿って reraised を直接ルーティング イベントを実際には<xref:System.Windows.ContentElement>します。  
  
 このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの 1 つ<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>イベント ルート上の各要素によって処理される添付イベントがイベント。  
  
 このイベントの引数を公開、基になる引数<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>イベント。 そのイベントがイベント ルート上処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります<xref:System.Windows.ContentElement.AddHandler%2A>、処理済みとしてマークされているイベントを処理する、イベント リスナーをするために、オプションを使用します。  
  
 概念的には、このイベントの待ち時間 (やその他のマウス ボタンのイベントに<xref:System.Windows.ContentElement>) マウス「サービス」である (によって提供される、サービス定義で、<xref:System.Windows.Input.Mouse>クラス)。 イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 (左から右に、アップダウン) を確認する必要はないの利便性を追加します。 非標準のボタンの状態のチェックなどの高度なシナリオを使用する必要があります、[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上、<xref:System.Windows.Input.Mouse>ものではなくクラスに対する<xref:System.Windows.ContentElement>です。  
  
<a name="routedEventInfo_MouseLeftButtonUp"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.MouseLeftButtonUpEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnMouseLeftButtonUp%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeftButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeftButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseLeftButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.MouseLeftButtonUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseMove" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上でマウス ポインターが動かされたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.MouseMove>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.MouseMove>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_MouseMove"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.MouseMoveEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   対応するトンネリング イベントが<xref:System.Windows.ContentElement.PreviewMouseMove>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnMouseMove%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.MouseMove" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseRightButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseRightButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseRightButtonDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でマウスの右ボタンが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この[ルーティング イベントの概要](~/docs/framework/wpf/advanced/routed-events-overview.md)、要素ツリーを通じてバブルのルートに従うように見えますが発生し、各によって、要素ツリーに沿って reraised を直接ルーティング イベントを実際には<xref:System.Windows.ContentElement>します。  
  
 このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの 1 つ<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>イベント ルート上の各要素によって処理される添付イベントがイベント。  
  
 このイベントの引数を公開、基になる引数<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>イベント。 そのイベントがイベント ルート上処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります<xref:System.Windows.ContentElement.AddHandler%2A>、処理済みとしてマークされているイベントを処理する、イベント リスナーをするために、オプションを使用します。  
  
 概念的には、このイベントの待ち時間 (やその他のマウス ボタンのイベントに<xref:System.Windows.ContentElement>) マウス「サービス」である (によって提供される、サービス定義で、<xref:System.Windows.Input.Mouse>クラス)。 イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 (左から右に、アップダウン) を確認する必要はないの利便性を追加します。 非標準のボタンの状態のチェックなどの高度なシナリオを使用する必要があります、[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上、<xref:System.Windows.Input.Mouse>ものではなくクラスに対する<xref:System.Windows.ContentElement>です。  
  
 右ボタンをマウス イベントは、アプリケーション シナリオでネイティブの処理を頻繁にあります。 たとえば、マウスの右ボタンを押すは、コンテキスト メニューを表示する可能性があります。 参照してください[ContextMenu 概要](~/docs/framework/wpf/controls/contextmenu-overview.md)です。  
  
<a name="routedEventInfo_MouseRightButtonDown"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.MouseRightButtonDownEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseRightButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseRightButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseRightButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.MouseRightButtonDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseRightButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseRightButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseRightButtonUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でマウスの右ボタンが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この[ルーティング イベントの概要](~/docs/framework/wpf/advanced/routed-events-overview.md)、要素ツリーを通じてバブルのルートに従うように見えますが発生し、各によって、要素ツリーに沿って reraised を直接ルーティング イベントを実際には<xref:System.Windows.ContentElement>します。  
  
 このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの 1 つ<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>イベント ルート上の各要素によって処理される添付イベントがイベント。  
  
 このイベントの引数を公開、基になる引数<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>イベント。 そのイベントがイベント ルート上処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります<xref:System.Windows.ContentElement.AddHandler%2A>、処理済みとしてマークされているイベントを処理する、イベント リスナーをするために、オプションを使用します。  
  
 概念的には、このイベントの待ち時間 (やその他のマウス ボタンのイベントに<xref:System.Windows.ContentElement>) マウス「サービス」である (によって提供される、サービス定義で、<xref:System.Windows.Input.Mouse>クラス)。 イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 (左から右に、アップダウン) を確認する必要はないの利便性を追加します。 非標準のボタンの状態のチェックなどの高度なシナリオを使用する必要があります、[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上、<xref:System.Windows.Input.Mouse>ものではなくクラスに対する<xref:System.Windows.ContentElement>です。  
  
<a name="routedEventInfo_MouseRightButtonUp"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.MouseRightButtonUpEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnMouseRightButtonUp%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseRightButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseRightButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseRightButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.MouseRightButtonUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上でいずれかのマウス ボタンが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.MouseUp>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.MouseUp>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
 <xref:System.Windows.ContentElement.MouseUp>イベントは、多くの場合、いずれかと共に<xref:System.Windows.ContentElement.MouseLeftButtonUp>または<xref:System.Windows.ContentElement.MouseRightButtonUp>、2 つの標準のマウス ボタンのいずれかのリリースに対応します。 <xref:System.Windows.ContentElement.MouseLeftButtonUp><xref:System.Windows.ContentElement.MouseRightButtonUp>も、ルーティング イベントをしています直接ルーティング イベントを適切なボタンに固有のイベントが発生したときに、<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>イベント イベント ルート上には、この要素に到達します。 「解説」を参照してください<xref:System.Windows.ContentElement.MouseLeftButtonUp>または<xref:System.Windows.ContentElement.MouseRightButtonUp>です。  
  
<a name="routedEventInfo_MouseUp"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.MouseUpEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   対応するトンネリング イベントが<xref:System.Windows.ContentElement.PreviewMouseUp>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnMouseUp%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.MouseUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheel">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseWheelEventHandler MouseWheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseWheelEventHandler MouseWheel" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseWheel" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseWheelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でユーザーがマウス ホイールを使用したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 フォーカスまたはマウスのキャプチャ、マウス ポインターが; よりも優先します。そのため、表示された場合、<xref:System.Windows.ContentElement.MouseWheel>対象を絞ったまたはキャプチャした要素からのイベント、マウス ポインター可能性があります実際には別の要素上です。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.MouseWheel>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.MouseWheel>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_MouseWheel"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.MouseWheelEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   対応するトンネリング イベントが<xref:System.Windows.ContentElement.PreviewMouseWheel>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnMouseWheel%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseWheelEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.MouseWheel" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public virtual bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">走査の各要求を視覚的に移動するには、既存のタブ オーダーまたはを方向を走査するモードにはいずれかを示すプロパティが含まれています。</param>
        <summary>この要素から別の要素にフォーカスを移動しようとしています。 ガイダンスの方向になり、この要素のビジュアルの親の組織内で解釈されますが、フォーカスを移動する方向を指定します。</summary>
        <returns>
          <see langword="true" />要求された検査が実行された場合それ以外の場合、<see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドの戻り値を確認してください。 戻り値の`false`コントロールの構成で定義されているタブ ストップの検査を実行し、走査の各要求はラップを要求していないかどうかに返される可能性があります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnCreateAutomationPeer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>特定のクラスを返します<see cref="T:System.Windows.Automation.Peers.AutomationPeer" />の実装、[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]インフラストラクチャです。</summary>
        <returns>型固有の <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> 実装。</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>このメソッドの実装は、通常、特定のコンス トラクターを呼び出す<see cref="T:System.Windows.Automation.Peers.AutomationPeer" />実装し、戻り値として返します。  
  
 すべて<see cref="T:System.Windows.ContentElement" />派生クラスは、独自の固有の仕様を提供するためにこのメソッドを実装する必要があります<see cref="T:System.Windows.Automation.Peers.AutomationPeer" />を実装する、[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]インフラストラクチャです。 このパターンの実装の詳細については、「<see cref="T:System.Windows.Automation.Peers.AutomationPeer" />です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnDragEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnDragEnter (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDragEnter(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnDragEnter(System.Windows.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.DragDrop.DragEnter" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDragLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnDragLeave (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDragLeave(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnDragLeave(System.Windows.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.DragDrop.DragLeave" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDragOver">
      <MemberSignature Language="C#" Value="protected virtual void OnDragOver (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDragOver(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnDragOver(System.Windows.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.DragDrop.DragOver" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDrop">
      <MemberSignature Language="C#" Value="protected virtual void OnDrop (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDrop(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnDrop(System.Windows.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.DragDrop.DragEnter" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGiveFeedback">
      <MemberSignature Language="C#" Value="protected virtual void OnGiveFeedback (System.Windows.GiveFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGiveFeedback(class System.Windows.GiveFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.GiveFeedbackEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.DragDrop.GiveFeedback" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A<see cref="T:System.Windows.RoutedEventArgs" />イベント データを格納します。 このイベント データの識別子を含める必要があります、<see cref="E:System.Windows.ContentElement.GotFocus" />イベント。</param>
        <summary>発生させる、<see cref="E:System.Windows.ContentElement.GotFocus" />渡されたイベント データを使用して、ルーティングされたイベント。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、仮想がイベントを発生させる既定の実装です。  
  
 これで * メソッドの実装は、イベントを発生させるためのものし、イベントを発生させるこの同じメソッドの実装が内部的に呼び出されるときに、<xref:System.Windows.ContentElement.IsFocused%2A>プロパティ値が変更されました。 <xref:System.Windows.ContentElement.OnGotFocus%2A>実装が異なるその他の[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]で * だけそのイベントに対するクラス処理を追加する便利な手段を提供する実装。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>意図的および例外いないフォーカス イベントを発生させることを確認する必要がない限り、実装は基本実装を呼び出します。 それ以外の場合、<see cref="E:System.Windows.ContentElement.GotFocus" />イベントは通常、この要素にフォーカスを設定する一般的なユーザーの操作中に発生しません。 要素にフォーカスを設定する予定がない場合は、設定されない要素を防ぐことができます<see cref="P:System.Windows.ContentElement.Focusable" />に<see langword="false" />です。 既定では、ことに注意してください。、<see cref="P:System.Windows.ContentElement.Focusable" />フォーカスを設定するための設定<see cref="P:System.Windows.ContentElement.Focusable" />意図的には必要ありません。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnGotKeyboardFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnGotKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Keyboard.GotKeyboardFocus" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGotMouseCapture">
      <MemberSignature Language="C#" Value="protected virtual void OnGotMouseCapture (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotMouseCapture(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotMouseCapture(System.Windows.Input.MouseEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Mouse.GotMouseCapture" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGotStylusCapture">
      <MemberSignature Language="C#" Value="protected virtual void OnGotStylusCapture (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotStylusCapture(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotStylusCapture(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.GotStylusCapture" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGotTouchCapture">
      <MemberSignature Language="C#" Value="protected virtual void OnGotTouchCapture (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotTouchCapture(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotTouchCapture(System.Windows.Input.TouchEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>クラスの処理を提供、<see cref="E:System.Windows.ContentElement.GotTouchCapture" />タッチがこの要素にキャプチャされるときに発生するイベントをルーティングします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.OnGotTouchCapture%2A>メソッドに既定の実装がありません。 オーバーライド<xref:System.Windows.ContentElement.OnGotTouchCapture%2A>を処理する派生クラスで、<xref:System.Windows.ContentElement.GotTouchCapture>イベント。 必ず、基本クラスの<xref:System.Windows.ContentElement.OnGotTouchCapture%2A>を基底クラス メソッドがイベントを受信します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsKeyboardFocusedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsKeyboardFocusedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsKeyboardFocusedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>未処理のときに呼び出される<see cref="E:System.Windows.ContentElement.IsKeyboardFocusedChanged" />イベントがこの要素で発生します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この仮想メソッドが発生したときの値、<xref:System.Windows.ContentElement.IsKeyboardFocused%2A>依存関係プロパティの変更。 仮想メソッドは、最初に発生し、必要に応じて、イベント データを操作できます。 続いて、<xref:System.Windows.ContentElement.IsKeyboardFocusedChanged>同じイベント データ インスタンスをイベントが発生します。 注意して、<xref:System.Windows.ContentElement.IsKeyboardFocusedChanged>イベントは、ルーティングされたイベントではありません。 そのため、クラス ハンドラーで処理されるようにマークすることはできません。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。 呼び出すことが基本の前に、または後に特別な処理の要件に応じて、します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsKeyboardFocusWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsKeyboardFocusWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsKeyboardFocusWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>直前に呼び出される、<see cref="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" />イベントは、この要素で発生します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この仮想メソッドが発生したときの値、<xref:System.Windows.ContentElement.IsKeyboardFocusWithin%2A>依存関係プロパティの値が変更します。 仮想メソッドは、最初に発生し、必要に応じて、イベント データを操作できます。 続いて、<xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged>同じイベント データ インスタンスをイベントが発生します。 注意して、<xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged>イベントは、ルーティングされたイベントではありません。 そのため、クラス ハンドラーで処理されるようにマークすることはできません。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。 呼び出すことが基本の前に、または後に特別な処理の要件に応じて、します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseCapturedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseCapturedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseCapturedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsMouseCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>未処理のときに呼び出される<see cref="E:System.Windows.ContentElement.IsMouseCapturedChanged" />イベントがこの要素で発生します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この仮想メソッドが発生したときの値、<xref:System.Windows.ContentElement.IsMouseCaptured%2A>依存関係プロパティの値が変更します。 仮想メソッドは、最初に発生し、必要に応じて、イベント データを操作できます。 続いて、<xref:System.Windows.ContentElement.IsMouseCapturedChanged>同じイベント データ インスタンスをイベントが発生します。 注意して、<xref:System.Windows.ContentElement.IsMouseCapturedChanged>イベントは、ルーティングされたイベントではありません。 そのため、クラス ハンドラーで処理されるようにマークすることはできません。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。 呼び出すことが基本の前に、または後に特別な処理の要件に応じて、します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseCaptureWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseCaptureWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseCaptureWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsMouseCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>未処理のときに呼び出される<see cref="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" />イベントがこの要素で発生します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>この仮想メソッドが発生したときの値、<see cref="P:System.Windows.ContentElement.IsMouseCaptureWithin" />依存関係プロパティの値が変更します。 仮想メソッドは、最初に発生し、必要に応じて、イベント データを操作できます。 続いて、<see cref="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" />同じイベント データ インスタンスをイベントが発生します。 イベントが; ルーティングされたイベントではないことに注意してください。そのため、クラス ハンドラーで処理されるようにマークすることはできません。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。 呼び出すことが基本の前に、または後に特別な処理の要件に応じて、します。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseDirectlyOverChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseDirectlyOverChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseDirectlyOverChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsMouseDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>未処理のときに呼び出される<see cref="E:System.Windows.ContentElement.IsMouseDirectlyOverChanged" />イベントがこの要素で発生します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この仮想メソッドが発生したときの値、<xref:System.Windows.ContentElement.IsMouseDirectlyOver%2A>依存関係プロパティの値が変更します。 仮想メソッドは、最初に発生し、必要に応じて、イベント データを操作できます。 続いて、<xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged>同じイベント データ インスタンスをイベントが発生します。 注意して、<xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged>イベントは、ルーティングされたイベントではありません。 そのため、クラス ハンドラーで処理されるようにマークすることはできません。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。 呼び出すことが基本の前に、または後に特別な処理の要件に応じて、します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusCapturedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusCapturedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusCapturedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsStylusCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>未処理のときに呼び出される<see cref="E:System.Windows.ContentElement.IsStylusCapturedChanged" />イベントがこの要素で発生します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この仮想メソッドが発生したときの値、<xref:System.Windows.ContentElement.IsStylusCaptured%2A>依存関係プロパティの値が変更します。 仮想メソッドは、最初に発生し、必要に応じて、イベント データを操作できます。 続いて、<xref:System.Windows.ContentElement.IsStylusCapturedChanged>同じイベント データ インスタンスをイベントが発生します。 イベントがルーティングされたイベントではないことに注意してください。 そのため、クラス ハンドラーで処理されるようにマークすることはできません。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。 呼び出すことが基本の前に、または後に特別な処理の要件に応じて、します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusCaptureWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusCaptureWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusCaptureWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsStylusCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>未処理のときに呼び出される<see cref="E:System.Windows.ContentElement.IsStylusCaptureWithinChanged" />イベントがこの要素で発生します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この仮想メソッドが発生したときの値、<xref:System.Windows.ContentElement.IsStylusCaptureWithin%2A>依存関係プロパティの値が変更します。 仮想メソッドは、最初に発生し、必要に応じて、イベント データを操作できます。 続いて、<xref:System.Windows.ContentElement.IsStylusCaptureWithinChanged>同じイベント データ インスタンスをイベントが発生します。 イベントがルーティングされたイベントではないことに注意してください。 そのため、クラス ハンドラーで処理されるようにマークすることはできません。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。 呼び出すことが基本の前に、または後に特別な処理の要件に応じて、します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusDirectlyOverChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusDirectlyOverChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusDirectlyOverChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsStylusDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>未処理のときに呼び出される<see cref="E:System.Windows.ContentElement.IsStylusDirectlyOverChanged" />イベントがこの要素で発生します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この仮想メソッドが発生したときの値、<xref:System.Windows.ContentElement.IsStylusDirectlyOver%2A>依存関係プロパティの値が変更します。 仮想メソッドは、最初に発生し、必要に応じて、イベント データを操作できます。 続いて、<xref:System.Windows.ContentElement.IsStylusDirectlyOverChanged>同じイベント データ インスタンスをイベントが発生します。 イベントがルーティングされたイベントではないことに注意してください。 そのため、クラス ハンドラーで処理されるようにマークすることはできません。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。 呼び出すことが基本の前に、または後に特別な処理の要件に応じて、します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected virtual void OnKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.KeyEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Keyboard.KeyDown" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キーボード操作は、専用の入力マネージャーによって処理されます。 その他のプログラミングに依存する機能キーストローク、たとえば、入力とコマンドのバインドは、一般的なキーストロークとして公開される前にキーストロークを処理する可能性があります。 システムの機能、イベントを処理し、としてマークするような入力する場合<xref:System.Windows.ContentElement.OnKeyDown%2A>は呼び出されません。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnKeyUp">
      <MemberSignature Language="C#" Value="protected virtual void OnKeyUp (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnKeyUp(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnKeyUp(System.Windows.Input.KeyEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.KeyEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Keyboard.KeyUp" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キーボード操作は、専用の入力マネージャーによって処理されます。 その他のプログラミングに依存する機能キーストローク、たとえば、入力とコマンドのバインドは、一般的なキーストロークとして公開される前にキーストロークを処理する可能性があります。 システムの機能、イベントを処理し、としてマークするような入力する場合<xref:System.Windows.ContentElement.OnKeyUp%2A>は呼び出されません。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLostFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnLostFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLostFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostFocus(System.Windows.RoutedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A<see cref="T:System.Windows.RoutedEventArgs" />イベント データを格納します。 このイベント データの識別子を含める必要があります、<see cref="E:System.Windows.ContentElement.LostFocus" />イベント。</param>
        <summary>発生させる、<see cref="E:System.Windows.ContentElement.LostFocus" />提供されているイベント データを使用して、ルーティングされたイベント。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、仮想がイベントを発生させる既定の実装です。  
  
 これで * メソッドの実装は、イベントを発生させるためのものし、イベントを発生させるこの同じメソッドの実装が内部的に呼び出されるときに、<xref:System.Windows.ContentElement.IsFocused%2A>プロパティ値が変更されました。 この実装が異なるその他の[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]で * だけそのイベントに対するクラス処理を追加する便利な手段を提供する実装。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>意図的および例外いないフォーカス イベントを発生させることを確認する必要がない限り、実装は基本実装を呼び出します。 それ以外の場合、<see cref="E:System.Windows.ContentElement.LostFocus" />イベントは通常、この要素にフォーカスを設定する一般的なユーザーの操作中に発生しません。 要素にフォーカスを設定する予定がない場合は、設定されない要素を防ぐことができます<see cref="P:System.Windows.ContentElement.Focusable" />に<see langword="false" />です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnLostKeyboardFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnLostKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />イベント データを格納します。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Keyboard.LostKeyboardFocus" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLostMouseCapture">
      <MemberSignature Language="C#" Value="protected virtual void OnLostMouseCapture (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostMouseCapture(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.Input.MouseEventArgs" />イベント データを格納します。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLostStylusCapture">
      <MemberSignature Language="C#" Value="protected virtual void OnLostStylusCapture (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostStylusCapture(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostStylusCapture(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.Input.StylusEventArgs" />イベント データを格納します。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.LostStylusCapture" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLostTouchCapture">
      <MemberSignature Language="C#" Value="protected virtual void OnLostTouchCapture (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostTouchCapture(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostTouchCapture(System.Windows.Input.TouchEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>クラス処理を提供、<see cref="E:System.Windows.ContentElement.LostTouchCapture" />ルーティング イベントにこの要素は、タッチのキャプチャを失ったときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.OnLostTouchCapture%2A>メソッドに既定の実装がありません。 オーバーライド<xref:System.Windows.ContentElement.OnLostTouchCapture%2A>を処理する派生クラスで、<xref:System.Windows.ContentElement.LostTouchCapture>イベント。 必ず、基本クラスの<xref:System.Windows.ContentElement.OnLostTouchCapture%2A>を基底クラス メソッドがイベントを受信します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDown">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、押されたマウス ボタンおよび処理済み状態に関する詳細を報告します。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Mouse.MouseDown" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 マウス ボタンの動作は、専用の入力マネージャーによっても処理されます。 その他のプログラミング機能の入力など、マウス ボタンの動作に依存し、バインディングのコマンドは、一般的なマウス ボタンの操作として公開される前に、アクションのハンドラーを呼び出す可能性があります。 これらの入力システム機能マーク場合、<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>イベントを処理するには、<xref:System.Windows.ContentElement.OnMouseDown%2A>は呼び出されません。  
  
 可能性のある、次のイベントに影響するイベントを処理済みとしてマークをこのクラスのハンドラーを使用する場合:<xref:System.Windows.ContentElement.MouseLeftButtonDown>と<xref:System.Windows.ContentElement.MouseRightButtonDown>です。 これらのイベントのいずれかは、受信側の要素で発生する可能性がありますと<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>を受信します。  
  
 このイベントを処理するクラスで処理済みのマークを付けた場合サブイベントも発生します。ただし、イベント データの処理済みの状態を通過するとします。 明示的に使用する場合を除き、サブイベントのインスタンス ハンドラーが呼び出されませんクラス処理でイベントを処理すると場合、<xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>で`handledEventsToo``true`ハンドラーをアタッチするためにします。 クラス ハンドラーも呼び出されないと、クラス ハンドラーが登録されていない限り、<xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>による署名`handledEventsToo``true`です。 処理することにより<xref:System.Windows.ContentElement.OnMouseDown%2A>処理の速度のすべての可能なマウス ボタンをクラス処理を記述することを示すは。 この動作が望ましくない可能性があります。そのため、この仮想メソッドを使用してイベントを処理済みとしてマークする場合は、注意を使用します。  
  
 各ボタンに固有の直接イベントもに、仮想 * メソッドです。かどうかこれらのボタンに固有のクラスのハンドラーをオーバーライドする場合がありますより適切な検討してください。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseEnter (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseEnter(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseEnter(System.Windows.Input.MouseEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>未処理のときに呼び出される<see cref="E:System.Windows.Input.Mouse.MouseEnter" />添付イベントがこの要素で発生します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。 呼び出すことが基本の前に、または後に特別な処理の要件に応じて、します。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、直接ルーティング戦略のルーティング イベントです。 標準的なインスタンス ハンドラーでも役立ちますが、イベントを処理済みとしてマーク (が指定されていないもの`handledEventsToo`) が呼び出されているからです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseLeave (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseLeave(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseLeave(System.Windows.Input.MouseEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>未処理のときに呼び出される<see cref="E:System.Windows.Input.Mouse.MouseLeave" />添付イベントがこの要素で発生します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。 呼び出すことが基本の前に、または後に特別な処理の要件に応じて、します。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、直接ルーティング戦略のルーティング イベントです。 標準的なインスタンス ハンドラーでも役立ちますが、イベントを処理済みとしてマーク (が指定されていないもの`handledEventsToo`) が呼び出されているからです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウスの左ボタンが押されたことを報告します。</param>
        <summary>未処理のときに呼び出される<see cref="E:System.Windows.ContentElement.MouseLeftButtonDown" />ルーティング イベントがこの要素で発生します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.MouseLeftButtonDown>イベントをバブルの経路を通るが表示されますが、間接的な方法で実際に移動します。 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>基になるイベントはバブル ルーティング、および各<xref:System.Windows.ContentElement>ルートが直接ルーティング イベントを発生させると同じ処理を使用、イベントに沿った<xref:System.Windows.ContentElement.MouseLeftButtonDown>です。 マークすることができますが、<xref:System.Windows.ContentElement.MouseLeftButtonDown>イベントをこの要素の目的の処理、処理済みの状態はイベント ルート上の他の要素は永続化されません。 イベントを全般インスタンス ハンドラーを防ぐために処理済みとしてマークするただし、(を指定しなかったもの`handledEventsToo`) が呼び出されているからです。  
  
 一般的なマウスのイベント処理の既定の実装<xref:System.Windows.ContentElement>リッスン<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>適切なローカル イベントに変換します。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクター内の代替クラス ハンドラーを登録<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>です。 マウスの処理の動作を変更することはできません<xref:System.Windows.ContentElement>オーバーライドすることで<xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>です。  
  
 代わりに、特定のマウスの状態のイベント処理を変更するためにこのメソッドをオーバーライドすることができます。 基本実装を呼び出すを選択するかどうかは、シナリオによって異なります。 呼び出すも期待する先祖のクラスでは、そのマウス イベントの既定の入力処理を無効に呼び出しに失敗<xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>です。 派生するなど、<xref:System.Windows.Controls.Button>オーバーライドと<xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>、基本実装を呼び出さずに、派生クラスでただし、この上書きを無効に、<xref:System.Windows.Controls.Primitives.ButtonBase.Click>イベント。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseLeftButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseLeftButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウスの左ボタンが放されたことを報告します。</param>
        <summary>未処理のときに呼び出される<see cref="E:System.Windows.ContentElement.MouseLeftButtonUp" />ルーティング イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.MouseLeftButtonUp>イベントをバブルの経路を通るが表示されますが、間接的な方法で実際に移動します。 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>基になるイベントはバブル ルーティング、および各<xref:System.Windows.ContentElement>ルートが直接ルーティング イベントを発生させると同じ処理を使用、イベントに沿った<xref:System.Windows.ContentElement.MouseLeftButtonUp>です。 マークすることができますが、<xref:System.Windows.ContentElement.MouseLeftButtonUp>イベントをこの要素の目的の処理、処理済みの状態はイベント ルート上の他の要素は永続化されません。 イベントを全般インスタンス ハンドラーを防ぐために処理済みとしてマークするただし、(を指定しなかったもの`handledEventsToo`) が呼び出されているからです。  
  
 一般的なマウスのイベント処理の既定の実装<xref:System.Windows.ContentElement>リッスン<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>適切なローカル イベントに変換します。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクター内の代替クラス ハンドラーを登録<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>です。 マウスの処理の動作を変更することはできません<xref:System.Windows.ContentElement>オーバーライドすることで<xref:System.Windows.ContentElement.OnMouseLeftButtonUp%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseMove">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseMove (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseMove(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseMove(System.Windows.Input.MouseEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Mouse.MouseMove" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseRightButtonDown">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseRightButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseRightButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウスの右ボタンが押されたことを報告します。</param>
        <summary>未処理のときに呼び出される<see cref="E:System.Windows.ContentElement.MouseRightButtonDown" />ルーティング イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.MouseRightButtonDown>イベントをバブルの経路を通るが表示されますが、間接的な方法で実際に移動します。 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>基になるイベントはバブル ルーティング、および各<xref:System.Windows.ContentElement>ルートが直接ルーティング イベントを発生させると同じ処理を使用、イベントに沿った<xref:System.Windows.ContentElement.MouseRightButtonDown>です。 マークすることができますが、<xref:System.Windows.ContentElement.MouseRightButtonDown>イベントをこの要素の目的の処理、処理済みの状態はイベント ルート上の他の要素は永続化されません。 イベントを全般インスタンス ハンドラーを防ぐために処理済みとしてマークするただし、(を指定しなかったもの`handledEventsToo`) が呼び出されているからです。  
  
 一般的なマウスのイベント処理の既定の実装<xref:System.Windows.ContentElement>リッスン<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>適切なローカル イベントに変換します。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクター内の代替クラス ハンドラーを登録<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>です。 マウスの処理の動作を変更することはできません<xref:System.Windows.ContentElement>オーバーライドすることで<xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>です。  
  
 代わりに、特定のマウスの状態のイベント処理を変更するためにこのメソッドをオーバーライドすることができます。 基本実装を呼び出すを選択するかどうかは、シナリオによって異なります。 呼び出すも期待する先祖のクラスでは、そのマウス イベントの既定の入力処理を無効に呼び出しに失敗<xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>です。 派生するなど、<xref:System.Windows.Controls.Control>オーバーライドと<xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>; 呼び出し元の基本せず、派生クラスでただし、この上書きが無効になります、コンテキスト メニュー上のサービス、コントロールに含まれるの<xref:System.Windows.Controls.Control>既定の動作です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseRightButtonUp">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseRightButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseRightButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウスの右ボタンが離されたことを報告します。</param>
        <summary>未処理のときに呼び出される<see cref="E:System.Windows.ContentElement.MouseRightButtonUp" />ルーティング イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.MouseRightButtonUp>イベントをバブルの経路を通るが表示されますが、間接的な方法で実際に移動します。 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>基になるイベントはバブル ルーティング、および各<xref:System.Windows.ContentElement>ルートが直接ルーティング イベントを発生させると同じ処理を使用、イベントに沿った<xref:System.Windows.ContentElement.MouseRightButtonUp>です。 マークすることができますが、<xref:System.Windows.ContentElement.MouseRightButtonUp>イベントをこの要素の目的の処理、処理済みの状態はイベント ルート上の他の要素は永続化されません。 イベントを全般インスタンス ハンドラーを防ぐために処理済みとしてマークするただし、(を指定しなかったもの`handledEventsToo`) が呼び出されているからです。  
  
 一般的なマウスのイベント処理の既定の実装<xref:System.Windows.ContentElement>リッスン<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>適切なローカル イベントに変換します。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクター内の代替クラス ハンドラーを登録<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>です。 マウスの処理の動作を変更することはできません<xref:System.Windows.ContentElement>オーバーライドすることで<xref:System.Windows.ContentElement.OnMouseRightButtonUp%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseUp">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウス ボタンが離されたことを報告します。</param>
        <summary>未処理のときに呼び出される<see cref="E:System.Windows.Input.Mouse.MouseUp" />ルーティング イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 マウス ボタンの動作は、専用の入力マネージャーによっても処理されます。 その他のプログラミング機能の入力など、マウス ボタンの動作に依存し、バインディングのコマンドは、一般的なマウス ボタンの操作として公開される前に、アクションのハンドラーを呼び出す可能性があります。 これらの入力システム機能マーク場合、<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>イベントを処理するには、<xref:System.Windows.ContentElement.OnMouseUp%2A>は呼び出されません。  
  
 可能性のある、次のイベントに影響するイベントを処理済みとしてマークをこのクラスのハンドラーを使用する場合:<xref:System.Windows.ContentElement.MouseLeftButtonUp>と<xref:System.Windows.ContentElement.MouseRightButtonUp>です。 これらのイベントのいずれかが受信側の要素に対して生成されるときに<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>を受信します。  
  
 このイベントを処理するクラスで処理済みのマークを付けた場合サブイベントも発生します。ただし、イベント データの処理済みの状態を通過するとします。 明示的に使用する場合を除き、サブイベントのインスタンス ハンドラーが呼び出されませんクラス処理でイベントを処理すると場合、<xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>で`handledEventsToo``true`ハンドラーをアタッチするためにします。 クラス ハンドラーも呼び出されないと、クラス ハンドラーが登録されていない限り、<xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>による署名`handledEventsToo``true`です。 処理することにより<xref:System.Windows.ContentElement.OnMouseUp%2A>操作をすべての可能なマウス ボタンをクラス処理を記述することを示すは。 この動作が望ましくない可能性があります。そのため、この仮想メソッドを使用してイベントを処理済みとしてマークする場合は、注意を使用します。  
  
 各ボタンに固有の直接イベントもに、仮想 * メソッドです。かどうかこれらのボタンに固有のクラスのハンドラーをオーバーライドする場合がありますより適切な検討してください。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseWheel">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseWheel (System.Windows.Input.MouseWheelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseWheel(class System.Windows.Input.MouseWheelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseWheelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseWheelEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Mouse.MouseWheel" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewDragEnter (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDragEnter(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewDragEnter(System.Windows.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.DragDrop.PreviewDragEnter" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。 プレビュー イベントを具体的には、もう 1 つのシナリオでは、マークして処理されるように、一致するバブル クラス ハンドラーは呼び出されません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewDragLeave (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDragLeave(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewDragLeave(System.Windows.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.DragDrop.PreviewDragLeave" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。 プレビュー イベントを具体的には、もう 1 つのシナリオでは、マークして処理されるように、一致するバブル クラス ハンドラーは呼び出されません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragOver">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewDragOver (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDragOver(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewDragOver(System.Windows.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.DragDrop.PreviewDragOver" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。 プレビュー イベントを具体的には、もう 1 つのシナリオでは、マークして処理されるように、一致するバブル クラス ハンドラーは呼び出されません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDrop">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewDrop (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDrop(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewDrop(System.Windows.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.DragDrop.PreviewDrop" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。 プレビュー イベントを具体的には、もう 1 つのシナリオでは、マークして処理されるように、一致するバブル クラス ハンドラーは呼び出されません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewGiveFeedback">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewGiveFeedback (System.Windows.GiveFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewGiveFeedback(class System.Windows.GiveFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.GiveFeedbackEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.DragDrop.PreviewGiveFeedback" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。 プレビュー イベントを具体的には、もう 1 つのシナリオでは、マークして処理されるように、一致するバブル クラス ハンドラーは呼び出されません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewGotKeyboardFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewGotKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewGotKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。 プレビュー イベントを具体的には、もう 1 つのシナリオでは、マークして処理されるように、一致するバブル クラス ハンドラーは呼び出されません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.KeyEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。 プレビュー イベントを具体的には、もう 1 つのシナリオでは、マークして処理されるように、一致するバブル クラス ハンドラーは呼び出されません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewKeyUp (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewKeyUp(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.KeyEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Keyboard.PreviewKeyUp" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。 プレビュー イベントを具体的には、もう 1 つのシナリオでは、マークして処理されるように、一致するバブル クラス ハンドラーは呼び出されません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewLostKeyboardFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewLostKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewLostKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。 プレビュー イベントを具体的には、もう 1 つのシナリオでは、マークして処理されるように、一致するバブル クラス ハンドラーは呼び出されません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、1 つ以上のマウス ボタンが押されたことを報告します。</param>
        <summary>未処理のときに呼び出される<see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" />添付ルーティング イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 マウス ボタンの動作は、専用の入力マネージャーによっても処理されます。 その他のプログラミング機能の入力など、マウス ボタンの動作に依存し、バインディングのコマンドは、一般的なマウス ボタンの操作として公開される前に、アクションのハンドラーを呼び出す可能性があります。 これらの入力システム機能マーク場合、<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>イベントを処理するには、<xref:System.Windows.ContentElement.OnPreviewMouseDown%2A>は呼び出されません。  
  
 可能性のある、次のイベントに影響するイベントを処理済みとしてマークをこのクラスのハンドラーを使用する場合:<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>と<xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>です。 これらのイベントのいずれかは、受信側の要素で発生する可能性がありますと<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>を受信します。  
  
 このイベントを処理するクラスで処理済みのマークを付けた場合サブイベントも発生します。ただし、イベント データの処理済みの状態を通過するとします。 明示的に使用する場合を除き、サブイベントのインスタンス ハンドラーが呼び出されませんクラス処理でイベントを処理すると場合、<xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>で`handledEventsToo``true`ハンドラーをアタッチするためにします。 クラス ハンドラーも呼び出されないと、クラス ハンドラーが登録されていない限り、<xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>による署名`handledEventsToo``true`です。 処理することにより<xref:System.Windows.ContentElement.OnPreviewMouseDown%2A>処理の速度のすべての可能なマウス ボタンをクラス処理を記述することを示すは。 この動作が望ましくない可能性があります。そのため、この仮想メソッドを使用してイベントを処理済みとしてマークする場合は、注意を使用します。  
  
 各ボタンに固有の直接イベントもに、仮想 * メソッドです。かどうかこれらのボタンに固有のクラスのハンドラーをオーバーライドする場合がありますより適切な検討してください。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。 プレビュー イベントを具体的には、もう 1 つのシナリオでは、マークして処理されるように、一致するバブル クラス ハンドラーは呼び出されません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウスの左ボタンが押されたことを報告します。</param>
        <summary>未処理のときに呼び出される<see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" />ルーティング イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>イベントは、トンネリングのルートで伝送に見えますが、実際には、間接的な方法で移動します。 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>基になるイベントをルーティングすると、トンネルおよび各<xref:System.Windows.ContentElement>ルートが直接ルーティング イベントを発生させると同じ処理を使用、イベントに沿った<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>です。 マークすることができますが、<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>イベントをこの要素の目的の処理、処理済みの状態はイベント ルート上の他の要素は永続化されません。 イベントを全般インスタンス ハンドラーを防ぐために処理済みとしてマークするただし、(を指定しなかったもの`handledEventsToo`) が呼び出されているからです。  
  
 一般的なマウスのイベント処理の既定の実装<xref:System.Windows.ContentElement>リッスン<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>適切なローカル イベントに変換します。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクター内の代替クラス ハンドラーを登録<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>です。 マウスの処理の動作を変更することはできません<xref:System.Windows.ContentElement>オーバーライドすることで<xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>です。  
  
 代わりに、特定のマウスの状態のイベント処理を変更するためにこのメソッドをオーバーライドすることができます。 基本実装を呼び出すを選択するかどうかは、シナリオによって異なります。 呼び出すも期待する先祖のクラスでは、そのマウス イベントの既定の入力処理を無効に呼び出しに失敗<xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>です。 派生するなど、<xref:System.Windows.Controls.Button>オーバーライドと<xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>、基本実装を呼び出さずに、派生クラスでただし、この上書きを無効に、<xref:System.Windows.Controls.Primitives.ButtonBase.Click>イベント。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseLeftButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseLeftButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウスの左ボタンが放されたことを報告します。</param>
        <summary>未処理のときに呼び出される<see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" />ルーティング イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>イベントは、トンネリングのルートで伝送に見えますが、実際には、間接的な方法で移動します。 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>基になるイベントをルーティングすると、トンネルおよび各<xref:System.Windows.ContentElement>ルートが直接ルーティング イベントを発生させると同じ処理を使用、イベントに沿った<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>です。 マークすることができますが、<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>イベントをこの要素の目的の処理、処理済みの状態はイベント ルート上の他の要素は永続化されません。 イベントを全般インスタンス ハンドラーを防ぐために処理済みとしてマークするただし、(を指定しなかったもの`handledEventsToo`) が呼び出されているからです。  
  
 一般的なマウスのイベント処理の既定の実装<xref:System.Windows.ContentElement>リッスン<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>適切なローカル イベントに変換します。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクター内の代替クラス ハンドラーを登録<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>です。 マウスの処理の動作を変更することはできません<xref:System.Windows.ContentElement>オーバーライドすることで<xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseMove">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseMove (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseMove(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。 プレビュー イベントを具体的には、もう 1 つのシナリオでは、マークして処理されるように、一致するバブル クラス ハンドラーは呼び出されません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseRightButtonDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseRightButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseRightButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウスの右ボタンが押されたことを報告します。</param>
        <summary>未処理のときに呼び出される<see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" />ルーティング イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>イベントは、トンネリングのルートで伝送に見えますが、実際には、間接的な方法で移動します。 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>基になるイベントをルーティングすると、トンネルおよび各<xref:System.Windows.ContentElement>ルートが直接ルーティング イベントを発生させると同じ処理を使用、イベントに沿った<xref:System.Windows.ContentElement.MouseRightButtonDown>です。 マークすることができますが、<xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>イベントをこの要素の目的の処理、処理済みの状態はイベント ルート上の他の要素は永続化されません。 イベントを全般インスタンス ハンドラーを防ぐために処理済みとしてマークするただし、(を指定しなかったもの`handledEventsToo`) が呼び出されているからです。  
  
 一般的なマウスのイベント処理の既定の実装<xref:System.Windows.ContentElement>リッスン<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>適切なローカル イベントに変換します。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクター内の代替クラス ハンドラーを登録<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>です。 マウスの処理の動作を変更することはできません<xref:System.Windows.ContentElement>オーバーライドすることで<xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>です。  
  
 代わりに、特定のマウスの状態のイベント処理を変更するためにこのメソッドをオーバーライドすることができます。 基本実装を呼び出すを選択するかどうかは、シナリオによって異なります。 呼び出すも期待する先祖のクラスでは、そのマウス イベントの既定の入力処理を無効に呼び出しに失敗<xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>です。 派生するなど、<xref:System.Windows.Controls.Control>オーバーライドと<xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>; 呼び出し元の基本せず、派生クラスでただし、この上書きが無効になります、コンテキスト メニュー上のサービス、コントロールに含まれるの<xref:System.Windows.Controls.Control>既定の動作です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseRightButtonUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseRightButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseRightButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウスの右ボタンが離されたことを報告します。</param>
        <summary>未処理のときに呼び出される<see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" />ルーティング イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>イベントは、トンネリングのルートで伝送に見えますが、実際には、間接的な方法で移動します。 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>基になるイベントをルーティングすると、トンネルおよび各<xref:System.Windows.ContentElement>ルートが直接ルーティング イベントを発生させると同じ処理を使用、イベントに沿った<xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>です。 マークすることができますが、<xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>イベントをこの要素の目的の処理、処理済みの状態はイベント ルート上の他の要素は永続化されません。 イベントを全般インスタンス ハンドラーを防ぐために処理済みとしてマークするただし、(を指定しなかったもの`handledEventsToo`) が呼び出されているからです。  
  
 一般的なマウスのイベント処理の既定の実装<xref:System.Windows.ContentElement>リッスン<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>適切なローカル イベントに変換します。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクター内の代替クラス ハンドラーを登録<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>です。 マウスの処理の動作を変更することはできません<xref:System.Windows.ContentElement>オーバーライドすることで<xref:System.Windows.ContentElement.OnPreviewMouseRightButtonUp%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、1 つ以上のマウス ボタンが離されたことを報告します。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 マウス ボタンの動作は、専用の入力マネージャーによっても処理されます。 その他のプログラミング機能の入力など、マウス ボタンの動作に依存し、バインディングのコマンドは、一般的なマウス ボタンの操作として公開される前に、アクションのハンドラーを呼び出す可能性があります。 これらの入力システム機能マーク場合、<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>イベントを処理するには、<xref:System.Windows.ContentElement.OnPreviewMouseUp%2A>は呼び出されません。  
  
 可能性のある、次のイベントに影響するイベントを処理済みとしてマークをこのクラスのハンドラーを使用する場合:<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>と<xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>です。 これらのイベントのいずれかが受信側の要素に対して生成されるときに<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>を受信します。  
  
 このイベントを処理するクラスで処理済みのマークを付けた場合サブイベントも発生します。ただし、イベント データの処理済みの状態を通過するとします。 明示的に使用する場合を除き、サブイベントのインスタンス ハンドラーが呼び出されませんクラス処理でイベントを処理すると場合、<xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>で`handledEventsToo``true`ハンドラーをアタッチするためにします。 クラス ハンドラーも呼び出されないと、クラス ハンドラーが登録されていない限り、<xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>による署名`handledEventsToo``true`です。 処理することにより<xref:System.Windows.ContentElement.OnPreviewMouseUp%2A>操作をすべての可能なマウス ボタンをクラス処理を記述することを示すは。 この動作が望ましくない可能性があります。そのため、この仮想メソッドを使用してイベントを処理済みとしてマークする場合は、注意を使用します。  
  
 各ボタンに固有の直接イベントもに、仮想 * メソッドです。かどうかこれらのボタンに固有のクラスのハンドラーをオーバーライドする場合がありますより適切な検討してください。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseWheel">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseWheel (System.Windows.Input.MouseWheelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseWheel(class System.Windows.Input.MouseWheelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseWheelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseWheelEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。 プレビュー イベントを具体的には、もう 1 つのシナリオでは、マークして処理されるように、一致するバブル クラス ハンドラーは呼び出されません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewQueryContinueDrag (System.Windows.QueryContinueDragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewQueryContinueDrag(class System.Windows.QueryContinueDragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.QueryContinueDragEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.DragDrop.PreviewQueryContinueDrag" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。 プレビュー イベントを具体的には、もう 1 つのシナリオでは、マークして処理されるように、一致するバブル クラス ハンドラーは呼び出されません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusButtonDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusButtonDown (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusButtonDown(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonDown" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。 プレビュー イベントを具体的には、もう 1 つのシナリオでは、マークして処理されるように、一致するバブル クラス ハンドラーは呼び出されません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusButtonUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusButtonUp (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusButtonUp(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonUp" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。 プレビュー イベントを具体的には、もう 1 つのシナリオでは、マークして処理されるように、一致するバブル クラス ハンドラーは呼び出されません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusDown (System.Windows.Input.StylusDownEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusDown(class System.Windows.Input.StylusDownEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusDownEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusDownEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusDown" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。 プレビュー イベントを具体的には、もう 1 つのシナリオでは、マークして処理されるように、一致するバブル クラス ハンドラーは呼び出されません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusInAirMove">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusInAirMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusInAirMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusInAirMove" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。 プレビュー イベントを具体的には、もう 1 つのシナリオでは、マークして処理されるように、一致するバブル クラス ハンドラーは呼び出されません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusInRange">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusInRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusInRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusInRange" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。 プレビュー イベントを具体的には、もう 1 つのシナリオでは、マークして処理されるように、一致するバブル クラス ハンドラーは呼び出されません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusMove">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusMove" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。 プレビュー イベントを具体的には、もう 1 つのシナリオでは、マークして処理されるように、一致するバブル クラス ハンドラーは呼び出されません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusOutOfRange">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusOutOfRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusOutOfRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusOutOfRange" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。 プレビュー イベントを具体的には、もう 1 つのシナリオでは、マークして処理されるように、一致するバブル クラス ハンドラーは呼び出されません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusSystemGesture">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusSystemGesture (System.Windows.Input.StylusSystemGestureEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusSystemGesture(class System.Windows.Input.StylusSystemGestureEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusSystemGestureEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusSystemGesture" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。 プレビュー イベントを具体的には、もう 1 つのシナリオでは、マークして処理されるように、一致するバブル クラス ハンドラーは呼び出されません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusUp (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusUp(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusUp" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。 プレビュー イベントを具体的には、もう 1 つのシナリオでは、マークして処理されるように、一致するバブル クラス ハンドラーは呼び出されません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTextInput">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewTextInput (System.Windows.Input.TextCompositionEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTextInput(class System.Windows.Input.TextCompositionEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TextCompositionEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TextCompositionEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.TextCompositionManager.PreviewTextInput" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。 プレビュー イベントを具体的には、もう 1 つのシナリオでは、マークして処理されるように、一致するバブル クラス ハンドラーは呼び出されません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewTouchDown (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTouchDown(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewTouchDown(System.Windows.Input.TouchEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>クラスの処理を提供、<see cref="E:System.Windows.ContentElement.PreviewTouchDown" />タッチは、この要素を押したときに発生するイベントをルーティングします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A>メソッドに既定の実装がありません。 オーバーライド<xref:System.Windows.ContentElement.OnPreviewTouchDown%2A>を処理する派生クラスで、<xref:System.Windows.ContentElement.PreviewTouchDown>イベント。 必ず、基本クラスの<xref:System.Windows.ContentElement.OnPreviewTouchDown%2A>を基底クラス メソッドがイベントを受信します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchMove">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewTouchMove (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTouchMove(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewTouchMove(System.Windows.Input.TouchEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>クラス処理を提供、<see cref="E:System.Windows.ContentElement.PreviewTouchMove" />タッチは、この要素の中に内部動かしたときに発生するイベントをルーティングします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A>メソッドに既定の実装がありません。 オーバーライド<xref:System.Windows.ContentElement.OnPreviewTouchMove%2A>を処理する派生クラスで、<xref:System.Windows.ContentElement.PreviewTouchMove>イベント。 必ず、基本クラスの<xref:System.Windows.ContentElement.OnPreviewTouchMove%2A>を基底クラス メソッドがイベントを受信します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewTouchUp (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTouchUp(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewTouchUp(System.Windows.Input.TouchEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>クラスの処理を提供、<see cref="E:System.Windows.ContentElement.PreviewTouchUp" />タッチがこの要素内にリリースされたときに発生するイベントをルーティングします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A>メソッドに既定の実装がありません。 オーバーライド<xref:System.Windows.ContentElement.OnPreviewTouchUp%2A>を処理する派生クラスで、<xref:System.Windows.ContentElement.PreviewTouchUp>イベント。 必ず、基本クラスの<xref:System.Windows.ContentElement.OnPreviewTouchUp%2A>を基底クラス メソッドがイベントを受信します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected virtual void OnQueryContinueDrag (System.Windows.QueryContinueDragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnQueryContinueDrag(class System.Windows.QueryContinueDragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.QueryContinueDragEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.DragDrop.QueryContinueDrag" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnQueryCursor">
      <MemberSignature Language="C#" Value="protected virtual void OnQueryCursor (System.Windows.Input.QueryCursorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnQueryCursor(class System.Windows.Input.QueryCursorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.QueryCursorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.QueryCursorEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Mouse.QueryCursor" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStylusButtonDown">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusButtonDown (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusButtonDown(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.StylusButtonDown" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStylusButtonUp">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusButtonUp (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusButtonUp(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.StylusButtonUp" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStylusDown">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusDown (System.Windows.Input.StylusDownEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusDown(class System.Windows.Input.StylusDownEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusDown(System.Windows.Input.StylusDownEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusDownEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusDownEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.StylusDown" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStylusEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusEnter (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusEnter(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusEnter(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>未処理のときに呼び出される<see cref="E:System.Windows.Input.Stylus.StylusEnter" />添付イベントがこの要素で発生します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。 呼び出すことが基本の前に、または後に特別な処理の要件に応じて、します。  
  
 このメソッドの目的はのような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 通常のインスタンス ハンドラーを禁止する場合にも役立ちますが、イベントを処理済みとしてマーク (が指定されていないもの`handledEventsToo`) が呼び出されているからです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStylusInAirMove">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusInAirMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusInAirMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusInAirMove(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.StylusInAirMove" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStylusInRange">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusInRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusInRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusInRange(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.StylusInRange" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStylusLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusLeave (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusLeave(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusLeave(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>未処理のときに呼び出される<see cref="E:System.Windows.Input.Stylus.StylusLeave" />添付イベントがこの要素で発生します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。 呼び出すことが基本の前に、または後に特別な処理の要件に応じて、します。  
  
 このメソッドの目的はのような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 通常のインスタンス ハンドラーを禁止する場合にも役立ちますが、イベントを処理済みとしてマーク (が指定されていないもの`handledEventsToo`) が呼び出されているからです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStylusMove">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusMove(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.StylusMove" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStylusOutOfRange">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusOutOfRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusOutOfRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.StylusOutOfRange" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStylusSystemGesture">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusSystemGesture (System.Windows.Input.StylusSystemGestureEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusSystemGesture(class System.Windows.Input.StylusSystemGestureEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusSystemGestureEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.StylusSystemGesture" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStylusUp">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusUp (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusUp(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusUp(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.StylusUp" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTextInput">
      <MemberSignature Language="C#" Value="protected virtual void OnTextInput (System.Windows.Input.TextCompositionEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTextInput(class System.Windows.Input.TextCompositionEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTextInput(System.Windows.Input.TextCompositionEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TextCompositionEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TextCompositionEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.TextCompositionManager.TextInput" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。 そのため、実装には、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントを reraise にはいけません。  
  
 ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。 イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchDown">
      <MemberSignature Language="C#" Value="protected virtual void OnTouchDown (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchDown(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchDown(System.Windows.Input.TouchEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>クラス処理を提供、<see cref="E:System.Windows.ContentElement.TouchDown" />タッチがこの要素の内部を押したときに発生するイベントをルーティングします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.OnTouchDown%2A>メソッドに既定の実装がありません。 オーバーライド<xref:System.Windows.ContentElement.OnTouchDown%2A>を処理する派生クラスで、<xref:System.Windows.ContentElement.TouchDown>イベント。 必ず、基本クラスの<xref:System.Windows.ContentElement.OnTouchDown%2A>を基底クラス メソッドがイベントを受信します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnTouchEnter (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchEnter(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchEnter(System.Windows.Input.TouchEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>クラスの処理を提供、<see cref="E:System.Windows.ContentElement.TouchEnter" />タッチから移動するときに発生するルーティング イベントをこの要素の境界内の外部です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.OnTouchEnter%2A>メソッドに既定の実装がありません。 オーバーライド<xref:System.Windows.ContentElement.OnTouchEnter%2A>を処理する派生クラスで、<xref:System.Windows.ContentElement.TouchEnter>イベント。 必ず、基本クラスの<xref:System.Windows.ContentElement.OnTouchEnter%2A>を基底クラス メソッドがイベントを受信します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnTouchLeave (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchLeave(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchLeave(System.Windows.Input.TouchEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>クラスの処理を提供、<see cref="E:System.Windows.ContentElement.TouchLeave" />タッチから移動するときに発生するルーティング イベントをこの要素の境界の外側の内部です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.OnTouchLeave%2A>メソッドに既定の実装がありません。 オーバーライド<xref:System.Windows.ContentElement.OnTouchLeave%2A>を処理する派生クラスで、<xref:System.Windows.ContentElement.TouchLeave>イベント。 必ず、基本クラスの<xref:System.Windows.ContentElement.OnTouchLeave%2A>を基底クラス メソッドがイベントを受信します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchMove">
      <MemberSignature Language="C#" Value="protected virtual void OnTouchMove (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchMove(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchMove(System.Windows.Input.TouchEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>クラス処理を提供、<see cref="E:System.Windows.ContentElement.TouchMove" />タッチは、この要素の中に内部動かしたときに発生するイベントをルーティングします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.OnTouchMove%2A>メソッドに既定の実装がありません。 オーバーライド<xref:System.Windows.ContentElement.OnTouchMove%2A>を処理する派生クラスで、<xref:System.Windows.ContentElement.TouchMove>イベント。 必ず、基本クラスの<xref:System.Windows.ContentElement.OnTouchMove%2A>を基底クラス メソッドがイベントを受信します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchUp">
      <MemberSignature Language="C#" Value="protected virtual void OnTouchUp (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchUp(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchUp(System.Windows.Input.TouchEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>クラスの処理を提供、<see cref="E:System.Windows.ContentElement.TouchUp" />タッチがこの要素内にリリースされたときに発生するイベントをルーティングします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.OnTouchUp%2A>メソッドに既定の実装がありません。 オーバーライド<xref:System.Windows.ContentElement.OnTouchUp%2A>を処理する派生クラスで、<xref:System.Windows.ContentElement.TouchUp>イベント。 必ず、基本クラスの<xref:System.Windows.ContentElement.OnTouchUp%2A>を基底クラス メソッドがイベントを受信します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public virtual System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction">要求されたフォーカスの移動の方向です。</param>
        <summary>派生クラスでオーバーライドされると、実際にその要素にフォーカスを移動しなくても指定したフォーカスの移動方向をフォーカスを受け取る要素を返します。</summary>
        <returns>要素がフォーカスを受け取った場合<see cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />が実際に呼び出されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このクラスでこのメソッドの既定の実装は完了せず、常に返します`null`です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewDragEnter" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素をドラッグ先とする、基になるドラッグ イベントが入力システムによって報告されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.PreviewDragEnter>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewDragEnter>イベントが、基になるに関連付けられている<xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewDragEnter"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewDragEnterEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.DragEventHandler>|  
  
-   バブルの対応するイベントが<xref:System.Windows.ContentElement.DragEnter>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnPreviewDragEnter%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewDragEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewDragEnter" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewDragLeave" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>入力システムが、この要素をドラッグ元とする、基になるドラッグ イベントを報告したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.PreviewDragLeave>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewDragLeave>イベントが、基になるに関連付けられている<xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewDragLeave"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewDragLeaveEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.DragEventHandler>|  
  
-   バブルの対応するイベントが<xref:System.Windows.ContentElement.DragLeave>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnPreviewDragLeave%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewDragLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewDragLeave" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewDragOver" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がドロップ先となる可能性のある、基になるドラッグ イベントを入力システムが報告したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.PreviewDragOver>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewDragOver>イベントが、基になるに関連付けられている<xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewDragOver"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewDragOverEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.DragEventHandler>|  
  
-   バブルの対応するイベントが<xref:System.Windows.ContentElement.DragOver>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnPreviewDragOver%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragOverEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragOverEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragOverEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewDragOverEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewDragOver" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDrop">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDrop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDrop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewDrop" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>入力システムがこの要素をドロップ先とするドロップ イベントを報告したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.PreviewDrop>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewDrop>イベントが、基になるに関連付けられている<xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewDrop"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewDropEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.DragEventHandler>|  
  
-   バブルの対応するイベントが<xref:System.Windows.ContentElement.Drop>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnPreviewDrop%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDropEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDropEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDropEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewDropEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewDrop" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.GiveFeedbackEventHandler PreviewGiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.GiveFeedbackEventHandler PreviewGiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewGiveFeedback" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ドラッグ アンド ドロップ操作が開始されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.PreviewGiveFeedback>イベントにより、ドラッグ アンド ドロップ操作中にユーザーに視覚的フィードバックを提供するためにマウス ポインターの外観を変更するドラッグ イベントのソース。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.PreviewGiveFeedback>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewGiveFeedback>イベントが、基になるに関連付けられている<xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewGiveFeedback"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewGiveFeedbackEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.GiveFeedbackEventHandler>|  
  
-   バブルの対応するイベントが<xref:System.Windows.ContentElement.GiveFeedback>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnPreviewGiveFeedback%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGiveFeedbackEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewGiveFeedbackEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewGiveFeedbackEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewGiveFeedbackEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewGiveFeedback" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGotKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler PreviewGotKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler PreviewGotKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にキーボード フォーカスが移動したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、ルーティング トンネリングを使用するため、フォーカスを持つ要素は、イベント ハンドラーが実際に添付されている要素ではなく子要素である可能性があります。 チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>フォーカスのある実際の要素を特定のイベント データ。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.PreviewGotKeyboardFocus>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewGotKeyboardFocus>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewGotKeyboardFocus"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewGotKeyboardFocusEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   バブルの対応するイベントが<xref:System.Windows.ContentElement.GotKeyboardFocus>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnPreviewGotKeyboardFocus%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGotKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewGotKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewGotKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewGotKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler PreviewKeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler PreviewKeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewKeyDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にキーボード フォーカスがある状態でいずれかのキーが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キーの処理は、コマンド実行やテキストの合成などの他のプラットフォーム機能と対話します。 <xref:System.Windows.ContentElement.KeyDown>イベントは、下位レベルのテキスト入力イベントを特定のコントロールで期待どおりに動作しない可能性があります。 これは、一部のコントロールがコントロールの複合か、テキストの上位レベルのバージョンを提供するクラスの処理が処理を入力し、関連するイベントです。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.PreviewKeyDown>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewKeyDown>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewKeyDown"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewKeyDownEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   バブルの対応するイベントが<xref:System.Windows.ContentElement.KeyDown>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnPreviewKeyDown%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewKeyDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewKeyDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewKeyDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewKeyDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler PreviewKeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler PreviewKeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewKeyUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にキーボード フォーカスがある状態でキーが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キーの処理は、コマンド実行やテキストの合成などの他のプラットフォーム機能と対話します。 <xref:System.Windows.ContentElement.KeyUp>イベントは、下位レベルのテキスト入力イベントを特定のコントロールで期待どおりに動作しない可能性があります。 これは、一部のコントロールがコントロールの複合か、テキストの上位レベルのバージョンを提供するクラスの処理が処理を入力し、関連するイベントです。 詳細については、個々 のコントロールのマニュアルを確認します。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.PreviewKeyUp>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewKeyUp>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewKeyUp"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewKeyUpEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   バブルの対応するイベントが<xref:System.Windows.ContentElement.KeyUp>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnPreviewKeyUp%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewKeyUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewKeyUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewKeyUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewKeyUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewLostKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler PreviewLostKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler PreviewLostKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素からキーボード フォーカスが離れたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、ルーティング トンネリングを使用しているために、フォーカスを失った要素は、イベント ハンドラーが実際に添付されている、要素ではなく子要素である可能性があります。 チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>フォーカスが失われた実際の要素を特定のイベント データ。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewLostKeyboardFocus"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewLostKeyboardFocusEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   バブルの対応するイベントが<xref:System.Windows.ContentElement.LostKeyboardFocus>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnPreviewLostKeyboardFocus%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewLostKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewLostKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewLostKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewLostKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にポインターがある状態でマウス ボタンが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.PreviewMouseDown>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewMouseDown>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
 <xref:System.Windows.ContentElement.PreviewMouseDown>イベントは、多くの場合、いずれかと共に<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>または<xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>、2 つの標準のマウス ボタンのいずれかのキーを押してに対応します。 <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown><xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>も、ルーティング イベントをしています直接ルーティング イベントを適切なボタンに固有のイベントが発生したときに、<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>イベント イベント ルート上には、この要素に到達します。 「解説」を参照してください<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>または<xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>です。  
  
<a name="routedEventInfo_PreviewMouseDown"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewMouseDownEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   バブルの対応するイベントが<xref:System.Windows.ContentElement.MouseDown>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnPreviewMouseDown%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewMouseDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でマウスの左ボタンが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この[ルーティング イベントの概要](~/docs/framework/wpf/advanced/routed-events-overview.md)、要素ツリーを通じてトンネリングのルートに従うように見えますが発生し、各によって、要素ツリーに沿って reraised を直接ルーティング イベントを実際には<xref:System.Windows.ContentElement>します。  
  
 このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの 1 つ<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>イベント ルート上の各要素によって処理される添付イベントがイベント。  
  
 このイベントの引数を公開、基になる引数<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>イベント。 そのイベントがイベント ルート上処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります<xref:System.Windows.ContentElement.AddHandler%2A>、処理済みとしてマークされているイベントを処理する、イベント リスナーをするために、オプションを使用します。  
  
 概念的には、このイベントの待ち時間 (やその他のマウス ボタンのイベントに<xref:System.Windows.ContentElement>) マウス「サービス」である (によって提供される、サービス定義で、<xref:System.Windows.Input.Mouse>クラス)。 イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 (左から右に、アップダウン) を確認する必要はないの利便性を追加します。 非標準のボタンの状態のチェックなどの高度なシナリオを使用する必要があります、[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上、<xref:System.Windows.Input.Mouse>ものではなくクラスに対する<xref:System.Windows.ContentElement>です。  
  
<a name="routedEventInfo_PreviewMouseLeftButtonDown"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDownEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseLeftButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseLeftButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseLeftButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でマウスの左ボタンが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この[ルーティング イベントの概要](~/docs/framework/wpf/advanced/routed-events-overview.md)、要素ツリーを通じてトンネリングのルートに従うように見えますが発生し、各によって、要素ツリーに沿って reraised を直接ルーティング イベントを実際には<xref:System.Windows.ContentElement>します。  
  
 このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの 1 つ<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>イベント ルート上の各要素によって処理される添付イベントがイベント。  
  
 このイベントの引数を公開、基になる引数<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>イベント。 そのイベントがイベント ルート上処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります<xref:System.Windows.ContentElement.AddHandler%2A>、処理済みとしてマークされているイベントを処理する、イベント リスナーをするために、オプションを使用します。  
  
 概念的には、このイベントの待ち時間 (やその他のマウス ボタンのイベントに<xref:System.Windows.ContentElement>) マウス「サービス」である (によって提供される、サービス定義で、<xref:System.Windows.Input.Mouse>クラス)。 イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 (左から右に、アップダウン) を確認する必要はないの利便性を追加します。 非標準のボタンの状態のチェックなどの高度なシナリオを使用する必要があります、[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上、<xref:System.Windows.Input.Mouse>ものではなくクラスに対する<xref:System.Windows.ContentElement>です。  
  
<a name="routedEventInfo_PreviewMouseLeftButtonUp"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUpEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseLeftButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseLeftButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseLeftButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler PreviewMouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler PreviewMouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseMove" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素上でマウス ポインターが動かされたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、どちらも要素の境界にマウス ポインターを最初に入力し、マウス ポインターが要素の境界内に残っているときに移動するともします。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.PreviewMouseMove>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewMouseMove>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewMouseMove"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewMouseMoveEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   バブルの対応するイベントが<xref:System.Windows.ContentElement.MouseMove>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnPreviewMouseMove%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewMouseMove" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でマウスの右ボタンが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この[ルーティング イベントの概要](~/docs/framework/wpf/advanced/routed-events-overview.md)、要素ツリーを通じてトンネリングのルートに従うように見えますが発生し、各によって、要素ツリーに沿って reraised を直接ルーティング イベントを実際には<xref:System.Windows.ContentElement>します。  
  
 このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの 1 つ<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>イベント ルート上の各要素によって処理される添付イベントがイベント。  
  
 このイベントの引数を公開、基になる引数<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>イベント。 そのイベントがイベント ルート上処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります<xref:System.Windows.ContentElement.AddHandler%2A>、処理済みとしてマークされているイベントを処理する、イベント リスナーをするために、オプションを使用します。  
  
 概念的には、このイベントの待ち時間 (やその他のマウス ボタンのイベントに<xref:System.Windows.ContentElement>) マウス「サービス」である (によって提供される、サービス定義で、<xref:System.Windows.Input.Mouse>クラス)。 イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 (左から右に、アップダウン) を確認する必要はないの利便性を追加します。 非標準のボタンの状態のチェックなどの高度なシナリオを使用する必要があります、[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上、<xref:System.Windows.Input.Mouse>ものではなくクラスに対する<xref:System.Windows.ContentElement>です。  
  
<a name="routedEventInfo_PreviewMouseRightButtonDown"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewMouseRightButtonDownEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseRightButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseRightButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseRightButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でマウスの右ボタンが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この[ルーティング イベントの概要](~/docs/framework/wpf/advanced/routed-events-overview.md)、要素ツリーを通じてトンネリングのルートに従うように見えますが発生し、各によって、要素ツリーに沿って reraised を直接ルーティング イベントを実際には<xref:System.Windows.ContentElement>します。  
  
 このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの 1 つ<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>イベント ルート上の各要素によって処理される添付イベントがイベント。  
  
 このイベントの引数を公開、基になる引数<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>イベント。 そのイベントがイベント ルート上処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります<xref:System.Windows.ContentElement.AddHandler%2A>、処理済みとしてマークされているイベントを処理する、イベント リスナーをするために、オプションを使用します。  
  
 概念的には、このイベントの待ち時間 (やその他のマウス ボタンのイベントに<xref:System.Windows.ContentElement>) マウス「サービス」である (によって提供される、サービス定義で、<xref:System.Windows.Input.Mouse>クラス)。 イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 (左から右に、アップダウン) を確認する必要はないの利便性を追加します。 非標準のボタンの状態のチェックなどの高度なシナリオを使用する必要があります、[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上、<xref:System.Windows.Input.Mouse>ものではなくクラスに対する<xref:System.Windows.ContentElement>です。  
  
<a name="routedEventInfo_PreviewMouseRightButtonUp"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewMouseRightButtonUpEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnPreviewMouseRightButtonUp%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseRightButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseRightButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseRightButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でいずれかのマウス ボタンが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.PreviewMouseUp>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewMouseUp>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
 <xref:System.Windows.ContentElement.PreviewMouseUp>イベントは、多くの場合、いずれかと共に<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>または<xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>、2 つの標準のマウス ボタンのいずれかのキーを押してに対応します。 <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp><xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>も、ルーティング イベントをしています直接ルーティング イベントを適切なボタンに固有のイベントが発生したときに、<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>イベント イベント ルート上には、この要素に到達します。 「解説」を参照してください<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>または<xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>です。  
  
<a name="routedEventInfo_PreviewMouseUp"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewMouseUpEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   バブルの対応するイベントが<xref:System.Windows.ContentElement.MouseUp>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnPreviewMouseUp%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewMouseUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheel">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseWheelEventHandler PreviewMouseWheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseWheelEventHandler PreviewMouseWheel" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseWheel" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseWheelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でユーザーがマウス ホイールを使用したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 フォーカスまたはマウスのキャプチャ、マウス ポインターが; よりも優先します。このため、対象を絞ったまたはキャプチャした要素からこのイベントを受信する場合、マウス ポインター実際にあります別の要素上です。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.PreviewMouseMove>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewMouseMove>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewMouseWheel"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewMouseWheelEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   バブルの対応するイベントが<xref:System.Windows.ContentElement.MouseWheel>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnPreviewMouseWheel%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseWheelEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewMouseWheel" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewQueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.QueryContinueDragEventHandler PreviewQueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.QueryContinueDragEventHandler PreviewQueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewQueryContinueDrag" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ドラッグ アンド ドロップ操作の実行中にキーボードまたはマウス ボタンの状態が変化したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.PreviewQueryContinueDrag>イベントにより、ドラッグ ソースがドラッグ アンド ドロップ操作を取り消す必要があるかどうかを宣言します。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.PreviewQueryContinueDrag>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewQueryContinueDrag>イベントが、基になるに関連付けられている<xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewQueryContinueDrag"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewQueryContinueDragEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.QueryContinueDragEventHandler>|  
  
-   バブルの対応するイベントが<xref:System.Windows.ContentElement.QueryContinueDrag>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnPreviewQueryContinueDrag%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewQueryContinueDragEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewQueryContinueDragEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewQueryContinueDragEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewQueryContinueDragEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewQueryContinueDrag" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusButtonDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にポインターがある状態でスタイラス ボタンが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.PreviewStylusButtonDown>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewStylusButtonDown>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。  
  
<a name="routedEventInfo_PreviewStylusButtonDown"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewStylusButtonDownEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   バブルの対応するイベントが<xref:System.Windows.ContentElement.StylusButtonDown>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnPreviewStylusButtonDown%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewStylusButtonDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusButtonUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にポインターがある状態でスタイラス ボタンが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.PreviewStylusButtonUp>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewStylusButtonUp>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。  
  
<a name="routedEventInfo_PreviewStylusButtonUp"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewStylusButtonUpEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   バブルの対応するイベントが<xref:System.Windows.ContentElement.StylusButtonUp>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnPreviewStylusButtonUp%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewStylusButtonUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusDownEventHandler PreviewStylusDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusDownEventHandler PreviewStylusDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusDownEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素上でスタイラスがデジタイザーに触れたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.PreviewStylusDown>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewStylusDown>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。  
  
<a name="routedEventInfo_PreviewStylusDown"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewStylusDownEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.StylusDownEventHandler>|  
  
-   バブルの対応するイベントが<xref:System.Windows.ContentElement.StylusDown>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnPreviewStylusDown%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewStylusDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInAirMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusInAirMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusInAirMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusInAirMove" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>実際には、デジタイザーに触れることがなく要素上でスタイラスを動かしたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.PreviewStylusInAirMove>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewStylusInAirMove>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。  
  
<a name="routedEventInfo_PreviewStylusInAirMove"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewStylusInAirMoveEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   バブルの対応するイベントが<xref:System.Windows.ContentElement.StylusInAirMove>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnPreviewStylusInAirMove%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInAirMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusInAirMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusInAirMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusInAirMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusInRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusInRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusInRange" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタイラスがこの要素上で検出されるまでデジタイザーに近づいたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.PreviewStylusInRange>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewStylusInRange>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。  
  
<a name="routedEventInfo_PreviewStylusInRange"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewStylusInRangeEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   バブルの対応するイベントが<xref:System.Windows.ContentElement.StylusInRange>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnPreviewStylusInRange%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusInRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusInRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusInRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewStylusInRange" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusMove" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素上にある間にスタイラスが移動すると発生します。 それ以外の場合、このイベントを発生させる、デジタイザーによって検出されている間にスタイラスが移動する必要があります<see cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" />が代わりに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.PreviewStylusMove>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewStylusMove>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。  
  
<a name="routedEventInfo_PreviewStylusMove"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewStylusMoveEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   バブルの対応するイベントが<xref:System.Windows.ContentElement.StylusMove>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnPreviewStylusMove%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewStylusMove" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusOutOfRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusOutOfRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusOutOfRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusOutOfRange" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタイラスがデジタイザーから離れすぎているために検出されないときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.PreviewStylusOutOfRange>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewStylusOutOfRange>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。  
  
<a name="routedEventInfo_PreviewStylusOutOfRange"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewStylusOutOfRangeEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   バブルの対応するイベントが<xref:System.Windows.ContentElement.StylusOutOfRange>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnPreviewStylusOutOfRange%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusOutOfRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusOutOfRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusOutOfRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusOutOfRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewStylusOutOfRange" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusSystemGesture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusSystemGestureEventHandler PreviewStylusSystemGesture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusSystemGestureEventHandler PreviewStylusSystemGesture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusSystemGesture" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusSystemGestureEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーがいずれかのスタイラス ジェスチャを実行したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 スタイラス ジェスチャの詳細については、次を参照してください。<xref:System.Windows.Input.SystemGesture>です。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.PreviewStylusSystemGesture>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewStylusSystemGesture>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。  
  
<a name="routedEventInfo_PreviewStylusSystemGesture"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewStylusSystemGestureEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.StylusSystemGestureEventHandler>|  
  
-   バブルの対応するイベントが<xref:System.Windows.ContentElement.StylusSystemGesture>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnPreviewStylusSystemGesture%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusSystemGestureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusSystemGestureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusSystemGestureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusSystemGestureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewStylusSystemGesture" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にスタイラスが、ユーザーがスタイラスをデジタイザーから離れたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.PreviewStylusDown>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewStylusDown>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。  
  
<a name="routedEventInfo_PreviewStylusUp"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewStylusUpEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   バブルの対応するイベントが<xref:System.Windows.ContentElement.StylusUp>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnPreviewStylusUp%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewStylusUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTextInput">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.TextCompositionEventHandler PreviewTextInput;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.TextCompositionEventHandler PreviewTextInput" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewTextInput" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.TextCompositionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がデバイスに依存しない方法でテキストを取得したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.PreviewTextInput>イベントにより、コンポーネントまたはアプリケーションをデバイスに依存しない方法で、テキスト入力をリッスンします。 キーボードは、主要な手段の<xref:System.Windows.ContentElement.PreviewTextInput>; が、音声認識、手書き認識、およびその他の入力デバイスも<xref:System.Windows.ContentElement.PreviewTextInput>します。  
  
 キーの組み合わせのため、既定のキーボードまたは入力方式エディターから — 複数のキー イベントが 1 つだけのテキスト入力イベントを発生させる可能性があります。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.PreviewTextInput>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewTextInput>イベントが、基になるに関連付けられている<xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewTextInput"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewTextInputEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.TextCompositionEventHandler>|  
  
-   バブルの対応するイベントが<xref:System.Windows.ContentElement.TextInput>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnPreviewTextInput%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTextInputEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTextInputEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTextInputEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewTextInputEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewTextInput" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchDown">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewTouchDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指がこの要素の上にある間に、その指で画面に触れると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定では、<xref:System.Windows.ContentElement.PreviewTouchDown>と<xref:System.Windows.ContentElement.TouchDown>指が画面に触れるし、移動するまでのイベントが発生しません。 画面に指を押すと、キーを押すと、移動せずに保持しているとの動作を保持する<xref:System.Windows.Input.Stylus>です。 プレス アンド ホールド動作は、マウスの右クリックに相当します。  
  
 により、<xref:System.Windows.ContentElement.PreviewTouchDown>と<xref:System.Windows.ContentElement.TouchDown>、画面に触れると発生するイベントを設定、<xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType>添付プロパティ`false`この要素のです。  
  
<a name="routedEventInfo_PreviewTouchDown"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewTouchDownEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.EventHandler%601>型の<xref:System.Windows.Input.TouchEventArgs>します。|  
  
-   バブルの対応するイベントが<xref:System.Windows.ContentElement.TouchDown>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnPreviewTouchDown%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewTouchDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewTouchDown" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchMove">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewTouchMove" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上に指があるときに、その指を画面上で動かすと発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_PreviewTouchMove"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewTouchMoveEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.EventHandler%601>型の<xref:System.Windows.Input.TouchEventArgs>します。|  
  
-   バブルの対応するイベントが<xref:System.Windows.ContentElement.TouchMove>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnPreviewTouchMove%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewTouchMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewTouchMove" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchUp">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewTouchUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上に指があるときに、その指が画面から離れると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_PreviewTouchUp"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewTouchUpEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.EventHandler%601>型の<xref:System.Windows.Input.TouchEventArgs>します。|  
  
-   バブルの対応するイベントが<xref:System.Windows.ContentElement.TouchUp>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnPreviewTouchUp%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewTouchUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewTouchUp" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.QueryContinueDragEventHandler QueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.QueryContinueDragEventHandler QueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.QueryContinueDrag" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ドラッグ アンド ドロップ操作の実行中にキーボードまたはマウス ボタンの状態が変化したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.QueryContinueDrag>イベントにより、ドラッグ ソースがドラッグ アンド ドロップ操作を取り消す必要があるかどうかを判断します。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.QueryContinueDrag>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.QueryContinueDrag>イベントが、基になるに関連付けられている<xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_QueryContinueDrag"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.QueryContinueDragEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.QueryContinueDragEventHandler>|  
  
-   対応するトンネリング イベントが<xref:System.Windows.ContentElement.PreviewQueryContinueDrag>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnQueryContinueDrag%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDragEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent QueryContinueDragEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent QueryContinueDragEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.QueryContinueDragEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.QueryContinueDrag" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryCursor">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.QueryCursorEventHandler QueryCursor;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.QueryCursorEventHandler QueryCursor" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.QueryCursor" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.QueryCursorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>カーソルの表示が要求されると発生します。 このイベントは、マウス ポインターが別の位置へ移動するたびに要素上で発生します。したがって、場合によってはカーソル オブジェクトを移動先の位置に基づいて変更する必要があります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.QueryCursor>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.QueryCursor>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
 このイベント名によって参照されているカーソルは、必ずしも (カーソルとも呼ばれる) テキストのカーソルではありません。 代わりに、いくつかの可能な入力に関連するデバイスまたはの概念に関連する画面上のグラフィカル表示を宣言するオブジェクトは、このコンテキストでのカーソル[!INCLUDE[TLA2#tla_win](~/includes/tla2sharptla-win-md.md)]プログラミングします。 そのオブジェクトがによって表される、<xref:System.Windows.Input.Cursor>クラス[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]です。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]入力システムでは、マウス ポインターの画面上の位置を表す場合は、このカーソルを変更することができます。 定義済みの値を使用することができます、<xref:System.Windows.Input.Cursors>列挙型、または画像ファイルとしてカスタム カーソルを宣言できます。  
  
 リッスンして、<xref:System.Windows.ContentElement.QueryCursor>イベントは、カーソル管理の効率的な方法ではありません。 各要素がで独自のカーソル動作を定義する代わりに、<xref:System.Windows.FrameworkContentElement.Cursor%2A>と<xref:System.Windows.FrameworkContentElement.ForceCursor%2A>です。 のみに依存する必要があります<xref:System.Windows.ContentElement.QueryCursor>かどうか WPF フレームワーク レベルの基本要素を使用していないまたはで特別な状況での要素ごとにカーソルの動作を定義するニーズを満たしていない、します。 応答でのカーソルの動作の実装の詳細については<xref:System.Windows.ContentElement.QueryCursor>を参照してください<xref:System.Windows.Input.QueryCursorEventHandler>です。  
  
<a name="routedEventInfo_QueryCursor"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.QueryCursorEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.QueryCursorEventHandler>|  
  
-   対応する定義済みのトンネリング イベントはありません。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnQueryCursor%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryCursorEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent QueryCursorEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent QueryCursorEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.QueryCursorEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.QueryCursor" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaiseEvent">
      <MemberSignature Language="C#" Value="public void RaiseEvent (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RaiseEvent(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A<see cref="T:System.Windows.RoutedEventArgs" />イベント データを格納しても発生させるイベントを識別します。</param>
        <summary>特定のルーティング イベントを発生させます。 <see cref="T:System.Windows.RoutedEvent" />内で識別されるときに生成される、<see cref="T:System.Windows.RoutedEventArgs" />提供されているインスタンス (として、<see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />そのイベント データのプロパティ)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `e`ルーティング イベントのすべてのデータの共通の基本型として型指定されたパラメーターです。 ただし、ために発生するイベントに使用される最も固有のイベント データの種類として、イベント データを指定してください<xref:System.Windows.RoutedEventArgs>派生クラスには、特定のイベントが発生するとは、特定の実際のデータ プロパティが含まれています。  
  
 <xref:System.Windows.RoutedEventArgs>イベントの状態のプロパティだけではありません。ルーティング イベントを発生させるも識別します。 このイベント発生パターンと、ルーティングされたイベント データの両方が異なる[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベントに関連するプロパティを通常だけが含まれるイベントやデータのクラスです。  
  
   
  
## Examples  
 次の例は、イベント データを作成、データをイベントの識別子を追加して、インスタンスを使用して、イベント データをカスタム ルーティング イベントを発生させます。  
  
 [!code-csharp[ContentElementsSmorgasbord#RaiseEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#raiseevent)]
 [!code-vb[ContentElementsSmorgasbord#RaiseEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#raiseevent)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseAllTouchCaptures">
      <MemberSignature Language="C#" Value="public void ReleaseAllTouchCaptures ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseAllTouchCaptures() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ReleaseAllTouchCaptures" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この要素からすべてのキャプチャされたタッチ デバイスを解放します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMouseCapture">
      <MemberSignature Language="C#" Value="public void ReleaseMouseCapture ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseMouseCapture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ReleaseMouseCapture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この要素には、キャプチャが保持されている場合は、マウスのキャプチャを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この要素がキャプチャを保持していない場合は、このメソッドを呼び出すも効果はありません。 値を確認してください<xref:System.Windows.ContentElement.IsMouseCaptured%2A>このメソッドを呼び出す前にします。  
  
   
  
## Examples  
 次のハンドラーは、キャプチャまたはマウス ボタンの状態に従ってマウス キャプチャを解放します。 例マウス ポインターを移動するよりもその他の代替手段が目的でキャプチャされたマウスの動きを使用する方法を示します、[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]です。  
  
 [!code-csharp[ContentElementsSmorgasbord#UIElementMouseCapture](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/Trackball.cs#uielementmousecapture)]
 [!code-vb[ContentElementsSmorgasbord#UIElementMouseCapture](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/trackball.vb#uielementmousecapture)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseStylusCapture">
      <MemberSignature Language="C#" Value="public void ReleaseStylusCapture ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseStylusCapture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ReleaseStylusCapture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この要素には、キャプチャが保持されている場合は、スタイラス デバイスのキャプチャを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この要素がキャプチャを保持していない場合は、このメソッドを呼び出すも効果はありません。 値を確認してください<xref:System.Windows.ContentElement.IsStylusCaptured%2A>このメソッドを呼び出す前にします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseTouchCapture">
      <MemberSignature Language="C#" Value="public bool ReleaseTouchCapture (System.Windows.Input.TouchDevice touchDevice);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReleaseTouchCapture(class System.Windows.Input.TouchDevice touchDevice) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ReleaseTouchCapture(System.Windows.Input.TouchDevice)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="touchDevice" Type="System.Windows.Input.TouchDevice" />
      </Parameters>
      <Docs>
        <param name="touchDevice">解放するデバイスです。</param>
        <summary>この要素から指定したタッチ デバイスを解放しようとしています。</summary>
        <returns>
          <see langword="true" />タッチ デバイスを放した場合です。それ以外の場合、<see langword="false" />です。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="touchDevice" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveHandler">
      <MemberSignature Language="C#" Value="public void RemoveHandler (System.Windows.RoutedEvent routedEvent, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="routedEvent">ハンドラーがアタッチされているルーティング イベントの識別子。</param>
        <param name="handler">この要素のイベント ハンドラー コレクションから削除する特定のハンドラー実装。</param>
        <summary>指定したルーティング イベント ハンドラーをこの要素から削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これを使用するための最も一般的なシナリオ[!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)]を実装する場合は、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]カスタム ルーティング イベントのハンドラーの削除」ロジックを実装するときに特に関連付けられている「ラッパー」イベント、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]レベル。 これを次の例「解説」セクションでは、このシナリオを示しています。  
  
 このメソッドを呼び出しても何も起こりませんメソッドの呼び出しの入力パラメーターに一致する条件で登録されたハンドラーがない場合。  
  
 数より多い場合に、イベント ハンドラーのストアの削除に最初のハンドラーのみ、条件に一致する 1 つのハンドラーがアタッチされます。 この動作は整合[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]の動作、`-=`演算子。  
  
 どちらも`routedEvent`も`handler`あります`null`です。 いずれかの値として提供しようとしています。`null`で例外が発生します。  
  
 このメソッドは無視、`handledEventsToo`場合は、ハンドラーが最初に提供されているパラメーターについては、追加、<xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>処理済みのイベントの処理を有効に署名します。 ハンドラーのいずれかの型が削除されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeCommandBindings">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeCommandBindings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeCommandBindings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ShouldSerializeCommandBindings" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>シリアル化プロセスでの内容をシリアル化する必要かどうかを返します、<see cref="P:System.Windows.ContentElement.CommandBindings" />このクラスのインスタンスのプロパティです。</summary>
        <returns>
          <see langword="true" /> プロパティ値をシリアル化する必要がある場合は <see cref="P:System.Windows.ContentElement.CommandBindings" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これは、戻り値は`true`場合<xref:System.Windows.ContentElement.CommandBindings%2A>ローカルに設定します。  
  
 これは、`ShouldSerialize`ためメソッドが用意されて、<xref:System.Windows.UIElement.CommandBindings%2A>プロパティには、単純な既定値にありません。 このメソッドは、既定値から、プロパティが変更されたかどうかを示します。 デザイナーを開発またはコントロールを組み込む独自の開発する場合に通常、このメソッドが呼び出す、<xref:System.Windows.UIElement>です。  
  
 詳細については、次を参照してください。 [ShouldSerialize メソッドとメソッドのリセットを既定値を定義する](~/docs/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods.md)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeInputBindings">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeInputBindings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeInputBindings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ShouldSerializeInputBindings" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>シリアル化プロセスでの内容をシリアル化する必要かどうかを返します、<see cref="P:System.Windows.ContentElement.InputBindings" />このクラスのインスタンスのプロパティです。</summary>
        <returns>
          <see langword="true" /> プロパティ値をシリアル化する必要がある場合は <see cref="P:System.Windows.ContentElement.InputBindings" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これは、戻り値は`true`場合<xref:System.Windows.ContentElement.InputBindings%2A>ローカルに設定します。  
  
 これは、`ShouldSerialize`ためメソッドが用意されて、<xref:System.Windows.UIElement.InputBindings%2A>プロパティには、単純な既定値にありません。 このメソッドは、既定値から、プロパティが変更されたかどうかを示します。 デザイナーを開発またはコントロールを組み込む独自の開発する場合に通常、このメソッドが呼び出す、<xref:System.Windows.UIElement>です。  
  
 詳細については、次を参照してください。 [ShouldSerialize メソッドとメソッドのリセットを既定値を定義する](~/docs/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods.md)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler StylusButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler StylusButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusButtonDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にポインターがある状態でスタイラス ボタンが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.StylusButtonDown>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.StylusButtonDown>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。  
  
<a name="routedEventInfo_StylusButtonDown"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.StylusButtonDownEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   対応するトンネリング イベントが<xref:System.Windows.ContentElement.PreviewStylusButtonDown>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnStylusButtonDown%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.StylusButtonDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler StylusButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler StylusButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusButtonUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にポインターがある状態でスタイラス ボタンが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.StylusButtonUp>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.StylusButtonUp>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。  
  
<a name="routedEventInfo_StylusButtonUp"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.StylusButtonUpEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   対応するトンネリング イベントが<xref:System.Windows.ContentElement.PreviewStylusButtonUp>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnStylusButtonUp%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.StylusButtonUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusDownEventHandler StylusDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusDownEventHandler StylusDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusDownEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタイラスがこの要素上でスタイラスがデジタイザーに触れたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.StylusDown>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.StylusDown>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。  
  
<a name="routedEventInfo_StylusDown"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.StylusDownEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusDownEventHandler>|  
  
-   対応するトンネリング イベントが<xref:System.Windows.ContentElement.PreviewStylusDown>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnStylusDown%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.StylusDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusEnter" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタイラスがこの要素の境界内に入ったときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.StylusEnter>[ルーティング イベントの概要](~/docs/framework/wpf/advanced/routed-events-overview.md)直接イベント ルーティング方法の処理を使用します。 ルート; 直接ルーティングされたイベントは発生しません代わりが処理される同じ要素では、発生します。 ただし、スタイルでのイベント トリガーなどのルーティング イベントの動作の他の側面を有効にする、操作を行います。  
  
 <xref:System.Windows.ContentElement.StylusEnter>スタイラスがこのイベントをさらに、要素の境界に入った時点を追跡するレポート文字どおり、<xref:System.Windows.ContentElement.IsStylusOver%2A>からプロパティ値が変更された`false`に`true`この要素上です。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.StylusEnter>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.StylusEnter>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。  
  
<a name="routedEventInfo_StylusEnter"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.StylusEnterEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnStylusEnter%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.StylusEnter" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInAirMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusInAirMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusInAirMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusInAirMove" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>実際には、デジタイザーに触れることがなく要素上でスタイラスを動かしたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.StylusInAirMove>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.StylusInAirMove>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。  
  
<a name="routedEventInfo_StylusInAirMove"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.StylusInAirMoveEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するトンネリング イベントが<xref:System.Windows.ContentElement.PreviewStylusInAirMove>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnStylusInAirMove%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInAirMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusInAirMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusInAirMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusInAirMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.StylusInAirMove" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusInRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusInRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusInRange" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタイラスがこの要素上で検出されるまでデジタイザーに近づいたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.StylusInRange>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.StylusInRange>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。  
  
<a name="routedEventInfo_StylusInRange"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.StylusInRangeEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するトンネリング イベントが<xref:System.Windows.ContentElement.PreviewStylusInRange>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnStylusInRange%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusInRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusInRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusInRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.StylusInRange" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusLeave" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタイラスが要素の境界内から出たときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.StylusLeave>[ルーティング イベントの概要](~/docs/framework/wpf/advanced/routed-events-overview.md)直接イベント ルーティング方法の処理を使用します。 ルート; 直接ルーティングされたイベントは発生しません代わりが処理される同じ要素では、発生します。 ただし、スタイルでのイベント トリガーなどのルーティング イベントの動作の他の側面を有効にする、操作を行います。  
  
 <xref:System.Windows.ContentElement.StylusLeave>スタイラス境界から出た要素、このイベントの詳細時点を追跡するレポート文字どおり、<xref:System.Windows.ContentElement.IsStylusOver%2A>からプロパティ値が変更された`true`に`false`この要素上です。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.StylusLeave>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.StylusLeave>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。  
  
<a name="routedEventInfo_StylusLeave"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.StylusLeaveEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnStylusLeave%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.StylusLeave" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusMove" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタイラスがこの要素上を移動すると発生します。 このイベントを発生させるには、デジタイザー上でスタイラスを移動する必要があります。 それ以外の場合、<see cref="E:System.Windows.ContentElement.StylusInAirMove" />が代わりに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.StylusMove>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.StylusMove>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。  
  
<a name="routedEventInfo_StylusMove"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.StylusMoveEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するトンネリング イベントが<xref:System.Windows.ContentElement.PreviewStylusMove>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnStylusMove%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.StylusMove" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusOutOfRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusOutOfRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusOutOfRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusOutOfRange" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタイラスがこの要素上で、検出されたデジタイザーから離れすぎているときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.StylusOutOfRange>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.StylusOutOfRange>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。  
  
<a name="routedEventInfo_StylusOutOfRange"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.StylusOutOfRangeEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するトンネリング イベントが<xref:System.Windows.ContentElement.PreviewStylusOutOfRange>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnStylusOutOfRange%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusOutOfRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusOutOfRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusOutOfRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusOutOfRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.StylusOutOfRange" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusSystemGesture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusSystemGestureEventHandler StylusSystemGesture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusSystemGestureEventHandler StylusSystemGesture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusSystemGesture" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusSystemGestureEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーがいずれかのスタイラス ジェスチャを実行したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 スタイラス ジェスチャの詳細については、次を参照してください。<xref:System.Windows.Input.SystemGesture>です。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.StylusSystemGesture>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.StylusSystemGesture>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。  
  
<a name="routedEventInfo_StylusSystemGesture"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.StylusSystemGestureEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusSystemGestureEventHandler>|  
  
-   対応するトンネリング イベントが<xref:System.Windows.ContentElement.PreviewStylusSystemGesture>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnStylusSystemGesture%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusSystemGestureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusSystemGestureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusSystemGestureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusSystemGestureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.StylusSystemGesture" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素上で、ユーザーがスタイラスをデジタイザーから離れたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.StylusUp>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.StylusUp>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。  
  
<a name="routedEventInfo_StylusUp"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.StylusUpEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するトンネリング イベントが<xref:System.Windows.ContentElement.PreviewStylusUp>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnStylusUp%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.StylusUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextInput">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.TextCompositionEventHandler TextInput;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.TextCompositionEventHandler TextInput" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TextInput" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.TextCompositionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がデバイスに依存しない方法でテキストを取得したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  このイベントは、複合コントロールの内部実装によって処理済みとして既にマーク可能性があります。 以下の解説を参照してください。  
  
 <xref:System.Windows.ContentElement.TextInput>イベントは、複合コントロールの内部実装によって処理済みとして既にマーク可能性があります。 たとえば、<xref:System.Windows.Controls.TextBox>複合コントロールは、ここで、<xref:System.Windows.ContentElement.TextInput>イベントが処理済みとして以外の場合は、合成内に既にマークされています。 コントロールは、コントロールがいくつかの種類のコントロールに特別な意味を持つものとして、方向キーなどの入力を解釈する必要があります。 使用する場合<xref:System.Windows.ContentElement.PreviewTextInput>テキスト入力用のハンドラーをアタッチするイベント、としてより良い結果を受け取ることがあります。 この手法は、コントロールの複合ハンドル済みとしては、このイベントをマークが既にあり、ハンドラーがイベント ルート上でイベントを受信できないように、ほとんどの場合を回避できます。  
  
 <xref:System.Windows.ContentElement.TextInput>イベントにより、コンポーネントまたはアプリケーションをデバイスに依存しない方法で、テキスト入力をリッスンします。 キーボードは、主要な手段の<xref:System.Windows.ContentElement.TextInput>、音声認識、手書き認識、およびその他の入力デバイス上げることもできますが、<xref:System.Windows.ContentElement.TextInput>です。  
  
 キーの組み合わせが原因: 既定のキーボードまたは入力方式エディターから — 複数のキー イベントが 1 つのテキスト入力イベントを発生させる可能性があります。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.TextInput>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.TextInput>イベントが、基になるに関連付けられている<xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_TextInput"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.TextInputEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.TextCompositionEventHandler>|  
  
-   対応するトンネリング イベントが<xref:System.Windows.ContentElement.PreviewTextInput>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnTextInput%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextInputEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TextInputEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TextInputEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TextInputEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.TextInput" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>です。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、次を参照してください。<xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchDown">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指がこの要素の上にある間に、その指で画面に触れると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定では、<xref:System.Windows.ContentElement.PreviewTouchDown>と<xref:System.Windows.ContentElement.TouchDown>指が画面に触れるし、移動するまでのイベントが発生しません。 画面に指を押すと、キーを押すと、移動せずに保持しているとの動作を保持する<xref:System.Windows.Input.Stylus>です。 プレス アンド ホールド動作は、マウスの右クリックに相当します。  
  
 により、<xref:System.Windows.ContentElement.PreviewTouchDown>と<xref:System.Windows.ContentElement.TouchDown>、画面に触れると発生するイベントを設定、<xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType>添付プロパティ`false`この要素のです。  
  
<a name="routedEventInfo_TouchDown"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.TouchDownEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.EventHandler%601>型の<xref:System.Windows.Input.TouchEventArgs>します。|  
  
-   対応するトンネリング イベントが<xref:System.Windows.ContentElement.PreviewTouchDown>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnTouchDown%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.TouchDown" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchEnter">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchEnter" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>タッチから移動するときに発生するこの要素の境界内の外部です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントはこの UI 要素にタッチ デバイスがキャプチャされるかどうか常に発生します。  
  
<a name="routedEventInfo_TouchEnter"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.TouchEnterEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.EventHandler%601>型の<xref:System.Windows.Input.TouchEventArgs>します。|  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnTouchEnter%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.TouchEnter" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesCaptured">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.TouchesCaptured" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にキャプチャされているすべてのタッチ デバイスを取得します。</summary>
        <value>列挙体<see cref="T:System.Windows.Input.TouchDevice" />をこの要素にキャプチャされているオブジェクト。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesCapturedWithin">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesCapturedWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesCapturedWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.TouchesCapturedWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>そのビジュアル ツリー内には、この要素にキャプチャされているすべてのタッチ デバイスまたはすべての子要素を取得します。</summary>
        <value>列挙体<see cref="T:System.Windows.Input.TouchDevice" />この要素またはそのビジュアル ツリー内のすべての子要素にキャプチャされているオブジェクト。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesDirectlyOver">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.TouchesDirectlyOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にあるすべてのタッチ デバイスを取得します。</summary>
        <value>列挙体<see cref="T:System.Windows.Input.TouchDevice" />この要素の上にあるオブジェクト。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesOver">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.TouchesOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>そのビジュアル ツリー内には、この要素の上にあるすべてのタッチ デバイスまたはすべての子要素を取得します。</summary>
        <value>列挙体<see cref="T:System.Windows.Input.TouchDevice" />この要素またはそのビジュアル ツリー内のすべての子要素の上にあるオブジェクト。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchLeave">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchLeave" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>タッチから移動するときに発生するこの要素の境界の外側の内部です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_TouchLeave"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.TouchLeaveEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.EventHandler%601>型の<xref:System.Windows.Input.TouchEventArgs>します。|  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnTouchLeave%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.TouchLeave" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchMove">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchMove" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上に指があるときに、その指を画面上で動かすと発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_TouchMove"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.TouchMoveEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.EventHandler%601>型の<xref:System.Windows.Input.TouchEventArgs>します。|  
  
-   対応するトンネリング イベントが<xref:System.Windows.ContentElement.PreviewTouchMove>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnTouchMove%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.TouchMove" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchUp">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上に指があるときに、その指が画面から離れると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_TouchUp"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.TouchUpEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.EventHandler%601>型の<xref:System.Windows.Input.TouchEventArgs>します。|  
  
-   対応するトンネリング イベントが<xref:System.Windows.ContentElement.PreviewTouchUp>です。  
  
-   オーバーライド<xref:System.Windows.ContentElement.OnTouchUp%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.TouchUp" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
