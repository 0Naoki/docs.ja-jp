<Type Name="Encoder" FullName="System.Text.Encoder">
  <TypeSignature Language="C#" Value="public abstract class Encoder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Encoder extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Text.Encoder" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>文字のセットをバイトのシーケンスに変換します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 実装のインスタンスを取得する、<xref:System.Text.Encoder>クラス、アプリケーションで使用する必要があります、<xref:System.Text.Encoding.GetEncoder%2A>のメソッド、<xref:System.Text.Encoding>実装します。  
  
 <xref:System.Text.Encoder.GetByteCount%2A>メソッドでは、Unicode 文字のセットをエンコードで発生するまでのバイト数を決定し、<xref:System.Text.Encoder.GetBytes%2A>メソッドでは、実際のエンコードを実行します。 いくつかのバージョンのどちらの方法で使用できる、<xref:System.Text.Encoder>クラスです。 詳細については、「<xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType>」を参照してください。  
  
 A<xref:System.Text.Encoder>オブジェクトは、連続する呼び出しの間の状態情報を保持`GetBytes`または<xref:System.Text.Decoder.Convert%2A>ことは正しくエンコードできますので、メソッドのブロックをまたぐシーケンスの文字です。 <xref:System.Text.Encoder>末尾が保存されますが、データ ブロックの最後の文字し、末尾の文字を使用して、次のエンコード操作もします。 たとえば、データ ブロックが上位サロゲートで終了し、一致する下位サロゲートが [次へ] のデータ ブロック内にある可能性があります。 したがって、<xref:System.Text.Encoding.GetDecoder%2A>と<xref:System.Text.Encoding.GetEncoder%2A>の完全なデータ ストリームではなくデータ ブロックを頻繁にこれらの操作を処理するためにネットワーク転送、ファイル操作に便利です。  
  
> [!NOTE]
>  データを設定して、状態情報がフラッシュされることを確認が必要がありますのストリームをアプリケーションが完了すると、`flush`パラメーターを`true`適切なメソッドの呼び出しで。 例外が発生したかを呼び出してストリームをアプリケーションに切り替え場合、<xref:System.Text.Encoder.Reset%2A>の内部状態をクリアする、`Encoder`オブジェクト。  
  
## <a name="version-considerations"></a>バージョンの考慮事項  
 A<xref:System.Text.Decoder>または<xref:System.Text.Encoder>変換操作中に、オブジェクトをシリアル化することができます。 オブジェクトの状態が同じ .NET Framework のバージョンで逆シリアル化される場合、保持は、別のバージョンで逆シリアル化される場合を失われます。  
  
   
  
## Examples  
 次の例では、指定されたエンコーディングを使用してバイトのブロックに Unicode 文字の配列を変換する方法を示します。 比較については、文字の配列は、まずを使用してエンコード<xref:System.Text.UTF7Encoding>です。 次に、文字の配列はエンコードを使用して、<xref:System.Text.Encoder>です。  
  
 [!code-cpp[System.Text.Encoder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoder Example/CPP/snippet.cpp#1)]
 [!code-csharp[System.Text.Encoder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoder Example/CS/snippet.cs#1)]
 [!code-vb[System.Text.Encoder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoder Example/VB/snippet.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>アプリケーションをこのクラスから継承するとき、すべてのメンバーをオーバーライドする必要があります。</para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Text.Encoder" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このクラスの実装のインスタンスを取得するアプリケーションを使用する必要があります、<xref:System.Text.Encoding.GetEncoder%2A>のメソッド、<xref:System.Text.Encoding>実装します。  
  
   
  
## Examples  
 次の例では、新しい初期化するための 2 つの手法<xref:System.Text.Encoder>インスタンス。  
  
 [!code-cpp[System.Text.Encoder.ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoder.ctor Example/CPP/ctor.cpp#1)]
 [!code-csharp[System.Text.Encoder.ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoder.ctor Example/CS/ctor.cs#1)]
 [!code-vb[System.Text.Encoder.ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoder.ctor Example/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public virtual void Convert (char* chars, int charCount, byte* bytes, int byteCount, bool flush, out int charsUsed, out int bytesUsed, out bool completed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Convert(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount, bool flush, [out] int32&amp; charsUsed, [out] int32&amp; bytesUsed, [out] bool&amp; completed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.Convert(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
        <Parameter Name="charsUsed" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="bytesUsed" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completed" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="chars">UTF-16 でエンコードされた変換対象の文字の文字列のアドレス。</param>
        <param name="charCount">文字数<c>chars</c>に変換します。</param>
        <param name="bytes">変換後のバイトを格納するバッファーのアドレス。</param>
        <param name="byteCount">内のバイトの最大数<c>バイト</c>変換に使用します。</param>
        <param name="flush">
          これ以上データの変換を行わないことを示す場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="charsUsed">このメソッドが戻るときからの文字の数を表す<c>chars</c>で変換に使用されました。 このパラメーターは初期化せずに渡されます。</param>
        <param name="bytesUsed">このメソッドから制御が戻るときに、変換に使用されたバイト数を格納します。 このパラメーターは初期化せずに渡されます。</param>
        <param name="completed">このメソッドが戻るときに、格納<see langword="true" />によってすべての文字が指定されている場合<c>charCount</c>された変換後、それ以外の<see langword="false" />します。 このパラメーターは初期化せずに渡されます。</param>
        <summary>バッファーに格納されている Unicode 文字をエンコード済みバイト シーケンスに変換し、その結果を別のバッファーに格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 注意して、<xref:System.Text.Encoder>オブジェクトへの呼び出しの間で状態を保存する<xref:System.Text.Encoder.Convert%2A>です。 これを設定する必要があります、アプリケーションでは、データ ストリームの処理が終わったら、`flush`パラメーターを`true`状態情報がフラッシュされるかどうかを確認します。 この設定では、エンコーダーは、データ ブロックの末尾に無効なバイトを無視し、内部バッファーをクリアします。 サロゲート ペアの上位サロゲートなどの論理ユニットの一部である残り処理後のデータは、現在のフォールバック設定に従って変換されます。  
  
 `Convert`メソッドが任意の量の入力のエンコードにはループ内で使用するように設計ファイルまたはストリームから読み取られるデータなどです。 エンコード操作の出力は、固定サイズのバッファーに格納します。 <xref:System.Text.Encoder.GetBytes%2A>出力バッファーが十分でない場合、例外がスローされますが、<xref:System.Text.Encoder.Convert%2A>は、できるだけ多くの領域を入力し、読み取りと書き込みバイト数の文字を返します。 参照してください、<xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType>詳細コメントのトピックです。  
  
 `completed`出力パラメーターは、入力バッファー内のすべてのデータが変換され、出力バッファーに格納されているかどうかを示します。 このパラメーターに設定されている`false`で文字の数が指定されている場合、`charCount`パラメーターによって指定されたバイト数を超えずに変換できません、`byteCount`パラメーター。 状況では、アプリケーション、出力バッファーの内容を使用か、新しい出力バッファーを提供インクリメント、`chars`パラメーターで指定された文字の数によって、`charsUsed`パラメーター、まず、`Convert`残りの入力を処理するには、もう一度メソッド。  
  
 `completed`パラメーターを設定することも`false`場合でも、`charsUsed`と`charCount`パラメーターが等しい。 内のデータが解決しない場合、このような状況が発生した、<xref:System.Text.Encoder>内に保存されていないオブジェクト、`chars`バッファー。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Text.Encoder.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" />or <paramref name="bytes" /> is <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> または <paramref name="byteCount" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">出力バッファーが小さすぎて、変換した入力を格納できません。 出力バッファーは、<see cref="Overload:System.Text.Encoder.GetByteCount" /> メソッドで示されるサイズ以上である必要があります。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました (を参照してください[.NET Framework の文字エンコーディング](~/docs/standard/base-types/character-encoding.md)の詳細について)  
  
 および  
  
 <see cref="P:System.Text.Encoder.Fallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public virtual void Convert (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex, int byteCount, bool flush, out int charsUsed, out int bytesUsed, out bool completed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Convert(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex, int32 byteCount, bool flush, [out] int32&amp; charsUsed, [out] int32&amp; bytesUsed, [out] bool&amp; completed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
        <Parameter Name="charsUsed" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="bytesUsed" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completed" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="chars">変換する文字の配列。</param>
        <param name="charIndex">最初の要素<c>chars</c>に変換します。</param>
        <param name="charCount">要素の数<c>chars</c>に変換します。</param>
        <param name="bytes">変換後のバイトを格納する配列。</param>
        <param name="byteIndex">最初の要素<c>バイト</c>どのデータを格納します。</param>
        <param name="byteCount">要素の最大数<c>バイト</c>変換に使用します。</param>
        <param name="flush">
          これ以上データの変換を行わないことを示す場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="charsUsed">このメソッドが戻るときからの文字の数を表す<c>chars</c>で変換に使用されました。 このパラメーターは初期化せずに渡されます。</param>
        <param name="bytesUsed">このメソッドから制御が戻るときに、変換の結果生成されたバイト数を格納します。 このパラメーターは初期化せずに渡されます。</param>
        <param name="completed">このメソッドが戻るときに、格納<see langword="true" />によってすべての文字が指定されている場合<c>charCount</c>された変換後、それ以外の<see langword="false" />します。 このパラメーターは初期化せずに渡されます。</param>
        <summary>Unicode 文字の配列をエンコード済みバイト シーケンスに変換し、その結果をバイト配列に格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 注意して、<xref:System.Text.Encoder>オブジェクトへの呼び出しの間で状態を保存する<xref:System.Text.Encoder.Convert%2A>です。 これを設定する必要があります、アプリケーションでは、データ ストリームの処理が終わったら、`flush`パラメーターを`true`状態情報がフラッシュされるかどうかを確認します。 この設定では、エンコーダーは、データ ブロックの末尾に無効なバイトを無視し、内部バッファーをクリアします。 サロゲート ペアの上位サロゲートなどの論理ユニットの一部である残り処理後のデータは、現在のフォールバック設定に従って変換されます。  
  
 `Convert`メソッドが、入力の任意の大きさをデコードするループ内で使用するため、ファイルまたはストリームから読み取られるデータなどです。 エンコード操作の出力は、固定サイズのバッファーに格納します。 <xref:System.Text.Encoder.GetBytes%2A>出力バッファーが十分でない場合、例外がスローされますが、<xref:System.Text.Encoder.Convert%2A>は、できるだけ多くの領域を入力し、読み取りと書き込みバイト数の文字を返します。 参照してください、<xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType>詳細コメントのトピックです。  
  
 `completed`出力パラメーターは、入力バッファー内のすべてのデータが変換され、出力バッファーに格納されているかどうかを示します。 このパラメーターに設定されている`false`で文字の数が指定されている場合、`charCount`パラメーターによって指定されたバイト数を超えずに変換できません、`byteCount`パラメーター。 状況では、アプリケーション、出力バッファーの内容を使用か、新しい出力バッファーを提供インクリメント、`chars`パラメーターで指定された文字の数によって、`charsUsed`パラメーター、まず、`Convert`残りの入力を処理するには、もう一度メソッド。  
  
 `completed`パラメーターを設定することも`false`場合でも、`charsUsed`と`charCount`パラメーターが等しい。 内のデータが解決しない場合、このような状況が発生した、<xref:System.Text.Encoder>内に保存されていないオブジェクト、`chars`バッファー。  
  
   
  
## Examples  
 次の例では、 <xref:System.Text.Encoder.Convert%2A> utf-16 のファイルに変換するメソッドが、utf-8 文字列の文字を使用して、 <xref:System.Text.Decoder.Convert%2A> utf-8 文字を utf-16 文字に変換します。  
  
 [!code-csharp[sys.txt.EncoderDecoder.convert#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.EncoderDecoder.convert/cs/edCvt.cs#1)]
 [!code-vb[sys.txt.EncoderDecoder.convert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.EncoderDecoder.convert/vb/edCvt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" />or <paramref name="bytes" /> is <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" />、<paramref name="charCount" />、<paramref name="byteIndex" />、または <paramref name="byteCount" /> が 0 未満です。  
  
 または  
  
 長さ<paramref name="chars" />  -  <paramref name="charIndex" />はより小さい<paramref name="charCount" />です。  
  
 または  
  
 長さ<paramref name="bytes" />  -  <paramref name="byteIndex" />はより小さい<paramref name="byteCount" />です。</exception>
        <exception cref="T:System.ArgumentException">出力バッファーが小さすぎて、変換した入力を格納できません。 出力バッファーは、<see cref="Overload:System.Text.Encoder.GetByteCount" /> メソッドで示されるサイズ以上である必要があります。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました (を参照してください[.NET Framework の文字エンコーディング](~/docs/standard/base-types/character-encoding.md)の詳細について)  
  
 および  
  
 <see cref="P:System.Text.Encoder.Fallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
      </Docs>
    </Member>
    <Member MemberName="Fallback">
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallback Fallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.EncoderFallback Fallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoder.Fallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.EncoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定、<see cref="T:System.Text.EncoderFallback" />現在のオブジェクト<see cref="T:System.Text.Encoder" />オブジェクト。</summary>
        <value><see cref="T:System.Text.EncoderFallback" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.EncoderFallback>オブジェクトは、文字をエンコード済みバイト シーケンスに変換できないときに呼び出されるエラー ハンドラーを表します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">セット操作の値は<see langword="null" />(<see langword="Nothing" />)。</exception>
        <exception cref="T:System.ArgumentException">設定操作で、新しい値を割り当てることができません現在<see cref="T:System.Text.EncoderFallbackBuffer" />オブジェクトには、まだエンコードされていないデータが含まれています。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました (を参照してください[.NET Framework の文字エンコーディング](~/docs/standard/base-types/character-encoding.md)の詳細について)  
  
 および  
  
 <see cref="P:System.Text.Encoder.Fallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
      </Docs>
    </Member>
    <Member MemberName="FallbackBuffer">
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallbackBuffer FallbackBuffer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.EncoderFallbackBuffer FallbackBuffer" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoder.FallbackBuffer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.EncoderFallbackBuffer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得、<see cref="T:System.Text.EncoderFallbackBuffer" />オブジェクトに現在関連付けられている<see cref="T:System.Text.Encoder" />オブジェクト。</summary>
        <value><see cref="T:System.Text.EncoderFallbackBuffer" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoder.FallbackBuffer%2A>オブジェクトによって使用されるデータを表す、<xref:System.Text.EncoderFallback>オブジェクト。 <xref:System.Text.EncoderFallback>オブジェクトは、文字をエンコード済みバイト シーケンスに変換できないときに呼び出されるエラー ハンドラーを表します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char* chars, int count, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char* chars, int32 count, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.GetByteCount(System.Char*,System.Int32,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="chars">エンコードする最初の文字へのポインター。</param>
        <param name="count">エンコードする文字数。</param>
        <param name="flush">
          <see langword="true" />計算の後に、エンコーダーの内部状態をクリアするをシミュレートするにはそれ以外の場合、<see langword="false" />です。</param>
        <summary>派生クラスでオーバーライドされた場合、指定した文字ポインターから始まる文字のセットをエンコードすることによって生成されるバイト数を計算します。 パラメーターでは、計算後に、エンコーダーの内部状態をクリアするかどうかを示します。</summary>
        <returns>指定した文字と内部バッファー内のすべての文字をエンコードすることによって生成されるバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、エンコーダーの状態には影響しません。  
  
 計算する正確な配列のサイズを<xref:System.Text.Encoder.GetBytes%2A>必要と結果のバイトを格納するアプリケーションを使用する必要があります<xref:System.Text.Encoder.GetByteCount%2A>です。  
  
 場合`GetBytes`で呼び出された`flush`'éý'`false`エンコーダーが内部バッファーにデータ ブロックの最後に末尾の文字を格納し、それらを次のエンコード操作で使用します。 アプリケーションを呼び出す必要があります`GetByteCount`呼び出す前にすぐにデータのブロックに`GetBytes`同じブロックのため、前のブロックから文字の後続のすべてが含まれている計算にします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /><see langword="null" /> (<see langword="Nothing" /> Visual Basic .NET で)。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> が 0 未満です。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました (を参照してください[.NET Framework の文字エンコーディング](~/docs/standard/base-types/character-encoding.md)の詳細について)  
  
 および  
  
 <see cref="P:System.Text.Encoder.Fallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetByteCount (char[] chars, int index, int count, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.GetByteCount(System.Char[],System.Int32,System.Int32,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="chars">エンコード対象の文字のセットを格納している文字配列。</param>
        <param name="index">エンコードする最初の文字のインデックス。</param>
        <param name="count">エンコードする文字数。</param>
        <param name="flush">
          <see langword="true" />計算の後に、エンコーダーの内部状態をクリアするをシミュレートするにはそれ以外の場合、<see langword="false" />です。</param>
        <summary>派生クラスでオーバーライドされた場合、指定した文字配列に格納されている文字のセットをエンコードすることによって生成されるバイト数を計算します。 パラメーターでは、計算後に、エンコーダーの内部状態をクリアするかどうかを示します。</summary>
        <returns>指定した文字と内部バッファー内のすべての文字をエンコードすることによって生成されるバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、エンコーダーの状態には影響しません。  
  
 計算する正確な配列のサイズを<xref:System.Text.Encoder.GetBytes%2A>必要と結果のバイトを格納するアプリケーションを使用する必要があります<xref:System.Text.Encoder.GetByteCount%2A>です。  
  
 場合`GetBytes`で呼び出された`flush`'éý'`false`エンコーダーが内部バッファーにデータ ブロックの最後に末尾の文字を格納し、それらを次のエンコード操作で使用します。 アプリケーションを呼び出す必要があります`GetByteCount`呼び出す前にすぐにデータのブロックに`GetBytes`同じブロックのため、前のブロックから文字の後続のすべてが含まれている計算にします。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています、<xref:System.Text.Encoder.GetByteCount%2A>メソッドを使用して、Unicode 文字の配列をエンコードするために必要なバイト数を返す<xref:System.Text.Encoder>です。  
  
 [!code-cpp[System.Text.Encoder.GetByteCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoder.GetByteCount Example/CPP/getbytecount-char[]-int32-int32.cpp#1)]
 [!code-csharp[System.Text.Encoder.GetByteCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoder.GetByteCount Example/CS/getbytecount-char[]-int32-int32.cs#1)]
 [!code-vb[System.Text.Encoder.GetByteCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoder.GetByteCount Example/VB/getbytecount-char[]-int32-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> または <paramref name="count" /> が 0 未満です。  
  
 または  
  
 <paramref name="index" /> および <paramref name="count" /> は <paramref name="chars" /> において有効な範囲を表していません。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました (を参照してください[.NET Framework の文字エンコーディング](~/docs/standard/base-types/character-encoding.md)の詳細について)  
  
 および  
  
 <see cref="P:System.Text.Encoder.Fallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (char* chars, int charCount, byte* bytes, int byteCount, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="chars">エンコードする最初の文字へのポインター。</param>
        <param name="charCount">エンコードする文字数。</param>
        <param name="bytes">結果のバイト シーケンスの書き込みを開始する位置へのポインター。</param>
        <param name="byteCount">書き込む最大バイト数。</param>
        <param name="flush">
          <see langword="true" />変換後に、エンコーダーの内部状態をクリアするにはそれ以外の場合、<see langword="false" />です。</param>
        <summary>派生クラスでオーバーライドされると、指定したバイト ポインターで始まる格納されるバイトのシーケンスに指定した文字ポインターと内部バッファー内のすべての文字で始まる文字のセットをエンコードします。 パラメーターでは、変換した後に、エンコーダーの内部状態をクリアするかどうかを示します。</summary>
        <returns><paramref name="bytes" /> パラメーターによって示される位置に書き込む実際のバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 注意して、<xref:System.Text.Encoder>オブジェクトへの呼び出しの間で状態を保存する<xref:System.Text.Encoder.GetBytes%2A>です。 これを設定する必要があります、アプリケーションでは、データ ストリームの処理が終わったら、`flush`パラメーターを`true`最後の呼び出しで`GetBytes`状態情報がフラッシュされると、エンコード済みバイトが正しく終了しているかどうかを確認します。 この設定では、エンコーダーは、一致しないサロゲートや不完全な結合順序など、データ ブロックの末尾に無効なバイトを無視し、内部バッファーをクリアします。  
  
 計算する正確なバッファーのサイズを`GetBytes`必要と結果の文字を格納するアプリケーションを使用する必要があります<xref:System.Text.Encoder.GetByteCount%2A>です。  
  
 場合`GetBytes`で呼び出された`flush`'éý'`false`エンコーダーが内部バッファーにデータ ブロックの末尾にある末尾バイトを格納し、それらを次のエンコード操作で使用します。 アプリケーションを呼び出す必要があります`GetByteCount`呼び出す前にすぐにデータのブロックに`GetBytes`同じブロックのため、前のブロックから文字の後続のすべてが含まれている計算にします。  
  
 入力ストリームの数のセグメントに変換する、アプリケーションがある場合は、使用を検討して、<xref:System.Text.Encoder.Convert%2A>メソッドです。 <xref:System.Text.Encoder.GetBytes%2A>出力バッファーが十分でない場合、例外がスローされますが、<xref:System.Text.Encoder.Convert%2A>は、できるだけ多くの領域を入力し、読み取りと書き込みバイト数の文字を返します。 参照してください、<xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType>詳細コメントのトピックです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" />is <see langword="null" /> (<see langword="Nothing" />).  
  
 または  
  
 <paramref name="bytes" />is <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> または <paramref name="byteCount" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="byteCount" />結果のバイト数未満です。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました (を参照してください[.NET Framework の文字エンコーディング](~/docs/standard/base-types/character-encoding.md)の詳細について)  
  
 および  
  
 <see cref="P:System.Text.Encoder.Fallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public abstract int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="chars">エンコード対象の文字のセットを格納している文字配列。</param>
        <param name="charIndex">エンコードする最初の文字のインデックス。</param>
        <param name="charCount">エンコードする文字数。</param>
        <param name="bytes">結果のバイト シーケンスを格納するバイト配列。</param>
        <param name="byteIndex">結果のバイト シーケンスを書き込む開始位置のインデックス。</param>
        <param name="flush">
          <see langword="true" />変換後に、エンコーダーの内部状態をクリアするにはそれ以外の場合、<see langword="false" />です。</param>
        <summary>派生クラスでオーバーライドされると、指定したバイト配列に指定した文字配列から文字と内部バッファー内の任意の文字のセットをエンコードします。 パラメーターでは、変換した後に、エンコーダーの内部状態をクリアするかどうかを示します。</summary>
        <returns><paramref name="bytes" /> に書き込まれた実際のバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 注意して、<xref:System.Text.Encoder>オブジェクトへの呼び出しの間で状態を保存する<xref:System.Text.Encoder.GetBytes%2A>です。 これを設定する必要があります、アプリケーションでは、データ ストリームの処理が終わったら、`flush`パラメーターを`true`最後の呼び出しで`GetBytes`状態情報がフラッシュされると、エンコード済みバイトが正しく終了しているかどうかを確認します。 この設定では、エンコーダーは、一致しないサロゲートや不完全な結合順序など、データ ブロックの末尾に無効なバイトを無視し、内部バッファーをクリアします。  
  
 計算する正確なバッファーのサイズを`GetBytes`必要と結果の文字を格納するアプリケーションを使用する必要があります<xref:System.Text.Encoder.GetByteCount%2A>です。  
  
 場合`GetBytes`で呼び出された`flush`'éý'`false`エンコーダーが内部バッファーにデータ ブロックの末尾にある末尾バイトを格納し、それらを次のエンコード操作で使用します。 アプリケーションを呼び出す必要があります`GetByteCount`呼び出す前にすぐにデータのブロックに`GetBytes`同じブロックのため、前のブロックから文字の後続のすべてが含まれている計算にします。  
  
 入力ストリームの数のセグメントに変換する、アプリケーションがある場合は、使用を検討して、<xref:System.Text.Encoder.Convert%2A>メソッドです。 <xref:System.Text.Encoder.GetBytes%2A>出力バッファーが十分でない場合、例外がスローされますが、<xref:System.Text.Encoder.Convert%2A>は、できるだけ多くの領域を入力し、読み取りと書き込みバイト数の文字を返します。 参照してください、<xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType>詳細コメントのトピックです。  
  
   
  
## Examples  
 次の例では、文字配列から要素の範囲をエンコードおよびバイト配列の要素の範囲内でエンコードされたバイトを格納する方法を示します。 <xref:System.Text.Encoder.GetByteCount%2A>メソッドを使用して必要な配列のサイズを決定を<xref:System.Text.Encoder.GetBytes%2A>です。  
  
 [!code-cpp[System.Text.Encoder.GetBytes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoder.GetBytes Example/CPP/getbytes-char[]-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.Encoder.GetBytes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoder.GetBytes Example/CS/getbytes-char[]-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.Encoder.GetBytes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoder.GetBytes Example/VB/getbytes-char[]-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" />is <see langword="null" /> (<see langword="Nothing" />).  
  
 または  
  
 <paramref name="bytes" />is <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" />または<paramref name="charCount" />または<paramref name="byteIndex" />が 0 未満です。  
  
 または  
  
 <paramref name="charIndex" /> および <paramref name="charCount" /> は <paramref name="chars" /> において有効な範囲を表していません。  
  
 または  
  
 <paramref name="byteIndex" /> が <paramref name="bytes" /> の有効なインデックスではありません。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="bytes" />十分な容量がない<paramref name="byteIndex" />に結果のバイトを合わせて、配列の末尾にします。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました (を参照してください[.NET Framework の文字エンコーディング](~/docs/standard/base-types/character-encoding.md)の詳細について)  
  
 および  
  
 <see cref="P:System.Text.Encoder.Fallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public virtual void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.Reset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスでオーバーライドされると、その初期状態に戻す、エンコーダーを設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドの内部状態をクリアする、<xref:System.Text.Encoder>オブジェクト。 メソッドを前回呼び出したときから保存された任意の状態情報をクリアする<xref:System.Text.Encoder.GetBytes%2A>または<xref:System.Text.Decoder.Convert%2A>など、後続の上位サロゲートなど、前のデータ ブロックの最後の文字です。  
  
 アプリケーションを呼び出す必要があります、`Reset`メソッドによって例外がスローされた後でも同じエンコーダーを再利用する必要がある場合<xref:System.Text.Encoder.GetBytes%2A>または<xref:System.Text.Encoder.GetByteCount%2A>アプリケーションは、ストリームを切り替えた場合またはします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
