<Type Name="SortedList" FullName="System.Collections.SortedList">
  <TypeSignature Language="C#" Value="public class SortedList : ICloneable, System.Collections.IDictionary" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit SortedList extends System.Object implements class System.Collections.ICollection, class System.Collections.IDictionary, class System.Collections.IEnumerable, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.SortedList" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.NonGeneric</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IDictionary</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.SortedList/SortedListDebugView))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>キーによって並べ替えられ、キーとインデックスを使ってアクセスできる、キー/値ペアのコレクションを表します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコレクションのジェネリック バージョンは、<xref:System.Collections.Generic.SortedList%602?displayProperty=nameWithType>です。  
  
 A<xref:System.Collections.SortedList>要素は、いずれかで、要素と同様に、キーを使用してアクセスできる<xref:System.Collections.IDictionary>実装、またはいずれかの要素と同様に、インデックスを使用して<xref:System.Collections.IList>実装します。  
  
 A<xref:System.Collections.SortedList>一覧です。 つまり、キーの 1 つの配列の要素を格納する 2 つの配列と関連付けられている値を別の配列オブジェクトを内部的に保持します。 各要素は、キー/値ペアとしてアクセスできる、<xref:System.Collections.DictionaryEntry>オブジェクト。 キーには`null`値を指定できますが、します。  
  
 容量、<xref:System.Collections.SortedList>オブジェクトは、要素の数、<xref:System.Collections.SortedList>を保持できます。 要素が追加されるにつれて、<xref:System.Collections.SortedList>容量を増やすは自動的に再割り当て、必要に応じて。 呼び出すことによって、容量を削減できる<xref:System.Collections.SortedList.TrimToSize%2A>かを設定して、<xref:System.Collections.SortedList.Capacity%2A>プロパティに明示的にします。  
  
 非常に大きな<xref:System.Collections.SortedList>オブジェクト、設定して、64 ビット システム上の 20億要素に最大の容量を増やすことができます、`enabled`する構成要素の属性`true`実行時環境でします。  
  
 要素、<xref:System.Collections.SortedList>オブジェクトは、キーにより並べ替えられたいずれかに従って、特定<xref:System.Collections.IComparer>実装では、ときに指定された、<xref:System.Collections.SortedList>が作成されたかに応じて、<xref:System.IComparable>キー自体で提供される実装します。 どちらの場合、<xref:System.Collections.SortedList>重複するキーはできません。  
  
 インデックス順序は、並べ替え順序に基づいています。 挿入される要素が追加されると、<xref:System.Collections.SortedList>正しい並べ替えの順序、およびインデックス作成もそれに応じて調整します。 要素が削除されると、インデックス作成もそれに応じて調整します。 要素が追加または削除、したがって、特定のキー/値ペアのインデックスを変更可能性があります、<xref:System.Collections.SortedList>オブジェクト。  
  
 操作、<xref:System.Collections.SortedList>オブジェクトに対する操作より遅くなる傾向があります、<xref:System.Collections.Hashtable>並べ替えを行うためのオブジェクト。 ただし、<xref:System.Collections.SortedList>の関連するキーまたはインデックスのいずれかの値へのアクセスを許可することで柔軟性を提供します。  
  
 このコレクション内の要素は、整数インデックスを使用してアクセスできます。  このコレクションのインデックスは 0 から始まります。  
  
 `foreach` C# 言語のステートメント (`for each` Visual Basic で)、コレクション内の要素の型のオブジェクトを返します。 以降の各要素、<xref:System.Collections.SortedList>オブジェクトがキー/値ペアを要素型は、キーの型または値の型ではありません。 要素の型は、代わりに、<xref:System.Collections.DictionaryEntry>です。 例:  
  
 [!code-cpp[Classic SortedList Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList Example/CPP/remarks.cpp#2)]
 [!code-csharp[Classic SortedList Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList Example/CS/remarks.cs#2)]
 [!code-vb[Classic SortedList Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList Example/VB/remarks.vb#2)]  
  
 `foreach`ステートメントは書き込まないことから、コレクションに読み取りのみが使用できる列挙子のラッパー。  
  
   
  
## Examples  
 次のコード例を作成および初期化する方法を示しています、<xref:System.Collections.SortedList>オブジェクトとそのキーと値を印刷する方法です。  
  
 [!code-cpp[Classic SortedList Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>パブリック静的 (<see langword="Shared" /> Visual Basic で) この型のメンバーは、スレッド セーフであります。 インスタンス メンバーの場合は、スレッド セーフであるとは限りません。  
  
 A<see cref="T:System.Collections.SortedList" />オブジェクト サポートできる複数のリーダーに同時に、コレクションが変更されない限り、します。 スレッド セーフを確保する、 <see cref="T:System.Collections.SortedList" />、によって返されるラッパーを介してすべての操作を行う必要があります、<see cref="M:System.Collections.SortedList.Synchronized(System.Collections.SortedList)" />メソッドです。  
  
 コレクションの列挙は、本質的にスレッド セーフなプロシージャではありません。 コレクションの同期がとられている場合でも、別のスレッドによってそのコレクションを変更できるため、変更の結果として列挙子は例外をスローします。 列挙処理を確実にスレッド セーフに行うには、列挙中にコレクションをロックするか、他のスレッドによって行われた変更によってスローされる例外をキャッチします。</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>新しいインスタンスを初期化、<see cref="T:System.Collections.SortedList" />が空で、クラスが既定の初期量を備え、に従って並べ替えられます、<see cref="T:System.IComparable" />に追加された各キーによって実装されるインターフェイス、<see cref="T:System.Collections.SortedList" />オブジェクト。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 各キーを実装する必要があります、<xref:System.IComparable>内の他のすべてのキーの比較ができるようにするインターフェイス、<xref:System.Collections.SortedList>オブジェクト。 よると、要素が並べ替えられて、<xref:System.IComparable>各キーに追加の実装、<xref:System.Collections.SortedList>です。  
  
 容量、<xref:System.Collections.SortedList>オブジェクトは、要素の数を<xref:System.Collections.SortedList>を保持できます。 要素が追加されるにつれて、<xref:System.Collections.SortedList>容量を増やすは自動的に内部の配列を再割り当てによる要求どおりです。  
  
 コレクションのサイズを推定できる場合に要素を追加するときにサイズ変更操作の数を実行する必要があるの初期量を指定する、<xref:System.Collections.SortedList>オブジェクト。  
  
 このコンス トラクターは、o (1) 操作です。  
  
   
  
## Examples  
 次のコード例を異なるコレクションを使用して作成<xref:System.Collections.SortedList>コンス トラクターのコレクションの動作の違いを示しています。  
  
 [!code-cpp[System.Collections.SortedList_ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/CPP/sortedlist_ctor.cpp#1)]
 [!code-csharp[System.Collections.SortedList_ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/CS/sortedlist_ctor.cs#1)]
 [!code-vb[System.Collections.SortedList_ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/VB/sortedlist_ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor(System.Collections.IComparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="comparer">キーの比較時に使用する <see cref="T:System.Collections.IComparer" /> の実装。  
  
 または  
  
 <see langword="null" />使用する、<see cref="T:System.IComparable" />各キーによって実装されます。</param>
        <summary>新しいインスタンスを初期化、<see cref="T:System.Collections.SortedList" />が空で、クラスが既定の初期量を備えされ、並べ替えは、指定に従って<see cref="T:System.Collections.IComparer" />インターフェイスです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要素は、指定に従って<xref:System.Collections.IComparer>実装します。 場合、`comparer`パラメーターは`null`、<xref:System.IComparable>各キーによって実装が使用されます。 したがって、各キーを実装する必要があります、<xref:System.IComparable>内の他のすべてのキーの比較ができるようにするインターフェイス、<xref:System.Collections.SortedList>オブジェクト。  
  
 容量、<xref:System.Collections.SortedList>オブジェクトは、要素の数を<xref:System.Collections.SortedList>を保持できます。 要素が追加されるにつれて、<xref:System.Collections.SortedList>容量を増やすは自動的に内部の配列を再割り当てによる要求どおりです。  
  
 コレクションのサイズを推定できる場合に要素を追加するときにサイズ変更操作の数を実行する必要があるの初期量を指定する、<xref:System.Collections.SortedList>オブジェクト。  
  
 このコンス トラクターは、o (1) 操作です。  
  
   
  
## Examples  
 次のコード例を異なるコレクションを使用して作成<xref:System.Collections.SortedList>コンス トラクターのコレクションの動作の違いを示しています。  
  
 [!code-cpp[System.Collections.SortedList_ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/CPP/sortedlist_ctor.cpp#1)]
 [!code-csharp[System.Collections.SortedList_ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/CS/sortedlist_ctor.cs#1)]
 [!code-vb[System.Collections.SortedList_ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/VB/sortedlist_ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (System.Collections.IDictionary d);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor(System.Collections.IDictionary)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
      </Parameters>
      <Docs>
        <param name="d"><see cref="T:System.Collections.IDictionary" />実装を新しいコピーを<see cref="T:System.Collections.SortedList" />オブジェクト。</param>
        <summary>新しいインスタンスを初期化、<see cref="T:System.Collections.SortedList" />を指定したディクショナリからコピーされた要素を含むクラスは、コピーした要素の数と同じ初期量を備えたし、に従って並べ替えられます、<see cref="T:System.IComparable" />各キーによって実装されるインターフェイス。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 各キーを実装する必要があります、<xref:System.IComparable>内の他のすべてのキーの比較ができるようにするインターフェイス、<xref:System.Collections.SortedList>オブジェクト。 よると、要素が並べ替えられて、<xref:System.IComparable>各キーに追加の実装、<xref:System.Collections.SortedList>です。  
  
 A<xref:System.Collections.Hashtable>オブジェクトの例に示します、<xref:System.Collections.IDictionary>このコンス トラクターに渡すことができる実装します。 新しい<xref:System.Collections.SortedList>オブジェクトに格納されている値とキーのコピーを格納する、<xref:System.Collections.Hashtable>です。  
  
 容量、<xref:System.Collections.SortedList>オブジェクトは、要素の数を<xref:System.Collections.SortedList>を保持できます。 要素が追加されるにつれて、<xref:System.Collections.SortedList>容量を増やすは自動的に内部の配列を再割り当てによる要求どおりです。  
  
 コレクションのサイズを推定できる場合に要素を追加するときにサイズ変更操作の数を実行する必要があるの初期量を指定する、<xref:System.Collections.SortedList>オブジェクト。  
  
 このコンス トラクターは、O (`n`) 操作では、ここで`n`内の要素の数は、`d`です。  
  
   
  
## Examples  
 次のコード例を異なるコレクションを使用して作成<xref:System.Collections.SortedList>コンス トラクターのコレクションの動作の違いを示しています。  
  
 [!code-cpp[System.Collections.SortedList_ctorDictionary#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/CPP/sortedlist_ctordictionary.cpp#1)]
 [!code-csharp[System.Collections.SortedList_ctorDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/CS/sortedlist_ctordictionary.cs#1)]
 [!code-vb[System.Collections.SortedList_ctorDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/VB/sortedlist_ctordictionary.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="d" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidCastException">1 つまたは複数の要素で<paramref name="d" />を実装していない、<see cref="T:System.IComparable" />インターフェイスです。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (int initialCapacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCapacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor(System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCapacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCapacity">最初の要素数を<see cref="T:System.Collections.SortedList" />オブジェクトを含めることができます。</param>
        <summary>新しいインスタンスを初期化、<see cref="T:System.Collections.SortedList" />が空で、クラス、指定した初期量、およびに従って並べ替えられます、<see cref="T:System.IComparable" />に追加された各キーによって実装されるインターフェイス、<see cref="T:System.Collections.SortedList" />オブジェクト。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 各キーを実装する必要があります、<xref:System.IComparable>内の他のすべてのキーの比較ができるようにするインターフェイス、<xref:System.Collections.SortedList>オブジェクト。 よると、要素が並べ替えられて、<xref:System.IComparable>各キーに追加の実装、<xref:System.Collections.SortedList>です。  
  
 容量、<xref:System.Collections.SortedList>オブジェクトは、要素の数を<xref:System.Collections.SortedList>を保持できます。 要素が追加されるにつれて、<xref:System.Collections.SortedList>容量を増やすは自動的に内部の配列を再割り当てによる要求どおりです。  
  
 コレクションのサイズを推定できる場合に要素を追加するときにサイズ変更操作の数を実行する必要があるの初期量を指定する、<xref:System.Collections.SortedList>オブジェクト。  
  
 このコンス トラクターは、O (`n`) 操作では、ここで`n`は`initialCapacity`します。  
  
   
  
## Examples  
 次のコード例を異なるコレクションを使用して作成<xref:System.Collections.SortedList>コンス トラクターのコレクションの動作の違いを示しています。  
  
 [!code-cpp[System.Collections.SortedList_ctorInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/CPP/sortedlist_ctorint.cpp#1)]
 [!code-csharp[System.Collections.SortedList_ctorInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/CS/sortedlist_ctorint.cs#1)]
 [!code-vb[System.Collections.SortedList_ctorInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/VB/sortedlist_ctorint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="initialCapacity" /> が 0 未満です。</exception>
        <exception cref="T:System.OutOfMemoryException">作成する十分なメモリがない、<see cref="T:System.Collections.SortedList" />指定したオブジェクト<paramref name="initialCapacity" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (System.Collections.IComparer comparer, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IComparer comparer, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor(System.Collections.IComparer,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="comparer">キーの比較時に使用する <see cref="T:System.Collections.IComparer" /> の実装。  
  
 または  
  
 <see langword="null" />使用する、<see cref="T:System.IComparable" />各キーによって実装されます。</param>
        <param name="capacity">最初の要素数を<see cref="T:System.Collections.SortedList" />オブジェクトを含めることができます。</param>
        <summary>新しいインスタンスを初期化、<see cref="T:System.Collections.SortedList" />が空で、クラスが指定した初期量を備えされ、並べ替えは、指定に従って<see cref="T:System.Collections.IComparer" />インターフェイスです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要素は、指定に従って<xref:System.Collections.IComparer>実装します。 場合、`comparer`パラメーターは`null`、<xref:System.IComparable>各キーによって実装が使用されます。 したがって、各キーを実装する必要があります、<xref:System.IComparable>内の他のすべてのキーの比較ができるようにするインターフェイス、<xref:System.Collections.SortedList>オブジェクト。  
  
 容量、<xref:System.Collections.SortedList>オブジェクトは、要素の数を<xref:System.Collections.SortedList>を保持できます。 要素が追加されるにつれて、<xref:System.Collections.SortedList>容量を増やすは自動的に内部の配列を再割り当てによる要求どおりです。  
  
 コレクションのサイズを推定できる場合に要素を追加するときにサイズ変更操作の数を実行する必要があるの初期量を指定する、<xref:System.Collections.SortedList>オブジェクト。  
  
 このコンス トラクターは、O (`n`) 操作では、ここで`n`は`capacity`します。  
  
   
  
## Examples  
 次のコード例を異なるコレクションを使用して作成<xref:System.Collections.SortedList>コンス トラクターのコレクションの動作の違いを示しています。  
  
 [!code-cpp[System.Collections.SortedList_ctorInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/CPP/sortedlist_ctorint.cpp#1)]
 [!code-csharp[System.Collections.SortedList_ctorInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/CS/sortedlist_ctorint.cs#1)]
 [!code-vb[System.Collections.SortedList_ctorInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/VB/sortedlist_ctorint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> が 0 未満です。</exception>
        <exception cref="T:System.OutOfMemoryException">作成する十分なメモリがない、<see cref="T:System.Collections.SortedList" />指定したオブジェクト<paramref name="capacity" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (System.Collections.IDictionary d, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor(System.Collections.IDictionary,System.Collections.IComparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="d"><see cref="T:System.Collections.IDictionary" />実装を新しいコピーを<see cref="T:System.Collections.SortedList" />オブジェクト。</param>
        <param name="comparer">キーの比較時に使用する <see cref="T:System.Collections.IComparer" /> の実装。  
  
 または  
  
 <see langword="null" />使用する、<see cref="T:System.IComparable" />各キーによって実装されます。</param>
        <summary>新しいインスタンスを初期化、<see cref="T:System.Collections.SortedList" />を指定したディクショナリからコピーされた要素を含むクラスが、コピーした要素の数と同じ初期量を備えたされ、並べ替えは、指定に従って<see cref="T:System.Collections.IComparer" />インターフェイスです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要素は、指定に従って<xref:System.Collections.IComparer>実装します。 場合、`comparer`パラメーターは`null`、<xref:System.IComparable>各キーによって実装が使用されます。 したがって、各キーを実装する必要があります、<xref:System.IComparable>内の他のすべてのキーの比較ができるようにするインターフェイス、<xref:System.Collections.SortedList>オブジェクト。  
  
 A<xref:System.Collections.Hashtable>オブジェクトの例に示します、<xref:System.Collections.IDictionary>このコンス トラクターに渡すことができる実装します。 新しい<xref:System.Collections.SortedList>オブジェクトに格納されている値とキーのコピーを格納する、<xref:System.Collections.Hashtable>です。  
  
 容量、<xref:System.Collections.SortedList>オブジェクトは、要素の数を<xref:System.Collections.SortedList>を保持できます。 要素が追加されるにつれて、<xref:System.Collections.SortedList>容量を増やすは自動的に内部の配列を再割り当てによる要求どおりです。  
  
 コレクションのサイズを推定できる場合に要素を追加するときにサイズ変更操作の数を実行する必要があるの初期量を指定する、<xref:System.Collections.SortedList>オブジェクト。  
  
 このコンス トラクターは、O (`n`) 操作では、ここで`n`内の要素の数は、`d`です。  
  
   
  
## Examples  
 次のコード例を異なるコレクションを使用して作成<xref:System.Collections.SortedList>コンス トラクターのコレクションの動作の違いを示しています。  
  
 [!code-cpp[System.Collections.SortedList_ctorDictionary#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/CPP/sortedlist_ctordictionary.cpp#1)]
 [!code-csharp[System.Collections.SortedList_ctorDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/CS/sortedlist_ctordictionary.cs#1)]
 [!code-vb[System.Collections.SortedList_ctorDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/VB/sortedlist_ctordictionary.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="d" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="comparer" /><see langword="null" />、および 1 つまたは複数の要素に<paramref name="d" />を実装していない、<see cref="T:System.IComparable" />インターフェイスです。</exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual void Add (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Add(System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">追加する要素のキー。</param>
        <param name="value">追加する要素の値。 値として <see langword="null" /> を指定できます。</param>
        <summary>指定したキーと値を持つ要素を追加、<see cref="T:System.Collections.SortedList" />オブジェクト。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 カーソルは、比較演算子を選択すると、明示的にまたは既定では、いずれかで決まるときに、<xref:System.Collections.SortedList>オブジェクトが作成されました。  
  
 場合<xref:System.Collections.SortedList.Count%2A>既に等しい<xref:System.Collections.SortedList.Capacity%2A>、容量、<xref:System.Collections.SortedList>オブジェクトが内部の配列を自動的に再割り当て増加し、新しい要素が追加される前に、既存の要素が新しい配列にコピーされます。  
  
 使用することも、<xref:System.Collections.SortedList.Item%2A>にキーの値を設定して、新しい要素を追加するプロパティが存在しません、<xref:System.Collections.SortedList>オブジェクト (たとえば、 `myCollection["myNonexistentKey"] = myValue`)。 ただしで指定したキーが既に存在する場合、 <xref:System.Collections.SortedList>、設定、<xref:System.Collections.SortedList.Item%2A>プロパティに古い値が上書きされます。 これに対し、<xref:System.Collections.SortedList.Add%2A>メソッドでは、既存の要素は変更しません。  
  
 要素、<xref:System.Collections.SortedList>オブジェクトは、キーにより並べ替えられたいずれかに従って、特定<xref:System.Collections.IComparer>実装では、ときに指定された、<xref:System.Collections.SortedList>が作成されたかに応じて、<xref:System.IComparable>キー自体で提供される実装します。  
  
 キーには`null`値を指定できますが、します。  
  
 このメソッドは、O (`n`)、並べ替えられていないデータの操作を`n`は<xref:System.Collections.SortedList.Count%2A>します。 これは、O (ログ`n`) 操作の場合は、新しい要素は、リストの末尾に追加します。 カーソルでは、サイズ変更が発生する場合、操作は O (`n`)。  
  
   
  
## Examples  
 次のコード例は、要素を追加する方法を示しています、<xref:System.Collections.SortedList>オブジェクト。  
  
 [!code-cpp[Classic SortedList.Add Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Add Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Add Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Add Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Add Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Add Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">指定した要素<paramref name="key" />に既に存在する、<see cref="T:System.Collections.SortedList" />オブジェクト。  
  
 または  
  
 <see cref="T:System.Collections.SortedList" />を使用する設定、<see cref="T:System.IComparable" />インターフェイス、および<paramref name="key" />を実装しません、<see cref="T:System.IComparable" />インターフェイスです。</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.SortedList" /> は読み取り専用です。  
  
 -または-  
  
 <see cref="T:System.Collections.SortedList" /> は固定サイズです。</exception>
        <exception cref="T:System.OutOfMemoryException">要素を追加するための十分な使用可能なメモリがない、<see cref="T:System.Collections.SortedList" />です。</exception>
        <exception cref="T:System.InvalidOperationException">比較演算子では、例外をスローします。</exception>
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public virtual int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定の容量、<see cref="T:System.Collections.SortedList" />オブジェクト。</summary>
        <value>要素の数を<see cref="T:System.Collections.SortedList" />オブジェクトを含めることができます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.SortedList.Capacity%2A>要素の数を<xref:System.Collections.SortedList>オブジェクトを格納できます。 <xref:System.Collections.SortedList.Count%2A>実際には、要素の数、<xref:System.Collections.SortedList>です。  
  
 <xref:System.Collections.SortedList.Capacity%2A>常により大きいまたは等しい<xref:System.Collections.SortedList.Count%2A>です。 場合<xref:System.Collections.SortedList.Count%2A>を超える<xref:System.Collections.SortedList.Capacity%2A>要素を追加するには、中に容量が前の要素をコピーし、新しい要素を追加する前に、内部配列の再割り当てによって自動的に増加します。  
  
 呼び出すことによって、容量を削減できる<xref:System.Collections.SortedList.TrimToSize%2A>かを設定して、<xref:System.Collections.SortedList.Capacity%2A>プロパティに明示的にします。 ときに、値の<xref:System.Collections.SortedList.Capacity%2A>が設定されている、明示的に指定した容量、それに合わせて内部の配列が再割り当てもします。  
  
 このプロパティの値を取得する場合は、o (1) 操作です。O は、プロパティの設定 (`n`) 操作、場所`n`新しい容量します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">割り当てられている値が現在の要素数より小さい、<see cref="T:System.Collections.SortedList" />オブジェクト。</exception>
        <exception cref="T:System.OutOfMemoryException">システムで使用可能なメモリが不足しています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public virtual void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Clear" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Collections.SortedList" /> オブジェクトからすべての要素を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.SortedList.Count%2A>0 に設定し、コレクションの要素から他のオブジェクトへの参照も解放します。  
  
 <xref:System.Collections.SortedList.Capacity%2A>変更されません。 容量をリセットする、<xref:System.Collections.SortedList>オブジェクトを呼び出す<xref:System.Collections.SortedList.TrimToSize%2A>設定や、<xref:System.Collections.SortedList.Capacity%2A>プロパティを直接です。 空のトリミング<xref:System.Collections.SortedList>のキャパシティを設定、<xref:System.Collections.SortedList>を既定の容量。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は<xref:System.Collections.SortedList.Count%2A>します。  
  
   
  
## Examples  
 次のコード例の未使用部分をトリミングする方法を示しています、<xref:System.Collections.SortedList>オブジェクトとの値をクリアする方法、<xref:System.Collections.SortedList>です。  
  
 [!code-cpp[Classic SortedList.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.SortedList" />オブジェクトは読み取り専用です。  
  
 または  
  
 <see cref="T:System.Collections.SortedList" /> は固定サイズです。</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Clone" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>簡易コピーを作成、<see cref="T:System.Collections.SortedList" />オブジェクト。</summary>
        <returns>簡易コピー、<see cref="T:System.Collections.SortedList" />オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 参照型または値の型が参照先のオブジェクトはコピーされないかどうか、コレクションの簡易コピーは、コレクションの要素のみをコピーします。 新しいコレクション内の参照は、元のコレクション内の参照をポイントする同じオブジェクトをポイントします。  
  
 これに対し、コレクションのディープ コピーされた要素をコピーして、要素が直接または間接的に参照するすべてです。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は<xref:System.Collections.SortedList.Count%2A>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public virtual bool Contains (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Contains(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key"><see cref="T:System.Collections.SortedList" /> オブジェクト内で検索されるキー。</param>
        <summary>指定するかどうか、<see cref="T:System.Collections.SortedList" />オブジェクトには、特定のキーが含まれています。</summary>
        <returns>
          <see langword="true" />場合、<see cref="T:System.Collections.SortedList" />オブジェクトには、指定した要素が含まれています。 <paramref name="key" />、それ以外の<see langword="false" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要素、<xref:System.Collections.SortedList>オブジェクトは、キーにより並べ替えられたいずれかに従って、特定<xref:System.Collections.IComparer>実装では、ときに指定された、<xref:System.Collections.SortedList>が作成されたかに応じて、<xref:System.IComparable>キー自体で提供される実装します。  
  
 <xref:System.Collections.SortedList.Contains%2A> は、<xref:System.Collections.IDictionary.Contains%2A?displayProperty=nameWithType> を実装します。 同様に動作が<xref:System.Collections.SortedList.ContainsKey%2A>です。  
  
 このメソッドは、バイナリ検索アルゴリズムを使用します。そのため、このメソッドは、O (ログ`n`) 操作では、ここで`n`は<xref:System.Collections.SortedList.Count%2A>します。  
  
 以降、.NET Framework 2.0 では、このメソッドを使用して、コレクションのオブジェクトの<xref:System.Object.Equals%2A>と<xref:System.IComparable.CompareTo%2A>メソッド`item`項目が存在するかどうかを確認します。 .NET Framework の以前のバージョンでは、この決定を使用して行われた、<xref:System.Object.Equals%2A>と<xref:System.IComparable.CompareTo%2A>のメソッド、`item`パラメーター コレクション内のオブジェクトにします。  
  
   
  
## Examples  
 次のコード例を確認する方法を示して かどうか、<xref:System.Collections.SortedList>オブジェクトには、特定の要素が含まれています。  
  
 [!code-cpp[Classic SortedList.Contains Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Contains Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Contains Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">比較演算子では、例外をスローします。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContainsKey">
      <MemberSignature Language="C#" Value="public virtual bool ContainsKey (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsKey(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.ContainsKey(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key"><see cref="T:System.Collections.SortedList" /> オブジェクト内で検索されるキー。</param>
        <summary>指定するかどうか、<see cref="T:System.Collections.SortedList" />オブジェクトには、特定のキーが含まれています。</summary>
        <returns>
          <see langword="true" />場合、<see cref="T:System.Collections.SortedList" />オブジェクトには、指定した要素が含まれています。 <paramref name="key" />、それ以外の<see langword="false" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要素、<xref:System.Collections.SortedList>オブジェクトは、キーにより並べ替えられたいずれかに従って、特定<xref:System.Collections.IComparer>実装では、ときに指定された、<xref:System.Collections.SortedList>が作成されたかに応じて、<xref:System.IComparable>キー自体で提供される実装します。  
  
 このメソッドの動作とまったく同じ、<xref:System.Collections.SortedList.Contains%2A>メソッドです。  
  
 このメソッドは、バイナリ検索アルゴリズムを使用します。そのため、このメソッドは、O (ログ`n`) 操作では、ここで`n`は<xref:System.Collections.SortedList.Count%2A>します。  
  
 以降、.NET Framework 2.0 では、このメソッドを使用して、コレクションのオブジェクトの<xref:System.Object.Equals%2A>と<xref:System.IComparable.CompareTo%2A>メソッド`item`項目が存在するかどうかを確認します。 .NET Framework の以前のバージョンでは、この決定を使用して行われた、<xref:System.Object.Equals%2A>と<xref:System.IComparable.CompareTo%2A>のメソッド、`item`パラメーター コレクション内のオブジェクトにします。  
  
   
  
## Examples  
 次のコード例を確認する方法を示して かどうか、<xref:System.Collections.SortedList>オブジェクトには、特定の要素が含まれています。  
  
 [!code-cpp[Classic SortedList.Contains Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Contains Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Contains Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">比較演算子では、例外をスローします。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContainsValue">
      <MemberSignature Language="C#" Value="public virtual bool ContainsValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.ContainsValue(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">内で検索する値、<see cref="T:System.Collections.SortedList" />オブジェクト。 値として <see langword="null" /> を指定できます。</param>
        <summary>指定するかどうか、<see cref="T:System.Collections.SortedList" />オブジェクトには、特定の値が含まれています。</summary>
        <returns>
          <see langword="true" />場合、<see cref="T:System.Collections.SortedList" />オブジェクトには、指定した要素が含まれています。 <paramref name="value" />、それ以外の<see langword="false" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要素の値、<xref:System.Collections.SortedList>オブジェクトを使用して、指定した値と比較されます、<xref:System.Object.Equals%2A>メソッドです。  
  
 このメソッドは、一方向の検索を実行します。したがって、平均実行時間に比例して<xref:System.Collections.SortedList.Count%2A>です。 つまり、このメソッドは、O (`n`) 操作、場所`n`は<xref:System.Collections.SortedList.Count%2A>します。  
  
 以降、.NET Framework 2.0 では、このメソッドを使用して、コレクションのオブジェクトの<xref:System.Object.Equals%2A>と<xref:System.IComparable.CompareTo%2A>メソッド`item`項目が存在するかどうかを確認します。 .NET Framework の以前のバージョンでは、この決定を使用して行われた、<xref:System.Object.Equals%2A>と<xref:System.IComparable.CompareTo%2A>のメソッド、`item`パラメーター コレクション内のオブジェクトにします。  
  
   
  
## Examples  
 次のコード例を確認する方法を示して かどうか、<xref:System.Collections.SortedList>オブジェクトには、特定の要素が含まれています。  
  
 [!code-cpp[Classic SortedList.Contains Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Contains Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Contains Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public virtual void CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.CopyTo(System.Array,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">1 次元<see cref="T:System.Array" />のコピー先であるオブジェクトを<see cref="T:System.Collections.DictionaryEntry" />からコピーされるオブジェクト<see cref="T:System.Collections.SortedList" />です。 <see cref="T:System.Array" /> には、0 から始まるインデックス番号が必要です。</param>
        <param name="arrayIndex">内の 0 から始まるインデックス<c>配列</c>コピーの開始位置。</param>
        <summary>コピー<see cref="T:System.Collections.SortedList" />要素を 1 次元<see cref="T:System.Array" />オブジェクト、配列の指定したインデックスから始まります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キー/値ペアがコピーされた、<xref:System.Array>オブジェクトを列挙子が反復処理する順序と同じ順序で、<xref:System.Collections.SortedList>オブジェクト。  
  
 内のキーのみをコピーする、<xref:System.Collections.SortedList>を使用して`SortedList.Keys.CopyTo`です。  
  
 値だけをコピーする、<xref:System.Collections.SortedList>を使用して`SortedList.Values.CopyTo`です。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は<xref:System.Collections.SortedList.Count%2A>します。  
  
   
  
## Examples  
 次のコード例の値をコピーする方法を示しています、<xref:System.Collections.SortedList>オブジェクトを 1 次元に<xref:System.Array>オブジェクト。  
  
 [!code-cpp[Classic SortedList.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.CopyTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> が多次元です。  
  
 または  
  
 ソース内の要素の数<see cref="T:System.Collections.SortedList" />オブジェクトがから利用可能な領域よりも大きい<paramref name="arrayIndex" />変換先の末尾に<paramref name="array" />です。</exception>
        <exception cref="T:System.InvalidCastException">コピー元の <see cref="T:System.Collections.SortedList" /> の型をコピー先の <paramref name="array" /> の型に自動的にキャストすることはできません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public virtual int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.Count" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>含まれる要素の数を取得、<see cref="T:System.Collections.SortedList" />オブジェクト。</summary>
        <value>含まれる要素の数、<see cref="T:System.Collections.SortedList" />オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 各要素は、キー/値ペアとしてアクセスできる、<xref:System.Collections.DictionaryEntry>オブジェクト。  
  
 <xref:System.Collections.SortedList.Capacity%2A>要素の数を<xref:System.Collections.SortedList>オブジェクトを格納できます。 <xref:System.Collections.SortedList.Count%2A>実際には、要素の数、<xref:System.Collections.SortedList>です。  
  
 <xref:System.Collections.SortedList.Capacity%2A>常により大きいまたは等しい<xref:System.Collections.SortedList.Count%2A>です。 場合<xref:System.Collections.SortedList.Count%2A>を超える<xref:System.Collections.SortedList.Capacity%2A>要素を追加するには、中に容量が前の要素をコピーし、新しい要素を追加する前に、内部配列の再割り当てによって自動的に増加します。  
  
 このプロパティ値を取得することは、O(1) 操作になります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByIndex">
      <MemberSignature Language="C#" Value="public virtual object GetByIndex (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetByIndex(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.GetByIndex(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">取得する値の 0 から始まるインデックス。</param>
        <summary>指定したインデックス位置の値を取得、<see cref="T:System.Collections.SortedList" />オブジェクト。</summary>
        <returns>指定したインデックスにある値、<see cref="T:System.Collections.SortedList" />オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス順序は、並べ替え順序に基づいています。 挿入される要素が追加されると、<xref:System.Collections.SortedList>正しい並べ替えの順序、およびインデックス作成もそれに応じて調整します。 要素が削除されると、インデックス作成もそれに応じて調整します。 要素が追加または削除、したがって、特定のキー/値ペアのインデックスを変更可能性があります、<xref:System.Collections.SortedList>オブジェクト。  
  
 このメソッドは、o (1) 操作です。  
  
   
  
## Examples  
 次のコード例は、1 つまたはすべてのキーを取得する方法を示しますまたはの値が、<xref:System.Collections.SortedList>オブジェクト。  
  
 [!code-cpp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.GetByIndex Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />有効なインデックスの範囲外である、<see cref="T:System.Collections.SortedList" />オブジェクト。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IDictionaryEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返します、<see cref="T:System.Collections.IDictionaryEnumerator" />を反復処理するオブジェクト、<see cref="T:System.Collections.SortedList" />オブジェクト。</summary>
        <returns><see cref="T:System.Collections.IDictionaryEnumerator" /> オブジェクトの <see cref="T:System.Collections.SortedList" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 C# 言語の `foreach` ステートメント (Visual Basic の場合は `for each`) を使用することで列挙子の複雑さを回避できます。  したがって、列挙子を直接操作するのではなく、`foreach` を使用することをお勧めします。  
  
 列挙子を使用すると、コレクション内のデータを読み取ることができますが、基になるコレクションを変更することはできません。  
  
 最初に、列挙子はコレクション内の 1 番目の要素の前に位置付けられます。 <xref:System.Collections.IEnumerator.Reset%2A> を実行した場合も、列挙子はこの位置に戻されます。  この位置では、<xref:System.Collections.IEnumerator.Current%2A> が未定義です。 そのため、<xref:System.Collections.IEnumerator.MoveNext%2A> の値を読み取る前に、<xref:System.Collections.IEnumerator.Current%2A> を呼び出して列挙子をコレクションの最初の要素に進める必要があります。  
  
 <xref:System.Collections.IEnumerator.Current%2A> は、<xref:System.Collections.IEnumerator.MoveNext%2A> または <xref:System.Collections.IEnumerator.Reset%2A> が呼び出されるまでは同じオブジェクトを返します。 <xref:System.Collections.IEnumerator.MoveNext%2A> は、<xref:System.Collections.IEnumerator.Current%2A> を次の要素に設定します。  
  
 場合<xref:System.Collections.IEnumerator.MoveNext%2A>列挙子をコレクションの末尾が、コレクション内の最後の要素の後に配置されているパスと<xref:System.Collections.IEnumerator.MoveNext%2A>返します`false`です。 列挙子がこの位置では、後続の呼び出しの場合<xref:System.Collections.IEnumerator.MoveNext%2A>を返すことも`false`します。 最後の呼び出し場合<xref:System.Collections.IEnumerator.MoveNext%2A>返される`false`、<xref:System.Collections.IEnumerator.Current%2A>が定義されていません。 <xref:System.Collections.IEnumerator.Current%2A> をコレクションの最初の要素にもう一度設定するには、<xref:System.Collections.IEnumerator.Reset%2A> を呼び出してから <xref:System.Collections.IEnumerator.MoveNext%2A> を呼び出します。  
  
 コレクションが変更されない限り、列挙子は有効です。 コレクションに対して変更 (要素の追加、変更、削除など) が行われると、列挙子は回復不可能な無効状態になり、その動作は未定義になります。  
  
 列挙子にはコレクションへの排他アクセス権限はないため、コレクションの列挙処理は本質的にスレッド セーフな処理ではありません。  列挙処理でスレッド セーフを確保するには、列挙処理が終わるまでコレクションをロックできます。  コレクションに対し複数のスレッドがアクセスして読み取りや書き込みを行うことができるようにするには、独自に同期化を実装する必要があります。  
  
 このメソッドは、o (1) 操作です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetKey">
      <MemberSignature Language="C#" Value="public virtual object GetKey (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetKey(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.GetKey(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">取得するキーの 0 から始まるインデックス。</param>
        <summary>指定したインデックス位置のキーを取得、<see cref="T:System.Collections.SortedList" />オブジェクト。</summary>
        <returns>指定したインデックスにあるキーを<see cref="T:System.Collections.SortedList" />オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス順序は、並べ替え順序に基づいています。 挿入される要素が追加されると、<xref:System.Collections.SortedList>正しい並べ替えの順序、およびインデックス作成もそれに応じて調整します。 要素が削除されると、インデックス作成もそれに応じて調整します。 要素が追加または削除、したがって、特定のキー/値ペアのインデックスを変更可能性があります、<xref:System.Collections.SortedList>オブジェクト。  
  
 このメソッドは、o (1) 操作です。  
  
   
  
## Examples  
 次のコード例は、1 つまたはすべてのキーを取得する方法を示しますまたはの値が、<xref:System.Collections.SortedList>オブジェクト。  
  
 [!code-cpp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.GetByIndex Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />有効なインデックスの範囲外である、<see cref="T:System.Collections.SortedList" />オブジェクト。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetKeyList">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IList GetKeyList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IList GetKeyList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.GetKeyList" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>内のキーを取得、<see cref="T:System.Collections.SortedList" />オブジェクト。</summary>
        <returns><see cref="T:System.Collections.IList" />オブジェクト内のキーを含む、<see cref="T:System.Collections.SortedList" />オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された<xref:System.Collections.IList>オブジェクトは、キーの読み取り専用ビュー、<xref:System.Collections.SortedList>オブジェクト。 基になる変更を加える<xref:System.Collections.SortedList>すぐに反映されます、<xref:System.Collections.IList>です。  
  
 返された要素<xref:System.Collections.IList>のキーと同じ順序で並べ替えられて、<xref:System.Collections.SortedList>です。  
  
 このメソッドがに似ていますが、<xref:System.Collections.SortedList.Keys%2A>プロパティが返されます、<xref:System.Collections.IList>オブジェクトの代わりに、<xref:System.Collections.ICollection>オブジェクト。  
  
 このメソッドは、o (1) 操作です。  
  
   
  
## Examples  
 次のコード例は、1 つまたはすべてのキーを取得する方法を示しますまたはの値が、<xref:System.Collections.SortedList>オブジェクト。  
  
 [!code-cpp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.GetByIndex Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValueList">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IList GetValueList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IList GetValueList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.GetValueList" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>内の値を取得、<see cref="T:System.Collections.SortedList" />オブジェクト。</summary>
        <returns><see cref="T:System.Collections.IList" />オブジェクトの値を含む、<see cref="T:System.Collections.SortedList" />オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された<xref:System.Collections.IList>オブジェクトは、の値の読み取り専用ビュー、<xref:System.Collections.SortedList>オブジェクト。 基になる変更を加える<xref:System.Collections.SortedList>すぐに反映されます、<xref:System.Collections.IList>です。  
  
 返された要素<xref:System.Collections.IList>の値と同じ順序で並べ替えられて、<xref:System.Collections.SortedList>です。  
  
 このメソッドがに似ていますが、<xref:System.Collections.SortedList.Values%2A>プロパティが返されます、<xref:System.Collections.IList>オブジェクトの代わりに、<xref:System.Collections.ICollection>オブジェクト。  
  
 このメソッドは、o (1) 操作です。  
  
   
  
## Examples  
 次のコード例は、1 つまたはすべてのキーを取得する方法を示しますまたはの値が、<xref:System.Collections.SortedList>オブジェクト。  
  
 [!code-cpp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.GetByIndex Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfKey">
      <MemberSignature Language="C#" Value="public virtual int IndexOfKey (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOfKey(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.IndexOfKey(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key"><see cref="T:System.Collections.SortedList" /> オブジェクト内で検索されるキー。</param>
        <summary>指定されたキーの 0 から始まるインデックスを返します、<see cref="T:System.Collections.SortedList" />オブジェクト。</summary>
        <returns>0 から始まるインデックス、<paramref name="key" />パラメーター場合<paramref name="key" />で見つかった、<see cref="T:System.Collections.SortedList" />オブジェクトです。 それ以外の場合、-1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要素、<xref:System.Collections.SortedList>オブジェクトは、キーにより並べ替えられたいずれかに従って、特定<xref:System.Collections.IComparer>実装では、ときに指定された、<xref:System.Collections.SortedList>が作成された、またはそれに対応する、<xref:System.IComparable>キー自体で提供される実装します。  
  
 インデックス順序は、並べ替え順序に基づいています。 挿入される要素が追加されると、<xref:System.Collections.SortedList>正しい並べ替えの順序、およびインデックス作成もそれに応じて調整します。 要素が削除されると、インデックス作成もそれに応じて調整します。 要素が追加または削除、したがって、特定のキー/値ペアのインデックスを変更可能性があります、<xref:System.Collections.SortedList>です。  
  
 このメソッドは、バイナリ検索アルゴリズムを使用します。そのため、このメソッドは、O (ログ`n`) 操作では、ここで`n`は<xref:System.Collections.SortedList.Count%2A>します。  
  
 以降、.NET Framework 2.0 では、このメソッドを使用して、コレクションのオブジェクトの<xref:System.Object.Equals%2A>と<xref:System.IComparable.CompareTo%2A>メソッド`item`項目が存在するかどうかを確認します。 .NET Framework の以前のバージョンでは、この決定を使用して行われた、<xref:System.Object.Equals%2A>と<xref:System.IComparable.CompareTo%2A>のメソッド、`item`パラメーター コレクション内のオブジェクトにします。  
  
   
  
## Examples  
 次のコード例は、キーまたは値のインデックスを確認する方法を示しています、<xref:System.Collections.SortedList>オブジェクト。  
  
 [!code-cpp[Classic SortedList.IndexOfKey Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.IndexOfKey Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.IndexOfKey Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">比較演算子では、例外をスローします。</exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOfValue">
      <MemberSignature Language="C#" Value="public virtual int IndexOfValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOfValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.IndexOfValue(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">内で検索する値、<see cref="T:System.Collections.SortedList" />オブジェクト。 値として <see langword="null" /> を指定できます。</param>
        <summary>指定した値の最初に見つかった位置の 0 から始まるインデックスを返します、<see cref="T:System.Collections.SortedList" />オブジェクト。</summary>
        <returns>最初に見つかった位置の 0 から始まるインデックス、<paramref name="value" />パラメーター場合<paramref name="value" />で見つかった、<see cref="T:System.Collections.SortedList" />オブジェクトです。 それ以外の場合、-1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス順序は、並べ替え順序に基づいています。 挿入される要素が追加されると、<xref:System.Collections.SortedList>正しい並べ替えの順序、およびインデックス作成もそれに応じて調整します。 要素が削除されると、インデックス作成もそれに応じて調整します。 要素が追加または削除、したがって、特定のキー/値ペアのインデックスを変更可能性があります、<xref:System.Collections.SortedList>オブジェクト。  
  
 要素の値、<xref:System.Collections.SortedList>を使用して、指定した値と比較されます、<xref:System.Object.Equals%2A>メソッドです。  
  
 このメソッドは一方向の検索を使用します。そのため、このメソッドは、O (`n`) 操作では、ここで`n`は<xref:System.Collections.SortedList.Count%2A>します。  
  
 以降、.NET Framework 2.0 では、このメソッドを使用して、コレクションのオブジェクトの<xref:System.Object.Equals%2A>と<xref:System.IComparable.CompareTo%2A>メソッド`item`項目が存在するかどうかを確認します。 .NET Framework の以前のバージョンでは、この決定を使用して行われた、<xref:System.Object.Equals%2A>と<xref:System.IComparable.CompareTo%2A>のメソッド、`item`パラメーター コレクション内のオブジェクトにします。  
  
   
  
## Examples  
 次のコード例は、キーまたは値のインデックスを確認する方法を示しています、<xref:System.Collections.SortedList>オブジェクト。  
  
 [!code-cpp[Classic SortedList.IndexOfKey Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.IndexOfKey Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.IndexOfKey Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public virtual bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>示す値を取得するかどうか、<see cref="T:System.Collections.SortedList" />オブジェクトのサイズが固定されています。</summary>
        <value>
          <see langword="true" />場合、<see cref="T:System.Collections.SortedList" />オブジェクトが固定サイズです。 それ以外の場合、<see langword="false" />です。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 固定サイズ コレクションできない追加または削除の要素のコレクションが作成された後で、既存の要素の変更はできます。  
  
 固定サイズ コレクションが追加および削除する要素を防止するラッパーで単純なコレクションそのための追加または削除、要素を含む、基になるコレクションが変更された場合、固定サイズ コレクションにはそれらの変更が反映されます。  
  
 このプロパティ値を取得することは、O(1) 操作になります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public virtual bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>示す値を取得するかどうか、<see cref="T:System.Collections.SortedList" />オブジェクトは読み取り専用です。</summary>
        <value>
          <see langword="true" />場合、<see cref="T:System.Collections.SortedList" />オブジェクトは読み取り専用です。 それ以外の場合、<see langword="false" />です。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 読み取り専用のコレクションでは、コレクション作成後に要素の追加、削除、または変更はできません。  
  
 読み取り専用であるコレクションは、コレクションのコレクションの変更を防止するラッパーです。そのため、基になるコレクションの変更が加えられた、読み取り専用コレクションはそれらの変更を反映します。  
  
 このプロパティ値を取得することは、O(1) 操作になります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public virtual bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.IsSynchronized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アクセスをするかどうかを示す値を取得、<see cref="T:System.Collections.SortedList" />オブジェクトが同期されている (スレッド セーフである)。</summary>
        <value>
          <see langword="true" /> オブジェクトへのアクセスが同期されている (スレッド セーフである) 場合は <see cref="T:System.Collections.SortedList" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 スレッド セーフを確保する、<xref:System.Collections.SortedList>オブジェクト、によって返されるラッパーを介してすべての操作を行う必要があります、<xref:System.Collections.SortedList.Synchronized%2A>メソッドです。  
  
 コレクションの列挙は、本質的にスレッド セーフなプロシージャではありません。 コレクションの同期がとられている場合でも、別のスレッドによってそのコレクションを変更できるため、変更の結果として列挙子は例外をスローします。 列挙処理を確実にスレッド セーフに行うには、列挙中にコレクションをロックするか、他のスレッドによって行われた変更によってスローされる例外をキャッチします。  
  
   
  
## Examples  
 次のコード例を使用してコレクションをロックする方法を示しています、<xref:System.Collections.SortedList.SyncRoot%2A>列挙中にプロパティです。  
  
 [!code-cpp[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/VB/source2.vb#2)]  
  
 このプロパティ値を取得することは、O(1) 操作になります。  
  
 次のコード例は、同期する方法を示します、<xref:System.Collections.SortedList>オブジェクトを決定するかどうか、<xref:System.Collections.SortedList>が同期されているし、同期を使用して<xref:System.Collections.SortedList>です。  
  
 [!code-cpp[Classic SortedList.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual object this[object key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.Item(System.Object)" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">取得または設定する値に関連付けられたキー。</param>
        <summary>取得し、特定のキーに関連付けられている値を設定、<see cref="T:System.Collections.SortedList" />オブジェクト。</summary>
        <value>関連付けられている値、<paramref name="key" />内のパラメーター、<see cref="T:System.Collections.SortedList" />場合<paramref name="key" />以外、それ以外の場合は、<see langword="null" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用することができます、 <xref:System.Collections.SortedList.Item%2A> 、次の構文を指定することによって、コレクション内の特定の要素にアクセスするプロパティ。`myCollection[key]`です。  
  
 要素を追加する新しいに存在しないキーの値を設定して、このプロパティを使用することもできます、<xref:System.Collections.SortedList>オブジェクト (たとえば、`myCollection["myNonexistentKey"] = myValue)`です。 ただしで指定したキーが既に存在する場合、 <xref:System.Collections.SortedList>、設定、<xref:System.Collections.SortedList.Item%2A>プロパティに古い値が上書きされます。 これに対し、<xref:System.Collections.SortedList.Add%2A>メソッドでは、既存の要素は変更しません。  
  
 キーには`null`値を指定できますが、します。 区別するために`null`指定したキーが見つからないため、返されると`null`指定したキーの値が返される`null`を使用して、<xref:System.Collections.SortedList.Contains%2A>メソッドまたは<xref:System.Collections.SortedList.ContainsKey%2A>一覧で、キーが存在するかどうかを決定するメソッド。  
  
 要素、<xref:System.Collections.SortedList>キーにより並べ替えられた、固有の仕様に従って、<xref:System.Collections.IComparer>実装では、ときに指定された、<xref:System.Collections.SortedList>が作成されたかに応じて、<xref:System.IComparable>キー自体で提供される実装します。  
  
 C# 言語キーワードを使用して実装する代わりに、インデクサーの定義、<xref:System.Collections.SortedList.Keys%2A>プロパティです。 Visual Basic は、<xref:System.Collections.SortedList.Item%2A> を既定のプロパティとして実装しており、同様のインデックス機能を提供します。  
  
 O は、このプロパティの値を取得する (ログ`n`) 操作では、ここで`n`は<xref:System.Collections.SortedList.Count%2A>します。 プロパティの設定は、O (ログ`n`) 操作の場合は、キーは既に、<xref:System.Collections.SortedList>です。 キーがない場合、一覧で、プロパティの設定は O (`n`)、並べ替えられていないデータまたは O の操作 (ログ`n`) 場合は、新しい要素は、リストの末尾に追加します。 カーソルでは、サイズ変更が発生する場合、操作は O (`n`)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException">プロパティが設定され、<see cref="T:System.Collections.SortedList" />オブジェクトは読み取り専用です。  
  
 または  
  
 プロパティを設定すると、 <paramref name="key" /> 、コレクションに存在しません、<see cref="T:System.Collections.SortedList" />固定サイズです。</exception>
        <exception cref="T:System.OutOfMemoryException">要素を追加するための十分な使用可能なメモリがない、<see cref="T:System.Collections.SortedList" />です。</exception>
        <exception cref="T:System.InvalidOperationException">比較演算子では、例外をスローします。</exception>
      </Docs>
    </Member>
    <Member MemberName="Keys">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ICollection Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.Keys" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>内のキーを取得、<see cref="T:System.Collections.SortedList" />オブジェクト。</summary>
        <value><see cref="T:System.Collections.ICollection" />オブジェクト内のキーを含む、<see cref="T:System.Collections.SortedList" />オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ICollection>オブジェクトは、キーの読み取り専用ビュー、<xref:System.Collections.SortedList>オブジェクト。 基になる変更を加える<xref:System.Collections.SortedList>すぐに反映されます、<xref:System.Collections.ICollection>です。  
  
 要素、<xref:System.Collections.ICollection>のキーと同じ順序で並べ替えられて、<xref:System.Collections.SortedList>です。  
  
 このプロパティがに似ていますが、<xref:System.Collections.SortedList.GetKeyList%2A>メソッド、コードが返されます、<xref:System.Collections.ICollection>オブジェクトの代わりに、<xref:System.Collections.IList>オブジェクト。  
  
 このメソッドは、o (1) 操作です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public virtual void Remove (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Remove(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Remove(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">削除する要素のキー。</param>
        <summary>指定したキーを持つ要素を削除、<see cref="T:System.Collections.SortedList" />オブジェクト。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定したキーを持つ要素が <xref:System.Collections.SortedList> オブジェクトに格納されていない場合、<xref:System.Collections.SortedList> は変更されません。 例外をスローすることはありません。  
  
 リストなどの連続する要素のコレクションでは、空白になった位置を埋めるために、削除された要素の後にある要素の位置が繰り上げられます。 コレクションにインデックスがある場合、移動した要素のインデックスも更新されます。 この動作は、要素が概念的にバケットにグループ化されているハッシュ テーブルなどのコレクションには適用されません。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は<xref:System.Collections.SortedList.Count%2A>します。  
  
   
  
## Examples  
 次のコード例は、要素を削除する方法を示しています、<xref:System.Collections.SortedList>オブジェクト。  
  
 [!code-cpp[Classic SortedList.RemoveAt Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.RemoveAt Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.RemoveAt Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.SortedList" />オブジェクトは読み取り専用です。  
  
 または  
  
 <see cref="T:System.Collections.SortedList" /> は固定サイズです。</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public virtual void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.RemoveAt(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">削除する要素の 0 から始まるインデックス。</param>
        <summary>指定したインデックス位置にある要素を削除、<see cref="T:System.Collections.SortedList" />オブジェクト。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス順序は、並べ替え順序に基づいています。 挿入される要素が追加されると、<xref:System.Collections.SortedList>正しい並べ替えの順序、およびインデックス作成もそれに応じて調整します。 要素が削除されると、インデックス作成もそれに応じて調整します。 要素が追加または削除、したがって、特定のキー/値ペアのインデックスを変更可能性があります、<xref:System.Collections.SortedList>オブジェクト。  
  
 リストなどの連続する要素のコレクションでは、空白になった位置を埋めるために、削除された要素の後にある要素の位置が繰り上げられます。 コレクションにインデックスがある場合、移動した要素のインデックスも更新されます。 この動作は、要素が概念的にバケットにグループ化されているハッシュ テーブルなどのコレクションには適用されません。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は<xref:System.Collections.SortedList.Count%2A>します。  
  
   
  
## Examples  
 次のコード例は、要素を削除する方法を示しています、<xref:System.Collections.SortedList>オブジェクト。  
  
 [!code-cpp[Classic SortedList.RemoveAt Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.RemoveAt Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.RemoveAt Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />有効なインデックスの範囲外である、<see cref="T:System.Collections.SortedList" />オブジェクト。</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.SortedList" /> は読み取り専用です。  
  
 -または-  
  
 <see cref="T:System.Collections.SortedList" /> は固定サイズです。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetByIndex">
      <MemberSignature Language="C#" Value="public virtual void SetByIndex (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetByIndex(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.SetByIndex(System.Int32,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">保存先となる位置の 0 から始まるインデックス<c>値</c>です。</param>
        <param name="value"><see cref="T:System.Object" />に保存する、<see cref="T:System.Collections.SortedList" />オブジェクト。 値として <see langword="null" /> を指定できます。</param>
        <summary>特定のインデックスの値で置き換え、<see cref="T:System.Collections.SortedList" />オブジェクト。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス順序は、並べ替え順序に基づいています。 挿入される要素が追加されると、<xref:System.Collections.SortedList>正しい並べ替えの順序、およびインデックス作成もそれに応じて調整します。 要素が削除されると、インデックス作成もそれに応じて調整します。 要素が追加または削除、したがって、特定のキー/値ペアのインデックスを変更可能性があります、<xref:System.Collections.SortedList>オブジェクト。  
  
 このメソッドは、o (1) 操作です。  
  
   
  
## Examples  
 次のコード例で既存の要素の値を交換する方法を示しています、<xref:System.Collections.SortedList>オブジェクト。  
  
 [!code-cpp[Classic SortedList.SetByIndex Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.SetByIndex Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.SetByIndex Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.SetByIndex Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.SetByIndex Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.SetByIndex Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />有効なインデックスの範囲外である、<see cref="T:System.Collections.SortedList" />オブジェクト。</exception>
      </Docs>
    </Member>
    <Member MemberName="Synchronized">
      <MemberSignature Language="C#" Value="public static System.Collections.SortedList Synchronized (System.Collections.SortedList list);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.SortedList Synchronized(class System.Collections.SortedList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Synchronized(System.Collections.SortedList)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.SortedList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="list" Type="System.Collections.SortedList" />
      </Parameters>
      <Docs>
        <param name="list">同期する <see cref="T:System.Collections.SortedList" /> オブジェクト。</param>
        <summary>同期 (スレッド セーフである) ラッパーを返します、<see cref="T:System.Collections.SortedList" />オブジェクト。</summary>
        <returns>A 同期 (スレッド セーフである) ラッパーを<see cref="T:System.Collections.SortedList" />オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 スレッド セーフを確保する、<xref:System.Collections.SortedList>オブジェクト、このラッパーのみを通じてすべての操作を行う必要があります。  
  
 コレクションの列挙は、本質的にスレッド セーフなプロシージャではありません。 コレクションの同期がとられている場合でも、別のスレッドによってそのコレクションを変更できるため、変更の結果として列挙子は例外をスローします。 列挙処理を確実にスレッド セーフに行うには、列挙中にコレクションをロックするか、他のスレッドによって行われた変更によってスローされる例外をキャッチします。  
  
   
  
## Examples  
 次のコード例を使用してコレクションをロックする方法を示しています、<xref:System.Collections.SortedList.SyncRoot%2A>列挙中にプロパティです。  
  
 [!code-cpp[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/VB/source2.vb#2)]  
  
 このメソッドは、o (1) 操作です。  
  
 次のコード例は、同期する方法を示します、<xref:System.Collections.SortedList>オブジェクトを決定するかどうか、<xref:System.Collections.SortedList>が同期されているし、同期を使用して<xref:System.Collections.SortedList>です。  
  
 [!code-cpp[Classic SortedList.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="list" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public virtual object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.SyncRoot" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アクセスを同期するために使用できるオブジェクトを取得、<see cref="T:System.Collections.SortedList" />オブジェクト。</summary>
        <value><see cref="T:System.Collections.SortedList" /> オブジェクトへのアクセスを同期するために使用できるオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 同期されたバージョンを作成する、<xref:System.Collections.SortedList>オブジェクトを使用して、<xref:System.Collections.SortedList.Synchronized%2A>メソッドです。 ただし、派生クラスは、独自の同期されたバージョンを指定、<xref:System.Collections.SortedList>を使用して、<xref:System.Collections.SortedList.SyncRoot%2A>プロパティです。 同期されたコードで操作を実行する必要があります、<xref:System.Collections.SortedList.SyncRoot%2A>の<xref:System.Collections.SortedList>、上で直接、<xref:System.Collections.SortedList>です。 これにより、他のオブジェクトから派生したコレクションを適切に操作できるようになります。 具体的には、同時に変更する可能性がある別スレッドとの適切な同期を維持、<xref:System.Collections.SortedList>オブジェクト。  
  
 コレクションの列挙は、本質的にスレッド セーフなプロシージャではありません。 コレクションの同期がとられている場合でも、別のスレッドによってそのコレクションを変更できるため、変更の結果として列挙子は例外をスローします。 列挙処理を確実にスレッド セーフに行うには、列挙中にコレクションをロックするか、他のスレッドによって行われた変更によってスローされる例外をキャッチします。  
  
   
  
## Examples  
 次のコード例を使用してコレクションをロックする方法を示しています、<xref:System.Collections.SortedList.SyncRoot%2A>列挙中にプロパティです。  
  
 [!code-cpp[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/VB/source2.vb#2)]  
  
 このプロパティ値を取得することは、O(1) 操作になります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.System#Collections#IEnumerable#GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返します、<see cref="T:System.Collections.IEnumerator" />を反復処理する、<see cref="T:System.Collections.SortedList" />です。</summary>
        <returns><see cref="T:System.Collections.IEnumerator" /> の <see cref="T:System.Collections.SortedList" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Visual Basic、C# の場合]  
  
 C# 言語の `foreach` ステートメント (Visual Basic の場合は `for each`) を使用することで列挙子の複雑さを回避できます。  したがって、列挙子を直接操作するのではなく、`foreach` を使用することをお勧めします。  
  
 列挙子を使用すると、コレクション内のデータを読み取ることができますが、基になるコレクションを変更することはできません。  
  
 最初に、列挙子はコレクション内の 1 番目の要素の前に位置付けられます。 <xref:System.Collections.IEnumerator.Reset%2A> を実行した場合も、列挙子はこの位置に戻されます。 この位置で、呼び出す<xref:System.Collections.IEnumerator.Current%2A>例外をスローします。 そのため、<xref:System.Collections.IEnumerator.MoveNext%2A> の値を読み取る前に、<xref:System.Collections.IEnumerator.Current%2A> を呼び出して列挙子をコレクションの最初の要素に進める必要があります。  
  
 <xref:System.Collections.IEnumerator.Current%2A> は、<xref:System.Collections.IEnumerator.MoveNext%2A> または <xref:System.Collections.IEnumerator.Reset%2A> が呼び出されるまでは同じオブジェクトを返します。 <xref:System.Collections.IEnumerator.MoveNext%2A> は、<xref:System.Collections.IEnumerator.Current%2A> を次の要素に設定します。  
  
 場合<xref:System.Collections.IEnumerator.MoveNext%2A>列挙子をコレクションの末尾が、コレクション内の最後の要素の後に配置されているパスと<xref:System.Collections.IEnumerator.MoveNext%2A>返します`false`です。 列挙子がこの位置では、後続の呼び出しの場合<xref:System.Collections.IEnumerator.MoveNext%2A>を返すことも`false`します。 場合は、最後の呼び出し<xref:System.Collections.IEnumerator.MoveNext%2A>返される`false`、呼び出し元<xref:System.Collections.IEnumerator.Current%2A>例外をスローします。 <xref:System.Collections.IEnumerator.Current%2A> をコレクションの最初の要素にもう一度設定するには、<xref:System.Collections.IEnumerator.Reset%2A> を呼び出してから <xref:System.Collections.IEnumerator.MoveNext%2A> を呼び出します。  
  
 コレクションが変更されない限り、列挙子は有効です。 無効になり、次の呼び出しに変更を追加するなど、コレクションを変更、または要素を削除するには、列挙子は回復不可能<xref:System.Collections.IEnumerator.MoveNext%2A>または<xref:System.Collections.IEnumerator.Reset%2A>スロー、<xref:System.InvalidOperationException>です。 間で、コレクションが変更された場合<xref:System.Collections.IEnumerator.MoveNext%2A>と<xref:System.Collections.IEnumerator.Current%2A>、<xref:System.Collections.IEnumerator.Current%2A>列挙子が既に無効になっている場合でもに設定されている要素を返します。  
  
 列挙子にはコレクションへの排他アクセス権限はないため、コレクションの列挙処理は本質的にスレッド セーフな処理ではありません。 コレクションの同期がとられている場合でも、別のスレッドによってそのコレクションを変更できるため、変更の結果として列挙子は例外をスローします。 列挙処理を確実にスレッド セーフに行うには、列挙中にコレクションをロックするか、他のスレッドによって行われた変更によってスローされる例外をキャッチします。  
  
 このメソッドは、o (1) 操作です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimToSize">
      <MemberSignature Language="C#" Value="public virtual void TrimToSize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void TrimToSize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.TrimToSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>実際の要素数を容量を設定、<see cref="T:System.Collections.SortedList" />オブジェクト。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、コレクションのメモリ オーバーヘッドを最小要素がコレクションに追加されない場合に使用できます。  
  
 リセット、<xref:System.Collections.SortedList>を呼び出し、初期状態のオブジェクト、<xref:System.Collections.SortedList.Clear%2A>メソッドを呼び出す前に<xref:System.Collections.SortedList.TrimToSize%2A>です。 空のトリミング<xref:System.Collections.SortedList>のキャパシティを設定、<xref:System.Collections.SortedList>を既定の容量。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は<xref:System.Collections.SortedList.Count%2A>します。  
  
   
  
## Examples  
 次のコード例の未使用部分をトリミングする方法を示しています、<xref:System.Collections.SortedList>オブジェクトとその値をクリアする方法です。  
  
 [!code-cpp[Classic SortedList.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.SortedList" />オブジェクトは読み取り専用です。  
  
 または  
  
 <see cref="T:System.Collections.SortedList" /> は固定サイズです。</exception>
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ICollection Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.Values" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>内の値を取得、<see cref="T:System.Collections.SortedList" />オブジェクト。</summary>
        <value><see cref="T:System.Collections.ICollection" />オブジェクトの値を含む、<see cref="T:System.Collections.SortedList" />オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ICollection>オブジェクトは、の値の読み取り専用ビュー、<xref:System.Collections.SortedList>オブジェクト。 基になる変更を加える<xref:System.Collections.SortedList>すぐに反映されます、<xref:System.Collections.ICollection>です。  
  
 要素、<xref:System.Collections.ICollection>の値と同じ順序で並べ替えられて、<xref:System.Collections.SortedList>です。  
  
 このプロパティがに似ていますが、<xref:System.Collections.SortedList.GetValueList%2A>メソッド、コードが返されます、<xref:System.Collections.ICollection>オブジェクトの代わりに、<xref:System.Collections.IList>オブジェクト。  
  
 このメソッドは、o (1) 操作です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
