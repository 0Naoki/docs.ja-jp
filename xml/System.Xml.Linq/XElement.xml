<Type Name="XElement" FullName="System.Xml.Linq.XElement">
  <TypeSignature Language="C#" Value="public class XElement : System.Xml.Linq.XContainer, System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XElement extends System.Xml.Linq.XContainer implements class System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="DocId" Value="T:System.Xml.Linq.XElement" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.XDocument</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.Linq</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Xml.Linq.XContainer</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Xml.Serialization.IXmlSerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeDescriptionProvider(typeof(MS.Internal.Xml.Linq.ComponentModel.XTypeDescriptionProvider`1&lt;System.Xml.Linq.XElement&gt;))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Xml.Serialization.XmlSchemaProvider(null, IsAny=true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>XML 要素を表します。  参照してください[XElement クラスの概要](http://msdn.microsoft.com/library/d35180fe-7016-4895-9bfc-ba1e3f7875ec)と使用法と例については、このページの「解説」セクション。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  この型の .NET Framework ソース コードを表示するを参照してください。、[参照ソース](http://referencesource.microsoft.com/#System.Xml.Linq/XLinq.cs#3367036406d1344a)です。 ソース コードをオンラインで参照、オフラインで表示、リファレンスをダウンロードおよび; デバッグ中にソース (パッチや更新を含む) をステップ参照してください[指示](http://referencesource.microsoft.com/)です。  
  
 このクラスは、XML 要素、基本的な XML 構造を表します。  参照してください[XElement クラスの概要](http://msdn.microsoft.com/library/d35180fe-7016-4895-9bfc-ba1e3f7875ec)の他の使用状況情報。  
  
 要素が、<xref:System.Xml.Linq.XName>で、必要に応じて、その属性し、コンテンツを含めることができます必要に応じて 1 つまたは複数 (詳細については、次を参照してください。 <xref:System.Xml.Linq.XContainer.Nodes%2A>)。  
  
 <xref:System.Xml.Linq.XElement>次の種類のコンテンツを含めることができます。  
  
-   <xref:System.Xml.Linq.XElement>  
  
-   <xref:System.Xml.Linq.XComment>  
  
-   <xref:System.Xml.Linq.XProcessingInstruction>  
  
-   <xref:System.Xml.Linq.XText>  
  
 有効なコンテンツの詳細について、<xref:System.Xml.Linq.XElement>を参照してください[有効なコンテンツの XElement オブジェクトと XDocument オブジェクト](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)です。  
  
 <xref:System.Xml.Linq.XElement>派生した<xref:System.Xml.Linq.XContainer>から派生した<xref:System.Xml.Linq.XNode>です。  
  
 いくつか<xref:System.Xml.Linq.XElement>XAML からメソッドを使用することができます。 詳細については、「[LINQ to XML の動的プロパティ](http://msdn.microsoft.com/library/0455f47c-4a68-4f2e-a3f8-dd1d85b99012)」を参照してください。  
  
   
  
## Examples  
 次の例では、XML ツリーを作成します。 新しい要素の内容は、LINQ クエリから取得されます。  
  
```csharp  
  
                XElement xmlTree1 = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5),  
    new XElement("Child6", 6)  
);  
  
XElement xmlTree2 = new XElement("Root",  
    from el in xmlTree1.Elements()  
    where((int)el >= 3 && (int)el <= 5)  
    select el  
);  
Console.WriteLine(xmlTree2);  
```  
  
```vb  
  
                Dim xmlTree1 As XElement = _  
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
            <Child6>6</Child6>  
        </Root>  
  
Dim xmlTree2 As XElement = _   
    <Root>  
        <%= From el In xmlTree1.Elements() _  
            Where el.Value >= 3 And el.Value <= 5 _  
            Select el %>  
    </Root>  
  
Console.WriteLine(xmlTree2)  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```xml  
  
                <Root>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 同じ例を次に示しますが、ここで、XML が名前空間には。 詳細については、次を参照してください。 [XML 名前空間の使用](http://msdn.microsoft.com/library/e3003209-3234-45be-a832-47feb7927430)です。  
  
```csharp  
  
                XNamespace aw = "http://www.adventure-works.com";  
XElement xmlTree1 = new XElement(aw + "Root",  
    new XElement(aw + "Child1", 1),  
    new XElement(aw + "Child2", 2),  
    new XElement(aw + "Child3", 3),  
    new XElement(aw + "Child4", 4),  
    new XElement(aw + "Child5", 5),  
    new XElement(aw + "Child6", 6)  
);  
  
XElement xmlTree2 = new XElement(aw + "Root",  
    from el in xmlTree1.Elements()  
    where((int)el >= 3 && (int)el <= 5)  
    select el  
);  
Console.WriteLine(xmlTree2);  
```  
  
```vb  
  
                Imports <xmlns="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim xmlTree1 As XElement = _  
            <Root>  
                <Child1>1</Child1>  
                <Child2>2</Child2>  
                <Child3>3</Child3>  
                <Child4>4</Child4>  
                <Child5>5</Child5>  
                <Child6>6</Child6>  
            </Root>  
  
        Dim xmlTree2 As XElement = _   
            <Root>  
                <%= From el In xmlTree1.Elements() _  
                    Where el.Value >= 3 And el.Value <= 5 _  
                    Select el %>  
            </Root>  
  
        Console.WriteLine(xmlTree2)  
    End SUb  
End Module  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```xml  
  
                <Root xmlns="http://www.adventure-works.com">  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Xml.Linq.XElement" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンス トラクターに渡すことができる有効なコンテンツに関する詳細については、「[有効なコンテンツの XElement オブジェクトと XDocument オブジェクト](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)です。  
  
 文字列からの暗黙的な変換がある<xref:System.Xml.Linq.XName>です。 新たに作成する代わりにパラメーターとして文字列を指定するのには、このコンス トラクターの一般的な使用<xref:System.Xml.Linq.XName>です。  
  
 加算演算子オーバー ロードを使用する一般的な使用方法を名前空間内の要素を作成するとき、<xref:System.Xml.Linq.XNamespace>および作成する文字列、<xref:System.Xml.Linq.XName>です。 詳細については、次を参照してください。 [XML 名前空間の使用](http://msdn.microsoft.com/library/e3003209-3234-45be-a832-47feb7927430)です。  
  
   
  
## Examples  
 次の例では、XML ツリーを作成します。 新しい要素の内容は、LINQ クエリから取得されます。  
  
```csharp  
  
                XElement xmlTree1 = new XElement("Root",  
    new XElement("Child", 1),  
    new XElement("Child", 2),  
    new XElement("Child", 3),  
    new XElement("Child", 4),  
    new XElement("Child", 5),  
    new XElement("Child", 6)  
);  
  
XElement xmlTree2 = new XElement("Root",  
    from el in xmlTree1.Elements()  
    where((int)el >= 3 && (int)el <= 5)  
    select el  
);  
Console.WriteLine(xmlTree2);  
```  
  
```vb  
  
                Dim xmlTree1 As XElement = _   
        <Root>  
            <Child>1</Child>  
            <Child>2</Child>  
            <Child>3</Child>  
            <Child>4</Child>  
            <Child>5</Child>  
            <Child>6</Child>  
        </Root>  
  
Dim xmlTree2 As XElement = _  
    <Root>  
        <%= From el In xmlTree1.Elements() _  
            Where el.Value >= 3 And el.Value <= 5 _  
            Select el %>  
    </Root>  
  
Console.WriteLine(xmlTree2)  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```xml  
  
                <Root>  
  <Child>3</Child>  
  <Child>4</Child>  
  <Child>5</Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XElement (System.Xml.Linq.XElement other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.Linq.XElement other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XElement)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="other" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="other"><see cref="T:System.Xml.Linq.XElement" />からコピー先のオブジェクト。</param>
        <summary>新しいインスタンスを初期化、<see cref="T:System.Xml.Linq.XElement" />から別のクラス<see cref="T:System.Xml.Linq.XElement" />オブジェクト。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンス トラクターは、要素のディープ コピーを作成します。  
  
   
  
## Examples  
 次の例は、XML ツリーを作成して、ツリーの複製を作成しを呼び出して<xref:System.Xml.Linq.XNode.DeepEquals%2A>、2 つの XML ツリーが等しいかどうかをテストします。  
  
```csharp  
  
                XElement xmlTree = new XElement("Root",  
    new XAttribute("Att1", 1),  
    new XElement("Child1", 1),  
    new XElement("Child2", 2)  
);  
  
// Create a clone of the tree.  
XElement treeClone = new XElement(xmlTree);  
  
Console.WriteLine("xmlTree = treeClone: {0}", XNode.DeepEquals(xmlTree, treeClone));  
  
// Do some work with xmlTree, perhaps pass it to other methods.  
xmlTree.Add(new XElement("Child3", 3));  
  
Console.WriteLine("xmlTree = treeClone: {0}", XNode.DeepEquals(xmlTree, treeClone));  
```  
  
```vb  
  
                Dim xmlTree As XElement = _  
        <Root Att1="1">  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
        </Root>  
  
' Create a clone of the tree.  
Dim treeClone As XElement = New XElement(xmlTree)  
  
Console.WriteLine("xmlTree = treeClone: {0}", XNode.DeepEquals(xmlTree, treeClone))  
  
' Do some work with xmlTree, perhaps pass it to other methods.  
xmlTree.Add(New XElement("Child3", 3))  
  
Console.WriteLine("xmlTree = treeClone: {0}", XNode.DeepEquals(xmlTree, treeClone))  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                xmlTree = treeClone: True  
xmlTree = treeClone: False  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XElement (System.Xml.Linq.XName name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.Linq.XName name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="name"><see cref="T:System.Xml.Linq.XName" />要素の名前を格納しています。</param>
        <summary>指定した名前を使用して、<see cref="T:System.Xml.Linq.XElement" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンス トラクターは、内容と属性を持たない要素を作成します。  
  
 文字列からの暗黙的な変換がある<xref:System.Xml.Linq.XName>です。 新たに作成する代わりにパラメーターとして文字列を指定するのには、このコンス トラクターの一般的な使用<xref:System.Xml.Linq.XName>です。 加算演算子オーバー ロードを使用する一般的な使用方法を名前空間内の要素を作成するとき、<xref:System.Xml.Linq.XNamespace>および作成する文字列、<xref:System.Xml.Linq.XName>です。 詳細については、次を参照してください。 [XML 名前空間の使用](http://msdn.microsoft.com/library/e3003209-3234-45be-a832-47feb7927430)です。  
  
   
  
## Examples  
 次の例では、内容の要素を作成しません。  
  
```csharp  
  
                XElement el = new XElement("Root");  
Console.WriteLine(el);  
```  
  
```vb  
  
                Dim el As XElement = <Root/>  
Console.WriteLine(el)  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```xml  
  
<Root />  
```  
  
 次の例では、コンテンツがないと、名前空間に要素を作成します。 詳細については、次を参照してください。 [XML 名前空間の使用](http://msdn.microsoft.com/library/e3003209-3234-45be-a832-47feb7927430)です。  
  
```  
  
                XNamespace aw = "http://www.adventure-works.com";  
XElement root = new XElement(aw + "Root");  
Console.WriteLine(root);  
```  
  
```vb  
  
                Imports <xmlns="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim root = <Root/>  
        Console.WriteLine(root)  
    End Sub  
End Module  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```xml  
  
<Root xmlns="http://www.adventure-works.com" />  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XElement (System.Xml.Linq.XStreamingElement other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.Linq.XStreamingElement other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XStreamingElement)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="other" Type="System.Xml.Linq.XStreamingElement" />
      </Parameters>
      <Docs>
        <param name="other"><see cref="T:System.Xml.Linq.XStreamingElement" />これの内容を繰り返し処理される未評価のクエリを格納している<see cref="T:System.Xml.Linq.XElement" />です。</param>
        <summary>新しいインスタンスを初期化、<see cref="T:System.Xml.Linq.XElement" />クラス、<see cref="T:System.Xml.Linq.XStreamingElement" />オブジェクト。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンス トラクターは、指定の内容を反復処理<xref:System.Xml.Linq.XStreamingElement>、され、その内容の要素を作成します。  
  
   
  
## Examples  
 次の例は、ソース XML ツリーを作成し、作成し、<xref:System.Xml.Linq.XStreamingElement>ソース XML ツリーに対してクエリからです。 シリアル化し、<xref:System.Xml.Linq.XStreamingElement>をコンソールには、ソース XML ツリーに新しい要素を追加し、シリアル化し、<xref:System.Xml.Linq.XStreamingElement>もう一度です。 ソース XML ツリーに新しく追加された要素の最初のシリアル化には含まれませんが、2 番目に含まれてを表示できます。  
  
```csharp  
  
                XElement src = new XElement("Root",  
                   new XElement("Child1", 1),  
                   new XElement("Child2", 2),  
                   new XElement("Child3", 3)  
               );  
XStreamingElement xse = new XStreamingElement("NewRoot",  
                            from el in src.Elements()  
                            where (int)el >= 2  
                            select el  
                        );  
Console.WriteLine(xse);  
src.Add(new XElement("Child4", 4));  
Console.WriteLine("----");  
Console.WriteLine(xse);  
```  
  
```vb  
  
                Dim src As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
        </Root>  
Dim xse As XStreamingElement = New XStreamingElement("NewRoot", _  
        From el In src.Elements() _  
        Where (CInt(el) >= 2) _  
        Select el _  
)  
Console.WriteLine(xse)  
src.Add(New XElement("Child4", 4))  
Console.WriteLine("----")  
Console.WriteLine(xse)  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                <NewRoot>  
  <Child2>2</Child2>  
  <Child3>3</Child3>  
</NewRoot>  
----  
<NewRoot>  
  <Child2>2</Child2>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XElement (System.Xml.Linq.XName name, object content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.Linq.XName name, object content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName,System.Object)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
        <Parameter Name="content" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name"><see cref="T:System.Xml.Linq.XName" />要素名を含むです。</param>
        <param name="content">要素の内容。</param>
        <summary>新しいインスタンスを初期化、<see cref="T:System.Xml.Linq.XElement" />指定した名前と内容を持つクラス。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンス トラクターは、指定されたコンテンツおよび属性を持つ要素を作成します。  
  
 文字列からの暗黙的な変換がある<xref:System.Xml.Linq.XName>です。 新たに作成する代わりにパラメーターとして文字列を指定するのには、このコンス トラクターの一般的な使用<xref:System.Xml.Linq.XName>です。  
  
 加算演算子オーバー ロードを使用する一般的な使用方法を名前空間内の要素を作成するとき、<xref:System.Xml.Linq.XNamespace>および作成する文字列、<xref:System.Xml.Linq.XName>です。 詳細については、次を参照してください。 [XML 名前空間の使用](http://msdn.microsoft.com/library/e3003209-3234-45be-a832-47feb7927430)です。  
  
 このコンス トラクターに渡すことができる有効なコンテンツに関する詳細については、「[有効なコンテンツの XElement オブジェクトと XDocument オブジェクト](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)です。  
  
   
  
## Examples  
 次の例では、XML ツリーを作成します。 新しい要素の内容は、LINQ クエリから取得されます。  
  
```csharp  
  
                XElement xmlTree1 = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5),  
    new XElement("Child6", 6)  
);  
  
XElement xmlTree2 = new XElement("Root",  
    from el in xmlTree1.Elements()  
    where((int)el >= 3 && (int)el <= 5)  
    select el  
);  
Console.WriteLine(xmlTree2);  
```  
  
```vb  
  
                Dim xmlTree1 As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
            <Child6>6</Child6>  
        </Root>  
  
Dim xmlTree2 As XElement = _  
    <Root>  
        <%= From el In xmlTree1.Elements() _  
            Where el.Value >= 3 And el.Value <= 5 _  
            Select el %>  
    </Root>  
  
Console.WriteLine(xmlTree2)  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```xml  
  
                <Root>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 次の例では、さまざまな種類のコンテンツの XML ツリーを作成します。  
  
```csharp  
  
                XElement root;  
  
// String content:  
root = new XElement("Root", "Some text");  
Console.WriteLine(root);  
  
// XElement object content:  
root = new XElement("Root",   
    new XElement("NewChild", "n")  
);  
Console.WriteLine(root);  
  
// XAttribute object content:  
root = new XElement("Root",   
    new XAttribute("NewAttribute", "n")  
);  
Console.WriteLine(root);  
  
// Double content:  
double dbl = 12.345;  
root = new XElement("Root", dbl);  
Console.WriteLine(root);  
  
// DateTime content:  
DateTime dt = new DateTime(2006, 10, 6, 12, 30, 00);  
root = new XElement("Root", dt);  
Console.WriteLine(root);  
  
// String array content:  
// Any collection other than a collection of XElement or XAttribute objects  
// are converted to strings. The strings are concatenated and added.  
string[] stringArray = {  
    "abc",  
    "def",  
    "ghi"  
};  
root = new XElement("Root", stringArray);  
Console.WriteLine(root);  
  
// XElement object array content:  
XElement[] ellArray = {  
    new XElement("NewChild1", 1),  
    new XElement("NewChild2", 2),  
    new XElement("NewChild3", 3)  
};  
root = new XElement("Root", ellArray);  
Console.WriteLine(root);  
  
// XAttribute object array content:  
XAttribute[] attArray = {  
    new XAttribute("NewAtt1", 1),  
    new XAttribute("NewAtt2", 2),  
    new XAttribute("NewAtt3", 3)  
};  
root = new XElement("Root", attArray);  
Console.WriteLine(root);  
```  
  
```vb  
  
                Dim root As XElement  
  
' String content:  
root = <Root>Some text</Root>  
Console.WriteLine(root)  
  
' XElement object content:  
root = <Root>  
           <NewChild>n</NewChild>  
       </Root>  
Console.WriteLine(root)  
  
' XAttribute object content:  
root = <Root NewAttribute="n"/>  
Console.WriteLine(root)  
  
' Double content:  
Dim dbl As Double = 12.345  
root = <Root><%= dbl %></Root>  
Console.WriteLine(root)  
  
' DateTime content:  
Dim dt As DateTime = New DateTime(2006, 10, 6, 12, 30, 0)  
root = <Root><%= dt %></Root>  
Console.WriteLine(root)  
  
' String array content:  
' Any collection other than a collection of XElement or XAttribute objects  
' are converted to strings. The strings are concatenated and added.  
  
Dim stringArray As String() = { _  
    "abc", _  
    "def", _  
    "ghi" _  
}  
root = <Root><%= stringArray %></Root>  
Console.WriteLine(root)  
  
' XElement object array content:  
Dim ellArray As XElement() = { _  
    <NewChild1>1</NewChild1>, _  
    <NewChild2>2</NewChild2>, _  
    <NewChild3>3</NewChild3> _  
}  
  
root = <Root><%= ellArray %></Root>  
Console.WriteLine(root)  
  
' XAttribute object array content  
Dim attArray As XAttribute() = { _  
    New XAttribute("NewAtt1", 1), _  
    New XAttribute("NewAtt2", 2), _  
    New XAttribute("NewAtt3", 3) _  
}  
root = <Root><%= attArray %></Root>  
Console.WriteLine(root)  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                <Root>Some text</Root>  
<Root>  
  <NewChild>n</NewChild>  
</Root>  
<Root NewAttribute="n" />  
<Root>12.345</Root>  
<Root>2006-10-06T12:30:00</Root>  
<Root>abcdefghi</Root>  
<Root>  
  <NewChild1>1</NewChild1>  
  <NewChild2>2</NewChild2>  
  <NewChild3>3</NewChild3>  
</Root>  
<Root NewAtt1="1" NewAtt2="2" NewAtt3="3" />  
```  
  
 次の例では、名前空間で XML ツリーを作成します。  
  
```csharp  
  
                // Create an XML tree in a namespace.  
XNamespace aw = "http://www.adventure-works.com";  
XElement root = new XElement(aw + "Root",  
    new XElement(aw + "Child", "child content")  
);  
Console.WriteLine(root);  
```  
  
```vb  
  
                ' Create an XML tree in a namespace.  
Dim root As XElement = _   
    <Root xmlns='http://www.adventure-works.com'>  
        <Child>child content</Child>  
    </Root>  
Console.WriteLine(root)  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```xml  
  
                <Root xmlns="http://www.adventure-works.com">  
  <Child>child content</Child>  
</Root>  
```  
  
 次の例では、入れ子になった名前空間を持つ XML ツリーを作成します。  
  
```csharp  
  
                // Create an XML tree with nested namespaces.  
XNamespace aw = "http://www.adventure-works.com";  
XNamespace fc = "www.fourthcoffee.com";  
XDocument root = new XDocument(  
    new XDeclaration("1.0", "utf-8", "yes"),  
    new XElement(aw + "Root",  
        new XElement(fc + "Child",  
            new XElement(aw + "DifferentChild", "other content")  
        )  
    )  
);  
Console.WriteLine(root);  
```  
  
```vb  
  
                ' Create an XML tree with nested namespaces.  
Dim root As XDocument = _   
    <?xml version='1.0'?>  
    <Root xmlns='http://www.adventure-works.com'>  
        <Child xmlns='www.fourthcoffee.com'>  
        <DifferentChild xmlns='http://www.adventure-works.com'>other content</DifferentChild>  
        </Child>  
    </Root>  
Console.WriteLine(root)  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```xml  
  
                <Root xmlns="http://www.adventure-works.com">  
  <Child xmlns="www.fourthcoffee.com">  
    <DifferentChild xmlns="http://www.adventure-works.com">other content</DifferentChild>  
  </Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XElement (System.Xml.Linq.XName name, params object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.Linq.XName name, object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName,System.Object[])" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="name"><see cref="T:System.Xml.Linq.XName" />要素名を含むです。</param>
        <param name="content">要素の初期コンテンツ。</param>
        <summary>新しいインスタンスを初期化、<see cref="T:System.Xml.Linq.XElement" />指定した名前と内容を持つクラス。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンス トラクターは、指定されたコンテンツおよび属性を持つ要素を作成します。  
  
 文字列からの暗黙的な変換がある<xref:System.Xml.Linq.XName>です。 新たに作成する代わりにパラメーターとして文字列を指定するのには、このコンス トラクターの一般的な使用<xref:System.Xml.Linq.XName>です。  
  
 加算演算子オーバー ロードを使用する一般的な使用方法を名前空間内の要素を作成するとき、<xref:System.Xml.Linq.XNamespace>および作成する文字列、<xref:System.Xml.Linq.XName>です。 詳細については、次を参照してください。 [XML 名前空間の使用](http://msdn.microsoft.com/library/e3003209-3234-45be-a832-47feb7927430)です。  
  
 このコンス トラクターに渡すことができる有効なコンテンツに関する詳細については、「[有効なコンテンツの XElement オブジェクトと XDocument オブジェクト](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)です。  
  
   
  
## Examples  
 次の例では、XML ツリーを作成します。 新しい要素の内容は、LINQ クエリから取得されます。  
  
```csharp  
  
                XElement xmlTree1 = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5),  
    new XElement("Child6", 6)  
);  
  
XElement xmlTree2 = new XElement("Root",  
    from el in xmlTree1.Elements()  
    where((int)el >= 3 && (int)el <= 5)  
    select el  
);  
Console.WriteLine(xmlTree2);  
```  
  
```vb  
  
                Dim xmlTree1 As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
            <Child6>6</Child6>  
        </Root>  
  
Dim xmlTree2 As XElement = _   
    <Root>  
        <%= From el In xmlTree1.Elements() _  
            Where el.Value >= 3 And el.Value <= 5 _  
            Select el %>  
    </Root>  
  
Console.WriteLine(xmlTree2)  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```xml  
  
                <Root>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 次の例では、さまざまな種類のコンテンツの XML ツリーを作成します。  
  
```csharp  
  
                XElement root;  
  
// String content:  
root = new XElement("Root", "Some text");  
Console.WriteLine(root);  
  
// XElement object content:  
root = new XElement("Root",   
    new XElement("NewChild", "n")  
);  
Console.WriteLine(root);  
  
// XAttribute object content:  
root = new XElement("Root",   
    new XAttribute("NewAttribute", "n")  
);  
Console.WriteLine(root);  
  
// Double content:  
double dbl = 12.345;  
root = new XElement("Root", dbl);  
Console.WriteLine(root);  
  
// DateTime content:  
DateTime dt = new DateTime(2006, 10, 6, 12, 30, 00);  
root = new XElement("Root", dt);  
Console.WriteLine(root);  
  
// String array content:  
// Any collection other than a collection of XElement or XAttribute objects  
// are converted to strings. The strings are concatenated and added.  
string[] stringArray = {  
    "abc",  
    "def",  
    "ghi"  
};  
root = new XElement("Root", stringArray);  
Console.WriteLine(root);  
  
// XElement object array content:  
XElement[] ellArray = {  
    new XElement("NewChild1", 1),  
    new XElement("NewChild2", 2),  
    new XElement("NewChild3", 3)  
};  
root = new XElement("Root", ellArray);  
Console.WriteLine(root);  
  
// XAttribute object array content:  
XAttribute[] attArray = {  
    new XAttribute("NewAtt1", 1),  
    new XAttribute("NewAtt2", 2),  
    new XAttribute("NewAtt3", 3)  
};  
root = new XElement("Root", attArray);  
Console.WriteLine(root);  
```  
  
```vb  
  
                Dim root As XElement  
  
' String content:  
root = <Root>Some text</Root>  
Console.WriteLine(root)  
  
' XElement object content:  
root = <Root>  
           <NewChild>n</NewChild>  
       </Root>  
Console.WriteLine(root)  
  
' XAttribute object content:  
root = <Root NewAttribute="n"/>  
Console.WriteLine(root)  
  
' Double content:  
Dim dbl As Double = 12.345  
root = <Root><%= dbl %></Root>  
Console.WriteLine(root)  
  
' DateTime content:  
Dim dt As DateTime = New DateTime(2006, 10, 6, 12, 30, 0)  
root = <Root><%= dt %></Root>  
Console.WriteLine(root)  
  
' String array content:  
' Any collection other than a collection of XElement or XAttribute objects  
' are converted to strings. The strings are concatenated and added.  
  
Dim stringArray As String() = { _  
    "abc", _  
    "def", _  
    "ghi" _  
}  
root = <Root><%= stringArray %></Root>  
Console.WriteLine(root)  
  
' XElement object array content:  
Dim ellArray As XElement() = { _  
    <NewChild1>1</NewChild1>, _  
    <NewChild2>2</NewChild2>, _  
    <NewChild3>3</NewChild3> _  
}  
  
root = <Root><%= ellArray %></Root>  
Console.WriteLine(root)  
  
' XAttribute object array content  
Dim attArray As XAttribute() = { _  
    New XAttribute("NewAtt1", 1), _  
    New XAttribute("NewAtt2", 2), _  
    New XAttribute("NewAtt3", 3) _  
}  
root = <Root><%= attArray %></Root>  
Console.WriteLine(root)  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                <Root>Some text</Root>  
<Root>  
  <NewChild>n</NewChild>  
</Root>  
<Root NewAttribute="n" />  
<Root>12.345</Root>  
<Root>2006-10-06T12:30:00</Root>  
<Root>abcdefghi</Root>  
<Root>  
  <NewChild1>1</NewChild1>  
  <NewChild2>2</NewChild2>  
  <NewChild3>3</NewChild3>  
</Root>  
<Root NewAtt1="1" NewAtt2="2" NewAtt3="3" />  
```  
  
 次の例では、名前空間で XML ツリーを作成します。  
  
```csharp  
  
                // Create an XML tree in a namespace.  
XNamespace aw = "http://www.adventure-works.com";  
XElement root = new XElement(aw + "Root",  
    new XElement(aw + "Child", "child content")  
);  
Console.WriteLine(root);  
```  
  
```vb  
  
                ' Create an XML tree in a namespace.  
Dim root As XElement = _   
    <Root xmlns='http://www.adventure-works.com'>  
        <Child>child content</Child>  
    </Root>  
Console.WriteLine(root)  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```xml  
  
                <Root xmlns="http://www.adventure-works.com">  
  <Child>child content</Child>  
</Root>  
```  
  
 次の例では、入れ子になった名前空間を持つ XML ツリーを作成します。  
  
```csharp  
  
                // Create an XML tree with nested namespaces.  
XNamespace aw = "http://www.adventure-works.com";  
XNamespace fc = "www.fourthcoffee.com";  
XElement root = new XElement(aw + "Root",  
    new XElement(fc + "Child",  
        new XElement(aw + "DifferentChild", "other content")  
    )  
);  
Console.WriteLine(root);  
```  
  
```vb  
  
                ' Create an XML tree with nested namespaces.  
Dim root As XDocument = _   
    <?xml version='1.0'?>  
    <Root xmlns='http://www.adventure-works.com'>  
        <Child xmlns='www.fourthcoffee.com'>  
        <DifferentChild xmlns='http://www.adventure-works.com'>other content</DifferentChild>  
        </Child>  
    </Root>  
Console.WriteLine(root)  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```xml  
  
                <Root xmlns="http://www.adventure-works.com">  
  <Child xmlns="www.fourthcoffee.com">  
    <DifferentChild xmlns="http://www.adventure-works.com">other content</DifferentChild>  
  </Child>  
</Root>  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AncestorsAndSelf">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>この要素およびこの要素の先祖を格納している、要素のコレクションを返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返されるコレクション内の要素は、ドキュメントの逆順になっています。  
  
 このメソッドは遅延実行を使用します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AncestorsAndSelf">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; AncestorsAndSelf ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; AncestorsAndSelf() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.AncestorsAndSelf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この要素およびこの要素の先祖を格納している、要素のコレクションを返します。</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerable`1" />の<see cref="T:System.Xml.Linq.XElement" />およびこの要素の先祖がこの要素を含む要素です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返されるコレクション内の要素は、ドキュメントの逆順になっています。  
  
 このメソッドは遅延実行を使用します。  
  
   
  
## Examples  
 次の例では、XML ツリーを作成します。 検出し、`GrandChild`要素、および、その先祖を出力します。  
  
```csharp  
  
                XElement xmlTree = new XElement("Root",  
    new XElement("Child",  
        new XElement("GrandChild", "element content")  
    )  
);  
XElement gc = xmlTree.Element("Child").Element("GrandChild");  
IEnumerable<XElement> aas =  
    from el in gc.AncestorsAndSelf()  
    select el;  
foreach (XElement el in aas)  
    Console.WriteLine(el.Name);  
```  
  
```vb  
  
                Dim xmlTree As XElement = _   
    <Root>  
        <Child>  
            <GrandChild>element content</GrandChild>  
        </Child>  
    </Root>  
  
Dim GC As XElement = xmlTree.<Child>.<GrandChild>(0)  
  
Dim aas As IEnumerable(Of XElement) = _  
    From el In GC.AncestorsAndSelf() _  
    Select el  
  
For Each el In aas  
    Console.WriteLine(el.Name)  
Next  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                GrandChild  
Child  
Root  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AncestorsAndSelf">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; AncestorsAndSelf (System.Xml.Linq.XName name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; AncestorsAndSelf(class System.Xml.Linq.XName name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.AncestorsAndSelf(System.Xml.Linq.XName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="name">照合する <see cref="T:System.Xml.Linq.XName" />。</param>
        <summary>この要素およびこの要素の先祖を格納している、フィルター処理された要素のコレクションを返します。 一致する要素だけ<see cref="T:System.Xml.Linq.XName" />コレクションに含まれます。</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerable`1" />の<see cref="T:System.Xml.Linq.XElement" />およびこの要素の先祖がこの要素が含まれています。 一致する要素だけ<see cref="T:System.Xml.Linq.XName" />コレクションに含まれます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返されるコレクション内の要素は、ドキュメントの逆順になっています。  
  
 このメソッドは遅延実行を使用します。  
  
   
  
## Examples  
 次の例は、これを使用します。  
  
```csharp  
  
                XElement xmlTree = new XElement("Root",  
    new XElement("Child",  
        new XElement("GrandChild", "element content")  
    )  
);  
XElement gc = xmlTree.Element("Child").Element("GrandChild");  
IEnumerable<XElement> aas = gc.AncestorsAndSelf("Child");  
foreach (XElement el in aas)  
    Console.WriteLine(el.Name);  
```  
  
```vb  
  
                Dim xmlTree As XElement = _   
    <Root>  
        <Child>  
            <GrandChild>element content</GrandChild>  
        </Child>  
    </Root>  
  
Dim GC As XElement = xmlTree.<Child>.<GrandChild>(0)  
Dim aas As IEnumerable(Of XElement) = GC.AncestorsAndSelf("Child")  
For Each el In aas  
    Console.WriteLine(el.Name)  
Next  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
Child  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Attribute">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XAttribute Attribute (System.Xml.Linq.XName name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.Linq.XAttribute Attribute(class System.Xml.Linq.XName name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Attribute(System.Xml.Linq.XName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="name"><see cref="T:System.Xml.Linq.XName" />の<see cref="T:System.Xml.Linq.XAttribute" />を取得します。</param>
        <summary>返します、<see cref="T:System.Xml.Linq.XAttribute" />この<see cref="T:System.Xml.Linq.XElement" />を持つ、指定した<see cref="T:System.Xml.Linq.XName" />です。</summary>
        <returns><see cref="T:System.Xml.Linq.XAttribute" />を持つ、指定した<see cref="T:System.Xml.Linq.XName" />です。<see langword="null" />場合は、指定した名前の属性がありません。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 いくつかは、要素または属性のコレクションを返します。 このメソッドは、1 つの属性のみを返します。 これとも呼ば、*シングルトン*(対照的に、*コレクション*)。  
  
 Visual Basic の場合は、統合属性軸を使用して、指定した名前の属性の値を取得できます。  
  
   
  
## Examples  
 次の例では、属性を持つ要素を作成します。 このメソッドを使用して属性を取得します。  
  
```csharp  
  
                XElement xmlTree = new XElement("Root",  
    new XAttribute("Att", "attribute content")  
);  
XAttribute att = xmlTree.Attribute("Att");  
Console.WriteLine(att);  
```  
  
```vb  
  
                Dim xmlTree As XElement = <Root Att="attribute content"/>  
  
Dim att As XAttribute = xmlTree.Attribute("Att")  
Console.WriteLine(att)  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
Att="attribute content"  
```  
  
 同じ例を次に示しますが、ここで、XML が名前空間には。 詳細については、次を参照してください。 [XML 名前空間の使用](http://msdn.microsoft.com/library/e3003209-3234-45be-a832-47feb7927430)です。  
  
```csharp  
  
                XNamespace aw = "http://www.adventure-works.com";  
XElement xmlTree = new XElement(aw + "Root",  
    new XAttribute(XNamespace.Xmlns + "aw", "http://www.adventure-works.com"),  
    new XAttribute(aw + "Att", "attribute content")  
);  
XAttribute att = xmlTree.Attribute(aw + "Att");  
Console.WriteLine(att);  
```  
  
```vb  
  
                Imports <xmlns:aw="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim xmlTree As XElement = <aw:Root aw:Att="attribute content"/>  
  
        Dim att As XAttribute = xmlTree.Attribute(GetXmlNamespace(aw) + "Att")  
        Console.WriteLine(att)  
    End Sub  
End Module  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
aw:Att="attribute content"  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Attributes">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>この要素の属性のコレクションを返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは遅延実行を使用します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XAttribute&gt; Attributes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XAttribute&gt; Attributes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Attributes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XAttribute&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この要素の属性のコレクションを返します。</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerable`1" />の<see cref="T:System.Xml.Linq.XAttribute" />のこの要素の属性です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返されるコレクションに属性は、要素に追加された順序でです。 XML から XML ツリーが解析された場合は、ドキュメントの順序で、属性が返されます。  
  
 このメソッドは遅延実行を使用します。  
  
   
  
## Examples  
 次の例では、次の 2 つの属性を持つ要素を作成します。 使用して、この要素のすべての属性を取得します。  
  
```csharp  
  
                XElement xmlTree = new XElement("Root",  
    new XAttribute("Att1", "content1"),  
    new XAttribute("Att2", "content2")  
);  
IEnumerable<XAttribute> attList =  
    from at in xmlTree.Attributes()  
    select at;  
foreach (XAttribute att in attList)  
    Console.WriteLine(att);  
```  
  
```vb  
  
                Dim xmlTree As XElement = <Root Att1="content1" Att2="content2"/>  
  
Dim attList As IEnumerable(Of XAttribute) = _  
From at In xmlTree.Attributes() _  
Select at  
  
For Each att In attList  
    Console.WriteLine(att)  
Next  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                Att1="content1"  
Att2="content2"  
```  
  
 同じ例を次に示しますが、ここで、XML が名前空間には。 詳細については、次を参照してください。 [XML 名前空間の使用](http://msdn.microsoft.com/library/e3003209-3234-45be-a832-47feb7927430)です。  
  
```csharp  
  
                XNamespace aw = "http://www.adventure-works.com";  
XElement xmlTree = new XElement(aw + "Root",  
    new XAttribute(aw + "Att1", "content1"),  
    new XAttribute(aw + "Att2", "content2"),  
    new XAttribute(XNamespace.Xmlns + "aw", "http://www.adventure-works.com")  
);  
IEnumerable<XAttribute> attList =  
    from at in xmlTree.Attributes()  
    select at;  
foreach (XAttribute att in attList)  
    Console.WriteLine(att);  
```  
  
```vb  
  
                Imports <xmlns:aw="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim xmlTree As XElement = <aw:Root aw:Att1="content1" aw:Att2="content2"/>  
  
        Dim attList As IEnumerable(Of XAttribute) = _  
            From at In xmlTree.Attributes() _  
            Select at  
  
        For Each att In attList  
            Console.WriteLine(att)  
        Next  
    End Sub  
End Module  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                aw:Att1="content1"  
aw:Att2="content2"  
xmlns:aw="http://www.adventure-works.com"  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XAttribute&gt; Attributes (System.Xml.Linq.XName name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XAttribute&gt; Attributes(class System.Xml.Linq.XName name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Attributes(System.Xml.Linq.XName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XAttribute&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="name">照合する <see cref="T:System.Xml.Linq.XName" />。</param>
        <summary>この要素の属性のフィルター処理されたコレクションを返します。 一致する要素だけ<see cref="T:System.Xml.Linq.XName" />コレクションに含まれます。</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerable`1" />の<see cref="T:System.Xml.Linq.XAttribute" />この要素の属性を格納しています。 一致する要素だけ<see cref="T:System.Xml.Linq.XName" />コレクションに含まれます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 属性名は、要素内で一意でなければなりません。 したがって、1 つだけの属性を含むコレクションを返します。 または、空のコレクションを返すことができます。  
  
 このメソッドは遅延実行を使用します。  
  
   
  
## Examples  
 次の例は、これを使用します。  
  
```csharp  
  
                XElement xmlTree = new XElement("Root",  
    new XAttribute("Att1", "content1"),  
    new XAttribute("Att2", "content2")  
);  
IEnumerable<XAttribute> attList = xmlTree.Attributes("Att1");  
foreach (XAttribute att in attList)  
    Console.WriteLine(att);  
```  
  
```vb  
  
                Dim xmlTree As XElement = <Root Att1="content1" Att2="content2"/>  
  
Dim attList As IEnumerable(Of XAttribute) = xmlTree.Attributes("Att1")  
  
For Each att In attList  
    Console.WriteLine(att)  
Next  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
Att1="content1"  
```  
  
 同じ例を次に示しますが、ここで、XML が名前空間には。 詳細については、次を参照してください。 [XML 名前空間の使用](http://msdn.microsoft.com/library/e3003209-3234-45be-a832-47feb7927430)です。  
  
```csharp  
  
                XNamespace aw = "http://www.adventure-works.com";  
XElement xmlTree = new XElement(aw + "Root",  
    new XAttribute(XNamespace.Xmlns + "aw", "http://www.adventure-works.com"),  
    new XAttribute(aw + "Att1", "content1"),  
    new XAttribute(aw + "Att2", "content2")  
);  
IEnumerable<XAttribute> attList = xmlTree.Attributes(aw + "Att1");  
foreach (XAttribute att in attList)  
    Console.WriteLine(att);  
```  
  
```vb  
  
                Imports <xmlns:aw="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim xmlTree As XElement = <aw:Root aw:Att1="content1" aw:Att2="content2"/>  
  
        Dim attList As IEnumerable(Of XAttribute) = xmlTree.Attributes(GetXmlNamespace(aw) + "Att1")  
  
        For Each att In attList  
            Console.WriteLine(att)  
        Next  
    End Sub  
End Module  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
aw:Att1="content1"  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DescendantNodesAndSelf">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XNode&gt; DescendantNodesAndSelf ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XNode&gt; DescendantNodesAndSelf() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.DescendantNodesAndSelf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XNode&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この要素およびこの要素のすべての子孫ノードをドキュメント順で格納している、ノードのコレクションを返します。</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerable`1" />の<see cref="T:System.Xml.Linq.XNode" />この要素、およびドキュメントの順序で、この要素のすべての子孫ノードが含まれています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは遅延実行を使用します。  
  
   
  
## Examples  
 次の例では、XML ツリーを作成し、これを使用します。  
  
```csharp  
  
                XElement xmlTree = new XElement("Root",  
    // Attributes are not nodes, so will not be returned by DescendantNodesAndSelf.  
    new XAttribute("Att1", "AttributeContent"),  
    new XElement("Child",  
        new XText("Some text"),  
        new XElement("GrandChild", "element content")  
    )  
);  
IEnumerable<XNode> dnas =  
    from node in xmlTree.DescendantNodesAndSelf()  
    select node;  
foreach (XNode node in dnas)  
{  
    if (node is XElement)  
        Console.WriteLine((node as XElement).Name);  
    else  
        Console.WriteLine(node);  
}  
```  
  
```vb  
  
                Dim xmlTree As XElement = _  
    <Root Att1="AttributeContent">  
        <Child>Some text<GrandChild>element content</GrandChild>  
        </Child>  
    </Root>  
  
Dim dnas As IEnumerable(Of XNode) = _  
    From node In xmlTree.DescendantNodesAndSelf() _  
    Select node  
  
For Each node In dnas  
    If TypeOf node Is XElement Then  
        Console.WriteLine(DirectCast(node, XElement).Name)  
    Else  
        Console.WriteLine(node)  
    End If  
Next  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                Root  
Child  
Some text  
GrandChild  
element content  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DescendantsAndSelf">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>この要素およびこの要素のすべての子孫要素をドキュメント順で格納している、要素のコレクションを返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは遅延実行を使用します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="DescendantsAndSelf">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; DescendantsAndSelf ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; DescendantsAndSelf() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.DescendantsAndSelf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この要素およびこの要素のすべての子孫要素をドキュメント順で格納している、要素のコレクションを返します。</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerable`1" />の<see cref="T:System.Xml.Linq.XElement" />この要素を格納している要素とすべての要素をドキュメント順で、この要素の子孫要素のです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは遅延実行を使用します。  
  
   
  
## Examples  
 次の例では、XML ツリーを作成し、これを使用します。  
  
```csharp  
  
                XElement xmlTree = new XElement("Root",  
    new XAttribute("Att1", "AttributeContent"),  
    new XElement("Child",  
        new XText("Some text"),  
        new XElement("GrandChild", "element content")  
    )  
);  
IEnumerable<XElement> das =  
    from el in xmlTree.DescendantsAndSelf()  
    select el;  
foreach (XElement el in das)  
    Console.WriteLine(el.Name);  
```  
  
```vb  
  
                Dim xmlTree As XElement = _  
    <Root Att1="AttributeContent">  
        <Child>Some text  
            <GrandChild>element content</GrandChild>  
        </Child>  
    </Root>  
  
Dim das As IEnumerable(Of XElement) = _  
    From el In xmlTree.DescendantsAndSelf() _  
    Select el  
  
For Each el In das  
    Console.WriteLine(el.Name)  
Next  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                Root  
Child  
GrandChild  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DescendantsAndSelf">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; DescendantsAndSelf (System.Xml.Linq.XName name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; DescendantsAndSelf(class System.Xml.Linq.XName name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.DescendantsAndSelf(System.Xml.Linq.XName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="name">照合する <see cref="T:System.Xml.Linq.XName" />。</param>
        <summary>この要素およびこの要素のすべての子孫要素をドキュメント順で格納している、フィルター処理された要素のコレクションを返します。 一致する要素だけ<see cref="T:System.Xml.Linq.XName" />コレクションに含まれます。</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerable`1" />の<see cref="T:System.Xml.Linq.XElement" />この要素とすべての要素をドキュメント順で、この要素の子孫要素が含まれています。 一致する要素だけ<see cref="T:System.Xml.Linq.XName" />コレクションに含まれます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは遅延実行を使用します。  
  
   
  
## Examples  
 次の例では、XML ツリーを作成し、これを使用します。  
  
```csharp  
  
                XElement xmlTree = new XElement("Root",  
    new XAttribute("Att1", "AttributeContent"),  
    new XElement("Child",  
        new XText("Some text"),  
        new XElement("GrandChild", "element content")  
    )  
);  
IEnumerable<XElement> das = xmlTree.DescendantsAndSelf("Child");  
foreach (XElement el in das)  
    Console.WriteLine(el.Name);  
```  
  
```vb  
  
                Dim xmlTree As XElement = _  
    <Root Att1="AttributeContent">  
        <Child>Some text  
            <GrandChild>element content</GrandChild>  
        </Child>  
    </Root>  
  
Dim das As IEnumerable(Of XElement) = xmlTree.DescendantsAndSelf("Child")  
  
For Each el In das  
    Console.WriteLine(el.Name)  
Next  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
Child  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EmptySequence">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; EmptySequence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; EmptySequence" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XElement.EmptySequence" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素の空のコレクションを取得します。</summary>
        <value><see cref="T:System.Collections.Generic.IEnumerable`1" />の<see cref="T:System.Xml.Linq.XElement" />空のコレクションを格納しています。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは要素のコレクションを返すメソッドを記述する場合にクラスの実装によって通常使用されます。 このプロパティを使用して、空のコレクションを取得する場合は、メソッドは要素を返すことがない必要があります、これ<xref:System.Xml.Linq.XElement>オブジェクト。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FirstAttribute">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XAttribute FirstAttribute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XAttribute FirstAttribute" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XElement.FirstAttribute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XAttribute</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の最初の属性を取得します。</summary>
        <value><see cref="T:System.Xml.Linq.XAttribute" />この要素の最初の属性を格納しています。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 属性は、要素に追加された順序で要素に格納されます。  
  
   
  
## Examples  
 次の例では、このプロパティを使用します。  
  
```csharp  
  
                XElement xmlTree = new XElement("Root",  
    new XAttribute("Att1", 1),  
    new XAttribute("Att2", 2),  
    new XAttribute("Att3", 3)  
);  
Console.WriteLine(xmlTree.FirstAttribute);  
```  
  
```vb  
  
                Dim xmlTree As XElement = <Root Att1="1" Att2="2" Att3="3"/>  
Console.WriteLine(xmlTree.FirstAttribute)  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
Att1="1"  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDefaultNamespace">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XNamespace GetDefaultNamespace ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.Linq.XNamespace GetDefaultNamespace() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.GetDefaultNamespace" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XNamespace</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>既定値を取得<see cref="T:System.Xml.Linq.XNamespace" />この<see cref="T:System.Xml.Linq.XElement" />です。</summary>
        <returns><see cref="T:System.Xml.Linq.XNamespace" />この既定の名前空間を格納している<see cref="T:System.Xml.Linq.XElement" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Namespace 宣言は、XML ツリー内の属性として永続化可能性があります。 これらの特別な属性は、既定の名前空間を含む、名前空間を宣言します。 このメソッドは、1 つを使用する必要がある場合は、既定の名前空間を宣言する名前空間宣言を検索し、返します、<xref:System.Xml.Linq.XNamespace>既定の名前空間。  
  
 既定の名前空間を宣言する属性がないかどうかは、このメソッドが戻る<xref:System.Xml.Linq.XNamespace.None%2A?displayProperty=nameWithType>です。  
  
 C# を使用して XML ツリーを作成するには、XML ツリーはシリアル化する既定の名前空間の場合は、属性として XML ツリーで、名前空間は保持されない場合も、このメソッドは、名前空間を既定の名前空間として報告されません。  
  
 Imports ステートメントを使用して既定の名前空間で XML を作成する場合は、Visual Basic および XML のリテラルを使用した XML ツリーを作成する、ときにし、名前空間の属性が作成ツリーで、Visual Basic コンパイラによってされこのメソッドはその名前空間を報告します。  
  
   
  
## Examples  
 次の例を既定の名前空間を持つ XML ツリーを作成します。 このメソッドを使用して、既定の名前空間を取得します。  
  
```csharp  
  
                String xml = "<root xmlns='http://www.adventure-works.com'/>";  
XElement e = XElement.Parse(xml);  
Console.WriteLine("Default namespace: {0}", e.GetDefaultNamespace());  
```  
  
```vb  
  
                Imports <xmlns="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim e As XElement = <root/>  
        Console.WriteLine("Default namespace: {0}", e.GetDefaultNamespace())  
    End Sub  
End Module  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
Default namespace: http://www.adventure-works.com  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNamespaceOfPrefix">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XNamespace GetNamespaceOfPrefix (string prefix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.Linq.XNamespace GetNamespaceOfPrefix(string prefix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.GetNamespaceOfPrefix(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XNamespace</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">検索対象の名前空間プレフィックスを格納している文字列。</param>
        <summary>この特定のプレフィックスに関連付けられている名前空間を取得<see cref="T:System.Xml.Linq.XElement" />です。</summary>
        <returns><see cref="T:System.Xml.Linq.XNamespace" />このプレフィックスに関連付けられている名前空間の<see cref="T:System.Xml.Linq.XElement" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、この要素のスコープ内にある名前空間属性の XML ツリーを検索します。 Namespace プレフィックスは、XML ツリー内にある名前空間属性で指定されます。  
  
   
  
## Examples  
 次の例を関連付けられたプリフィックスを持つ名前空間を持つ XML ツリーを作成します。 取得し、このメソッドを使用して、<xref:System.Xml.Linq.XNamespace>プレフィックス。  
  
```csharp  
  
                XElement xmlTree = XElement.Parse("<Root xmlns:aw='http://www.adventure-works.com'/>");  
XNamespace awNamespace = xmlTree.GetNamespaceOfPrefix("aw");  
Console.WriteLine("Namespace: {0}", awNamespace);  
```  
  
 通常使用 Visual Basic を使用する場合、 [GetXmlNamespace 演算子](~/docs/visual-basic/language-reference/operators/getxmlnamespace-operator.md)次のように、演算子  
  
```vb  
  
                Imports <xmlns:aw="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim xmlTree As XElement = <aw:Root/>  
        Dim awNamespace As XNamespace = GetXmlNamespace(aw)  
        Console.WriteLine("Namespace: {0}", awNamespace)  
    End Sub  
End Module  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
Namespace: http://www.adventure-works.com  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPrefixOfNamespace">
      <MemberSignature Language="C#" Value="public string GetPrefixOfNamespace (System.Xml.Linq.XNamespace ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPrefixOfNamespace(class System.Xml.Linq.XNamespace ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.GetPrefixOfNamespace(System.Xml.Linq.XNamespace)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ns" Type="System.Xml.Linq.XNamespace" />
      </Parameters>
      <Docs>
        <param name="ns"><see cref="T:System.Xml.Linq.XNamespace" />を検索します。</param>
        <summary>この名前空間に関連付けられているプレフィックスを取得<see cref="T:System.Xml.Linq.XElement" />です。</summary>
        <returns>A<see cref="T:System.String" />名前空間プレフィックスを格納しています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、この要素のスコープ内にある名前空間属性の XML ツリーを検索します。 Namespace プレフィックスは、XML ツリー内にある名前空間属性で指定されます。  
  
 名前空間は、既定の名前空間、名前空間のプレフィックスがない場合は、このメソッドは null を返します。  
  
   
  
## Examples  
 次の例では、プレフィックスを持つ名前空間を含む XML ツリーを作成します。 このメソッドを使用して、名前空間のプレフィックスを取得します。 この例には、文字列からの暗黙的な変換が使用されて<xref:System.Xml.Linq.XNamespace>このメソッドを呼び出すときにします。  
  
```csharp  
  
                XElement xmlTree = XElement.Parse("<Root xmlns:aw='http://www.adventure-works.com'/>");  
string prefix = xmlTree.GetPrefixOfNamespace("http://www.adventure-works.com");  
Console.WriteLine("Prefix: {0}", prefix);  
```  
  
```vb  
  
                Imports <xmlns:aw="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim xmlTree As XElement = <aw:Root/>  
        Dim prefix As String = xmlTree.GetPrefixOfNamespace("http://www.adventure-works.com")  
        Console.WriteLine("Prefix: {0}", prefix)  
    End Sub  
End Module  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
Prefix: aw  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasAttributes">
      <MemberSignature Language="C#" Value="public bool HasAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XElement.HasAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素が 1 つ以上の属性を持っているかどうかを示す値を取得します。</summary>
        <value>
          この要素が 1 つ以上の属性を持っている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、このプロパティを使用します。  
  
```csharp  
  
                XElement xmlTree1 = new XElement("Root",  
    new XAttribute("Att1", 1)  
);  
Console.WriteLine(xmlTree1.HasAttributes);  
XElement xmlTree2 = new XElement("Root");  
Console.WriteLine(xmlTree2.HasAttributes);  
```  
  
```vb  
  
                Dim xmlTree1 As XElement = <Root Att1="1"/>  
Console.WriteLine(xmlTree1.HasAttributes)  
  
Dim xmlTree2 As XElement = <Root/>  
Console.WriteLine(xmlTree2.HasAttributes)  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
True  
False  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasElements">
      <MemberSignature Language="C#" Value="public bool HasElements { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasElements" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XElement.HasElements" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素が 1 つ以上の子要素を持っているかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" />この要素には、少なくとも 1 つの子要素がある場合それ以外の場合<see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、このプロパティを使用します。  
  
```csharp  
  
                XElement xmlTree1 = new XElement("Root",  
    new XElement("Child", 1)  
);  
Console.WriteLine(xmlTree1.HasElements);  
XElement xmlTree2 = new XElement("Root", "contents");  
Console.WriteLine(xmlTree2.HasElements);  
```  
  
```vb  
  
                Dim xmlTree1 As XElement = _   
        <Root>  
            <Child>1</Child>  
        </Root>  
Console.WriteLine(xmlTree1.HasElements)  
  
Dim xmlTree2 As XElement = <Root>contents</Root>  
Console.WriteLine(xmlTree2.HasElements)  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                True  
False  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEmpty">
      <MemberSignature Language="C#" Value="public bool IsEmpty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmpty" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XElement.IsEmpty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素に内容が格納されていないかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" />この要素にコンテンツが含まれていない場合それ以外の場合<see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 開始タグと終了タグの間でコンテンツを含む要素が空の要素であると見なされますできませんに注意してください。 長さのコンテンツがありません。 開始タグのみを含み、強制終了された空の要素として表される要素だけが空にすると見なされます。  
  
   
  
## Examples  
 次の例では、さまざまな XML ツリーを作成し、各ツリーには、このプロパティの値を示しています。  
  
```csharp  
  
                XElement el1 = new XElement("Root");  
Console.WriteLine(el1);  
Console.WriteLine(el1.IsEmpty);  
Console.WriteLine();  
XElement el2 = new XElement("Root", "content");  
Console.WriteLine(el2);  
Console.WriteLine(el2.IsEmpty);  
Console.WriteLine();  
XElement el3 = new XElement("Root", "");  
Console.WriteLine(el3);  
Console.WriteLine(el3.IsEmpty);  
Console.WriteLine();  
el3.ReplaceAll(null);  
Console.WriteLine(el3);  
Console.WriteLine(el3.IsEmpty);  
```  
  
```vb  
  
                Dim el1 As XElement = <Root/>  
Console.WriteLine(el1)  
Console.WriteLine(el1.IsEmpty)  
Console.WriteLine()  
Dim el2 As XElement = <Root>content</Root>  
Console.WriteLine(el2)  
Console.WriteLine(el2.IsEmpty)  
Console.WriteLine()  
Dim el3 As XElement = <Root></Root>  
Console.WriteLine(el3)  
Console.WriteLine(el3.IsEmpty)  
Console.WriteLine()  
el3.ReplaceAll(Nothing)  
Console.WriteLine(el3)  
Console.WriteLine(el3.IsEmpty)  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                <Root />  
True  
  
<Root>content</Root>  
False  
  
<Root></Root>  
False  
  
<Root />  
True  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LastAttribute">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XAttribute LastAttribute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XAttribute LastAttribute" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XElement.LastAttribute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XAttribute</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の最後の属性を取得します。</summary>
        <value><see cref="T:System.Xml.Linq.XAttribute" />この要素の最後の属性を格納しています。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 属性は、要素に追加された順序で要素に格納されます。  
  
   
  
## Examples  
 次の例では、次の 3 つの属性を持つ XML ツリーを作成します。 これは、後の出力として最後の属性を書き込みます。  
  
```csharp  
  
                XElement xmlTree = new XElement("Root",  
    new XAttribute("Att1", 1),  
    new XAttribute("Att2", 2),  
    new XAttribute("Att3", 3)  
);  
Console.WriteLine(xmlTree.LastAttribute);  
```  
  
```vb  
  
                Dim xmlTree As XElement = <Root Att1="1" Att2="2" Att3="3"/>  
Console.WriteLine(xmlTree.LastAttribute)  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
Att3="3"  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>新たに作成<see cref="T:System.Xml.Linq.XElement" />から、URI で指定されたファイルから、 <see cref="T:System.IO.TextReader" />、または、<see cref="T:System.Xml.XmlReader" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドのオーバー ロードのいずれかを使用するにを読み込む、<xref:System.Xml.Linq.XElement>ファイルから、 <xref:System.IO.TextReader>、または<xref:System.Xml.XmlReader>です。  
  
 作成する、<xref:System.Xml.Linq.XElement>から XML を表す文字列を使用して<xref:System.Xml.Linq.XElement.Parse%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XElement Load (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XElement Load(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Load(System.IO.Stream)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">XML データを格納しているストリーム。</param>
        <summary>新たに作成<see cref="T:System.Xml.Linq.XElement" />指定のストリームを使用してインスタンス。</summary>
        <returns><see cref="T:System.Xml.Linq.XElement" />ストリームに含まれているデータの読み取りに使用されるオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 読み込みオプションを制御する場合は、使用、<xref:System.Xml.Linq.XElement.Load%2A>を受け取るオーバー ロード<xref:System.Xml.Linq.LoadOptions>をパラメーターとして。  
  
 XML の読み込み機能への LINQ の基盤となって<xref:System.Xml.XmlReader>です。 によってスローされる例外をキャッチするため、<xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType>メソッドをオーバー ロードおよび<xref:System.Xml.XmlReader>を読み取り、ドキュメントを解析するメソッド。  
  
 変更しなければならない場合<xref:System.Xml.XmlReaderSettings>、次の手順します。  
  
1.  作成、<xref:System.Xml.XmlReader>のいずれかを呼び出すことによって、<xref:System.Xml.XmlReader.Create%2A>を受け取るオーバー ロード<xref:System.Xml.XmlReaderSettings>をパラメーターとして。  
  
2.  渡す、<xref:System.Xml.XmlReader>のいずれかに、<xref:System.Xml.Linq.XElement>の<xref:System.Xml.Linq.XElement.Load%2A>を取るオーバー ロード<xref:System.Xml.XmlReader>をパラメーターとして。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XElement Load (System.IO.TextReader textReader);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XElement Load(class System.IO.TextReader textReader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Load(System.IO.TextReader)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textReader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="textReader">A<see cref="T:System.IO.TextReader" />のことが読み取られる、<see cref="T:System.Xml.Linq.XElement" />コンテンツ。</param>
        <summary>読み込み、<see cref="T:System.Xml.Linq.XElement" />から、<see cref="T:System.IO.TextReader" />です。</summary>
        <returns><see cref="T:System.Xml.Linq.XElement" />読み取られた XML を含む指定された対象から<see cref="T:System.IO.TextReader" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、XML ツリーに生の XML を読み取ります。 ファイル内のすべての余分な空白を破棄します。  
  
 XML の読み込み機能への LINQ の基盤となって<xref:System.Xml.XmlReader>です。 によってスローされる例外をキャッチするため、<xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType>メソッドをオーバー ロードおよび<xref:System.Xml.XmlReader>を読み取り、ドキュメントを解析するメソッド。  
  
   
  
## Examples  
 次の例から要素を読み込み、<xref:System.IO.StringReader>です。  
  
```csharp  
  
                TextReader sr = new StringReader("<Root><Child/></Root>");  
XElement xmlTree = XElement.Load(sr);  
sr.Close();  
Console.WriteLine(xmlTree);  
```  
  
```vb  
  
                Dim sr As TextReader = New StringReader("<Root><Child/></Root>")  
Dim xmlTree As XElement = XElement.Load(sr)  
sr.Close()  
Console.WriteLine(xmlTree)  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```xml  
  
                <Root>  
  <Child />  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XElement Load (string uri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XElement Load(string uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Load(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uri">新しいに読み込むファイルを参照する URI 文字列<see cref="T:System.Xml.Linq.XElement" />です。</param>
        <summary>読み込み、<see cref="T:System.Xml.Linq.XElement" />ファイルからです。</summary>
        <returns><see cref="T:System.Xml.Linq.XElement" />指定されたファイルの内容を格納します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、XML ツリーに生の XML を読み取ります。 ファイル内のすべての余分な空白を破棄します。  
  
 XML の読み込み機能への LINQ の基盤となって<xref:System.Xml.XmlReader>です。 によってスローされる例外をキャッチするため、<xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType>メソッドをオーバー ロードおよび<xref:System.Xml.XmlReader>を読み取り、ドキュメントを解析するメソッド。  
  
   
  
## Examples  
 次の例は、XML ツリーを作成し、ファイルに保存し、このメソッドを使用してロード、<xref:System.Xml.Linq.XElement>ファイルからです。  
  
```csharp  
  
                XElement xmlTree1 = new XElement("Root",  
    new XElement("Child", "content")  
);  
xmlTree1.Save("Tree.xml");  
  
XElement xmlTree2 = XElement.Load("Tree.xml");  
Console.WriteLine(xmlTree2.Name);  
```  
  
```vb  
  
                Dim xmlTree1 As XElement = _   
        <Root>  
            <Child>Content</Child>  
        </Root>  
xmlTree1.Save("Tree.xml")  
  
Dim xmlTree2 As XElement = XElement.Load("Tree.xml")  
Console.WriteLine(xmlTree2.Name)  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
Root  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XElement Load (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XElement Load(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Load(System.Xml.XmlReader)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">A<see cref="T:System.Xml.XmlReader" />は、コンテンツを読み取ること、<see cref="T:System.Xml.Linq.XElement" />です。</param>
        <summary>読み込み、<see cref="T:System.Xml.Linq.XElement" />から、<see cref="T:System.Xml.XmlReader" />です。</summary>
        <returns><see cref="T:System.Xml.Linq.XElement" />読み取られた XML を含む指定された対象から<see cref="T:System.Xml.XmlReader" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 作成することで、 <xref:System.Xml.XmlNodeReader> DOM ドキュメントとしを使用してから、<xref:System.Xml.XmlNodeReader>を作成する、 <xref:System.Xml.Linq.XElement>、このメソッドは、linq to XML ツリーに DOM ドキュメントのコピーを作成するために使用できます。  
  
 XML の読み込み機能への LINQ の基盤となって<xref:System.Xml.XmlReader>です。 によってスローされる例外をキャッチするため、<xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType>メソッドをオーバー ロードおよび<xref:System.Xml.XmlReader>を読み取り、ドキュメントを解析するメソッド。  
  
   
  
## Examples  
 次の例は、DOM ドキュメントを作成、作成、 <xref:System.Xml.XmlNodeReader> DOM ドキュメントからリーダーからツリーをインスタンス化します。 このコードは、DOM ドキュメントを LINQ に、XML ツリーを効果的にコピーします。  
  
```csharp  
// Create a DOM document with some content.  
XmlDocument doc = new XmlDocument();  
XmlElement child = doc.CreateElement("Child");  
child.InnerText = "child contents";  
XmlElement root = doc.CreateElement("Root");  
root.AppendChild(child);  
doc.AppendChild(root);  
  
// Create a reader and move to the content.  
using (XmlNodeReader nodeReader = new XmlNodeReader(doc)) {  
    // the reader must be in the Interactive state in order to  
    // Create a LINQ to XML tree from it.  
    nodeReader.MoveToContent();  
  
    XElement xRoot = XElement.Load(nodeReader);  
    Console.WriteLine(xRoot);  
}  
```  
  
```vb  
' Create a DOM document with some content.  
Dim doc As XmlDocument = New XmlDocument()  
Dim child As XmlElement = doc.CreateElement("Child")  
child.InnerText = "child contents"  
Dim root As XmlElement = doc.CreateElement("Root")  
root.AppendChild(child)  
doc.AppendChild(root)  
  
' Create a reader and move to the content.  
Using nodeReader = New XmlNodeReader(doc)  
    ' the reader must be in the Interactive state in order to  
    ' Create a LINQ to XML tree from it.  
    nodeReader.MoveToContent()  
  
    Dim xRoot As XElement = XElement.Load(nodeReader)  
    Console.WriteLine(xRoot)  
End Using  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```xml  
  
                <Root>  
  <Child>child contents</Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XElement Load (System.IO.Stream stream, System.Xml.Linq.LoadOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XElement Load(class System.IO.Stream stream, valuetype System.Xml.Linq.LoadOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Load(System.IO.Stream,System.Xml.Linq.LoadOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
      </Parameters>
      <Docs>
        <param name="stream">XML データが含まれるストリーム。</param>
        <param name="options">A<see cref="T:System.Xml.Linq.LoadOptions" />ベース URI および行情報を読み込むかどうかを指定するオブジェクト。</param>
        <summary>新たに作成<see cref="T:System.Xml.Linq.XElement" />インスタンスで指定されたストリームを使用して、必要に応じて空白を保持する、ベースの URI を設定および行の情報を保持します。</summary>
        <returns><see cref="T:System.Xml.Linq.XElement" />ストリームに含まれるデータの読み取りに使用されるオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 XML の読み込み機能への LINQ の基盤となって<xref:System.Xml.XmlReader>です。 によってスローされる例外をキャッチするため、<xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType>メソッドをオーバー ロードおよび<xref:System.Xml.XmlReader>を読み取り、ドキュメントを解析するメソッド。  
  
 変更しなければならない場合<xref:System.Xml.XmlReaderSettings>、次の手順します。  
  
1.  作成、<xref:System.Xml.XmlReader>のいずれかを呼び出すことによって、<xref:System.Xml.XmlReader.Create%2A>を受け取るオーバー ロード<xref:System.Xml.XmlReaderSettings>をパラメーターとして。  
  
2.  渡す、<xref:System.Xml.XmlReader>のいずれかに、<xref:System.Xml.Linq.XElement>の<xref:System.Xml.Linq.XElement.Load%2A>を取るオーバー ロード<xref:System.Xml.XmlReader>をパラメーターとして。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XElement Load (System.IO.TextReader textReader, System.Xml.Linq.LoadOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XElement Load(class System.IO.TextReader textReader, valuetype System.Xml.Linq.LoadOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Load(System.IO.TextReader,System.Xml.Linq.LoadOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textReader" Type="System.IO.TextReader" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
      </Parameters>
      <Docs>
        <param name="textReader">A<see cref="T:System.IO.TextReader" />のことが読み取られる、<see cref="T:System.Xml.Linq.XElement" />コンテンツ。</param>
        <param name="options">A<see cref="T:System.Xml.Linq.LoadOptions" />空白に関する動作、およびベース URI および行情報を読み込むかどうかを指定します。</param>
        <summary>読み込み、<see cref="T:System.Xml.Linq.XElement" />から、<see cref="T:System.IO.TextReader" />と必要に応じて空白を保持する行の情報を保持します。</summary>
        <returns><see cref="T:System.Xml.Linq.XElement" />読み取られた XML を含む指定された対象から<see cref="T:System.IO.TextReader" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ソース XML がインデントを設定できない場合は、設定、<xref:System.Xml.Linq.LoadOptions.PreserveWhitespace>にフラグが設定`options`により、ソース XML 内のすべての空白文字を読み取るリーダー。 型のノード<xref:System.Xml.Linq.XText>両方は、有意の空白スペースを作成します。  
  
 設定しない場合は、ソース XML では、インデント、<xref:System.Xml.Linq.LoadOptions.PreserveWhitespace>にフラグが設定`options`ソース XML で意味のない空白をすべて無視するリーダーをによりします。 意味のない空白のテキスト ノードなしは、XML ツリーが作成されます。  
  
 XML ソースがインデントを設定できない場合は、設定、<xref:System.Xml.Linq.LoadOptions.PreserveWhitespace>フラグ`options`も何も起こりません。 有意の空白は維持され、全体にわたる複数の空白テキスト ノードの作成を引き起こす可能性のある意味のない空白はありません。  
  
 詳細については、次を参照してください。[読み込みまたは XML の解析中に空白を維持](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d)と[維持空白中にシリアル化する](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)です。  
  
 使用して<xref:System.Xml.Linq.XElement.Parse%2A>を作成する、 <xref:System.Xml.Linq.XElement> XML を表す文字列から。  
  
 設定<xref:System.Xml.Linq.LoadOptions.SetBaseUri>効果はありませんから読み込むときに、<xref:System.IO.TextReader>です。  
  
 設定した場合は、パフォーマンスの低下、<xref:System.Xml.Linq.LoadOptions.SetLineInfo>フラグ。  
  
 行の情報は、XML ドキュメントの読み込み後すぐに正確です。 ドキュメントの読み込み後、XML ツリーを変更する場合は、行の情報が無意味になる可能性があります。  
  
 XML の読み込み機能への LINQ の基盤となって<xref:System.Xml.XmlReader>です。 によってスローされる例外をキャッチするため、<xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType>メソッドをオーバー ロードおよび<xref:System.Xml.XmlReader>を読み取り、ドキュメントを解析するメソッド。  
  
   
  
## Examples  
 次の例、<xref:System.Xml.Linq.XElement>から、 <xref:System.IO.StringReader> 2 つの異なる方法で: 空白文字を保持して、空白を保持しません。 クエリを使用して、結果として得られる XML ツリー内の空白ノードの数を決定します。  
  
```csharp  
  
                TextReader sr;  
int whiteSpaceNodes;  
  
sr = new StringReader("<Root> <Child> </Child> </Root>");  
XElement xmlTree1 = XElement.Load(sr, LoadOptions.None);  
sr.Close();  
whiteSpaceNodes = xmlTree1  
    .DescendantNodesAndSelf()  
    .OfType<XText>()  
    .Where(tNode => tNode.ToString().Trim().Length == 0)  
    .Count();  
Console.WriteLine("Count of white space nodes (not preserving whitespace): {0}", whiteSpaceNodes);  
  
sr = new StringReader("<Root> <Child> </Child> </Root>");  
XElement xmlTree2 = XElement.Load(sr, LoadOptions.PreserveWhitespace);  
sr.Close();  
whiteSpaceNodes = xmlTree2  
    .DescendantNodesAndSelf()  
    .OfType<XText>()  
    .Where(tNode => tNode.ToString().Trim().Length == 0)  
    .Count();  
Console.WriteLine("Count of white space nodes (preserving whitespace): {0}", whiteSpaceNodes);  
```  
  
```vb  
  
                Dim sr As TextReader  
Dim whiteSpaceNodes As Integer  
  
sr = New StringReader("<Root> <Child> </Child> </Root>")  
Dim xmlTree1 As XElement = XElement.Load(sr, LoadOptions.None)  
sr.Close()  
whiteSpaceNodes = xmlTree1 _  
    .DescendantNodesAndSelf() _  
    .OfType(Of XText)() _  
    .Where(Function(ByVal tNode As XNode) tNode.ToString().Trim().Length = 0) _  
    .Count()  
Console.WriteLine("Count of white space nodes (not preserving whitespace): {0}", whiteSpaceNodes)  
  
sr = New StringReader("<Root> <Child> </Child> </Root>")  
Dim xmlTree2 As XElement = XElement.Load(sr, LoadOptions.PreserveWhitespace)  
sr.Close()  
whiteSpaceNodes = xmlTree2 _  
    .DescendantNodesAndSelf() _  
    .OfType(Of XText)() _  
    .Where(Function(ByVal tNode As XNode) tNode.ToString().Trim().Length = 0) _  
    .Count()  
Console.WriteLine("Count of white space nodes (preserving whitespace): {0}", whiteSpaceNodes)  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                Count of white space nodes (not preserving whitespace): 0  
Count of white space nodes (preserving whitespace): 3  
```  
  
 次の例から読み込むように行情報を読み込みます、<xref:System.IO.TextReader>です。 行の情報が印刷されます。  
  
```csharp  
  
                TextReader sr = new StringReader(  
@"<Root>  
  <Child>  
    <GrandChild1/>  
    <GrandChild2/>  
  </Child>  
</Root>");  
XElement po = XElement.Load(sr,  
    LoadOptions.SetLineInfo);  
Console.WriteLine("{0}{1}{2}",  
    "Element Name".PadRight(20),  
    "Line".PadRight(5),  
    "Position");  
Console.WriteLine("{0}{1}{2}",  
    "------------".PadRight(20),  
    "----".PadRight(5),  
    "--------");  
foreach (XElement e in po.DescendantsAndSelf())  
    Console.WriteLine("{0}{1}{2}",  
        ("".PadRight(e.Ancestors().Count() * 2) + e.Name).PadRight(20),  
        ((IXmlLineInfo)e).LineNumber.ToString().PadRight(5),  
        ((IXmlLineInfo)e).LinePosition);  
```  
  
```vb  
  
                Dim sr As TextReader = New StringReader( _  
    "<Root>" & Environment.NewLine & _  
    "  <Child>" & Environment.NewLine & _  
    "    <GrandChild1/>" & Environment.NewLine & _  
    "    <GrandChild2/>" & Environment.NewLine & _  
    "  </Child>" & Environment.NewLine & _  
    "</Root>")  
Dim po As XElement = XElement.Load(sr, LoadOptions.SetLineInfo)  
Console.WriteLine("{0}{1}{2}", _  
    "Element Name".PadRight(20), _  
    "Line".PadRight(5), _  
    "Position")  
Console.WriteLine("{0}{1}{2}", _  
    "------------".PadRight(20), _  
    "----".PadRight(5), _  
    "--------")  
For Each e As XElement In po.DescendantsAndSelf()  
    Console.WriteLine("{0}{1}{2}", _  
        ("".PadRight(e.Ancestors().Count() * 2) & e.Name.ToString).PadRight(20), _  
        (DirectCast(e, IXmlLineInfo)).LineNumber.ToString().PadRight(5), _  
        (DirectCast(e, IXmlLineInfo)).LinePosition)  
Next  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                Element Name        Line Position  
------------        ---- --------  
Root                1    2  
  Child             2    4  
    GrandChild1     3    6  
    GrandChild2     4    6  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XElement Load (string uri, System.Xml.Linq.LoadOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XElement Load(string uri, valuetype System.Xml.Linq.LoadOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Load(System.String,System.Xml.Linq.LoadOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.String" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
      </Parameters>
      <Docs>
        <param name="uri">読み込むファイルを参照する URI 文字列、<see cref="T:System.Xml.Linq.XElement" />です。</param>
        <param name="options">A<see cref="T:System.Xml.Linq.LoadOptions" />空白に関する動作、およびベース URI および行情報を読み込むかどうかを指定します。</param>
        <summary>読み込み、<see cref="T:System.Xml.Linq.XElement" />ファイルから、必要に応じて空白を保持する、ベース URI を設定および保持行情報。</summary>
        <returns><see cref="T:System.Xml.Linq.XElement" />指定されたファイルの内容を格納します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ソース XML がインデントを設定できない場合は、設定、<xref:System.Xml.Linq.LoadOptions.PreserveWhitespace>にフラグが設定`options`により、ソース XML 内のすべての空白文字を読み取るリーダー。 型のノード<xref:System.Xml.Linq.XText>両方は、有意の空白スペースを作成します。  
  
 設定しない場合は、ソース XML では、インデント、<xref:System.Xml.Linq.LoadOptions.PreserveWhitespace>にフラグが設定`options`ソース XML で意味のない空白をすべて無視するリーダーをによりします。 意味のない空白のテキスト ノードなしは、XML ツリーが作成されます。  
  
 XML ソースがインデントを設定できない場合は、設定、<xref:System.Xml.Linq.LoadOptions.PreserveWhitespace>フラグ`options`も何も起こりません。 有意の空白は維持され、全体にわたる複数の空白テキスト ノードの作成を引き起こす可能性のある意味のない空白はありません。  
  
 詳細については、次を参照してください。[読み込みまたは XML の解析中に空白を維持](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d)と[維持空白中にシリアル化する](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)です。  
  
 使用して<xref:System.Xml.Linq.XElement.Parse%2A>を作成する、 <xref:System.Xml.Linq.XElement> XML を表す文字列から。  
  
 設定した場合は、パフォーマンスの低下、<xref:System.Xml.Linq.LoadOptions.SetBaseUri>と<xref:System.Xml.Linq.LoadOptions.SetLineInfo>フラグ。  
  
 ベース URI と行の情報は XML ドキュメントの読み込み後すぐに正確です。 ドキュメントの読み込み後、XML ツリーを変更する場合は、ベース URI および行の情報が無意味になる可能性があります。  
  
 XML の読み込み機能への LINQ の基盤となって<xref:System.Xml.XmlReader>です。 によってスローされる例外をキャッチするため、<xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType>メソッドをオーバー ロードおよび<xref:System.Xml.XmlReader>を読み取り、ドキュメントを解析するメソッド。  
  
   
  
## Examples  
 次の例、 <xref:System.Xml.Linq.XElement> 2 つの異なる方法でファイルから: 空白文字を保持して、空白を保持しません。 クエリを使用して、結果として得られる XML ツリー内の空白ノードの数を決定します。  
  
```csharp  
  
                XElement xmlTree1 = XElement.Parse("<Root> <Child>  </Child> </Root>", LoadOptions.PreserveWhitespace);  
xmlTree1.Save("Tree.xml");  
Console.WriteLine(xmlTree1);  
  
int whiteSpaceNodes;  
XElement xmlTree2 = XElement.Load("Tree.xml",  
    LoadOptions.None);  
whiteSpaceNodes = xmlTree2  
    .DescendantNodesAndSelf()  
    .OfType<XText>()  
    .Where(tNode => tNode.ToString().Trim().Length == 0)  
    .Count();  
Console.WriteLine("Count of white space nodes (not preserving whitespace): {0}", whiteSpaceNodes);  
  
XElement xmlTree3 = XElement.Load("Tree.xml",  
    LoadOptions.PreserveWhitespace);  
whiteSpaceNodes = xmlTree3  
    .DescendantNodesAndSelf()  
    .OfType<XText>()  
    .Where(tNode => tNode.ToString().Trim().Length == 0)  
    .Count();  
Console.WriteLine("Count of white space nodes (preserving whitespace): {0}", whiteSpaceNodes);  
```  
  
```vb  
  
                Dim xmlTree1 As XElement = XElement.Parse("<Root> <Child>  </Child> </Root>", LoadOptions.PreserveWhitespace)  
xmlTree1.Save("Tree.xml")  
Console.WriteLine(xmlTree1)  
  
Dim whiteSpaceNodes As Integer  
Dim xmlTree2 As XElement = XElement.Load("Tree.xml", LoadOptions.None)  
whiteSpaceNodes = xmlTree2 _  
                  .DescendantNodesAndSelf() _  
                  .OfType(Of XText)() _  
                  .Where(Function(ByVal tNode As XNode) tNode.ToString().Trim().Length = 0) _  
                  .Count()  
Console.WriteLine("Count of white space nodes (not preserving whitespace): {0}", whiteSpaceNodes)  
  
Dim xmlTree3 As XElement = XElement.Load("Tree.xml", LoadOptions.PreserveWhitespace)  
whiteSpaceNodes = xmlTree3 _  
                  .DescendantNodesAndSelf() _  
                  .OfType(Of XText)() _  
                  .Where(Function(ByVal tNode As XNode) tNode.ToString().Trim().Length = 0) _  
                  .Count()  
Console.WriteLine("Count of white space nodes (preserving whitespace): {0}", whiteSpaceNodes)  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                <Root> <Child>  </Child> </Root>  
Count of white space nodes (not preserving whitespace): 0  
Count of white space nodes (preserving whitespace): 3  
```  
  
 次の例は、ファイルが読み込まれるベース URI および行の情報を読み込みます。 ベース URI と行の情報を出力します。  
  
 この例では次のリソース ファイル:[サンプル XML ファイル: 一般的な購買発注書 (LINQ to XML)](http://msdn.microsoft.com/library/0606c09f-6e43-4f8d-95c8-e8e2e08d2348)です。  
  
```csharp  
  
                XElement po = XElement.Load("PurchaseOrder.xml",  
    LoadOptions.SetBaseUri | LoadOptions.SetLineInfo);  
string[] splitUri = po.BaseUri.Split('/');  
Console.WriteLine("BaseUri: {0}", splitUri[splitUri.Length - 1]);  
Console.WriteLine();  
Console.WriteLine("{0}{1}{2}",  
    "Element Name".PadRight(20),  
    "Line".PadRight(5),  
    "Position");  
Console.WriteLine("{0}{1}{2}",  
    "------------".PadRight(20),  
    "----".PadRight(5),  
    "--------");  
foreach (XElement e in po.DescendantsAndSelf())  
    Console.WriteLine("{0}{1}{2}",  
        ("".PadRight(e.Ancestors().Count() * 2) + e.Name).PadRight(20),  
        ((IXmlLineInfo)e).LineNumber.ToString().PadRight(5),  
        ((IXmlLineInfo)e).LinePosition);  
```  
  
```vb  
  
        Dim po As XElement = XElement.Load("PurchaseOrder.xml", LoadOptions.SetBaseUri Or LoadOptions.SetLineInfo)  
Dim splitUri() As String = po.BaseUri.Split("/")  
Console.WriteLine("BaseUri: {0}", splitUri(splitUri.Length - 1))  
Console.WriteLine()  
Console.WriteLine("{0}{1}{2}", _  
    "Element Name".PadRight(20), _  
    "Line".PadRight(5), _  
    "Position")  
Console.WriteLine("{0}{1}{2}", _  
    "------------".PadRight(20), _  
    "----".PadRight(5), _  
    "--------")  
For Each e As XElement In po.DescendantsAndSelf()  
    Console.WriteLine("{0}{1}{2}", _  
        ("".PadRight(e.Ancestors().Count() * 2) & e.Name.ToString()).PadRight(20), _  
        (DirectCast(e, IXmlLineInfo)).LineNumber.ToString().PadRight(5), _  
        (DirectCast(e, IXmlLineInfo)).LinePosition)  
Next  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                BaseUri: PurchaseOrder.xml  
  
Element Name        Line Position  
------------        ---- --------  
PurchaseOrder       2    2  
  Address           3    4  
    Name            4    6  
    Street          5    6  
    City            6    6  
    State           7    6  
    Zip             8    6  
    Country         9    6  
  Address           11   4  
    Name            12   6  
    Street          13   6  
    City            14   6  
    State           15   6  
    Zip             16   6  
    Country         17   6  
  DeliveryNotes     19   4  
  Items             20   4  
    Item            21   6  
      ProductName   22   8  
      Quantity      23   8  
      USPrice       24   8  
      Comment       25   8  
    Item            27   6  
      ProductName   28   8  
      Quantity      29   8  
      USPrice       30   8  
      ShipDate      31   8  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XElement Load (System.Xml.XmlReader reader, System.Xml.Linq.LoadOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XElement Load(class System.Xml.XmlReader reader, valuetype System.Xml.Linq.LoadOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Load(System.Xml.XmlReader,System.Xml.Linq.LoadOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
      </Parameters>
      <Docs>
        <param name="reader">A<see cref="T:System.Xml.XmlReader" />は、コンテンツを読み取ること、<see cref="T:System.Xml.Linq.XElement" />です。</param>
        <param name="options">A<see cref="T:System.Xml.Linq.LoadOptions" />空白に関する動作、およびベース URI および行情報を読み込むかどうかを指定します。</param>
        <summary>読み込み、<see cref="T:System.Xml.Linq.XElement" />から、 <see cref="T:System.Xml.XmlReader" />、必要に応じて空白を保持する、基本の URI を設定および行の情報を保持します。</summary>
        <returns><see cref="T:System.Xml.Linq.XElement" />読み取られた XML を含む指定された対象から<see cref="T:System.Xml.XmlReader" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 作成することで、 <xref:System.Xml.XmlNodeReader> DOM ドキュメントとしを使用してから、<xref:System.Xml.XmlNodeReader>を作成する、 <xref:System.Xml.Linq.XElement>、このメソッドは、linq to XML ツリーに DOM ドキュメントのコピーを作成するために使用できます。  
  
 使用して<xref:System.Xml.Linq.XElement.Parse%2A>を作成する、 <xref:System.Xml.Linq.XElement> XML を表す文字列から。  
  
 設定<xref:System.Xml.Linq.LoadOptions.PreserveWhitespace>からの読み込みのときは無効な<xref:System.Xml.XmlReader>します。 <xref:System.Xml.XmlReader>かどうか読み取りの空白に構成されます。 LINQ to XML ツリーに表示されます、空白ノードをリーダー サーフェスします。 これはかどうかに関係なく動作になります<xref:System.Xml.Linq.LoadOptions.PreserveWhitespace>設定されているか。  
  
 <xref:System.Xml.XmlReader>か、有効な基本 URI があります。 設定した場合<xref:System.Xml.Linq.LoadOptions.SetBaseUri>、ベース URI は、によって報告されるベース URI から XML ツリーに設定されます、<xref:System.Xml.XmlReader>です。  
  
 <xref:System.Xml.XmlReader>か、有効なライン情報があります。 設定した場合<xref:System.Xml.Linq.LoadOptions.SetLineInfo>、行の情報は、によって報告される行の情報から、XML ツリーに設定されます、<xref:System.Xml.XmlReader>です。  
  
 設定した場合は、パフォーマンスの低下、<xref:System.Xml.Linq.LoadOptions.SetLineInfo>フラグ。  
  
 行の情報は、XML ドキュメントの読み込み後すぐに正確です。 ドキュメントの読み込み後、XML ツリーを変更する場合は、行の情報が無意味になる可能性があります。  
  
 XML の読み込み機能への LINQ の基盤となって<xref:System.Xml.XmlReader>です。 によってスローされる例外をキャッチするため、<xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType>メソッドをオーバー ロードおよび<xref:System.Xml.XmlReader>を読み取り、ドキュメントを解析するメソッド。  
  
   
  
## Examples  
 次の例から読み込む行情報を読み込みます、<xref:System.Xml.XmlReader>です。 行の情報が印刷されます。  
  
```csharp  
  
                string markup =  
@"<Root>  
    <Child>  
        <GrandChild/>  
    </Child>  
</Root>";  
  
// Create a reader and move to the content.  
using (XmlReader nodeReader = XmlReader.Create(new StringReader(markup)))  
{  
    // the reader must be in the Interactive state in order to  
    // Create a LINQ to XML tree from it.  
    nodeReader.MoveToContent();  
  
    XElement xRoot = XElement.Load(nodeReader, LoadOptions.SetLineInfo);  
    Console.WriteLine("{0}{1}{2}",  
        "Element Name".PadRight(20),  
        "Line".PadRight(5),  
        "Position");  
    Console.WriteLine("{0}{1}{2}",  
        "------------".PadRight(20),  
        "----".PadRight(5),  
        "--------");  
    foreach (XElement e in xRoot.DescendantsAndSelf())  
        Console.WriteLine("{0}{1}{2}",  
            ("".PadRight(e.Ancestors().Count() * 2) + e.Name).PadRight(20),  
            ((IXmlLineInfo)e).LineNumber.ToString().PadRight(5),  
            ((IXmlLineInfo)e).LinePosition);  
}  
```  
  
```vb  
  
                Dim markup As String = _  
    "<Root>" & Environment.NewLine & _  
    "    <Child>" & Environment.NewLine & _  
    "        <GrandChild/>" & Environment.NewLine & _  
    "    </Child>" & Environment.NewLine & _  
    "</Root>"  
  
' Create a reader and move to the content.  
Using nodeReader As XmlReader = XmlReader.Create(New StringReader(markup))  
  
    ' the reader must be in the Interactive state in order to  
    ' Create a LINQ to XML tree from it.  
    nodeReader.MoveToContent()  
  
    Dim xRoot As XElement = XElement.Load(nodeReader, LoadOptions.SetLineInfo)  
    Console.WriteLine("{0}{1}{2}", _  
        "Element Name".PadRight(20), _  
        "Line".PadRight(5), _  
        "Position")  
    Console.WriteLine("{0}{1}{2}", _  
        "------------".PadRight(20), _  
        "----".PadRight(5), _  
        "--------")  
    For Each e As XElement In xRoot.DescendantsAndSelf()  
        Console.WriteLine("{0}{1}{2}", _  
            ("".PadRight(e.Ancestors().Count() * 2) & e.Name.ToString).PadRight(20), _  
            (DirectCast(e, IXmlLineInfo)).LineNumber.ToString().PadRight(5), _  
            (DirectCast(e, IXmlLineInfo)).LinePosition)  
    Next  
End Using  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                Element Name        Line Position  
------------        ---- --------  
Root                1    2  
  Child             2    6  
    GrandChild      3    10  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Xml.Linq.XElement&gt; LoadAsync (System.IO.Stream stream, System.Xml.Linq.LoadOptions options, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Xml.Linq.XElement&gt; LoadAsync(class System.IO.Stream stream, valuetype System.Xml.Linq.LoadOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.LoadAsync(System.IO.Stream,System.Xml.Linq.LoadOptions,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="stream">To be added.</param>
        <param name="options">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Xml.Linq.XElement&gt; LoadAsync (System.IO.TextReader textReader, System.Xml.Linq.LoadOptions options, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Xml.Linq.XElement&gt; LoadAsync(class System.IO.TextReader textReader, valuetype System.Xml.Linq.LoadOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.LoadAsync(System.IO.TextReader,System.Xml.Linq.LoadOptions,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textReader" Type="System.IO.TextReader" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="textReader">To be added.</param>
        <param name="options">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Xml.Linq.XElement&gt; LoadAsync (System.Xml.XmlReader reader, System.Xml.Linq.LoadOptions options, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Xml.Linq.XElement&gt; LoadAsync(class System.Xml.XmlReader reader, valuetype System.Xml.Linq.LoadOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.LoadAsync(System.Xml.XmlReader,System.Xml.Linq.LoadOptions,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="reader">To be added.</param>
        <param name="options">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XName Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XName Name" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XElement.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XName</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の名前を取得または設定します。</summary>
        <value><see cref="T:System.Xml.Linq.XName" />この要素の名前を格納しています。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは生成の設定、<xref:System.Xml.Linq.XObject.Changed>と<xref:System.Xml.Linq.XObject.Changing>イベント。  
  
   
  
## Examples  
 次の例では、要素の名前を特定するのにこのプロパティを使用します。  
  
```csharp  
  
                XElement el1 = new XElement("Root", "content");  
Console.WriteLine(el1.Name);  
  
XNamespace ns = "http://www.adventure-works.com";  
XElement el2 = new XElement(ns + "Root", "content");  
Console.WriteLine(el2.Name);  
Console.WriteLine(el2.Name.Namespace);  
Console.WriteLine(el2.Name.LocalName);  
el2.Name = ns + "NewName";  
Console.WriteLine(el2.Name);  
```  
  
```vb  
  
                Imports <xmlns:aw="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim el1 As XElement = <Root>content</Root>  
        Console.WriteLine(el1.Name)  
  
        Dim el2 As XElement = <aw:Root>content</aw:Root>  
        Console.WriteLine(el2.Name)  
        Console.WriteLine(el2.Name.Namespace)  
        Console.WriteLine(el2.Name.LocalName)  
        Dim aw as XNamespace = GetXmlNamespace(aw)  
        el2.Name = aw + "NewName"  
        Console.WriteLine(el2.Name)  
    End Sub  
End Module  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                Root  
{http://www.adventure-works.com}Root  
http://www.adventure-works.com  
Root  
{http://www.adventure-works.com}NewName  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNodeType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlNodeType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XElement.NodeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このノードのノード型を取得します。</summary>
        <value>ノード型。 <see cref="T:System.Xml.Linq.XElement" />オブジェクト、この値は<see cref="F:System.Xml.XmlNodeType.Element" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 すべてのクラスから派生したため<xref:System.Xml.Linq.XObject>を含む、<xref:System.Xml.Linq.XObject.NodeType%2A>プロパティの具体的なサブクラスのコレクションで動作するコードを記述することができます<xref:System.Xml.Linq.XObject>です。 コードは、コレクション内の各ノードのノード型をテストできます。  
  
   
  
## Examples  
 次の例では、要素のノード型を印刷するのにこのプロパティを使用します。  
  
```csharp  
  
                XElement el1 = new XElement("Root", "content");  
Console.WriteLine(el1.NodeType);  
Console.WriteLine();  
```  
  
```vb  
  
                Dim el1 As XElement = <Root>content</Root>  
Console.WriteLine(el1.NodeType.ToString())  
Console.WriteLine()  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
Element  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator bool (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Boolean" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator DateTime (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.DateTime op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.DateTime" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator DateTimeOffset (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.DateTimeOffset op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.DateTimeOffset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator decimal (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Decimal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator double (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float64 op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Double" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator Guid (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Guid op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Guid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator int (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int32 op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Int32" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator long (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int64 op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Int64" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator Nullable&lt;bool&gt; (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Nullable`1&lt;bool&gt; op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Boolean}" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator Nullable&lt;DateTime&gt; (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Nullable`1&lt;valuetype System.DateTime&gt; op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.DateTime}" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.DateTime&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator Nullable&lt;DateTimeOffset&gt; (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.DateTimeOffset}" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.DateTimeOffset&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator Nullable&lt;decimal&gt; (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Decimal}" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator Nullable&lt;double&gt; (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Nullable`1&lt;float64&gt; op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Double}" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator Nullable&lt;Guid&gt; (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Nullable`1&lt;valuetype System.Guid&gt; op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Guid}" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Guid&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator Nullable&lt;int&gt; (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Nullable`1&lt;int32&gt; op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Int32}" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator Nullable&lt;long&gt; (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Nullable`1&lt;int64&gt; op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Int64}" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator Nullable&lt;float&gt; (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Nullable`1&lt;float32&gt; op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Single}" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator Nullable&lt;TimeSpan&gt; (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Nullable`1&lt;valuetype System.TimeSpan&gt; op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.TimeSpan}" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.TimeSpan&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator Nullable&lt;uint&gt; (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Nullable`1&lt;unsigned int32&gt; op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.UInt32}" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.UInt32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator Nullable&lt;ulong&gt; (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Nullable`1&lt;unsigned int64&gt; op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.UInt64}" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.UInt64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator float (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float32 op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Single" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator string (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname string op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.String" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator TimeSpan (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.TimeSpan op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.TimeSpan" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator uint (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int32 op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.UInt32" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ulong (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int64 op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.UInt64" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XElement Parse (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XElement Parse(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Parse(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">A <see cref="T:System.String" /> XML を格納しています。</param>
        <summary>負荷、 <see cref="T:System.Xml.Linq.XElement" /> XML を表す文字列から。</summary>
        <returns><see cref="T:System.Xml.Linq.XElement" />を含む XML 文字列から取得されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドでは、空白文字は保持されません。 XML ツリー内の空白を保持する場合は、オーバー ロードを使用して、<xref:System.Xml.Linq.XElement.Parse%2A>を受け取るメソッド<xref:System.Xml.Linq.LoadOptions>をパラメーターとして。 詳細については、次を参照してください。[読み込みまたは XML の解析中に空白を維持](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d)と[維持空白中にシリアル化する](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)です。  
  
 XML の読み込み機能への LINQ の基盤となって<xref:System.Xml.XmlReader>です。 によってスローされる例外をキャッチするため、<xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType>メソッドをオーバー ロードおよび<xref:System.Xml.XmlReader>を読み取り、ドキュメントを解析するメソッド。  
  
   
  
## Examples  
 次の例では、XML を表す文字列を作成します。 文字列を解析し、<xref:System.Xml.Linq.XElement>です。  
  
```csharp  
  
                XElement xmlTree = XElement.Parse("<Root> <Child> </Child> </Root>");  
Console.WriteLine(xmlTree);  
```  
  
```vb  
  
                Dim xmlTree As XElement = <Root><Child></Child></Root>  
Console.WriteLine(xmlTree)  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```xml  
  
                <Root>  
  <Child></Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XElement Parse (string text, System.Xml.Linq.LoadOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XElement Parse(string text, valuetype System.Xml.Linq.LoadOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Parse(System.String,System.Xml.Linq.LoadOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
      </Parameters>
      <Docs>
        <param name="text">A <see cref="T:System.String" /> XML を格納しています。</param>
        <param name="options">A<see cref="T:System.Xml.Linq.LoadOptions" />空白に関する動作、およびベース URI および行情報を読み込むかどうかを指定します。</param>
        <summary>負荷、<see cref="T:System.Xml.Linq.XElement" />から XML を含む文字列、必要に応じて空白の保持および保持する行情報。</summary>
        <returns><see cref="T:System.Xml.Linq.XElement" />を含む XML 文字列から取得されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ソース XML がインデントを設定できない場合は、設定、<xref:System.Xml.Linq.LoadOptions.PreserveWhitespace>にフラグが設定`options`により、ソース XML 内のすべての空白文字を読み取るリーダー。 型のノード<xref:System.Xml.Linq.XText>両方は、有意の空白スペースを作成します。  
  
 設定しない場合は、ソース XML では、インデント、<xref:System.Xml.Linq.LoadOptions.PreserveWhitespace>にフラグが設定`options`ソース XML で意味のない空白をすべて無視するリーダーをによりします。 意味のない空白のテキスト ノードなしは、XML ツリーが作成されます。  
  
 XML ソースがインデントを設定できない場合は、設定、<xref:System.Xml.Linq.LoadOptions.PreserveWhitespace>フラグ`options`も何も起こりません。 有意の空白は維持され、全体にわたる複数の空白テキスト ノードの作成を引き起こす可能性のある意味のない空白はありません。  
  
 詳細については、次を参照してください。[読み込みまたは XML の解析中に空白を維持](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d)と[維持空白中にシリアル化する](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)です。  
  
 設定<xref:System.Xml.Linq.LoadOptions.SetBaseUri>効果はありませんから解析の際に、<xref:System.String>です。  
  
 <xref:System.Xml.XmlReader>か、有効なライン情報があります。 設定した場合<xref:System.Xml.Linq.LoadOptions.SetLineInfo>、行の情報は、によって報告される行の情報から、XML ツリーに設定されます、<xref:System.Xml.XmlReader>です。  
  
 設定した場合は、パフォーマンスの低下、<xref:System.Xml.Linq.LoadOptions.SetLineInfo>フラグ。  
  
 行の情報は、XML ドキュメントの読み込み後すぐに正確です。 ドキュメントの読み込み後、XML ツリーを変更する場合は、行の情報が無意味になる可能性があります。  
  
 XML の読み込み機能への LINQ の基盤となって<xref:System.Xml.XmlReader>です。 によってスローされる例外をキャッチするため、<xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType>メソッドをオーバー ロードおよび<xref:System.Xml.XmlReader>を読み取り、ドキュメントを解析するメソッド。  
  
   
  
## Examples  
 次の例に文字列を解析して、 <xref:System.Xml.Linq.XElement> 2 つの異なる方法で: 空白文字を保持して、空白を保持しません。 クエリを使用して、結果として得られる XML ツリー内の空白ノードの数を決定します。  
  
```csharp  
  
                int whiteSpaceNodes;  
  
XElement xmlTree1 = XElement.Parse("<Root> <Child> </Child> </Root>",  
    LoadOptions.None);  
whiteSpaceNodes = xmlTree1  
    .DescendantNodesAndSelf()  
    .OfType<XText>()  
    .Where(tNode => tNode.ToString().Trim().Length == 0)  
    .Count();  
Console.WriteLine("Count of white space nodes (not preserving whitespace): {0}",  
    whiteSpaceNodes);  
  
XElement xmlTree2 = XElement.Parse("<Root> <Child> </Child> </Root>",  
    LoadOptions.PreserveWhitespace);  
whiteSpaceNodes = xmlTree2  
    .DescendantNodesAndSelf()  
    .OfType<XText>()  
    .Where(tNode => tNode.ToString().Trim().Length == 0)  
    .Count();  
Console.WriteLine("Count of white space nodes (preserving whitespace): {0}",  
    whiteSpaceNodes);  
```  
  
```vb  
  
                Dim whiteSpaceNodes As Integer  
  
Dim xmlTree1 As XElement = XElement.Parse("<Root> <Child> </Child> </Root>", LoadOptions.None)  
whiteSpaceNodes = xmlTree1 _  
    .DescendantNodesAndSelf() _  
    .OfType(Of XText)() _  
    .Where(Function(ByVal tNode As XNode) tNode.ToString().Trim().Length = 0) _  
    .Count()  
Console.WriteLine("Count of white space nodes (not preserving whitespace): {0}", whiteSpaceNodes)  
  
Dim xmlTree2 As XElement = XElement.Parse("<Root> <Child> </Child> </Root>", LoadOptions.PreserveWhitespace)  
whiteSpaceNodes = xmlTree2 _  
    .DescendantNodesAndSelf() _  
    .OfType(Of XText)() _  
    .Where(Function(ByVal tNode As XNode) tNode.ToString().Trim().Length = 0) _  
    .Count()  
Console.WriteLine("Count of white space nodes (preserving whitespace): {0}", whiteSpaceNodes)  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                Count of white space nodes (not preserving whitespace): 0  
Count of white space nodes (preserving whitespace): 3  
```  
  
 次の例では、文字列を解析する際に行情報が保持されます。  
  
```csharp  
  
                string markup =  
@"<Root>  
    <Child>  
        <GrandChild/>  
    </Child>  
</Root>";  
  
XElement xRoot = XElement.Parse(markup, LoadOptions.SetLineInfo);  
Console.WriteLine("{0}{1}{2}",  
    "Element Name".PadRight(20),  
    "Line".PadRight(5),  
    "Position");  
Console.WriteLine("{0}{1}{2}",  
    "------------".PadRight(20),  
    "----".PadRight(5),  
    "--------");  
foreach (XElement e in xRoot.DescendantsAndSelf())  
    Console.WriteLine("{0}{1}{2}",  
        ("".PadRight(e.Ancestors().Count() * 2) + e.Name).PadRight(20),  
        ((IXmlLineInfo)e).LineNumber.ToString().PadRight(5),  
        ((IXmlLineInfo)e).LinePosition);  
```  
  
```vb  
  
                Dim markup As String = _  
"<Root>" & Environment.NewLine & _  
"    <Child>" & Environment.NewLine & _  
"        <GrandChild/>" & Environment.NewLine & _  
"    </Child>" & Environment.NewLine & _  
"</Root>"  
  
Dim xRoot As XElement = XElement.Parse(markup, LoadOptions.SetLineInfo)  
Console.WriteLine("{0}{1}{2}", _  
    "Element Name".PadRight(20), _  
    "Line".PadRight(5), _  
    "Position")  
Console.WriteLine("{0}{1}{2}", _  
    "------------".PadRight(20), _  
    "----".PadRight(5), _  
    "--------")  
For Each e As XElement In xRoot.DescendantsAndSelf()  
    Console.WriteLine("{0}{1}{2}", _  
        ("".PadRight(e.Ancestors().Count() * 2) & e.Name.ToString).PadRight(20), _  
        DirectCast(e, IXmlLineInfo).LineNumber.ToString().PadRight(5), _  
        DirectCast(e, IXmlLineInfo).LinePosition)  
Next  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                Element Name        Line Position  
------------        ---- --------  
Root                1    2  
  Child             2    6  
    GrandChild      3    10  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public void RemoveAll ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAll() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.RemoveAll" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このノードおよび属性を削除<see cref="T:System.Xml.Linq.XElement" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドが発生、<xref:System.Xml.Linq.XObject.Changed>と<xref:System.Xml.Linq.XObject.Changing>イベント。  
  
   
  
## Examples  
 次の例では、属性と子要素を持つ要素を作成します。 属性と子要素の両方を削除するには、このメソッドを呼び出します。  
  
```csharp  
  
                XElement root = new XElement("Root",  
    new XAttribute("Att1", 1),  
    new XAttribute("Att2", 2),  
    new XAttribute("Att3", 3),  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3)  
);  
root.RemoveAll();   // removes children elements and attributes of root  
Console.WriteLine(root);  
```  
  
```vb  
  
                Dim root As XElement = _   
        <Root Attr1="1" Attr2="2" Attr3="3">  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
        </Root>  
  
root.RemoveAll()   ' removes children elements and attributes of root  
Console.WriteLine(root)  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```xml  
  
<Root />  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAttributes">
      <MemberSignature Language="C#" Value="public void RemoveAttributes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAttributes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.RemoveAttributes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この属性を削除する<see cref="T:System.Xml.Linq.XElement" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドが発生、<xref:System.Xml.Linq.XObject.Changed>と<xref:System.Xml.Linq.XObject.Changing>イベント。  
  
   
  
## Examples  
 次の例では、属性と子要素を持つ要素を作成します。 属性を削除するには、このメソッドを呼び出します。 子要素のままになります。  
  
```csharp  
  
                XElement root = new XElement("Root",  
    new XAttribute("Att1", 1),  
    new XAttribute("Att2", 2),  
    new XAttribute("Att3", 3),  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3)  
);  
root.RemoveAttributes();  
Console.WriteLine(root);  
```  
  
```vb  
  
                Dim root As XElement = _   
    <Root Attr1="1" Attr2="2" Attr3="3">  
        <Child1>1</Child1>  
        <Child2>2</Child2>  
        <Child3>3</Child3>  
     </Root>  
  
root.RemoveAttributes()  
Console.WriteLine(root)  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```xml  
  
                <Root>  
  <Child1>1</Child1>  
  <Child2>2</Child2>  
  <Child3>3</Child3>  
</Root>   
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReplaceAll">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>この要素の子ノードおよび属性を、指定された内容で置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、スナップショットのセマンティクスを使用して、新しい内容で作成します。 これは、現在の要素の内容を照会およびクエリの結果を指定した新しいコンテンツとして使用できることを意味します。  
  
 この関数に渡すことができる有効なコンテンツに関する詳細については、「[有効なコンテンツの XElement オブジェクトと XDocument オブジェクト](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)です。  
  
 このメソッドが発生、<xref:System.Xml.Linq.XObject.Changed>と<xref:System.Xml.Linq.XObject.Changing>イベント。  
  
   
  
## Examples  
 次の例では、このメソッドは、クエリ結果の要素の内容を交換する LINQ クエリの結果を渡します。 内容が置き換えられている要素を照会します。  
  
```csharp  
  
                XElement xmlTree = new XElement("Root",  
    new XElement("Data", 1),  
    new XElement("Data", 2),  
    new XElement("Data", 3),  
    new XElement("Data", 4),  
    new XElement("Data", 5)  
);  
  
Console.WriteLine(xmlTree);  
Console.WriteLine("-----");  
  
xmlTree.ReplaceAll(  
    from el in xmlTree.Elements()  
    where (int)el >= 3  
    select new XElement("NewData", (int)el)  
);  
  
Console.WriteLine(xmlTree);  
```  
  
```vb  
  
                Dim xmlTree As XElement = _  
    <Root>  
        <Data>1</Data>  
        <Data>2</Data>  
        <Data>3</Data>  
        <Data>4</Data>  
        <Data>5</Data>  
    </Root>  
  
Console.WriteLine(xmlTree)  
Console.WriteLine("-----")  
  
xmlTree.ReplaceAll( _  
    From el In xmlTree.Elements _  
    Where el.Value >= 3 _  
    Select <NewData><%= el.Value %></NewData> _  
)  
  
Console.WriteLine(xmlTree)  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                <Root>  
  <Data>1</Data>  
  <Data>2</Data>  
  <Data>3</Data>  
  <Data>4</Data>  
  <Data>5</Data>  
</Root>  
-----  
<Root>  
  <NewData>3</NewData>  
  <NewData>4</NewData>  
  <NewData>5</NewData>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReplaceAll">
      <MemberSignature Language="C#" Value="public void ReplaceAll (object content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReplaceAll(object content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.ReplaceAll(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="content">この要素の子ノードおよび属性を置き換える内容。</param>
        <summary>この要素の子ノードおよび属性を、指定された内容で置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、まず、既存のコンテンツおよび属性を削除します。 これは、後、追加、指定した`content`です。  
  
 このメソッドは、スナップショットのセマンティクスを使用して、新しい内容で作成します。 これは、現在の要素の内容を照会およびクエリの結果を指定した新しいコンテンツとして使用できることを意味します。  
  
 この関数に渡すことができる有効なコンテンツに関する詳細については、「[有効なコンテンツの XElement オブジェクトと XDocument オブジェクト](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)です。  
  
 このメソッドが発生、<xref:System.Xml.Linq.XObject.Changed>と<xref:System.Xml.Linq.XObject.Changing>イベント。  
  
   
  
## Examples  
 次の例では、このメソッドを使用します。  
  
```csharp  
  
                XElement root = new XElement("Root",  
    new XElement("Child", "child content")  
);  
  
// ReplaceAll with an XElement object.  
root.ReplaceAll(new XElement("NewChild", "n"));  
Console.WriteLine(root);  
  
// ReplaceAll with an XAttribute object.  
root.ReplaceAll(new XAttribute("NewAttribute", "n"));  
Console.WriteLine(root);  
  
// ReplaceAll with a string.  
root.ReplaceAll("Some text");  
Console.WriteLine(root);  
  
// ReplaceAll with a double.  
double dbl = 12.345;  
root.ReplaceAll(dbl);  
Console.WriteLine(root);  
  
// ReplaceAll with a DateTime object.  
DateTime dt = new DateTime(2006, 10, 6, 12, 30, 00);  
root.ReplaceAll(dt);  
Console.WriteLine(root);  
  
// ReplaceAll with a string array.  
// Any collection other than a collection of XElement or XAttribute objects  
// are converted to strings. The strings are concatenated and added.  
string[] stringArray = {  
    "abc",  
    "def",  
    "ghi"  
};  
root.ReplaceAll(stringArray);  
Console.WriteLine(root);  
  
// ReplaceAll with an array of XElement objects.  
XElement[] ellArray = {  
    new XElement("NewChild1", 1),  
    new XElement("NewChild2", 2),  
    new XElement("NewChild3", 3)  
};  
root.ReplaceAll(ellArray);  
Console.WriteLine(root);  
  
// ReplaceAll with an array of XAttribute objects.  
XAttribute[] attArray = {  
    new XAttribute("NewAtt1", 1),  
    new XAttribute("NewAtt2", 2),  
    new XAttribute("NewAtt3", 3)  
};  
root.ReplaceAll(attArray);  
Console.WriteLine(root);  
```  
  
```vb  
  
                Dim root As XElement = _   
    <Root>  
        <Child>child content</Child>  
    </Root>  
  
' ReplaceAll with an XElement object.  
root.ReplaceAll(<NewChild>n</NewChild>)  
Console.WriteLine(root)  
  
' ReplaceAll with an XAttribute object.  
root.ReplaceAll(New XAttribute("NewAttribute", "n"))  
Console.WriteLine(root)  
  
' ReplaceAll with a string.  
root.ReplaceAll("Some text")  
Console.WriteLine(root)  
  
' ReplaceAll with a double.  
Dim dbl As Double = 12.345  
root.ReplaceAll(dbl)  
Console.WriteLine(root)  
  
' ReplaceAll with a DateTime object.  
Dim dt As DateTime = New DateTime(2006, 10, 6, 12, 30, 0)  
root.ReplaceAll(dt)  
Console.WriteLine(root)  
  
' ReplaceAll with a string array.  
' Any collection other than a collection of XElement or XAttribute objects  
' are converted to strings. The strings are concatenated and added.  
Dim stringArray As String() = { _  
    "abc", _  
    "def", _  
    "ghi" _  
}  
root.ReplaceAll(stringArray)  
Console.WriteLine(root)  
  
' ReplaceAll with an array of XElement objects.  
Dim ellArray As XElement() = { _  
    New XElement("NewChild1", 1), _  
    New XElement("NewChild2", 2), _  
    New XElement("NewChild3", 3) _  
}  
root.ReplaceAll(ellArray)  
Console.WriteLine(root)  
  
' ReplaceAll with an array of XAttribute objects.  
Dim attArray As XAttribute() = { _  
New XAttribute("NewAtt1", 1), _  
New XAttribute("NewAtt2", 2), _  
New XAttribute("NewAtt3", 3) _  
}  
root.ReplaceAll(attArray)  
Console.WriteLine(root)  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                <Root>  
  <NewChild>n</NewChild>  
</Root>  
<Root NewAttribute="n" />  
<Root>Some text</Root>  
<Root>12.345</Root>  
<Root>2006-10-06T12:30:00</Root>  
<Root>abcdefghi</Root>  
<Root>  
  <NewChild1>1</NewChild1>  
  <NewChild2>2</NewChild2>  
  <NewChild3>3</NewChild3>  
</Root>  
<Root NewAtt1="1" NewAtt2="2" NewAtt3="3" />  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReplaceAll">
      <MemberSignature Language="C#" Value="public void ReplaceAll (params object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReplaceAll(object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.ReplaceAll(System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="content">コンテンツ オブジェクトのパラメーター リスト。</param>
        <summary>この要素の子ノードおよび属性を、指定された内容で置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、まず、既存のコンテンツおよび属性を削除します。 これは、後、追加、指定した`content`です。  
  
 このメソッドは、スナップショットのセマンティクスを使用して、新しい内容で作成します。 これは、現在の要素の内容を照会およびクエリの結果を指定した新しいコンテンツとして使用できることを意味します。  
  
 この関数に渡すことができる有効なコンテンツに関する詳細については、「[有効なコンテンツの XElement オブジェクトと XDocument オブジェクト](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)です。  
  
 このメソッドが発生、<xref:System.Xml.Linq.XObject.Changed>と<xref:System.Xml.Linq.XObject.Changing>イベント。  
  
   
  
## Examples  
 次の例では、このメソッドは、クエリ結果の要素の内容を交換する LINQ クエリの結果を渡します。  
  
```csharp  
  
                XElement xmlTree1 = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5),  
    new XElement("Child6", 6)  
);  
  
XElement root = new XElement("Root",  
    new XElement("Child", "child content")  
);  
  
root.ReplaceAll(  
    from el in xmlTree1.Elements()  
    where((int)el >= 3 && (int)el <= 5)  
    select el  
);  
Console.WriteLine(root);  
```  
  
```vb  
  
                Dim xmlTree1 As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
            <Child6>6</Child6>  
        </Root>  
  
Dim root As XElement = <Root>  
                           <Child>child content</Child>  
                       </Root>  
  
root.ReplaceAll( _  
    From el In xmlTree1.Elements() _  
    Where el.Value >= 3 And el.Value <= 5 _  
    Select el _  
)  
  
Console.WriteLine(root)  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```xml  
  
                <Root>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReplaceAttributes">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>この要素の属性を、指定された内容で置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドが発生、<xref:System.Xml.Linq.XObject.Changed>と<xref:System.Xml.Linq.XObject.Changing>イベント。  
  
 この関数に渡すことができる有効なコンテンツに関する詳細については、「[有効なコンテンツの XElement オブジェクトと XDocument オブジェクト](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)です。  
  
   
  
## Examples  
 次の例では、次の 3 つの属性を持つ要素を作成します。 このメソッドを使用して、1 つの属性を持つすべての要素の属性を置き換えます。  
  
```csharp  
  
                XElement root = new XElement("Root",  
    new XAttribute("Att1", 1),  
    new XAttribute("Att2", 2),  
    new XAttribute("Att3", 3)  
);  
root.ReplaceAttributes(  
    new XAttribute("NewAtt1", 101)  
);  
Console.WriteLine(root);  
```  
  
```vb  
  
                Dim root As XElement = <Root Att1="1" Att2="2" Att3="3"/>  
root.ReplaceAttributes(New XAttribute("NewAtt1", 101))  
Console.WriteLine(root)  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```xml  
  
<Root NewAtt1="101" />  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReplaceAttributes">
      <MemberSignature Language="C#" Value="public void ReplaceAttributes (object content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReplaceAttributes(object content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.ReplaceAttributes(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="content">この要素の属性を置き換える内容。</param>
        <summary>この要素の属性を、指定された内容で置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、まず既存の属性を削除します。 これは、後、追加、指定した`content`です。  
  
 この関数に渡すことができる有効なコンテンツに関する詳細については、「[有効なコンテンツの XElement オブジェクトと XDocument オブジェクト](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)です。  
  
 このメソッドが発生、<xref:System.Xml.Linq.XObject.Changed>と<xref:System.Xml.Linq.XObject.Changing>イベント。  
  
   
  
## Examples  
 次の例では、次の 3 つの属性を持つ要素を作成します。 このメソッドを使用して、1 つの属性を持つすべての要素の属性を置き換えます。  
  
```csharp  
  
                XElement root = new XElement("Root",  
    new XAttribute("Att1", 1),  
    new XAttribute("Att2", 2),  
    new XAttribute("Att3", 3)  
);  
root.ReplaceAttributes(  
    new XAttribute("NewAtt1", 101)  
);  
Console.WriteLine(root);  
```  
  
```vb  
  
                Dim root As XElement = <Root Att1="1" Att2="2" Att3="3"/>  
root.ReplaceAttributes(New XAttribute("NewAtt1", 101))  
Console.WriteLine(root)  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```xml  
  
<Root NewAtt1="101" />  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReplaceAttributes">
      <MemberSignature Language="C#" Value="public void ReplaceAttributes (params object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReplaceAttributes(object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.ReplaceAttributes(System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="content">コンテンツ オブジェクトのパラメーター リスト。</param>
        <summary>この要素の属性を、指定された内容で置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、まず既存の属性を削除します。 これは、後、追加、指定した`content`です。  
  
 この関数に渡すことができる有効なコンテンツに関する詳細については、「[有効なコンテンツの XElement オブジェクトと XDocument オブジェクト](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)です。  
  
 このメソッドが発生、<xref:System.Xml.Linq.XObject.Changed>と<xref:System.Xml.Linq.XObject.Changing>イベント。  
  
   
  
## Examples  
 次の例では、次の 3 つの属性を持つ要素を作成します。 その他の属性で属性を置き換えます。  
  
```csharp  
  
                XElement root = new XElement("Root",  
    new XAttribute("Att1", 1),  
    new XAttribute("Att2", 2),  
    new XAttribute("Att3", 3)  
);  
root.ReplaceAttributes(  
    new XAttribute("NewAtt1", 101),  
    new XAttribute("NewAtt2", 102),  
    new XAttribute("NewAtt3", 103)  
);  
Console.WriteLine(root);  
```  
  
```vb  
  
                Dim root As XElement = <Root Att1="1" Att2="2" Att3="3"/>  
root.ReplaceAttributes( _  
New XAttribute("NewAtt1", 101), _  
New XAttribute("NewAtt2", 102), _  
New XAttribute("NewAtt3", 103))  
Console.WriteLine(root)  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```xml  
  
<Root NewAtt1="101" NewAtt2="102" NewAtt3="103" />  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Save(System.IO.Stream)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">これを出力するストリーム<see cref="T:System.Xml.Linq.XElement" />にします。</param>
        <summary>これは出力<see cref="T:System.Xml.Linq.XElement" />を指定した<see cref="T:System.IO.Stream" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 シリアル化された XML はインデントされます。 すべての余分な空白は削除され、され、XML は適切なインデントにできるように、追加の空白文字が追加されます。 このメソッドの動作は、その意味のない空白は保持されません。  
  
 空白を制御する場合は、オーバー ロードを使用して<xref:System.Xml.Linq.XElement.Save%2A>を受け取る<xref:System.Xml.Linq.SaveOptions>をパラメーターとして。 使用して、<xref:System.Xml.Linq.SaveOptions.DisableFormatting>インデントされていない XML を保存するオプションです。 これにより、XML ツリーで表されるとおりにすべての空白文字を書き込むライター。  
  
 使用して、<xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces>重複する名前空間宣言を削除する場合はオプションです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.TextWriter textWriter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.TextWriter textWriter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Save(System.IO.TextWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textWriter" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="textWriter">A<see cref="T:System.IO.TextWriter" />を<see cref="T:System.Xml.Linq.XElement" />に書き込まれます。</param>
        <summary>この要素にシリアル化、<see cref="T:System.IO.TextWriter" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 シリアル化された XML はインデントされます。 すべての余分な空白は削除され、され、XML は適切なインデントにできるように、追加の空白文字が追加されます。 このメソッドの動作は、空白は保持されません。  
  
 空白を制御する場合は、オーバー ロードを使用して<xref:System.Xml.Linq.XElement.Save%2A>を指定することができます<xref:System.Xml.Linq.SaveOptions>をパラメーターとして。 詳細については、次を参照してください。[読み込みまたは XML の解析中に空白を維持](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d)と[維持空白中にシリアル化する](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)です。  
  
   
  
## Examples  
 次の例を作成、<xref:System.Xml.Linq.XElement>にドキュメントを保存、 <xref:System.IO.StringWriter>、し、コンソールに文字列を出力します。  
  
```csharp  
  
                XElement root = XElement.Parse(@"<Root> <Child> Text </Child> </Root>");  
using (StringWriter sw = new StringWriter()) {  
    root.Save(sw);  
    Console.WriteLine(sw.ToString());  
}  
```  
  
```vb  
  
                Dim root As XElement = <Root><Child> Text </Child></Root>  
Using sw = New StringWriter()  
    root.Save(sw)  
    Console.WriteLine(sw.ToString())  
End Using  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```xml  
  
                <?xml version="1.0" encoding="utf-16"?>  
<Root>  
  <Child> Text </Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Save(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">A<see cref="T:System.String" />ファイルの名前を格納しています。</param>
        <summary>この要素をシリアル化してファイルに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 シリアル化された XML はインデントされます。 すべての余分な空白は削除され、され、XML は適切なインデントにできるように、追加の空白文字が追加されます。 このメソッドの動作は、XML ツリー内のノードは保持されません、意味のない空白文字です。  
  
 空白を制御する場合は、オーバー ロードを使用して<xref:System.Xml.Linq.XElement.Save%2A>を指定することができます<xref:System.Xml.Linq.SaveOptions>をパラメーターとして。 詳細については、次を参照してください。[読み込みまたは XML の解析中に空白を維持](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d)と[維持空白中にシリアル化する](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)です。  
  
   
  
## Examples  
 次の例を作成、<xref:System.Xml.Linq.XElement>をファイルにドキュメントを保存、および、ファイルをコンソールに出力します。  
  
```csharp  
  
                XElement root = new XElement("Root",  
    new XElement("Child", "child content")  
);  
root.Save("Root.xml");  
string str = File.ReadAllText("Root.xml");  
Console.WriteLine(str);  
```  
  
```vb  
  
                Dim root As XElement = _   
        <Root>  
            <Child>child content</Child>  
        </Root>  
root.Save("Root.xml")  
Dim Str As String = File.ReadAllText("Root.xml")  
Console.WriteLine(Str)  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```xml  
  
                <?xml version="1.0" encoding="utf-8"?>  
<Root>  
  <Child>child content</Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Save(System.Xml.XmlWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">A<see cref="T:System.Xml.XmlWriter" />を<see cref="T:System.Xml.Linq.XElement" />に書き込まれます。</param>
        <summary>この要素にシリアル化、<see cref="T:System.Xml.XmlWriter" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <xref:System.Xml.Linq.XElement> を <xref:System.Xml.XmlWriter> に保存する方法を次の例に示します。  
  
```csharp  
  
                StringBuilder sb = new StringBuilder();  
XmlWriterSettings xws = new XmlWriterSettings();  
xws.OmitXmlDeclaration = true;  
using (XmlWriter xw = XmlWriter.Create(sb, xws)) {  
    XElement root = new XElement("Root",  
        new XElement("Child", "child content")  
    );  
    root.Save(xw);  
}  
Console.WriteLine(sb.ToString());  
```  
  
```vb  
  
                Dim sb As StringBuilder = New StringBuilder()  
Dim xws As XmlWriterSettings = New XmlWriterSettings()  
xws.OmitXmlDeclaration = True  
Using xw = XmlWriter.Create(sb, xws)  
    Dim root As XElement = <Root>  
                               <Child>child content</Child>  
                           </Root>  
    root.Save(xw)  
End Using  
Console.WriteLine(sb.ToString())  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```xml  
  
<Root><Child>child content</Child></Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.Stream stream, System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.Stream stream, valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Save(System.IO.Stream,System.Xml.Linq.SaveOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="stream">これを出力するストリーム<see cref="T:System.Xml.Linq.XElement" />にします。</param>
        <param name="options">A<see cref="T:System.Xml.Linq.SaveOptions" />書式設定動作を指定するオブジェクト。</param>
        <summary>これは出力<see cref="T:System.Xml.Linq.XElement" />を指定した<see cref="T:System.IO.Stream" />書式指定動作を指定して必要に応じて、します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定では、`options`に設定されている<xref:System.Xml.Linq.SaveOptions.None>です。 このオプションは無関係で意味のない空白はすべて削除し、XML が適切なインデントされないように、適切な意味のない空白を追加します。  
  
 インデントされていない XML を保存する場合は、指定、<xref:System.Xml.Linq.SaveOptions.DisableFormatting>を示すフラグ`options`です。 これにより、XML ツリーで表されるとおりにすべての空白文字を書き込むライター。  
  
 使用して<xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces>重複する名前空間宣言を削除する場合はオプションです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.TextWriter textWriter, System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.TextWriter textWriter, valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Save(System.IO.TextWriter,System.Xml.Linq.SaveOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textWriter" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="textWriter"><see cref="T:System.IO.TextWriter" />に XML を出力します。</param>
        <param name="options">A<see cref="T:System.Xml.Linq.SaveOptions" />書式設定動作を指定します。</param>
        <summary>この要素にシリアル化、 <see cref="T:System.IO.TextWriter" />、書式設定オプションで無効にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデントされていない XML を保存する場合は、指定、<xref:System.Xml.Linq.SaveOptions.DisableFormatting>を示すフラグ`options`です。 これにより、XML ツリーで表されるとおりにすべての空白文字を書き込むライター。  
  
 インデントされた XML を保存する場合を指定しない、<xref:System.Xml.Linq.SaveOptions.DisableFormatting>を示すフラグ`options`です。 これは、余分なで意味のない空白はすべてを削除し、XML が適切なインデントされないように、適切な意味のない空白を追加します。 これは、既定の動作とのオーバー ロードの動作、<xref:System.Xml.Linq.XElement.Save%2A>を受け取らないメソッド`options`をパラメーターとして。  
  
 詳細については、次を参照してください。[読み込みまたは XML の解析中に空白を維持](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d)と[維持空白中にシリアル化する](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)です。  
  
   
  
## Examples  
 次の例では、このメソッドの 2 つの使用を示します。 初めて使用するには、空白が維持されます。 2 番目のシリアル化、<xref:System.Xml.Linq.XElement>書式を設定しています。 ドキュメントがあるないためホワイト スペースが構築されては、インデントは設定されません、XML を出力する空白を維持します。  
  
```csharp  
  
                XElement root = XElement.Parse(@"<Root> <Child> Text </Child> </Root>");  
  
using (StringWriter sw = new StringWriter())  
{  
    root.Save(sw, SaveOptions.DisableFormatting);  
    Console.WriteLine(sw.ToString());  
}  
  
Console.WriteLine("=====");  
  
using (StringWriter sw = new StringWriter())  
{  
    root.Save(sw, SaveOptions.None);  
    Console.WriteLine(sw.ToString());  
}  
```  
  
```vb  
  
                Dim root As XElement = <Root><Child> Text </Child></Root>  
  
Using sw = New StringWriter()  
    root.Save(sw, SaveOptions.DisableFormatting)  
    Console.WriteLine(sw.ToString())  
End Using  
  
Console.WriteLine("=====")  
  
Using sw = New StringWriter()  
    root.Save(sw, SaveOptions.None)  
    Console.WriteLine(sw.ToString())  
End Using  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                <?xml version="1.0" encoding="utf-16"?><Root><Child> Text </Child></Root>  
=====  
<?xml version="1.0" encoding="utf-16"?>  
<Root>  
  <Child> Text </Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (string fileName, System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(string fileName, valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Save(System.String,System.Xml.Linq.SaveOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="fileName">A<see cref="T:System.String" />ファイルの名前を格納しています。</param>
        <param name="options">A<see cref="T:System.Xml.Linq.SaveOptions" />書式設定動作を指定します。</param>
        <summary>この要素をシリアル化してファイルに書き込み、オプションで、書式設定を無効にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデントされていない XML を保存する場合は、指定、<xref:System.Xml.Linq.SaveOptions.DisableFormatting>を示すフラグ`options`です。 これにより、XML ツリーで表されるとおりにすべての空白文字を書き込むライター。  
  
 インデントされた XML を保存する場合を指定しない、<xref:System.Xml.Linq.SaveOptions.DisableFormatting>を示すフラグ`options`です。 これは、余分なで意味のない空白はすべてを削除し、XML が適切なインデントされないように、適切な意味のない空白を追加します。 これは、既定の動作とのオーバー ロードの動作、<xref:System.Xml.Linq.XElement.Save%2A>を受け取らないメソッド`options`をパラメーターとして。  
  
 詳細については、次を参照してください。[読み込みまたは XML の解析中に空白を維持](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d)と[維持空白中にシリアル化する](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)です。  
  
   
  
## Examples  
 次の例では、このメソッドの 2 つの使用を示します。 初めて使用するには、空白が維持されます。 2 つ目のシリアル化、<xref:System.Xml.Linq.XElement>書式を設定しています。  
  
```csharp  
  
                string str;  
XElement root = XElement.Parse(@"<Root> <Child> Text </Child> </Root>");  
  
root.Save("Root.xml", SaveOptions.DisableFormatting);  
str = File.ReadAllText("Root.xml");  
Console.WriteLine(str);  
  
Console.WriteLine("=====");  
  
root.Save("Root.xml", SaveOptions.None);  
str = File.ReadAllText("Root.xml");  
Console.WriteLine(str);  
```  
  
```vb  
  
                Dim str As String  
Dim root As XElement = <Root><Child> Text </Child></Root>  
  
root.Save("Root.xml", SaveOptions.DisableFormatting)  
str = File.ReadAllText("Root.xml")  
Console.WriteLine(str)  
  
Console.WriteLine("=====")  
  
root.Save("Root.xml", SaveOptions.None)  
str = File.ReadAllText("Root.xml")  
Console.WriteLine(str)  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                <?xml version="1.0" encoding="utf-8"?><Root><Child> Text </Child></Root>  
=====  
<?xml version="1.0" encoding="utf-8"?>  
<Root>  
  <Child> Text </Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task SaveAsync (System.Xml.XmlWriter writer, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task SaveAsync(class System.Xml.XmlWriter writer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.SaveAsync(System.Xml.XmlWriter,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="writer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task SaveAsync (System.IO.Stream stream, System.Xml.Linq.SaveOptions options, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task SaveAsync(class System.IO.Stream stream, valuetype System.Xml.Linq.SaveOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.SaveAsync(System.IO.Stream,System.Xml.Linq.SaveOptions,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="stream">To be added.</param>
        <param name="options">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task SaveAsync (System.IO.TextWriter textWriter, System.Xml.Linq.SaveOptions options, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task SaveAsync(class System.IO.TextWriter textWriter, valuetype System.Xml.Linq.SaveOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.SaveAsync(System.IO.TextWriter,System.Xml.Linq.SaveOptions,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textWriter" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="textWriter">To be added.</param>
        <param name="options">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAttributeValue">
      <MemberSignature Language="C#" Value="public void SetAttributeValue (System.Xml.Linq.XName name, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAttributeValue(class System.Xml.Linq.XName name, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.SetAttributeValue(System.Xml.Linq.XName,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name"><see cref="T:System.Xml.Linq.XName" />を変更する属性の名前を格納しています。</param>
        <param name="value">属性に代入する値。 値の場合、属性が削除された<see langword="null" />です。 値がそれ以外の場合、文字列形式に変換されに割り当てられている、<see cref="P:System.Xml.Linq.XAttribute.Value" />属性のプロパティです。</param>
        <summary>属性の値を設定、属性の追加または属性を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、一連の属性として名前/値ペアの一覧を管理しやすいように設計されています。 一覧を保持する場合のペアを追加のペアを変更またはのペアを削除する必要があります。 属性として存在しない名前指定してこのメソッドを呼び出した場合、このメソッドは、属性を作成します。 既存の属性の名前を渡してこのメソッドを呼び出す場合は、このメソッドは、指定した値を属性の値を変更します。 渡す場合`null`の`value`、このメソッドは、属性を削除します。  
  
 このメソッドが発生、<xref:System.Xml.Linq.XObject.Changed>と<xref:System.Xml.Linq.XObject.Changing>イベント。  
  
 値は、指定した名前を持つ属性に割り当てられます。 指定した名前を持つ属性が存在しない場合は、新しい属性が追加されます。 値が場合`null`、指定した名前を持つ属性が存在する場合は削除します。  
  
 詳細については、次を参照してください。[名前/値ペアの維持](http://msdn.microsoft.com/library/fe9798bf-b5e2-4a3c-a86c-7f8638912691)です。  
  
   
  
## Examples  
 次の例では、属性を持つ要素を作成します。 このメソッドを使用して、属性の内容を置き換えます。  
  
```csharp  
// Create an element with no content.  
XElement root = new XElement("Root");  
  
// Add some name/value pairs.  
root.SetAttributeValue("Att1", 1);  
root.SetAttributeValue("Att2", 2);  
root.SetAttributeValue("Att3", 3);  
Console.WriteLine(root);  
  
// Modify one of the name/value pairs.  
root.SetAttributeValue("Att2", 22);  
Console.WriteLine(root);  
  
// Remove one of the name/value pairs.  
root.SetAttributeValue("Att3", null);  
Console.WriteLine(root);  
```  
  
```vb  
' Create an element with no content.  
Dim root As XElement = <Root/>  
  
' Add some name/value pairs.  
root.SetAttributeValue("Att1", 1)  
root.SetAttributeValue("Att2", 2)  
root.SetAttributeValue("Att3", 3)  
Console.WriteLine(root)  
  
' Modify one of the name/value pairs.  
root.SetAttributeValue("Att2", 22)  
Console.WriteLine(root)  
  
' Remove one of the name/value pairs.  
root.SetAttributeValue("Att3", Nothing)  
Console.WriteLine(root)  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                <Root Att1="1" Att2="2" Att3="3" />  
<Root Att1="1" Att2="22" Att3="3" />  
<Root Att1="1" Att2="22" />  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="value" />のインスタンスは、<see cref="T:System.Xml.Linq.XObject" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetElementValue">
      <MemberSignature Language="C#" Value="public void SetElementValue (System.Xml.Linq.XName name, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetElementValue(class System.Xml.Linq.XName name, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.SetElementValue(System.Xml.Linq.XName,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name"><see cref="T:System.Xml.Linq.XName" />を変更する子要素の名前を格納しています。</param>
        <param name="value">子要素に代入する値。 値の場合、子要素が削除された<see langword="null" />です。 値がそれ以外の場合、文字列形式に変換されに割り当てられている、<see cref="P:System.Xml.Linq.XElement.Value" />子要素のプロパティです。</param>
        <summary>子要素の値の設定、子要素の追加、または子要素の削除を行います。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、一連の子要素として名前/値ペアの一覧を管理しやすいように設計されています。 一覧を保持する場合のペアを追加のペアを変更またはのペアを削除する必要があります。 子要素として存在しない名前指定してこのメソッドを呼び出した場合、このメソッドは、子要素を作成します。 既存の子要素の名前を渡してこのメソッドを呼び出す場合は、このメソッドは、指定した値に子要素の値を変更します。 渡す場合`null`の`value`、このメソッドは、子要素を削除します。  
  
 このメソッドには、イベントが発生します。  
  
 値は、指定した名前の最初の子要素に割り当てられます。 指定した名前を持つ子要素が存在しない場合は、新しい子要素が追加されます。 値が null の場合、指定した名前を持つ最初の子要素、存在する場合は削除されます。  
  
 このメソッドは、指定された子要素に子ノードまたは属性を追加できません。 このメソッドは、任意のオブジェクトから派生する場合に例外をスロー<xref:System.Xml.Linq.XObject>として渡される`value`です。  
  
 詳細については、次を参照してください。[名前/値ペアの維持](http://msdn.microsoft.com/library/fe9798bf-b5e2-4a3c-a86c-7f8638912691)です。  
  
   
  
## Examples  
 次の例では、子要素を持つ要素を作成します。 このメソッドを使用して、子要素の値を設定します。  
  
```csharp  
// Create an element with no content  
XElement root = new XElement("Root");  
  
// Add some name/value pairs.  
root.SetElementValue("Ele1", 1);  
root.SetElementValue("Ele2", 2);  
root.SetElementValue("Ele3", 3);  
Console.WriteLine(root);  
  
// Modify one of the name/value pairs.  
root.SetElementValue("Ele2", 22);  
Console.WriteLine(root);  
  
// Remove one of the name/value pairs.  
root.SetElementValue("Ele3", null);  
Console.WriteLine(root);  
```  
  
```vb  
' Create an element with no content.  
Dim root As XElement = <Root/>  
  
' Add some name/value pairs.  
root.SetElementValue("Ele1", 1)  
root.SetElementValue("Ele2", 2)  
root.SetElementValue("Ele3", 3)  
Console.WriteLine(root)  
  
' Modify one of the name/value pairs.  
root.SetElementValue("Ele2", 22)  
Console.WriteLine(root)  
  
' Remove one of the name/value pairs.  
root.SetElementValue("Ele3", Nothing)  
Console.WriteLine(root)  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                <Root>  
  <Ele1>1</Ele1>  
  <Ele2>2</Ele2>  
  <Ele3>3</Ele3>  
</Root>  
<Root>  
  <Ele1>1</Ele1>  
  <Ele2>22</Ele2>  
  <Ele3>3</Ele3>  
</Root>  
<Root>  
  <Ele1>1</Ele1>  
  <Ele2>22</Ele2>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="value" />のインスタンスは、<see cref="T:System.Xml.Linq.XObject" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.SetValue(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">この要素に代入する値。 値は、文字列形式に変換されに割り当てられている、<see cref="P:System.Xml.Linq.XElement.Value" />プロパティです。</param>
        <summary>現在の要素の値を設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドが発生、<xref:System.Xml.Linq.XObject.Changed>と<xref:System.Xml.Linq.XObject.Changing>イベント。  
  
 派生したクラスのインスタンスを渡すことはできません<xref:System.Xml.Linq.XObject>など<xref:System.Xml.Linq.XElement>です。  
  
   
  
## Examples  
 次の例では、子要素が含まれる要素を作成します。 このメソッドを使用して要素の値を設定します。  
  
```csharp  
  
                XElement root = new XElement("Root",  
    new XElement("Child", "child content")  
);  
root.SetValue("new content");  
Console.WriteLine(root);  
```  
  
```vb  
  
                Dim root As XElement = _   
        <Root>  
            <Child>child content</Child>  
        </Root>  
  
root.SetValue("new content")  
Console.WriteLine(root)  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```xml  
  
<Root>new content</Root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" />は、<see cref="T:System.Xml.Linq.XObject" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.GetSchema">
      <MemberSignature Language="C#" Value="System.Xml.Schema.XmlSchema IXmlSerializable.GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Xml.Schema.XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.System#Xml#Serialization#IXmlSerializable#GetSchema" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このオブジェクトの XML 表現を記述する XML スキーマ定義を取得します。</summary>
        <returns><see cref="T:System.Xml.Schema.XmlSchema" />によって生成されるオブジェクトの XML 表現を表す、<see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" />メソッドによって消費されると、<see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />メソッドです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドの実装の一部である、<xref:System.Xml.Serialization.IXmlSerializable>インターフェイスです。  
  
 このメソッドは内部 LINQ には to XML オブジェクトが含まれているオブジェクト グラフをシリアル化するために使用されます。 XML オブジェクトを LINQ を含むオブジェクト グラフをシリアル化の例は、次を参照してください。[シリアル番号化オブジェクト グラフを含む XElement オブジェクト](http://msdn.microsoft.com/library/443d7904-a6f0-450a-b1a4-5d7ed869d1d5)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.ReadXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader"><see cref="T:System.Xml.XmlReader" />オブジェクトが逆シリアル化します。</param>
        <summary>オブジェクトの XML 表現からオブジェクトを生成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドの実装の一部である、<xref:System.Xml.Serialization.IXmlSerializable>インターフェイスです。  
  
 このメソッドは内部 LINQ には to XML オブジェクトが含まれているオブジェクト グラフをシリアル化するために使用されます。 XML オブジェクトを LINQ を含むオブジェクト グラフをシリアル化の例は、次を参照してください。[シリアル番号化オブジェクト グラフを含む XElement オブジェクト](http://msdn.microsoft.com/library/443d7904-a6f0-450a-b1a4-5d7ed869d1d5)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.WriteXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer"><see cref="T:System.Xml.XmlWriter" />このオブジェクトのシリアル化します。</param>
        <summary>オブジェクトを XML 表現に変換します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、LINQ には to XML オブジェクトが含まれているオブジェクト グラフをマーシャ リングの内部使用されます。 XML オブジェクトを LINQ を含むオブジェクト グラフをシリアル化の例は、次を参照してください。[シリアル番号化オブジェクト グラフを含む XElement オブジェクト](http://msdn.microsoft.com/library/443d7904-a6f0-450a-b1a4-5d7ed869d1d5)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public string Value { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Value" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XElement.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の連結されたテキスト コンテンツを取得または設定します。</summary>
        <value>A<see cref="T:System.String" />を含むすべてのこの要素のテキスト コンテンツ。 複数のテキスト ノードがある場合は、連結されます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを使用して、取得または要素の値を設定します。  
  
 このプロパティは生成の設定、<xref:System.Xml.Linq.XObject.Changed>と<xref:System.Xml.Linq.XObject.Changing>イベント。  
  
 明示的な変換演算子を使用しなどの要素を null 許容型に割り当てるに都合が場合、要素の値を取得する点がある場合は、存在していることを確認して`string`または<xref:System.Nullable%601>の<xref:System.Int32>します。 Null 許容型に設定されている要素が存在しない場合`null`です。 これに対し、このプロパティを使用する場合は、する必要があることを確認、<xref:System.Xml.Linq.XContainer.Element%2A>メソッドが返されません`null`このプロパティにアクセスする前にします。  
  
   
  
## Examples  
 次の例では、混合コンテンツを持つ要素のテキストを取得するのにこのプロパティを使用します。  
  
```csharp  
  
                XElement el = XElement.Parse("<Root>This is <b>mixed</b> content</Root>");  
Console.WriteLine("{0}", el.Value);  
```  
  
```vb  
  
                Dim el As XElement = <Root>This is <b>mixed</b> content</Root>  
Console.WriteLine("{0}", el.Value)  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
This is mixed content  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteTo">
      <MemberSignature Language="C#" Value="public override void WriteTo (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteTo(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.WriteTo(System.Xml.XmlWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer"><see cref="T:System.Xml.XmlWriter" />にこのメソッドが作成されます。</param>
        <summary>この要素を書き込み、<see cref="T:System.Xml.XmlWriter" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例を記述する方法を示しています、<xref:System.Xml.Linq.XElement>を<xref:System.Xml.XmlWriter>です。 例が XML 宣言を作成していないことに注意してください。  
  
```csharp  
  
                StringBuilder sb = new StringBuilder();  
XmlWriterSettings xws = new XmlWriterSettings();  
xws.OmitXmlDeclaration = true;  
xws.Indent = true;  
  
using (XmlWriter xw = XmlWriter.Create(sb, xws)) {  
    xw.WriteStartElement("Root");  
  
    XElement child1 = new XElement("Child",  
        new XElement("GrandChild", "some content")  
    );  
    child1.WriteTo(xw);  
  
    XElement child2 = new XElement("AnotherChild",  
        new XElement("GrandChild", "different content")  
    );  
    child2.WriteTo(xw);  
  
    xw.WriteEndElement();  
}  
  
Console.WriteLine(sb.ToString());  
```  
  
```vb  
  
                Dim sb As StringBuilder = New StringBuilder()  
Dim xws As XmlWriterSettings = New XmlWriterSettings()  
xws.OmitXmlDeclaration = True  
xws.Indent = True  
  
Using xw = XmlWriter.Create(sb, xws)  
    xw.WriteStartElement("Root")  
    Dim child1 As XElement = _  
        <Child>  
            <GrandChild>some content</GrandChild>  
        </Child>  
    child1.WriteTo(xw)  
    Dim child2 As XElement = _   
        <AnotherChild>  
            <GrandChild>different content</GrandChild>  
        </AnotherChild>  
    child2.WriteTo(xw)  
    xw.WriteEndElement()  
End Using  
  
Console.WriteLine(sb.ToString())  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```xml  
  
                <Root>  
  <Child>  
    <GrandChild>some content</GrandChild>  
  </Child>  
  <AnotherChild>  
    <GrandChild>different content</GrandChild>  
  </AnotherChild>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteToAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteToAsync (System.Xml.XmlWriter writer, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteToAsync(class System.Xml.XmlWriter writer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.WriteToAsync(System.Xml.XmlWriter,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="writer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
