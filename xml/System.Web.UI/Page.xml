<Type Name="Page" FullName="System.Web.UI.Page">
  <TypeSignature Language="C#" Value="public class Page : System.Web.UI.TemplateControl, System.Web.IHttpHandler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Page extends System.Web.UI.TemplateControl implements class System.Web.IHttpHandler" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.Page" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Web.UI.TemplateControl</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Web.IHttpHandler</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Load")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer("Microsoft.VisualStudio.Web.WebForms.WebFormCodeDomSerializer, Microsoft.VisualStudio.Web, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.TypeCodeDomSerializer, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Web.WebForms.WebFormDesigner, Microsoft.VisualStudio.Web, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.ComponentModel.Design.IRootDesigner))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignerCategory("ASPXCodeBehind")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>ASP.NET Web アプリケーションのホストであるサーバーから要求される .aspx ファイル (Web フォーム ページとも呼ばれる) を表します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page>クラスは、.aspx 拡張子を持つファイルに関連付けられています。 これらのファイルは実行時としてコンパイル<xref:System.Web.UI.Page>オブジェクトし、サーバーのメモリにキャッシュします。  
  
 コードの分離手法を使用して、Web フォーム ページを作成する場合は、このクラスから派生します。 Microsoft Visual Studio などのアプリケーションの迅速な development (RAD) デザイナーは、Web フォーム ページを作成するのに、このモデルを自動的に使用します。  
  
 <xref:System.Web.UI.Page>オブジェクトを実装するものを除く、ページ内のすべてのサーバー コントロールの名前付けコンテナーとして機能、<xref:System.Web.UI.INamingContainer>インターフェイスや、このインターフェイスを実装するコントロールの子コントロールは、します。  
  
 <xref:System.Web.UI.Page>クラスは、コントロールを Web アプリケーションのユーザー インターフェイスとして機能し、そのためのセキュリティで保護されたコードの記述およびアプリケーションのセキュリティ保護が後に確認のベスト プラクティスを調査する必要があります。 これらのトピックの概要については、次を参照してください。[概要の Web アプリケーション セキュリティの脅威](http://msdn.microsoft.com/library/88d61678-f84e-4622-ae80-53128821855a)、 [NIB: セキュリティ ポリシーのベスト プラクティス](http://msdn.microsoft.com/en-us/d49bc4d5-efb7-4caa-a2fe-e4d3cec63c05)、および[セキュリティの基本概念](~/docs/standard/security/key-security-concepts.md)です。 詳細については、次を参照してください。[標準コントロールのセキュリティで保護する](http://msdn.microsoft.com/library/f3e7718f-63d0-44a3-bd5f-48cc2059c2a8)、[する方法: 安全なエラー メッセージを表示](http://msdn.microsoft.com/library/6f70ac33-6e11-4e98-ab7d-bae9c0e7eefa)、[する方法: 保護に対してスクリプトによる攻略の文字列を HTML エンコードを適用することによって、Web アプリケーションで](http://msdn.microsoft.com/library/6f67973f-dda0-45a1-ba9d-e88532d7dc5b)、および[検証コントロールの概要](http://msdn.microsoft.com/en-us/3c0e7514-cff2-4bed-936d-ee3f7b740190)です。  
  
   
  
## Examples  
 Visual Studio の Web サイト プロジェクトとソース コードは、このトピックで使用可能な:[ダウンロード](http://go.microsoft.com/fwlink/?LinkId=192425)です。  
  
 次のコード例を示していますが、どのように<xref:System.Web.UI.Page>クラスは、分離コード ページ モデルで使用します。 分離コードのソース ファイルが、ページの基本クラスから継承する部分クラスを宣言することに注意してください。 ベース ページのクラスを指定できます<xref:System.Web.UI.Page>、または別のクラスから派生したできます<xref:System.Web.UI.Page>です。 さらに、部分クラスは、フィールドのメンバーとして定義する必要はありません ページで定義されているコントロールを使用する分離コード ファイルに注意してください。  
  
 [!code-csharp[System.Web.UI.Page_Overview#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_Overview/cs/pageexample.aspx.cs#2)]
 [!code-vb[System.Web.UI.Page_Overview#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_Overview/vb/pageexample.aspx.vb#2)]  
  
 次のコード例では、上記のコード ビハインド ソース ファイルに対応する .aspx ファイルを示します。  
  
> [!IMPORTANT]
>  この例には、ユーザー入力を受け付けるテキスト ボックスがあります。これにより、セキュリティが脆弱になる可能性があります。 既定では、ASP.NET Web ページによって、ユーザー入力にスクリプトまたは HTML 要素が含まれていないかどうかが検証されます。 詳細については、次を参照してください。[スクリプト悪用概要](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)です。  
  
 [!code-aspx-csharp[System.Web.UI.Page_Overview#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_Overview/cs/pageexample.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page_Overview#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_Overview/vb/pageexample.aspx#1)]  
  
 ディレクティブを使用して、使用する必要があります、`Inherits`と`CodeFile`.aspx ファイルに分離コード ファイルをリンクする属性。 この例では、`Inherits`属性を示します、`MyCodeBehind`クラスおよび`CodeFile`属性がクラスを含む言語固有のファイルへのパスを示します。  
  
 次のコード例は、単一ファイル ページ モデルおよびへのアクセス方法を示しています、<xref:System.Web.UI.Page.IsPostBack%2A>プロパティおよび<xref:System.Web.UI.Page.Response%2A>のプロパティ、<xref:System.Web.UI.Page>です。  
  
 [!code-aspx-csharp[System.Web.UI.Page_Overview2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_Overview2/cs/pageexample.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page_Overview2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_Overview2/vb/pageexample.aspx#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Page ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Web.UI.Page" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定のコンス トラクターは、すべてのフィールドを既定値を初期化します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddContentTemplate">
      <MemberSignature Language="C#" Value="protected void AddContentTemplate (string templateName, System.Web.UI.ITemplate template);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddContentTemplate(string templateName, class System.Web.UI.ITemplate template) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AddContentTemplate(System.String,System.Web.UI.ITemplate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="templateName" Type="System.String" />
        <Parameter Name="template" Type="System.Web.UI.ITemplate" />
      </Parameters>
      <Docs>
        <param name="templateName">追加するコンテンツのテンプレートの名前。</param>
        <param name="template">コンテンツのテンプレート</param>
        <summary>現在のページまたはマスター ページ、マスター ページを参照する場合、マスター ページに渡される (コンテンツ コントロール) からのコンテンツのコレクションを作成するページの初期化中に呼び出されます。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Web.HttpException">同じ名前のコンテンツのテンプレートは既に存在します。</exception>
      </Docs>
    </Member>
    <Member MemberName="AddOnPreRenderCompleteAsync">
      <MemberSignature Language="C#" Value="public void AddOnPreRenderCompleteAsync (System.Web.BeginEventHandler beginHandler, System.Web.EndEventHandler endHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddOnPreRenderCompleteAsync(class System.Web.BeginEventHandler beginHandler, class System.Web.EndEventHandler endHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AddOnPreRenderCompleteAsync(System.Web.BeginEventHandler,System.Web.EndEventHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="beginHandler" Type="System.Web.BeginEventHandler" />
        <Parameter Name="endHandler" Type="System.Web.EndEventHandler" />
      </Parameters>
      <Docs>
        <param name="beginHandler">デリゲート、<see cref="T:System.Web.BeginEventHandler" />メソッドです。</param>
        <param name="endHandler">デリゲート、<see cref="T:System.Web.EndEventHandler" />メソッドです。</param>
        <summary>非同期ページの状態情報を必要としない最初と最後のイベント ハンドラー デリゲートを登録します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Web.UI.Page.AddOnPreRenderCompleteAsync%2A>非同期 Web ページにハンドラーを追加します。  
  
 複数の非同期ハンドラーを登録することができます。ただし、一度に 1 つだけのハンドラーが実行されます。 同時に複数の非同期メソッドを処理する場合は、1 つを使用する必要があります<xref:System.Web.BeginEventHandler>メソッドとそのハンドラーからの複数の非同期操作を起動します。  
  
 間で非同期のハンドラーが呼び出される、<xref:System.Web.UI.Control.PreRender>と<xref:System.Web.UI.Page.PreRenderComplete>イベント。  
  
 最初に、すべて<xref:System.Web.UI.Page>イベント (を通じて、<xref:System.Web.UI.Control.PreRender>イベント) は、実行、および各し、登録されている<xref:System.Web.BeginEventHandler>メソッドが呼び出されます。 ときに、ハンドラーが完了したら、対応する<xref:System.Web.EndEventHandler>メソッドが呼び出されます。 複数の非同期ハンドラーがある場合は、[次へ] のハンドラーが呼び出されます。  
  
 登録済みの非同期イベント ハンドラーが呼び出された後、残りのページのイベントが呼び出されると、以降で、<xref:System.Web.UI.Page.PreRenderComplete>イベント。  
  
   
  
## Examples  
 次のコード例では、非同期要求を使ってのローカル Web サーバーの既定のページの HTML ソース コードを表示する、<xref:System.Web.UI.WebControls.TextBox>コントロール。  
  
> [!IMPORTANT]
>  この例には、ユーザー入力を受け付けるテキスト ボックスがあります。これにより、セキュリティが脆弱になる可能性があります。 既定では、ASP.NET Web ページによって、ユーザー入力にスクリプトまたは HTML 要素が含まれていないかどうかが検証されます。 詳細については、次を参照してください。[スクリプト悪用概要](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)です。  
  
 [!code-aspx-csharp[PageAddOnPreRenderCompleteAsync#1](~/samples/snippets/csharp/VS_Snippets_WebNet/PageAddOnPreRenderCompleteAsync/CS/pageaddonprerendercompleteasynccs.aspx#1)]
 [!code-aspx-vb[PageAddOnPreRenderCompleteAsync#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageAddOnPreRenderCompleteAsync/VB/pageaddonprerendercompleteasyncvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see langword="&lt;async&gt;" />ページ ディレクティブに設定されていない<see langword="true" />です。  
  
 \- または  
  
 <see cref="M:System.Web.UI.Page.AddOnPreRenderCompleteAsync(System.Web.BeginEventHandler,System.Web.EndEventHandler)" />メソッドは、<see cref="E:System.Web.UI.Control.PreRender" />イベント。</exception>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Web.UI.PageAsyncTask.BeginHandler" /> または <see cref="P:System.Web.UI.PageAsyncTask.EndHandler" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="AddOnPreRenderCompleteAsync">
      <MemberSignature Language="C#" Value="public void AddOnPreRenderCompleteAsync (System.Web.BeginEventHandler beginHandler, System.Web.EndEventHandler endHandler, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddOnPreRenderCompleteAsync(class System.Web.BeginEventHandler beginHandler, class System.Web.EndEventHandler endHandler, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AddOnPreRenderCompleteAsync(System.Web.BeginEventHandler,System.Web.EndEventHandler,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="beginHandler" Type="System.Web.BeginEventHandler" />
        <Parameter Name="endHandler" Type="System.Web.EndEventHandler" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="beginHandler">デリゲート、<see cref="T:System.Web.BeginEventHandler" />メソッドです。</param>
        <param name="endHandler">デリゲート、<see cref="T:System.Web.EndEventHandler" />メソッドです。</param>
        <param name="state">イベント ハンドラーの状態情報を格納するオブジェクト。</param>
        <summary>開始と終了時刻非同期ページのイベント ハンドラー デリゲートを登録します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Web.UI.Page.AddOnPreRenderCompleteAsync%2A>メソッドを非同期の Web ページに状態情報を必要とするハンドラーを追加します。 渡されたオブジェクト、`state`パラメーターで指定されたイベント ハンドラー デリゲートの間で情報を転送するアプリケーションに必要な任意のオブジェクトを指定できます、`beginHandler`と`endHandler`パラメーター。  
  
 複数の非同期ハンドラーを登録することができます。ただし、一度に 1 つだけのハンドラーが実行されます。 同時に複数の非同期メソッドを処理する場合は、1 つを使用する必要があります<xref:System.Web.BeginEventHandler>メソッドとそのハンドラーからの複数の非同期操作を起動します。  
  
 間で非同期のハンドラーが呼び出される、<xref:System.Web.UI.Control.PreRender>と<xref:System.Web.UI.Page.PreRenderComplete>イベント。  
  
 最初に、すべて<xref:System.Web.UI.Page>イベント (を通じて、<xref:System.Web.UI.Control.PreRender>イベント) は、実行、および各し、登録されている<xref:System.Web.BeginEventHandler>メソッドが呼び出されます。 ときに、ハンドラーが完了したら、対応する<xref:System.Web.EndEventHandler>メソッドが呼び出されます。 複数の非同期ハンドラーがある場合は、[次へ] のハンドラーが呼び出されます。  
  
 登録済みの非同期イベント ハンドラーが呼び出された後、残りのページのイベントが呼び出されると、以降で、<xref:System.Web.UI.Page.PreRenderComplete>イベント。  
  
   
  
## Examples  
 次のコード例では、非同期要求を使ってのローカル Web サーバーの既定のページの HTML ソース コードを表示する、<xref:System.Web.UI.WebControls.TextBox>コントロール。  
  
> [!IMPORTANT]
>  この例には、ユーザー入力を受け付けるテキスト ボックスがあります。これにより、セキュリティが脆弱になる可能性があります。 既定では、ASP.NET Web ページによって、ユーザー入力にスクリプトまたは HTML 要素が含まれていないかどうかが検証されます。 詳細については、次を参照してください。[スクリプト悪用概要](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)です。  
  
 [!code-aspx-csharp[PageAddOnPreRenderCompleteAsync#1](~/samples/snippets/csharp/VS_Snippets_WebNet/PageAddOnPreRenderCompleteAsync/CS/pageaddonprerendercompleteasynccs.aspx#1)]
 [!code-aspx-vb[PageAddOnPreRenderCompleteAsync#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageAddOnPreRenderCompleteAsync/VB/pageaddonprerendercompleteasyncvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see langword="&lt;async&gt;" />ページ ディレクティブに設定されていない<see langword="true" />です。  
  
 \- または  
  
 <see cref="M:System.Web.UI.Page.AddOnPreRenderCompleteAsync(System.Web.BeginEventHandler,System.Web.EndEventHandler)" />メソッドは、<see cref="E:System.Web.UI.Control.PreRender" />イベント。</exception>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Web.UI.PageAsyncTask.BeginHandler" /> または <see cref="P:System.Web.UI.PageAsyncTask.EndHandler" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="AddWrappedFileDependencies">
      <MemberSignature Language="C#" Value="protected void AddWrappedFileDependencies (object virtualFileDependencies);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddWrappedFileDependencies(object virtualFileDependencies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AddWrappedFileDependencies(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualFileDependencies" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="virtualFileDependencies"><see cref="T:System.Object" />ファイル名の一覧を含むです。</param>
        <summary>現在のページを構成する依存ファイルの一覧を追加します。 このメソッドは、ASP.NET ページ フレームワークによって内部的に使用し、コードから直接使用するものではありません。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.AddWrappedFileDependencies%2A>メソッドは、現在のページを構成するユーザー コントロール ファイルなどのファイルの一覧を追加します。 これらのページのいずれかを変更する場合、ページ全体には、要求時に、[次へ] がコンパイルされます。 このメソッドは、.NET Framework インフラストラクチャをサポートします。独自に作成したコードから直接使用するためのものではありません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Application">
      <MemberSignature Language="C#" Value="public System.Web.HttpApplicationState Application { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpApplicationState Application" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Application" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpApplicationState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の Web 要求に対する <see cref="T:System.Web.HttpApplicationState" /> オブジェクトを取得します。</summary>
        <value>現在のデータ、<see cref="T:System.Web.HttpApplicationState" />クラスです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[Page.Application_Sample1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page.Application_Sample1/CS/applicationcs.aspx#1)]
 [!code-vb[Page.Application_Sample1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page.Application_Sample1/VB/applicationvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AspCompatBeginProcessRequest">
      <MemberSignature Language="C#" Value="protected IAsyncResult AspCompatBeginProcessRequest (System.Web.HttpContext context, AsyncCallback cb, object extraData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.IAsyncResult AspCompatBeginProcessRequest(class System.Web.HttpContext context, class System.AsyncCallback cb, object extraData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AspCompatBeginProcessRequest(System.Web.HttpContext,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
        <Parameter Name="cb" Type="System.AsyncCallback" />
        <Parameter Name="extraData" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="context"><see cref="T:System.Web.HttpContext" />現在の要求に関する情報を使用します。</param>
        <param name="cb">コールバック メソッド。</param>
        <param name="extraData">ASP 要求と同じ方法で要求を処理するために必要な追加データ。</param>
        <summary>Active Server Page (ASP) のリソースの要求を開始します。 このメソッドは、従来の ASP アプリケーションとの互換性を提供します。</summary>
        <returns><see cref="T:System.IAsyncResult" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを呼び出さないでください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AspCompatEndProcessRequest">
      <MemberSignature Language="C#" Value="protected void AspCompatEndProcessRequest (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void AspCompatEndProcessRequest(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AspCompatEndProcessRequest(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">要求によって生成される ASP ページです。</param>
        <summary>Active Server Page (ASP) のリソースの要求を終了します。 このメソッドは、従来の ASP アプリケーションとの互換性を提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを呼び出さないでください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AspCompatMode">
      <MemberSignature Language="C#" Value="protected bool AspCompatMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AspCompatMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.AspCompatMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページをシングル スレッド アパートメント (STA) スレッドで実行できるかどうかを示す値を設定します。</summary>
        <value>
          <see langword="true" />ページは、Active Server Pages (ASP) のコードをサポートしている場合それ以外の場合、<see langword="false" />です。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定すると`true`、このプロパティは、シングル スレッド アパートメント (STA) スレッドで実行するページを使用します。 これにより、ページから Visual Basic 6.0 で開発したコンポーネントなどの STA コンポーネントを呼び出すことができます。 このプロパティを設定`true`ページから、そのアンマネージ ASP 組み込みオブジェクトへのアクセスを必要とする COM + コンポーネントを呼び出すことができます。 これらは、ASP 経由でアクセスできる`ObjectContext`オブジェクトまたは`OnStartPage`メソッドです。  
  
 ほとんどの状況では、コードでこのプロパティを設定しないでください。 設定、`aspcompat`属性を`true`.aspx ファイルで、ディレクティブを使用します。 ページが要求されると、動的に生成されたクラスは、プロパティを設定します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncMode">
      <MemberSignature Language="C#" Value="protected bool AsyncMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AsyncMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.AsyncMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページが同期または非同期で処理されるかどうかを示す値を設定します。</summary>
        <value>
          <see langword="true" />ページが非同期的に処理された場合それ以外の場合、<see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.AsyncMode%2A>プロパティで設定されて、<xref:System.Web.UI.Page>パーサーのページのコードが生成されたときにします。 使用して、`Async`この値を設定するディレクティブ内の属性です。  
  
 非同期ページがうまくできない場合に、`AspCompat`属性に設定されている`true`または`Transaction`属性が以外の値に設定が`Disabled`ディレクティブにします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncPageBeginProcessRequest">
      <MemberSignature Language="C#" Value="protected IAsyncResult AsyncPageBeginProcessRequest (System.Web.HttpContext context, AsyncCallback callback, object extraData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.IAsyncResult AsyncPageBeginProcessRequest(class System.Web.HttpContext context, class System.AsyncCallback callback, object extraData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AsyncPageBeginProcessRequest(System.Web.HttpContext,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="extraData" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="context"><see cref="T:System.Web.HttpContext" />要求します。</param>
        <param name="callback">プロセスが完了するときに通知するコールバック メソッド。</param>
        <param name="extraData">非同期のメソッドの状態データ。</param>
        <summary>非同期のページ要求の処理を開始します。</summary>
        <returns>非同期の要求を参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncPageEndProcessRequest">
      <MemberSignature Language="C#" Value="protected void AsyncPageEndProcessRequest (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void AsyncPageEndProcessRequest(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AsyncPageEndProcessRequest(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result"><see cref="T:System.IAsyncResult" />保留中の非同期要求を参照します。</param>
        <summary>非同期のページ要求の処理を終了します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan AsyncTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan AsyncTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.AsyncTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または非同期タスクを処理するときに使用されるタイムアウト間隔を示す値を設定します。</summary>
        <value>A<see cref="T:System.TimeSpan" />の非同期タスクの完了を許可された時間間隔を格納しています。 既定の時間間隔は、45 秒です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ページの非同期のタイムアウトは、非同期タスクを実行するページが待機する時間を表します。 ほとんどの状況では、コードでこのプロパティを設定しないでください。 ページ非同期のタイムアウト間隔を使用して、設定、または Web 構成ファイルのディレクティブにします。 ページ ディレクティブでは、ページの構成セクションで設定された値が上書きされます。  
  
 使用して、非同期タスクを定義する、<xref:System.Web.UI.PageAsyncTask>クラスし、開始、終了、およびタイムアウトのハンドラーを登録します。 指定された時間間隔で、非同期タスクが完了しない場合、タイムアウトのハンドラーが呼び出されます。  
  
   
  
## Examples  
 使用を次のコード例に示します、<xref:System.Web.UI.Page.AsyncTimeout%2A>を持つプロパティ、<xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A>と<xref:System.Web.UI.Page.RegisterAsyncTask%2A>メソッドです。 先頭、末尾、およびタイムアウト ハンドラーの使用に注意してください。 指定されているタスクの割り当て時刻を超えた場合、非同期タスクのような状況を示す例では、人為的な遅延が導入された、<xref:System.Web.UI.Page.AsyncTimeout%2A>プロパティです。 現実のシナリオで非同期タスクは、データベースの呼び出しまたはイメージの生成を実行するために使用可能性がありますなどとタイムアウト ハンドラーは、一定の時間で、タスクは実行されない場合に下げるを提供します。 なお、 <xref:System.Web.UI.Page.AsyncTimeout%2A> page ディレクティブでプロパティを設定します。  
  
 [!code-aspx-csharp[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.aspx#1)]  
  
 [!code-csharp[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.cs#2)]
 [!code-vb[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">プロパティは、負の値に設定されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="AutoPostBackControl">
      <MemberSignature Language="C#" Value="public System.Web.UI.Control AutoPostBackControl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control AutoPostBackControl" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.AutoPostBackControl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはポストバックの実行に使用されるページで、コントロールを設定します。</summary>
        <value>ポストバックを実行するために使用するコントロール。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Buffer">
      <MemberSignature Language="C#" Value="public bool Buffer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Buffer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Buffer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページ出力がバッファリングされるかどうかを示す値を設定します。</summary>
        <value>
          <see langword="true" />ページ出力がバッファリングされる場合それ以外の場合、<see langword="false" />です。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ほとんどの状況では、コードでこのプロパティを設定しないでください。 設定、<xref:System.Web.UI.Page.Buffer%2A>属性を`true`.aspx ファイルで、ディレクティブを使用します。 ページが要求されると、動的に生成されたクラスは、プロパティを設定します。  
  
> [!NOTE]
>  <xref:System.Web.UI.Page.Buffer%2A>設定および取得するプロパティ、<xref:System.Web.HttpResponse.BufferOutput%2A>プロパティです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cache">
      <MemberSignature Language="C#" Value="public System.Web.Caching.Cache Cache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Caching.Cache Cache" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Cache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.Caching.Cache</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得、<see cref="T:System.Web.Caching.Cache" />ページが含まれているアプリケーションに関連付けられているオブジェクト。</summary>
        <value><see cref="T:System.Web.Caching.Cache" />ページのアプリケーションに関連付けられています。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アプリケーションの<xref:System.Web.Caching.Cache>オブジェクトでは、格納および後続の要求に任意のデータを取得することができます。 キャッシュ専用に関連付けられていないページやユーザーのセッションです。 アプリケーションのパフォーマンスを強化するには、主に使用されます。 詳細については、次を参照してください。[アプリケーション データをキャッシュ](http://msdn.microsoft.com/library/206f977d-7860-4d20-bdd5-c3b3d8479f3d)です。 アプリケーションのキャッシュとページ出力キャッシュの違いの詳細については、次を参照してください。 [ASP.NET のキャッシュの概要](http://msdn.microsoft.com/library/5ec28012-4972-4dc3-b3e8-9d20401fe11d)です。  
  
   
  
## Examples  
 次のコード例に 2 つの整数の合計の挿入、<xref:System.Web.Caching.Cache?displayProperty=nameWithType>オブジェクトを使用して、<xref:System.Web.UI.Page.Cache%2A?displayProperty=nameWithType>プロパティです。 さらを使用して値を取得、<xref:System.Web.Caching.Cache.Get%2A?displayProperty=nameWithType>メソッドに書き込むと、 <xref:System.Web.UI.WebControls.Label> Web サーバー コントロールです。  
  
 [!code-csharp[System.Web.Page.Cache_Replacement#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Page.Cache_Replacement/CS/pagecachecs.aspx#1)]
 [!code-vb[System.Web.Page.Cache_Replacement#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Page.Cache_Replacement/VB/pagecachevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">インスタンス<see cref="T:System.Web.Caching.Cache" />は作成されません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ClientQueryString">
      <MemberSignature Language="C#" Value="public string ClientQueryString { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ClientQueryString" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ClientQueryString" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要求された URL のクエリ文字列の部分を取得します。</summary>
        <value>要求された URL のクエリ文字列部分。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.ClientQueryString%2A>プロパティには、ブラウザーが要求された URL のクエリ文字列の部分が含まれています。 たとえば、要求された URL は"http://www.contoso.com/default.aspx?id=100"、<xref:System.Web.UI.Page.ClientQueryString%2A>プロパティが格納されます"id = 100" です。 <xref:System.Web.UI.Page.ClientQueryString%2A>でエンコードされたプロパティを使用して、<xref:System.Web.HttpServerUtility.UrlDecode%2A?displayProperty=nameWithType>クエリ文字列をデコードするメソッド。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientScript">
      <MemberSignature Language="C#" Value="public System.Web.UI.ClientScriptManager ClientScript { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ClientScriptManager ClientScript" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ClientScript" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ClientScriptManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得、<see cref="T:System.Web.UI.ClientScriptManager" />オブジェクトを管理、登録、およびページにスクリプトを追加するために使用します。</summary>
        <value><see cref="T:System.Web.UI.ClientScriptManager" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Web.UI.Page.ClientScript%2A>を取得するプロパティ、<xref:System.Web.UI.ClientScriptManager>管理、登録、およびスクリプトを Web ページに追加するために使用できるオブジェクト。 詳細については、<xref:System.Web.UI.ClientScriptManager> クラスを参照してください。  
  
 <xref:System.Web.UI.ClientScriptManager>クラスはで新しく[!INCLUDE[vstecasplong](~/includes/vstecasplong-md.md)]置き換えます<xref:System.Web.UI.Page>クラスは使用されなくなりましたスクリプトを管理するためのメソッドです。  
  
   
  
## Examples  
 例については、次を参照してください。、<xref:System.Web.UI.ClientScriptManager>クラスの概要に関するトピック。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientTarget">
      <MemberSignature Language="C#" Value="public string ClientTarget { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ClientTarget" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ClientTarget" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはによりブラウザーの機能の自動検出をオーバーライドして、特定のブラウザー クライアント用のページのレンダリング方法を指定する値を設定します。</summary>
        <value>A<see cref="T:System.String" />をオーバーライドするブラウザーの機能を指定します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定しない場合、 <xref:System.Web.UI.Page.ClientTarget%2A> 、プロパティ、<xref:System.Web.HttpBrowserCapabilities>オブジェクトに関連付けられている、<xref:System.Web.UI.Page.Request%2A?displayProperty=nameWithType>プロパティには、クライアント ブラウザーの機能が反映されます。 このプロパティを設定すると、クライアント ブラウザーの検出が無効になり、ページは、指定した値 (エイリアス) に関連付けられているブラウザーの機能を使用します。  
  
 Web サーバー コンピューター上のルート Web.config 構成ファイルには、一般的なユーザー エージェント文字列の代わりに使用できる次の既定のエイリアスを定義します。  
  
-   `uplevel`、Internet Explorer 6.0 と同じブラウザーの機能を指定します。  
  
-   `downlevel`、クライアント スクリプトをサポートしていない古いブラウザーと同じブラウザーの機能を指定します。 このエイリアスを使用して、Web ページがクライアント スクリプトが無効になっているブラウザーでどのように動作する方法を決定することができます。  
  
 このプロパティを使用してプログラムからエイリアスを設定することも設定を使用して宣言できるは、`ClientTarget`ディレクティブの属性です。  
  
 追加のエイリアスを定義することができます、`clientTarget`アプリケーション レベルの Web.config ファイルのセクションです。 詳細については、次を参照してください。 [clientTarget 要素 (ASP.NET 設定スキーマ)](http://msdn.microsoft.com/en-us/17a0fa6e-a065-49cc-b900-ef73eda6a922)です。  
  
   
  
## Examples  
 次のコード例を定義、`ie302`エイリアス、Web.config ファイルでアプリケーションを構成するために必要なセクションがあります。 このエイリアスを使用して設定できます、<xref:System.Web.UI.Page.ClientTarget%2A>プロパティを`ie302`および Internet Explorer 3.02 ブラウザーの専用のページをカスタマイズします。  
  
```  
<configuration>  
  <system.web>  
   <clientTarget>  
    <add alias="ie302" useragent="Mozilla/2.0 (compatible; MSIE 3.02; Windows NT 3.5)" />  
   </clientTarget>  
  </system.web>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodePage">
      <MemberSignature Language="C#" Value="public int CodePage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CodePage" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.CodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のコード ページ識別子を設定<see cref="T:System.Web.UI.Page" />です。</summary>
        <value>現在のコード ページ識別子を表す整数<see cref="T:System.Web.UI.Page" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ほとんどの状況では、コードでこのプロパティを設定しないでください。 設定、`CodePage`属性を .aspx ファイルで、ディレクティブを使用する値にします。 ページが要求されると、動的に生成されたクラスは、プロパティを設定します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>HTTP MIME タイプを設定、<see cref="T:System.Web.HttpResponse" />ページに関連付けられているオブジェクト。</summary>
        <value>現在のページに関連付けられている HTTP MIME タイプ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ほとんどの状況では、コードでこのプロパティを設定しないでください。 設定、`ContentType`属性の .aspx ファイルで、ディレクティブを使用します。 ページが要求されると、動的に生成されたクラスは、プロパティを設定します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Context">
      <MemberSignature Language="C#" Value="protected override System.Web.HttpContext Context { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpContext Context" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Context" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得、<see cref="T:System.Web.HttpContext" />ページに関連付けられているオブジェクト。</summary>
        <value><see cref="T:System.Web.HttpContext" />現在のページに関連付けられている情報を含むオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、要求、応答、セッション、およびアプリケーションに関する情報など、ページの実行コンテキストにプログラムでアクセスを提供します。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Web.UI.Page.Context%2A>プロパティへのアクセスを<xref:System.Web.HttpContext.AddError%2A?displayProperty=nameWithType>と<xref:System.Web.HttpContext.ClearError%2A?displayProperty=nameWithType>メソッドおよび<xref:System.Web.HttpContext.AllErrors%2A?displayProperty=nameWithType>プロパティです。 使用して 3 つのカスタム例外を作成、<xref:System.Web.HttpContext.AddError%2A>メソッドを使用して、<xref:System.Web.HttpContext.AllErrors%2A>プロパティ配列へのこれらの例外を読み込めません。 次に、配列を含むページに書き込み、使用して、<xref:System.Web.HttpContext.ClearError%2A>からすべてのエラーをクリアする方法、<xref:System.Web.UI.Page.Context%2A>プロパティです。  
  
 [!code-csharp[System.Web.UI.Page.Context#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Context/CS/pagecontextcs.aspx#1)]
 [!code-vb[System.Web.UI.Page.Context#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Context/VB/pagecontextvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateHtmlTextWriter">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.HtmlTextWriter CreateHtmlTextWriter (System.IO.TextWriter tw);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Web.UI.HtmlTextWriter CreateHtmlTextWriter(class System.IO.TextWriter tw) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.CreateHtmlTextWriter(System.IO.TextWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.HtmlTextWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tw" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="tw"><see cref="T:System.IO.TextWriter" /> を作成するために使用する <see cref="T:System.Web.UI.HtmlTextWriter" />。</param>
        <summary>作成、<see cref="T:System.Web.UI.HtmlTextWriter" />ページのコンテンツを表示するオブジェクト。</summary>
        <returns><see cref="T:System.Web.UI.HtmlTextWriter" />または<see cref="T:System.Web.UI.Html32TextWriter" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.CreateHtmlTextWriter%2A>メソッドを作成、<xref:System.IO.TextWriter>を通じて、<xref:System.Web.HttpRequest.Browser%2A>のプロパティ、<xref:System.Web.HttpContext.Request%2A>ページ要求に関連付けられているオブジェクト。 参照を追加することができます、<xref:System.Web.UI.HtmlTextWriter>で、`browserCaps`構成セクション。 上書き、<xref:System.Web.UI.Page.CreateHtmlTextWriter%2A>カスタム検索を実行するメソッド。  
  
   
  
## Examples  
 次のコード例では、 <xref:System.Web.UI.Page.CreateHtmlTextWriter%2A> 、カスタムのインスタンスを作成するメソッド<xref:System.Web.UI.HtmlTextWriter>という名前のオブジェクト`MyHtmlTextWriter`です。 <xref:System.Web.UI.Page.CreateHtmlTextWriter%2A>でメソッドがオーバーライドされる、`MyPage`から派生したクラス<xref:System.Web.UI.Page>できるように、`MyHtmlTextWriter`ページが要求されたときに、ASP.NET サーバー コントロールをレンダリングします。 この例はアダプターしないようにすることに注意してください<xref:System.IO.TextWriter>動作します。  
  
 [!code-csharp[Page_CreateHtmlTextWriter#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_CreateHtmlTextWriter/CS/page_createhtmltextwriter.cs#2)]
 [!code-vb[Page_CreateHtmlTextWriter#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_CreateHtmlTextWriter/VB/page_createhtmltextwriter.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateHtmlTextWriterFromType">
      <MemberSignature Language="C#" Value="public static System.Web.UI.HtmlTextWriter CreateHtmlTextWriterFromType (System.IO.TextWriter tw, Type writerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.UI.HtmlTextWriter CreateHtmlTextWriterFromType(class System.IO.TextWriter tw, class System.Type writerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.CreateHtmlTextWriterFromType(System.IO.TextWriter,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.HtmlTextWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tw" Type="System.IO.TextWriter" />
        <Parameter Name="writerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="tw"><see cref="T:System.IO.TextWriter" /> を作成するために使用する <see cref="T:System.Web.UI.HtmlTextWriter" />。</param>
        <param name="writerType">作成するテキスト ライターの型。</param>
        <summary>指定した作成<see cref="T:System.Web.UI.HtmlTextWriter" />ページのコンテンツを表示するオブジェクト。</summary>
        <returns><see cref="T:System.Web.UI.HtmlTextWriter" />ページの内容を表示します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、ページ アダプターで内部的に使用されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><paramref name="writerType" />パラメーターが無効な型に設定します。</exception>
      </Docs>
    </Member>
    <Member MemberName="Culture">
      <MemberSignature Language="C#" Value="public string Culture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Culture" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Culture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>カルチャ ID を設定、<see cref="T:System.Threading.Thread" />ページに関連付けられているオブジェクト。</summary>
        <value>有効なカルチャ id。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定、 `Culture` .aspx ファイルでは、ディレクティブの属性です。 ページが要求されたときに、動的に生成されたクラスは、このプロパティの値を設定します。 値を明示的に設定するさらに、<xref:System.Web.UI.Page.Culture%2A>ファイル プログラムから、または Web.config の要素のプロパティです。  
  
 <xref:System.Web.UI.Page.Culture%2A>ヘルプ ページのコンテンツをローカライズするプロパティを使用します。 任意の有効なカルチャ ID を設定することができます。 たとえば、`en-us`カルチャ ID では、アメリカ英語、while にページを設定、`fr`カルチャ ID では、フランス語にページを設定します。 値を設定することもできます。`auto`の優先言語と設定するには、ブラウザーの自動検出を実行します。 言語の自動検出をなど、既定値で修飾できます`auto:en-us`です。  
  
 詳細については、次を参照してください。、<xref:System.Globalization.CultureInfo>クラスの概要です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DesignerInitialize">
      <MemberSignature Language="C#" Value="public void DesignerInitialize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DesignerInitialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.DesignerInitialize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>インスタンスの初期化を実行、 <see cref="T:System.Web.UI.Page" /> RAD デザイナーで必要とされるクラスです。 このメソッドは、デザイン時にのみ使用されます。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeterminePostBackMode">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Specialized.NameValueCollection DeterminePostBackMode ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Collections.Specialized.NameValueCollection DeterminePostBackMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.DeterminePostBackMode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返します、<see cref="T:System.Collections.Specialized.NameValueCollection" />にポスト バックされた POST または GET コマンドのいずれかを使用して、ページ データ。</summary>
        <returns>A<see cref="T:System.Collections.Specialized.NameValueCollection" />フォーム データを含むオブジェクト。 フォームの情報が返されます、ポストバックが POST コマンドを使用する場合、<see cref="P:System.Web.UI.Page.Context" />オブジェクト。 ポストバックのでは、GET コマンドを使用する場合、クエリ文字列の情報が返されます。 ページは、最初に要求されている場合<see langword="null" />が返されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.DeterminePostBackMode%2A>メソッドを返します、<xref:System.Collections.Specialized.NameValueCollection>データを格納しているオブジェクトにポスト バックされたページ。 ページが存在するには、ポストバック イベントが発生したかどうかを決定するために使用される VIEWSTATE と EVENTTARGET フィールドが表示されません。 <xref:System.Web.UI.Page.IsPostBack%2A>場合、プロパティが設定、<xref:System.Web.UI.Page.DeterminePostBackMode%2A>メソッドが呼び出されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeterminePostBackModeUnvalidated">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Specialized.NameValueCollection DeterminePostBackModeUnvalidated ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Collections.Specialized.NameValueCollection DeterminePostBackModeUnvalidated() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.DeterminePostBackModeUnvalidated" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>要求で ASP.NET 要求の検証を実行しなくても、POST または GET コマンドのいずれかを使用して、ページにポストされたデータの名前と値のコレクションを返します。</summary>
        <returns>未検証のフォームのデータを格納するオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 詳細については、<xref:System.Web.UnvalidatedRequestValues> クラスを参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableEventValidation">
      <MemberSignature Language="C#" Value="public virtual bool EnableEventValidation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableEventValidation" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.EnableEventValidation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはページがポストバックとコールバックのイベントを検証するかどうかを示す値を設定します。</summary>
        <value>
          <see langword="true" />ページ ポストバック イベントとコールバック イベント; を検証する場合それ以外の場合、<see langword="false" />です。既定値は<see langword="true" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ときに、<xref:System.Web.UI.Page.EnableEventValidation%2A>プロパティに設定されている`true`ASP.NET では、コントロールのイベントがそのコントロールによって表示されたユーザー インターフェイスから送られたことを検証します。 レンダリング時にイベントを登録し、イベントをポストバックまたはコールバックの処理中に検証コントロールです。 たとえば、リスト コントロールには、オプション ポストバックの要求が受信した場合は、オプション番号 4 を指定する場合と、ページが表示されると、1、2、または 3 の番号にはが含まれている場合、ASP.NET には、例外が発生します。 ASP.NET のすべてのイベント ドリブン コントロールは、既定ではこの機能を使用します。  
  
 実行時に、クライアントのコントロールを変更するクライアント スクリプトを記述する場合は、使用する必要があります、 <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> false イベント妥当性確認エラーを回避するためにメソッドです。  
  
> [!IMPORTANT]
>  この機能は、不正なまたは悪意のあるポストバック要求とコールバックのリスクを軽減します。 イベントの検証を無効にしないことを強くお勧めします。  
  
 設定する、<xref:System.Web.UI.Page.EnableEventValidation%2A>プロパティを設定して、`enableEventValidation`ディレクティブの属性または`enableEventValidation`Web.config ファイル内の要素の属性です。 コードでこのプロパティを設定した場合、ページが初期化される前に設定する必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Web.UI.Page.EnableEventValidation" />ページの初期化後にプロパティが設定されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="EnableViewState">
      <MemberSignature Language="C#" Value="public override bool EnableViewState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.EnableViewState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定、ページがそのビュー ステートを保持し、任意のサーバーのビュー ステートがそれを制御するかどうかを示す値が含まれている現在のページ要求の終了時にします。</summary>
        <value>
          <see langword="true" />ページがビュー状態を保持する場合それ以外の場合、<see langword="false" />です。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ビュー ステートを無効にする理由については、次を参照してください。<xref:System.Web.UI.Control.EnableViewState%2A?displayProperty=nameWithType>です。  
  
 場合でも<xref:System.Web.UI.Page.EnableViewState%2A>は`false`ページがポストバックを検出するために、ASP.NET によって使用される非表示のビュー状態フィールドを含めることがあります。  
  
   
  
## Examples  
 次のコード例のセット、<xref:System.Web.UI.Page.EnableViewState%2A>プロパティを`false`ページが読み込まれるときにします。 ビュー ステートが無効になります、<xref:System.Web.UI.Page>オブジェクト、どちらも、ページのビュー ステート情報もページに含まれるすべてのコントロールを保存することを意味します。  
  
> [!IMPORTANT]
>  この例には、ユーザー入力を受け付けるテキスト ボックスがあります。これにより、セキュリティが脆弱になる可能性があります。 既定では、ASP.NET Web ページによって、ユーザー入力にスクリプトまたは HTML 要素が含まれていないかどうかが検証されます。 詳細については、次を参照してください。[スクリプト悪用概要](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)です。  
  
 [!code-csharp[Page_EnableViewState_ReSubmit_1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_EnableViewState_ReSubmit_1/CS/page_enableviewstate.cs#1)]
 [!code-vb[Page_EnableViewState_ReSubmit_1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_EnableViewState_ReSubmit_1/VB/page_enableviewstate.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableViewStateMac">
      <MemberSignature Language="C#" Value="public bool EnableViewStateMac { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableViewStateMac" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.EnableViewStateMac" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはクライアントからページがポストされるときに、ページのビュー ステートのメッセージ認証コード (MAC) をチェックするかどうかを示す値を設定します。</summary>
        <value>
          <see langword="true" />ビュー ステートの MAC がチェックされ、エンコードされている必要がある場合それ以外の場合、<see langword="false" />です。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ビュー ステート MAC は、ページがブラウザーに送信されるときに、ページのビュー状態が保存されている非表示の変数の暗号化されたバージョンです。 このプロパティに設定するときに`true`、暗号化されたビュー ステートがオンになっていることが改ざんされていないクライアントのことを確認します。  
  
 コードでこのプロパティを設定できません。 設定、`EnableViewStateMac`属性の .aspx ファイルで、ディレクティブを使用します。 ページが要求されると、動的に生成されたクラスは、プロパティを設定します。  
  
> [!IMPORTANT]
>  この属性設定しないで`false`実稼働 Web サイトで、アプリケーションまたはページがビュー ステートを使用していない場合でもです。 により、MAC のビューステートは、ビュー ステートに加えその他の ASP.NET 機能のセキュリティを確保します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ErrorPage">
      <MemberSignature Language="C#" Value="public string ErrorPage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ErrorPage" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ErrorPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはページのハンドルされない例外が発生した場合、要求元のブラウザーをリダイレクトする、エラー ページを設定します。</summary>
        <value>エラー ページがブラウザーをリダイレクトします。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[Page_ErrorPage#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_ErrorPage/CS/page_errorpage.cs.aspx#1)]
 [!code-vb[Page_ErrorPage#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_ErrorPage/VB/page_errorpage.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteRegisteredAsyncTasks">
      <MemberSignature Language="C#" Value="public void ExecuteRegisteredAsyncTasks ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExecuteRegisteredAsyncTasks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.ExecuteRegisteredAsyncTasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>非同期タスクの実行を開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、非同期タスクを定義する、<xref:System.Web.UI.PageAsyncTask>クラスです。 タスクが定義され、ページを使用して、登録した後、 <xref:System.Web.UI.Page.RegisterAsyncTask%2A> 、メソッド、<xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A>非同期タスクを開始するメソッドを呼び出すことができます。  
  
 <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A>メソッドが自動的に呼び出される非同期以外のページ、ページときの処理に存在する場合、非同期タスクは、登録されているいずれかの時点は呼び出されます。 この自動呼び出し<xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A>直前に発生する、<xref:System.Web.UI.Page.PreRenderComplete>イベント。 呼び出す、<xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A>タスクをこのメソッドが自動的に呼び出されないときに起動するためのメソッドです。 ただし、非同期タスクがのみ 1 回も実行される<xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A>も複数回呼び出すことができます。  
  
 <xref:System.Web.UI.Page.AsyncTimeout%2A>プロパティはリセットを呼び出すたびに、<xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A>メソッドです。 最後の値、<xref:System.Web.UI.Page.AsyncTimeout%2A>を呼び出す前に、<xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A>メソッドが優先されます。 非同期タスクが受け取る場合よりも多く<xref:System.Web.UI.Page.AsyncTimeout%2A>、後続のタスクを中に呼び出される<xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A>呼び出しがすぐにタイムアウトします。  
  
   
  
## Examples  
 使用を次のコード例に示します、<xref:System.Web.UI.Page.AsyncTimeout%2A>を持つプロパティ、<xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A>と<xref:System.Web.UI.Page.RegisterAsyncTask%2A>メソッドです。 先頭、末尾、およびタイムアウト ハンドラーの使用に注意してください。 指定されているタスクの割り当て時刻を超えた場合、非同期タスクのような状況を示す例では、人為的な遅延が導入された、<xref:System.Web.UI.Page.AsyncTimeout%2A>プロパティです。 現実のシナリオで非同期タスクは、データベースの呼び出しまたはイメージの生成を実行するために使用可能性がありますなどとタイムアウト ハンドラーは、一定の時間で、タスクは実行されない場合に下げるを提供します。  
  
 [!code-aspx-csharp[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.aspx#1)]  
  
 [!code-csharp[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.cs#2)]
 [!code-vb[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">非同期タスクの例外があります。</exception>
      </Docs>
    </Member>
    <Member MemberName="FileDependencies">
      <MemberSignature Language="C#" Value="protected System.Collections.ArrayList FileDependencies { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ArrayList FileDependencies" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.FileDependencies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is HttpResponse.AddFileDependencies. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ArrayList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ファイルの配列を設定、現在<see cref="T:System.Web.HttpResponse" />オブジェクトが依存します。</summary>
        <value>配列をファイルは現在<see cref="T:System.Web.HttpResponse" />オブジェクトが依存します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは推奨されていません。 使用して、<xref:System.Web.HttpResponse.AddFileDependencies%2A>メソッドまたは<xref:System.Web.HttpResponse.AddFileDependency%2A>のメソッド、<xref:System.Web.HttpResponse>クラスの代わりにします。  
  
 ほとんどの状況では、コードでこのプロパティを設定しないでください。 設定、`FileDependencies`属性を`true`.aspx ファイルで、ディレクティブを使用します。 ページが要求されると、動的に生成されたクラスは、プロパティを設定します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindControl">
      <MemberSignature Language="C#" Value="public override System.Web.UI.Control FindControl (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Web.UI.Control FindControl(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.FindControl(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">検索するコントロールの識別子。</param>
        <summary>指定した識別子を持つサーバー コントロールのページの名前付けコンテナーを検索します。</summary>
        <returns>指定したコントロールまたは<see langword="null" />指定されたコントロールが存在しない場合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.FindControl%2A>メソッドは、コントロールにアクセスするために使用できますが<xref:System.Web.UI.Control.ID%2A>デザイン時に使用できません。 メソッドのみ、ページの即時更新サブスクリプションまたは最上位レベル、コンテナーを検索です。これは、ページに含まれている名前付けコンテナーでのコントロールの再帰的に検索をしません。 下位の名前付けコンテナー内のコントロールにアクセスするには、呼び出し、`FindControl`そのコンテナーのメソッドです。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています、<xref:System.Web.UI.Page.FindControl%2A>テンプレート内部のコントロールを検索します。 この例では 2 つ<xref:System.Web.UI.WebControls.Repeater>コントロールが定義されます。 キャッチするさまざまな方法を示していますそれぞれ、<xref:System.Web.UI.WebControls.LinkButton.Click>のイベント、<xref:System.Web.UI.WebControls.LinkButton>リピータ項目テンプレートの内部です。  
  
 [!code-aspx-csharp[System.Web.UI.Page_FindControl#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_FindControl/cs/pagefindcontrolcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page_FindControl#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_FindControl/vb/pagefindcontrolvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Form">
      <MemberSignature Language="C#" Value="public System.Web.UI.HtmlControls.HtmlForm Form { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.HtmlControls.HtmlForm Form" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Form" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.HtmlControls.HtmlForm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページの HTML フォームを取得します。</summary>
        <value><see cref="T:System.Web.UI.HtmlControls.HtmlForm" />ページに関連付けられているオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Web.UI.Page.Form%2A>プロパティ、メソッドとプロパティのアクセスを<xref:System.Web.UI.HtmlControls.HtmlForm>ページ コントロール階層の基本であるオブジェクト。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FrameworkInitialize">
      <MemberSignature Language="C#" Value="protected override void FrameworkInitialize ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void FrameworkInitialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.FrameworkInitialize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ページの宣言型の特性に基づき、ページの生成中に、コントロールのツリーを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.FrameworkInitialize%2A>メソッドの初期化、<xref:System.Web.UI.Page>オブジェクトし、ページの宣言型の特性に基づきコントロール ツリーを作成します。 <xref:System.Web.UI.Page.FrameworkInitialize%2A>メソッドは、ページの解析中のコード生成や、<xref:System.Web.UI.Page>宣言型のページのクラスです。 通常、このメソッドをオーバーライドする必要が上にありません必要があります。 をオーバーライドする場合、基本クラスの呼び出しを必ず<xref:System.Web.UI.Page.FrameworkInitialize%2A>メソッドです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDataItem">
      <MemberSignature Language="C#" Value="public object GetDataItem ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetDataItem() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetDataItem" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>データ バインディング コンテキスト スタックの上部にあるデータ項目を取得します。</summary>
        <returns>データ バインドのコンテキスト スタックの上部にあるオブジェクトです。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">ページのデータ バインド コンテキストはありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackClientEvent">
      <MemberSignature Language="C#" Value="public string GetPostBackClientEvent (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientEvent(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetPostBackClientEvent(System.Web.UI.Control,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.GetPostBackEventReference. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">クライアント イベントのポストバックを受信するサーバー コントロール。</param>
        <param name="argument">A<see cref="T:System.String" />に渡される<see cref="M:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent(System.String)" />です。</param>
        <summary>指定されたイベント引数を使用して指定したコントロールのサーバーにポストバックするクライアント イベントで使用できる参照を取得します。</summary>
        <returns>クライアント イベントを表す文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 参照してください、<xref:System.Web.UI.ClientScriptManager>代替方法についてはこのメンバーのクラスです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackClientHyperlink">
      <MemberSignature Language="C#" Value="public string GetPostBackClientHyperlink (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientHyperlink(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.GetPostBackClientHyperlink. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">ポストバックを処理するサーバー コントロール。</param>
        <param name="argument">サーバー コントロールに、パラメーターが渡されます。</param>
        <summary>参照を取得<see langword="javascript:" />クライアント イベントで指定されたイベント引数を使用して、指定したコントロールのサーバーへのポストバックを使用できるの先頭に追加されます。</summary>
        <returns>対象のコントロールの ID とイベントの引数を含むポストバック関数に JavaScript の呼び出しを表す文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 参照してください、<xref:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink%2A>のこのメンバーを使用します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetPostBackEventReference(System.Web.UI.Control)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.GetPostBackEventReference. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">サーバーにポストバックを処理するサーバー コントロール。</param>
        <summary>サーバーへのポストバックが発生するクライアント イベントで使用できる文字列を返します。 参照文字列が定義されている指定した<see cref="T:System.Web.UI.Control" />オブジェクト。</summary>
        <returns>文字列をクライアントでは、スクリプトとして扱われたとき、ポストバックが開始します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドの使用は推奨されていません。 使用して、<xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>メソッドで、<xref:System.Web.UI.ClientScriptManager>クラスの代わりにします。  
  
   
  
## Examples  
 [!code-csharp[Page_GetPostBackEventReference#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_GetPostBackEventReference/CS/page_getpostbackeventreference.cs#2)]
 [!code-vb[Page_GetPostBackEventReference#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_GetPostBackEventReference/VB/page_getpostbackeventreference.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetPostBackEventReference(System.Web.UI.Control,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.GetPostBackEventReference. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">ポストバックを処理するサーバー コントロール。</param>
        <param name="argument">サーバー コントロールに、パラメーターが渡されます。</param>
        <summary>サーバーへのポストバックが発生するクライアント イベントで使用できる文字列を返します。 参照文字列は、ポストバックおよびその他のイベント情報の文字列引数を処理する指定されたコントロールによって定義されます。</summary>
        <returns>文字列をクライアントでは、スクリプトとして扱われたとき、ポストバックが開始します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドの使用は推奨されていません。 使用して、<xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>メソッドで、<xref:System.Web.UI.ClientScriptManager>クラスの代わりにします。  
  
   
  
## Examples  
 [!code-csharp[Page_GetPostBackEventReference#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_GetPostBackEventReference/CS/page_getpostbackeventreference.cs#1)]
 [!code-vb[Page_GetPostBackEventReference#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_GetPostBackEventReference/VB/page_getpostbackeventreference.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetTypeHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetTypeHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetTypeHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>によって生成されるハッシュ コードを取得<see cref="T:System.Web.UI.Page" />で生成されたオブジェクトの実行時間。 一意のハッシュ コードです、<see cref="T:System.Web.UI.Page" />オブジェクトのコントロールの階層です。</summary>
        <returns>実行時に生成されたハッシュ コード。 既定値は 0 です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドをオーバーライドしないでください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValidators">
      <MemberSignature Language="C#" Value="public System.Web.UI.ValidatorCollection GetValidators (string validationGroup);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.ValidatorCollection GetValidators(string validationGroup) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetValidators(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ValidatorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="validationGroup" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="validationGroup">戻るには、検証グループまたは<see langword="null" />を既定の検証グループを返します。</param>
        <summary>指定された検証グループの検証コントロールのコレクションを返します。</summary>
        <returns>A<see cref="T:System.Web.UI.ValidatorCollection" />指定された検証グループの検証コントロールを格納しています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.GetValidators%2A>メソッドは、特定の検証グループに関連付けられているすべての検証オブジェクトを取得します。 既定の検証グループを返すことができます (せずコントロールに関連付けられているすべての検証コントロール、`ValidationGroup`プロパティ セット) を設定して、`validationGroup`パラメーターを`null`です。  
  
 検証グループのメンバーを検証するには、コレクションと呼び出しを列挙することができます、<xref:System.Web.UI.IValidator.Validate%2A>各検証メソッドが返されます。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Web.UI.Page.GetValidators%2A>を既定の検証グループを返すメソッド。  
  
 [!code-csharp[PageGetValidators#1](~/samples/snippets/csharp/VS_Snippets_WebNet/PageGetValidators/CS/pagegetvalidatorscs.aspx#1)]
 [!code-vb[PageGetValidators#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageGetValidators/VB/pagegetvalidatorsvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWrappedFileDependencies">
      <MemberSignature Language="C#" Value="protected object GetWrappedFileDependencies (string[] virtualFileDependencies);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object GetWrappedFileDependencies(string[] virtualFileDependencies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetWrappedFileDependencies(System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualFileDependencies" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="virtualFileDependencies">仮想ファイルの場所の文字列配列。</param>
        <summary>仮想ファイルの場所の一覧に対応する物理ファイル名の一覧を返します。</summary>
        <returns>物理ファイルの場所の一覧を含むオブジェクトです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.GetWrappedFileDependencies%2A>メソッドは、現在のページを構成するユーザー コントロール ファイルなどのファイルの一覧を取得します。 これらのページのいずれかが変更された場合、ページ全体には、要求時に、[次へ] がコンパイルされます。 このメソッドをオーバーライドしないでください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Header">
      <MemberSignature Language="C#" Value="public System.Web.UI.HtmlControls.HtmlHead Header { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.HtmlControls.HtmlHead Header" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Header" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.HtmlControls.HtmlHead</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>場合、ページの文書のヘッダーを取得、<see langword="head" />で要素が定義されている、<see langword="runat=server" />ページの宣言でします。</summary>
        <value><see cref="T:System.Web.UI.HtmlControls.HtmlHead" />ページ ヘッダーを含むです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.Header%2A>プロパティへの参照を取得する、<xref:System.Web.UI.HtmlControls.HtmlHead>オブジェクト、ページのドキュメントのヘッダー情報の設定を使用することです。 <xref:System.Web.UI.HtmlControls.HtmlHead>スタイル シート、スタイル ルール、タイトル、およびメタデータをなどの情報を追加することができます、`head`要素。  
  
> [!NOTE]
>  メソッドを使用してプログラムからスタイルを追加する、<xref:System.Web.UI.IStyleSheet>非同期ポストバック中のインターフェイスはサポートされていません。 Web ページに AJAX 機能を追加すると、非同期ポストバックはページ全体を更新することがなく、ページの領域を更新します。 詳細については、次を参照してください。 [Microsoft Ajax 概要](http://msdn.microsoft.com/library/be84d9b3-b7cd-47d7-8494-be4abfaad9cb)です。  
  
   
  
## Examples  
 次のコード例は、アクセスする方法を示します、<xref:System.Web.UI.HtmlControls.HtmlHead>を使用したプログラムの制御、<xref:System.Web.UI.Page.Header%2A>プロパティです。 A`title`要素および`style`に要素を追加、`head`ページの要素。  
  
 [!code-aspx-csharp[System.Web.UI.HtmlControls.HtmlHeadClass#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.HtmlControls.HtmlHeadClass/CS/htmlheadclasscs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.HtmlControls.HtmlHeadClass#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.HtmlControls.HtmlHeadClass/VB/htmlheadclassvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ID">
      <MemberSignature Language="C#" Value="public override string ID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定の特定のインスタンスの識別子、<see cref="T:System.Web.UI.Page" />クラスです。</summary>
        <value>インスタンスの識別子、<see cref="T:System.Web.UI.Page" />クラスです。 既定値は、'_Page' です。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IdSeparator">
      <MemberSignature Language="C#" Value="public virtual char IdSeparator { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char IdSeparator" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IdSeparator" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページ上のコントロールの一意の ID を構築するときに、コントロールの識別子を区切るために使用する文字を取得します。</summary>
        <value>コントロールの識別子を区切るために使用する文字。 既定値を設定、<see cref="T:System.Web.UI.Adapters.PageAdapter" />ページを表示するインスタンス。 <see cref="P:System.Web.UI.Page.IdSeparator" />はサーバー側フィールドでありは変更できません。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InitComplete">
      <MemberSignature Language="C#" Value="public event EventHandler InitComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler InitComplete" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.InitComplete" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページの初期化が完了したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.InitComplete>イベントは、ページの初期化段階の最後に呼び出されます。 ページのライフ サイクルのこの段階で宣言されたすべて、ページ上のコントロールが初期化されるが、ページの状態はまだ設定します。 サーバー コントロールにアクセスできますが、それらがまだ含まれていませんユーザーから返される情報には。  
  
 イベント処理の詳細については、次を参照してください。 [NIB: イベントの利用](http://msdn.microsoft.com/en-us/01e4f1bc-e55e-413f-98c7-6588493e5f67)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeCulture">
      <MemberSignature Language="C#" Value="protected virtual void InitializeCulture ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitializeCulture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.InitializeCulture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>セット、<see cref="P:System.Web.UI.Page.Culture" />と<see cref="P:System.Web.UI.Page.UICulture" />ページの現在のスレッドにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.InitializeCulture%2A>メソッドにはコード ロジックは含まれません。 機能を拡張する開発者の制御、<xref:System.Web.UI.Page>クラスをオーバーライドして、<xref:System.Web.UI.Page.InitializeCulture%2A>初期化するメソッドを<xref:System.Web.UI.Page.Culture%2A>と<xref:System.Web.UI.Page.UICulture%2A>ページの情報です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="InitOutputCache">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在のページ要求の出力キャッシュを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドはコードから直接使用するためのものではありません。 を有効にして、ページの出力キャッシュを操作するには、これらのアプローチのいずれかを使用します。  
  
-   .Aspx ファイルで宣言によって、ディレクティブを使用してオプションを設定します。  
  
-   メソッドとプロパティの使用、<xref:System.Web.HttpCachePolicy>によって公開される、クラス、`Response.Cache`ページのコード内のオブジェクト。  
  
 詳細については、次を参照してください。 [ASP.NET ページのキャッシュ](http://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="InitOutputCache">
      <MemberSignature Language="C#" Value="protected virtual void InitOutputCache (System.Web.UI.OutputCacheParameters cacheSettings);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void InitOutputCache(class System.Web.UI.OutputCacheParameters cacheSettings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.InitOutputCache(System.Web.UI.OutputCacheParameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheSettings" Type="System.Web.UI.OutputCacheParameters" />
      </Parameters>
      <Docs>
        <param name="cacheSettings"><see cref="T:System.Web.UI.OutputCacheParameters" />キャッシュの設定を格納しています。</param>
        <summary>現在のページ要求の出力キャッシュのに基づいて初期化、<see cref="T:System.Web.UI.OutputCacheParameters" />オブジェクト。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを呼び出す必要はありません。 を有効にして、ページの出力キャッシュを操作するには、.aspx ファイルまたはメソッドとプロパティのいずれか、ディレクティブを使用、<xref:System.Web.HttpCachePolicy>クラスです。 後者はを通してアクセス`Response.Cache`ページのコード宣言ブロックまたは分離コード ファイル内の構文。 詳細については、次を参照してください。 [ASP.NET ページのキャッシュ](http://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">キャッシュ プロファイルが見つかりませんでした。  
  
 \- または  
  
 不足しているディレクティブまたは構成の設定は、プロファイルの属性です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">出力キャッシュ設定の場所が正しくありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="InitOutputCache">
      <MemberSignature Language="C#" Value="protected virtual void InitOutputCache (int duration, string varyByHeader, string varyByCustom, System.Web.UI.OutputCacheLocation location, string varyByParam);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitOutputCache(int32 duration, string varyByHeader, string varyByCustom, valuetype System.Web.UI.OutputCacheLocation location, string varyByParam) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.InitOutputCache(System.Int32,System.String,System.String,System.Web.UI.OutputCacheLocation,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Int32" />
        <Parameter Name="varyByHeader" Type="System.String" />
        <Parameter Name="varyByCustom" Type="System.String" />
        <Parameter Name="location" Type="System.Web.UI.OutputCacheLocation" />
        <Parameter Name="varyByParam" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="duration">出力キャッシュに格納されているオブジェクトが有効の量。</param>
        <param name="varyByHeader">出力キャッシュからコンテンツ ヘッダーのセミコロン区切りリストによって異なります。</param>
        <param name="varyByCustom"><see langword="Vary" /> HTTP ヘッダー。</param>
        <param name="location"><see cref="T:System.Web.UI.OutputCacheLocation" /> 値のいずれか。</param>
        <param name="varyByParam">GET または POST メソッドによって異なりますが、出力キャッシュからコンテンツを受け取るパラメーターのセミコロンで区切った一覧。</param>
        <summary>現在のページ要求の出力キャッシュを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを呼び出す必要はありません。 を有効にして、ページの出力キャッシュを操作するには、.aspx ファイルまたはメソッドとプロパティのいずれか、ディレクティブを使用、<xref:System.Web.HttpCachePolicy>クラスです。 後者はを通してアクセス`Response.Cache`ページのコードの構文。 詳細については、次を参照してください。 [ASP.NET ページのキャッシュ](http://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">無効な値が指定されて<paramref name="location" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="InitOutputCache">
      <MemberSignature Language="C#" Value="protected virtual void InitOutputCache (int duration, string varyByContentEncoding, string varyByHeader, string varyByCustom, System.Web.UI.OutputCacheLocation location, string varyByParam);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitOutputCache(int32 duration, string varyByContentEncoding, string varyByHeader, string varyByCustom, valuetype System.Web.UI.OutputCacheLocation location, string varyByParam) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.InitOutputCache(System.Int32,System.String,System.String,System.String,System.Web.UI.OutputCacheLocation,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Int32" />
        <Parameter Name="varyByContentEncoding" Type="System.String" />
        <Parameter Name="varyByHeader" Type="System.String" />
        <Parameter Name="varyByCustom" Type="System.String" />
        <Parameter Name="location" Type="System.Web.UI.OutputCacheLocation" />
        <Parameter Name="varyByParam" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="duration">出力キャッシュに格納されているオブジェクトが有効の量。</param>
        <param name="varyByContentEncoding">セミコロンで区切られた一連の文字セット (コンテンツのエンコード)、出力キャッシュの内容によって異なります。</param>
        <param name="varyByHeader">出力キャッシュからコンテンツ ヘッダーのセミコロン区切りリストによって異なります。</param>
        <param name="varyByCustom"><see langword="Vary" /> HTTP ヘッダー。</param>
        <param name="location"><see cref="T:System.Web.UI.OutputCacheLocation" /> 値のいずれか。</param>
        <param name="varyByParam">GET または POST メソッドによって異なりますが、出力キャッシュからコンテンツを受け取るパラメーターのセミコロンで区切った一覧。</param>
        <summary>現在のページ要求の出力キャッシュを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを呼び出す必要はありません。 を有効にして、ページの出力キャッシュを操作するには、.aspx ファイル、またはメソッドとプロパティのいずれか、ディレクティブを使用、<xref:System.Web.HttpCachePolicy>クラスです。 後者はを通してアクセス`Response.Cache`ページのコードの構文。 詳細については、次を参照してください。 [ASP.NET ページのキャッシュ](http://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">無効な値が指定されて<paramref name="location" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsAsync">
      <MemberSignature Language="C#" Value="public bool IsAsync { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAsync" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsAsync" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページが非同期的に処理されるかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" />ページが非同期モードである場合それ以外の場合、<see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、 <xref:System.Web.UI.Page.IsAsync%2A> Web ページが非同期モードで実行されているかどうかを決定するプロパティです。 この情報は、ページのコントロールまたはコード ページが非同期かに応じて、動作を変更する必要がある場合に便利です。 非同期プログラミングの詳細については、次を参照してください。[非同期操作](~/docs/framework/data/adonet/sql/asynchronous-operations.md)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCallback">
      <MemberSignature Language="C#" Value="public bool IsCallback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCallback" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページ要求がコールバックの結果であるかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" />ページ要求がコールバック; の結果である場合それ以外の場合、<see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 詳細については、次を参照してください。[ポストバックなしクライアント コールバックの実装](http://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClientScriptBlockRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptBlockRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptBlockRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.IsClientScriptBlockRegistered(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.IsClientScriptBlockRegistered(string key). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">検索対象のクライアント スクリプトの文字列のキー。</param>
        <summary>指定したキーをクライアント スクリプト ブロックがページに登録されているかどうかを判断します。</summary>
        <returns>
          <see langword="true" />スクリプト ブロックが登録されている場合それ以外の場合、<see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを呼び出す前に呼び出します<xref:System.Web.UI.Page.RegisterClientScriptBlock%2A?displayProperty=nameWithType>をクライアント側スクリプトを不必要にまとめることを回避します。 これは、スクリプトを作成するサーバーのリソースの消費量が必要な場合に特に重要です。  
  
 <xref:System.Web.UI.Page.IsClientScriptBlockRegistered%2A> メソッドの使用は推奨されていません。 使用して、<xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A>メソッドで、<xref:System.Web.UI.ClientScriptManager>クラスです。  
  
   
  
## Examples  
 使用を次のコード例に示します、<xref:System.Web.UI.Page.RegisterClientScriptBlock%2A>メソッドと組み合わせて、<xref:System.Web.UI.Page.IsClientScriptBlockRegistered%2A>メソッドです。 コード宣言ブロックで記述された ECMAScript が既に登録されていない場合、によって決定される<xref:System.Web.UI.Page.IsClientScriptBlockRegistered%2A>、<xref:System.Web.UI.Page.RegisterClientScriptBlock%2A>呼び出しが行われます。  
  
 [!code-aspx-csharp[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/CS/defaultcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/VB/defaultvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCrossPagePostBack">
      <MemberSignature Language="C#" Value="public bool IsCrossPagePostBack { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCrossPagePostBack" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsCrossPagePostBack" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページがページ間のポストバックに関係するかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" />ページがページ間の要求; に参加している場合それ以外の場合、<see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET では、別の 1 つのページからコントロールを転送するための 2 つのメカニズムを提供します。 使用することができます、<xref:System.Web.HttpServerUtility.Transfer%2A>ページ、または間での処理を転送する方法は、ページの URL を割り当てることでページ間の要求をすることができます、<xref:System.Web.UI.WebControls.IButtonControl.PostBackUrl%2A>を実装するボタン コントロールのプロパティ、<xref:System.Web.UI.WebControls.IButtonControl>インターフェイスです。  
  
 どちらの場合、<xref:System.Web.UI.Page.PreviousPage%2A>ページのプロパティには、前または送信元のページを表すオブジェクトが含まれています。 たとえば、ページ A 投稿ページ B まで、ページの A の場合は、<xref:System.Web.UI.Page.IsCrossPagePostBack%2A>プロパティ (経由でアクセスできる、<xref:System.Web.UI.Page.PreviousPage%2A>プロパティ) は`true`ページ b の<xref:System.Web.UI.Page.PreviousPage%2A>プロパティはページ A の名前になります  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPostBack">
      <MemberSignature Language="C#" Value="public bool IsPostBack { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPostBack" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsPostBack" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページが最初に表示しているか、ポストバックへの応答内に読み込まれているかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" />クライアントのポストバック; への応答内のページに読み込まれている場合それ以外の場合、<see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ポストバックとコールバックの違いの詳細については、次を参照してください。[ポストバックなしクライアント コールバックの実装](http://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185)です。  
  
   
  
## Examples  
 次の例の値をテストする方法を示しています、<xref:System.Web.UI.Page.IsPostBack%2A>プロパティ ページが最初に表示しているか、ポストバックに応答してかを判断するために、ページが読み込まれるときにします。 コードを呼び出す場合は、ページが最初にレンダリングされて、<xref:System.Web.UI.Page.Validate%2A?displayProperty=nameWithType>メソッドです。  
  
 (非表示) ページのマークアップを含む<xref:System.Web.UI.WebControls.RequiredFieldValidator>エントリがない場合、必要な入力フィールドにアスタリスクを表示するコントロール。 呼び出す<xref:System.Web.UI.Page.Validate%2A?displayProperty=nameWithType>送信 ボタンをクリックするまで待機しているのではなく、ページの表示する際にすぐに表示されるアスタリスクをによりします。 ポストバックされた後にを呼び出す必要はありません<xref:System.Web.UI.Page.Validate%2A?displayProperty=nameWithType>の一部としてそのメソッドが呼び出されるため、<xref:System.Web.UI.Page>ライフ サイクルです。  
  
 [!code-csharp[System.Web.UI.Page.Validate#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Validate/CS/validate.cs.aspx#1)]
 [!code-vb[System.Web.UI.Page.Validate#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Validate/VB/validate.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPostBackEventControlRegistered">
      <MemberSignature Language="C#" Value="public bool IsPostBackEventControlRegistered { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPostBackEventControlRegistered" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsPostBackEventControlRegistered" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ポストバックを実行するページにコントロールが登録されているかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" />コントロールに登録されています。それ以外の場合、<see langword="false" />です。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReusable">
      <MemberSignature Language="C#" Value="public bool IsReusable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReusable" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsReusable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>示す値を取得するかどうか、<see cref="T:System.Web.UI.Page" />オブジェクトを再利用できます。</summary>
        <value>
          常に <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStartupScriptRegistered">
      <MemberSignature Language="C#" Value="public bool IsStartupScriptRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsStartupScriptRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.IsStartupScriptRegistered(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.IsStartupScriptRegistered(string key). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">検索対象のスタートアップ スクリプトの文字列のキー。</param>
        <summary>クライアントのスタートアップ スクリプトに登録されているかどうかを判断、<see cref="T:System.Web.UI.Page" />オブジェクト。</summary>
        <returns>
          <see langword="true" />スタートアップ スクリプトは、登録されている場合それ以外の場合、<see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを呼び出す前に呼び出します<xref:System.Web.UI.Page.RegisterStartupScript%2A?displayProperty=nameWithType>をクライアント側スクリプトを不必要にまとめることを回避します。 これは、スクリプトを作成するサーバーのリソースの消費量が必要な場合に特に重要です。  
  
 <xref:System.Web.UI.Page.IsStartupScriptRegistered%2A> メソッドの使用は推奨されていません。 使用して、<xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A>メソッドで、<xref:System.Web.UI.ClientScriptManager>クラスです。  
  
   
  
## Examples  
 使用を次のコード例に示します、<xref:System.Web.UI.Page.RegisterStartupScript%2A>メソッドと組み合わせて、<xref:System.Web.UI.Page.IsStartupScriptRegistered%2A>メソッドです。 コード宣言ブロックで記述された ECMAScript が既に登録されていない場合、によって決定される<xref:System.Web.UI.Page.IsStartupScriptRegistered%2A>、<xref:System.Web.UI.Page.RegisterStartupScript%2A>呼び出しが行われます。  
  
 [!code-aspx-csharp[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/CS/defaultcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/VB/defaultvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValid">
      <MemberSignature Language="C#" Value="public bool IsValid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValid" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsValid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページの検証が成功したかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" />ページの検証が成功した場合それ以外の場合、<see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを返すの`true`、現在の検証グループのすべての検証サーバー コントロールが正常に検証する必要があります。 呼び出した後にのみ、このプロパティを確認する必要があります、<xref:System.Web.UI.Page.Validate%2A?displayProperty=nameWithType>メソッド、またはセット、`CausesValidation`プロパティを`true`で、`OnServerClick`フォーム処理を開始する ASP.NET サーバー コントロールのイベント ハンドラー。 これらのサーバー コントロールが含まれて、 <xref:System.Web.UI.WebControls.Button>、 <xref:System.Web.UI.HtmlControls.HtmlButton>、 <xref:System.Web.UI.HtmlControls.HtmlInputButton>、 <xref:System.Web.UI.HtmlControls.HtmlInputImage>、 <xref:System.Web.UI.WebControls.ImageButton>、および<xref:System.Web.UI.WebControls.LinkButton>クラスです。  
  
 使用して検証グループの検証を強制する場合、<xref:System.Web.UI.Page.Validate%2A>メソッドを指定された検証グループ内のすべての検証コントロールも検証する必要がありますが正常にします。  
  
   
  
## Examples  
 次のコード例では、使用方法を示します、<xref:System.Web.UI.Page.IsValid%2A>条件付きステートメントを設定するプロパティです。 プロパティを返す場合`true`、`Text`のプロパティ、 `lblOutput` 「ページが正しく!」に設定します。 それ以外の場合、「一部の必須フィールドが空です」に設定されています。  
  
 [!code-csharp[System.Web.UI.Page.Validate#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Validate/CS/validate.cs.aspx#2)]
 [!code-vb[System.Web.UI.Page.Validate#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Validate/VB/validate.vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><see cref="P:System.Web.UI.Page.IsValid" />検証が行われる前にプロパティが呼び出されます。</exception>
      </Docs>
    </Member>
    <Member MemberName="Items">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionary Items { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Items" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Items" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページ コンテキストに格納されているオブジェクトの一覧を取得します。</summary>
        <value>参照、<see cref="T:System.Collections.IDictionary" />ページ コンテキストに格納されたオブジェクトします。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Web.UI.Page.Items%2A>ページの要求と同じ有効期間を持つオブジェクトを格納するプロパティです。 このプロパティは読み取り専用です。ただし、オブジェクトを追加できる、<xref:System.Collections.IDictionary>オブジェクトを返します。  
  
 追加されたオブジェクト、<xref:System.Web.UI.Page.Items%2A>プロパティには、ページの有効期間全体で使用できるオブジェクトを追加できるように、<xref:System.Web.UI.Page.Items%2A>ページ ライフ サイクルの早い段階でイベントのプロパティは、サイクル、後続のイベントでこれらのオブジェクトにアクセスします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LCID">
      <MemberSignature Language="C#" Value="public int LCID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 LCID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.LCID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ロケール識別子を設定、<see cref="T:System.Threading.Thread" />ページに関連付けられているオブジェクト。</summary>
        <value>ロケール識別子を渡す、<see cref="T:System.Threading.Thread" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ほとんどの状況では、コードでこのプロパティを設定しないでください。 `LCID` .Aspx ファイルのディレクティブで属性を設定することができますが、優先ロケール識別子の設定方法を使用すると、<xref:System.Web.UI.Page.Culture%2A>と<xref:System.Web.UI.Page.UICulture%2A>プロパティです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadComplete">
      <MemberSignature Language="C#" Value="public event EventHandler LoadComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LoadComplete" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.LoadComplete" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページのライフ サイクルの読み込み段階の最後に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.LoadComplete>すべてポストバック データの後にイベントが発生し、ビュー状態データが読み込まれるは、ページと後、<xref:System.Web.UI.Control.OnLoad%2A>ページのすべてのコントロールのメソッドが呼び出されました。  
  
 イベント処理の詳細については、次を参照してください。 [NIB: イベントの利用](http://msdn.microsoft.com/en-us/01e4f1bc-e55e-413f-98c7-6588493e5f67)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadPageStateFromPersistenceMedium">
      <MemberSignature Language="C#" Value="protected virtual object LoadPageStateFromPersistenceMedium ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object LoadPageStateFromPersistenceMedium() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.LoadPageStateFromPersistenceMedium" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>保存されたすべてのビュー状態に関する情報を読み込み、<see cref="T:System.Web.UI.Page" />オブジェクト。</summary>
        <returns>保存されたビュー ステート。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.LoadPageStateFromPersistenceMedium%2A>メソッドを使用、<xref:System.Web.UI.PageStatePersister.Load%2A>のメソッド、<xref:System.Web.UI.PageStatePersister?displayProperty=nameWithType>によって参照されるオブジェクト、<xref:System.Web.UI.Page.PageStatePersister%2A>をロード プロパティのビュー状態情報の保存、<xref:System.Web.UI.Page>オブジェクト。  
  
 ASP.NET には 2 つのサブフォルダーが含まれています、<xref:System.Web.UI.PageStatePersister>クラス、 <xref:System.Web.UI.HiddenFieldPageStatePersister> ASP.NET ページに含まれる非表示フィールドの状態情報を保存するクラスと<xref:System.Web.UI.SessionPageStatePersister>で状態を保存するクラス、<xref:System.Web.UI.Page.Session%2A>要求に関連付けられているオブジェクト。  
  
 任意の場所で状態を保存する必要がありますを作成する新しいの子孫、<xref:System.Web.UI.PageStatePersister>クラスを保存し、任意の永続メディアへの状態を読み込みます。 新たに作成する例については<xref:System.Web.UI.PageStatePersister>オブジェクトを参照してください、<xref:System.Web.UI.PageStatePersister>クラスです。  
  
 .NET Framework version 1.0 または 1.1 では、ロードする場合は、このメソッドをオーバーライドを使用している場合、<xref:System.Web.UI.Page>状態から非表示フィールド以外のものです。 またをオーバーライドする必要があるように選択した場合、<xref:System.Web.UI.Page.SavePageStateToPersistenceMedium%2A>メソッドです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaintainScrollPositionOnPostBack">
      <MemberSignature Language="C#" Value="public bool MaintainScrollPositionOnPostBack { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MaintainScrollPositionOnPostBack" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.MaintainScrollPositionOnPostBack" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ポストバック後に、クライアント ブラウザー内の同じ位置にユーザーを返すかどうかを示す値を取得または設定します。 このプロパティは廃止された<see cref="P:System.Web.UI.Page.SmartNavigation" />プロパティです。</summary>
        <value>
          <see langword="true" />クライアントの位置を保持する必要があります。 場合それ以外の場合、<see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Web ページは、サーバーにポストバックされる、ユーザーは、ページの上部に返されます。 長い Web ページで、つまり、ユーザーは、ページ上の最後の位置にページをスクロールします。  
  
 ときに、<xref:System.Web.UI.Page.MaintainScrollPositionOnPostBack%2A>プロパティに設定されている`true`ユーザーは、代わりに返される最後の位置 ページでします。  
  
 設定する、<xref:System.Web.UI.Page.MaintainScrollPositionOnPostBack%2A>プロパティに、 [@ Page](http://msdn.microsoft.com/en-us/f06cf9e5-22bb-461d-8b8f-549e53ff40a4)ディレクティブです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MapPath">
      <MemberSignature Language="C#" Value="public string MapPath (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MapPath(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.MapPath(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">A<see cref="T:System.String" />を表す仮想パス。</param>
        <summary>仮想パス、絶対または相対パス、またはアプリケーションの相対パスにマップする物理パスを取得します。</summary>
        <returns>仮想パスまたはアプリケーションの相対パスに関連付けられている物理パス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <xref:System.Web.UI.Page.MapPath%2A>プロパティでは、ホスティング環境に関する機密情報を含めることができます可能性があります。 戻り値をユーザーに表示されません必要があります。  
  
   
  
## Examples  
 次の例では、<xref:System.Web.UI.Page.MapPath%2A>サブフォルダーの物理パスを取得します。 読み取られたファイル名を追加し、<xref:System.Web.UI.WebControls.TextBox.Text%2A>のプロパティ、<xref:System.Web.UI.WebControls.TextBox>コントロール。 そのファイルへの絶対物理パスになります。  
  
 [!code-csharp[Page_MapPath_ResponseEncoding#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_MapPath_ResponseEncoding/CS/page_mappath_responseencoding.cs.aspx#1)]
 [!code-vb[Page_MapPath_ResponseEncoding#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_MapPath_ResponseEncoding/VB/page_mappath_responseencoding.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Master">
      <MemberSignature Language="C#" Value="public System.Web.UI.MasterPage Master { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.MasterPage Master" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Master" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.MasterPage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページの全体的な外観を決定するマスター ページを取得します。</summary>
        <value><see cref="T:System.Web.UI.MasterPage" />存在する場合は、このページに関連付け、それ以外の<see langword="null" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.Master%2A>プロパティから返される、<xref:System.Web.UI.MasterPage>このページに関連付けられているオブジェクト。 このプロパティは読み取り専用です。ただしでのプロパティを設定することができます、<xref:System.Web.UI.MasterPage>オブジェクトを返します。  
  
 <xref:System.Web.UI.Page.Master%2A>プロパティはマスター ページを参照するページでのみ有効ですが、<xref:System.Web.UI.Page.MasterPageFile%2A>プロパティです。 アクセスする場合、 <xref:System.Web.UI.Page.Master%2A>  プロパティ ページ、マスター ページを参照しないで`null`が返されます。 マスター ページの内容が後までに使用できる、<xref:System.Web.UI.Page.PreInit>イベントが発生しました。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MasterPageFile">
      <MemberSignature Language="C#" Value="public virtual string MasterPageFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MasterPageFile" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.MasterPageFile" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはマスター ページの仮想パスを設定します。</summary>
        <value>マスター ページの仮想パス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.MasterPageFile%2A>プロパティは、このページに関連付けられているマスター ページファイルのルートから、アプリケーションの) 仮想パス。 <xref:System.Web.UI.Page.MasterPageFile%2A>プロパティでのみ設定できます、<xref:System.Web.UI.Page.PreInit>イベント; を設定しようとすると、<xref:System.Web.UI.Page.MasterPageFile%2A>後にプロパティ、<xref:System.Web.UI.Page.PreInit>イベントがスローされます、<xref:System.InvalidOperationException>例外。 場合、<xref:System.Web.UI.Page.MasterPageFile%2A>プロパティが有効でない型の例外<xref:System.Web.HttpException>ページ ライフ サイクルの後半でスローされるプロパティ設定されている場合に例外がスローされませんが、<xref:System.Web.UI.Page.PreInit>イベント。  
  
 持つページ、<xref:System.Web.UI.Page.MasterPageFile%2A>プロパティ セットのコンテンツ ページされ、したがってされる最上位レベルのみのコントロールを含めることができます<xref:System.Web.UI.WebControls.Content>コントロール。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Web.UI.Page.MasterPageFile" />後にプロパティが設定されて、<see cref="E:System.Web.UI.Page.PreInit" />イベントが完了しました。</exception>
        <exception cref="T:System.Web.HttpException">指定されたファイル、<see cref="P:System.Web.UI.Page.MasterPageFile" />プロパティは存在しません。  
  
 \- または  
  
 ページはありません、<see cref="T:System.Web.UI.WebControls.Content" />コントロールをトップレベル コントロールとして。</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxPageStateFieldLength">
      <MemberSignature Language="C#" Value="public int MaxPageStateFieldLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxPageStateFieldLength" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.MaxPageStateFieldLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはページの [状態] フィールドの最大の長さを設定します。</summary>
        <value>(バイト単位)、ページの状態 フィールドの最大長。 既定値は -1 です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ときに、<xref:System.Web.UI.Page.MaxPageStateFieldLength%2A>プロパティが正の数値に設定されている、クライアント ブラウザーに送信されるビュー ステートは、複数の隠しフィールドに分割、および各フィールドの値がで指定されたサイズより小さい、<xref:System.Web.UI.Page.MaxPageStateFieldLength%2A>プロパティです。  
  
 設定、<xref:System.Web.UI.Page.MaxPageStateFieldLength%2A>負の数 (既定値) をプロパティでは、ビュー状態フィールドをチャンクに分割されないことを示します。 設定、<xref:System.Web.UI.Page.MaxPageStateFieldLength%2A>少数のパフォーマンスの低下にあります。  
  
 値を設定、<xref:System.Web.UI.Page.MaxPageStateFieldLength%2A>プロパティに、Web.config ファイルのです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Web.UI.Page.MaxPageStateFieldLength" />プロパティが-1 または正の数と等しくないです。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Web.UI.Page.MaxPageStateFieldLength" />ページの初期化後にプロパティが設定されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="MetaDescription">
      <MemberSignature Language="C#" Value="public string MetaDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MetaDescription" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.MetaDescription" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>"Description"のコンテンツ設定を取得または<see langword="meta" />要素。</summary>
        <value>"Description"のコンテンツ<see langword="meta" />要素。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML`meta`要素は、検索エンジンの番組表を向上させるために使用できます。 「説明」`meta`要素は一覧のプレビューを向上させるために一部の検索エンジンによって使用されます。  
  
 「説明」がある場合`meta`内の要素、`head`ページ マークアップの要素、`meta`ページが表示される場合は、要素をページに追加します。 ページのマークアップは既に"description"場合`meta`要素では、このプロパティを取得または設定、`content`の属性、`meta`要素。  
  
 ディレクティブに、このプロパティを設定することもできます。  
  
   
  
## Examples  
 設定した場合、 <xref:System.Web.UI.Page.MetaDescription%2A> 「ASP.NET の概要」ページのプロパティは、次要素は、レンダリングされる HTML に表示されます。  
  
 `<meta name="description" content="ASP.NET Overview" />`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">ページには、ヘッダー コントロールはありません (、<see langword="head" />を持つ要素、<see langword="runat" />属性"server"に設定)。</exception>
      </Docs>
    </Member>
    <Member MemberName="MetaKeywords">
      <MemberSignature Language="C#" Value="public string MetaKeywords { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MetaKeywords" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.MetaKeywords" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>「キーワード」のコンテンツ設定を取得または<see langword="meta" />要素。</summary>
        <value>「キーワード」のコンテンツ<see langword="meta" />要素。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML`meta`要素は、検索エンジンの番組表を向上させるために使用できます。 「キーワード」`meta`要素が使用されていないすべてのまたは主要な検索エンジンではほとんどの重みを指定します。  
  
 「キーワード」がある場合`meta`内の要素、`head`ページ マークアップの要素、`meta`ページが表示される場合は、要素をページに追加します。 ページのマークアップは既に「キーワード」場合`meta`要素では、このプロパティを取得または設定、`content`の属性、`meta`要素。  
  
 ディレクティブに、このプロパティを設定することもできます。  
  
   
  
## Examples  
 設定した場合、 <xref:System.Web.UI.Page.MetaKeywords%2A> 「HTML、CSS、JavaScript、XML」をページのプロパティは、次の要素は、レンダリングされる HTML に表示されます。  
  
 `<meta name="keywords" content=" HTML,CSS,XML,JavaScript" />`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">ページには、ヘッダー コントロールはありません (、<see langword="head" />を持つ要素、<see langword="runat" />属性"server"に設定)。</exception>
      </Docs>
    </Member>
    <Member MemberName="ModelBindingExecutionContext">
      <MemberSignature Language="C#" Value="public System.Web.ModelBinding.ModelBindingExecutionContext ModelBindingExecutionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.ModelBinding.ModelBindingExecutionContext ModelBindingExecutionContext" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ModelBindingExecutionContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ModelBinding.ModelBindingExecutionContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>モデル バインディング実行コンテキストを取得します。</summary>
        <value>モデル バインディング実行コンテキスト。 モデル バインディング実行コンテキストは場合<see langword="null" />、新しい 1 つが作成され、返されます。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModelState">
      <MemberSignature Language="C#" Value="public System.Web.ModelBinding.ModelStateDictionary ModelState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.ModelBinding.ModelStateDictionary ModelState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ModelState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ModelBinding.ModelStateDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>モデル バインディングの検証とモデルの状態を格納するモデル状態ディクショナリ オブジェクトを取得します。</summary>
        <value>モデル状態ディクショナリ オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Web フォーム モデル バインディングの使用に関するチュートリアル シリーズは、次を参照してください。[モデル バインディング機能と Web フォーム](http://go.microsoft.com/fwlink/?LinkId=286117)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected override void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnInit(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>発生させる、<see cref="E:System.Web.UI.Control.Init" />イベント ページを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.OnInit%2A>メソッドを作成するために必要な初期化とセットアップの手順を実行、<xref:System.Web.UI.Page>インスタンス。 このページのライフ サイクル ステージで ページで宣言されたサーバー コントロールは既定の状態に初期化されます。ただし、各コントロールのビュー ステートがまだ設定します。 ページ上のコントロールが中に、ページ上の他のサーバー コントロールにアクセスできない、`Page_Init`フェーズでは、他のコントロールの親または子コントロールがかどうかに関係なく、します。 他のサーバー コントロールが作成され、アクセスできる状態である保証はありません。  
  
 <xref:System.Web.UI.Page.OnInit%2A>メソッドは、<xref:System.Web.UI.Page.OnPreInit%2A>メソッドとの前に、<xref:System.Web.UI.Page.OnInitComplete%2A>メソッドです。  
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、「[イベント](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)」を参照してください。  
  
 <xref:System.Web.UI.Page.OnInit%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Web.UI.Page.OnInit(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Web.UI.Page.OnInit(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnInitComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnInitComplete (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitComplete(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnInitComplete(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>発生させる、<see cref="E:System.Web.UI.Page.InitComplete" />ページの初期化後のイベントです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.OnInitComplete%2A>ページの初期化が完了した後にメソッドが呼び出されます。 このページのライフ サイクル ステージで宣言されたすべて、ページ上のコントロールが初期化されるが、ページのビュー ステートがまだ設定します。 サーバー コントロールにアクセスできますが、それらがまだ含まれていませんユーザーから返される情報には。  
  
 <xref:System.Web.UI.Page.OnInitComplete%2A>メソッドは、最後の発生、<xref:System.Web.UI.Page>初期化段階と、負荷のステージの前にします。  
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、「[イベント](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)」を参照してください。  
  
 <xref:System.Web.UI.Page.OnInitComplete%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Web.UI.Page.OnInitComplete(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Web.UI.Page.OnInitComplete(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnLoadComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnLoadComplete (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLoadComplete(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnLoadComplete(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>発生させる、<see cref="E:System.Web.UI.Page.LoadComplete" />ページ読み込み段階の最後のイベントです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.OnLoadComplete%2A>メソッドは、ページを読み込む段階の最後に呼び出されます。 この時点でページ ライフ サイクルは、すべてのポストバック データとビューステート データが読み込み済みで、ページ上のコントロールにします。  
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。 [NIB: イベントを発生させる](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2)です。  
  
 <xref:System.Web.UI.Page.OnLoadComplete%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Web.UI.Page.OnLoadComplete(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Web.UI.Page.OnLoadComplete(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPreInit">
      <MemberSignature Language="C#" Value="protected virtual void OnPreInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnPreInit(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>発生させる、<see cref="E:System.Web.UI.Page.PreInit" />ページの初期化の開始時のイベントです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.OnPreInit%2A>ページの初期化段階の先頭にメソッドが呼び出されます。  
  
 後に、<xref:System.Web.UI.Page.OnPreInit%2A>メソッドが呼び出される、パーソナル化情報が読み込まれ、ページのテーマが存在する場合は初期化されます。 これは、優先されるステージを動的に定義にも、<xref:System.Web.UI.PageTheme>または<xref:System.Web.UI.MasterPage>ページ。  
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、「[イベント](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)」を参照してください。  
  
 <xref:System.Web.UI.Page.OnPreInit%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Web.UI.Page.OnPreInit(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Web.UI.Page.OnPreInit(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPreLoad">
      <MemberSignature Language="C#" Value="protected virtual void OnPreLoad (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreLoad(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnPreLoad(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>発生させる、<see cref="E:System.Web.UI.Page.PreLoad" />イベント ポストバック データがページのサーバー コントロールにその前に読み込まれた後、<see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />イベント。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.OnPreLoad%2A>メソッドが呼び出されたユーザーから返されたすべてのポストバック データが読み込まれます。 この段階で、ページのライフ サイクルで、ビュー ステート情報とポストバック データ宣言コントロールと初期化段階で作成されたコントロールがページのコントロールに読み込まれます。  
  
 作成されたコントロール、<xref:System.Web.UI.Page.OnPreLoad%2A>メソッドは、ビューステートとポストバック データを読み込むこともできます。  
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、「[イベント](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)」を参照してください。  
  
 <xref:System.Web.UI.Page.OnPreLoad%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Web.UI.Page.OnPreLoad(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Web.UI.Page.OnPreLoad(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPreRenderComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnPreRenderComplete (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreRenderComplete(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnPreRenderComplete(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>発生させます、<see cref="E:System.Web.UI.Page.PreRenderComplete" />後のイベント、<see cref="M:System.Web.UI.Page.OnPreRenderComplete(System.EventArgs)" />イベントと、ページが表示される前にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.OnPreRenderComplete%2A>プリレンダ リング、ページのライフ サイクルの段階が完了すると、メソッドが呼び出されます。 ページのライフ サイクルのこの段階では、すべてのコントロールが作成され、ページは、出力を表示する準備が。  
  
 これは、最後のページのビュー状態を保存する前に呼び出すイベントです。  
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、「[イベント](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)」を参照してください。  
  
 <xref:System.Web.UI.Page.OnPreRenderComplete%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Web.UI.Page.OnPreRenderComplete(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Web.UI.Page.OnPreRenderComplete(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnSaveStateComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnSaveStateComplete (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSaveStateComplete(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnSaveStateComplete(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A<see cref="T:System.EventArgs" />イベント データを含むオブジェクト。</param>
        <summary>発生させる、<see cref="E:System.Web.UI.Page.SaveStateComplete" />ページの状態を永続化に使用するメディアに保存した後のイベントです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.OnSaveStateComplete%2A>メソッドは、コントロールの状態情報がページの永続化中に書き込まれたときに呼び出されます。 永続化中に呼び出すことによって状態情報が書き込まれる、<xref:System.Web.UI.Page.SavePageStateToPersistenceMedium%2A>メソッドです。  
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、「[イベント](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)」を参照してください。  
  
 <xref:System.Web.UI.Page.OnSaveStateComplete%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Web.UI.Page.OnSaveStateComplete(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Web.UI.Page.OnSaveStateComplete(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="PageAdapter">
      <MemberSignature Language="C#" Value="public System.Web.UI.Adapters.PageAdapter PageAdapter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Adapters.PageAdapter PageAdapter" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.PageAdapter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Adapters.PageAdapter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>特定の要求元ブラウザーのページを表示するアダプターを取得します。</summary>
        <value><see cref="T:System.Web.UI.Adapters.PageAdapter" />ページを表示します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.PageAdapter%2A>プロパティは、固有の仕様を返します<xref:System.Web.UI.Adapters.PageAdapter>の動作を変更するオブジェクト、<xref:System.Web.UI.Page>要求側のブラウザーのオブジェクト。  
  
 特定<xref:System.Web.UI.Adapters.PageAdapter>オブジェクトは、入力方向の特性を調べることによって決まります<xref:System.Web.UI.Page.Request%2A>オブジェクト。 要求のライフ サイクル イベントをアダプターが選択された場合、<xref:System.Web.UI.Adapters.PageAdapter>オブジェクトに対応するイベントの上書き、<xref:System.Web.UI.Page>オブジェクト。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PageStatePersister">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.PageStatePersister PageStatePersister { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.PageStatePersister PageStatePersister" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.PageStatePersister" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.PageStatePersister</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得、<see cref="T:System.Web.UI.PageStatePersister" />ページに関連付けられているオブジェクト。</summary>
        <value>A<see cref="T:System.Web.UI.PageStatePersister" />ページに関連付けられています。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTTP 要求と応答は、本質的にステートレスです。 HTTP 要求の間で状態を維持するために ASP.NET サーバー ページを格納できます<xref:System.Web.UI.Page>状態です。 ビュー状態と呼ばれる、この状態は、ページとコントロールの設定、およびページとコントロールのようにいる場合、ユーザーがページに最後のラウンド トリップで対話し、ものと同じものを表示できるようにするデータで構成されます。 同じページに後続の要求間でのビュー ステートを格納するいくつかのメカニズムが存在します。 抽象<xref:System.Web.UI.PageStatePersister>クラスは、これらの状態の記憶域メカニズムの基本クラスを表します。  
  
 ページの開発者が通常必要ありませんを使用して、<xref:System.Web.UI.Page.PageStatePersister%2A>プロパティです。 <xref:System.Web.UI.Page.PageStatePersister%2A>プロパティは、主の機能を拡張するコントロールの開発者によって使用、<xref:System.Web.UI.Page>クラスです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="postEventArgumentID">
      <MemberSignature Language="C#" Value="public const string postEventArgumentID;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string postEventArgumentID" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.Page.postEventArgumentID" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示されたページ EVENTARGUMENT 隠しフィールドを定義する文字列。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="postEventSourceID">
      <MemberSignature Language="C#" Value="public const string postEventSourceID;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string postEventSourceID" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.Page.postEventSourceID" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示されたページ EVENTTARGET 隠しフィールドを定義する文字列。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreInit">
      <MemberSignature Language="C#" Value="public event EventHandler PreInit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PreInit" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.PreInit" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページの初期化の前に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントでは、ポストバックへの応答で、ページが読み込まれているかどうかなど、ページ要求の条件を確認することができます。 プロファイルのプロパティの値をチェックすることもできます。  
  
 イベントでは、ページのライフ サイクルの後で使用される値を設定することができます。 動的に、マスター ページまたは、要求されたページのテーマを設定し、ダイナミック コントロールを作成できます。  
  
 方法の詳細については<xref:System.Web.UI.Page.PreInit>イベントに組み込まれて、ASP.NET のライフ サイクルは、「 [ASP.NET ページ ライフ サイクルの概要](http://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreLoad">
      <MemberSignature Language="C#" Value="public event EventHandler PreLoad;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PreLoad" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.PreLoad" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページの前に発生した<see cref="E:System.Web.UI.Control.Load" />イベント。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.PreLoad>イベントは、すべてのポストバック データの処理後、および、<xref:System.Web.UI.Control.Load>イベント。 2 回目の試行する前にポストバック データを読み込む、<xref:System.Web.UI.Page.OnLoadComplete%2A>イベント。 イベント処理の詳細については、次を参照してください。 [NIB: イベントの利用](http://msdn.microsoft.com/en-us/01e4f1bc-e55e-413f-98c7-6588493e5f67)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreRenderComplete">
      <MemberSignature Language="C#" Value="public event EventHandler PreRenderComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PreRenderComplete" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.PreRenderComplete" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページのコンテンツがレンダリングされる前に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.PreRenderComplete>ページのライフ サイクルの前のレンダリング段階が完了すると、イベントが発生します。 ページのライフ サイクルのこの段階ですべてのコントロールを作成、必要なすべての改ページが完了したら、およびページは、出力を表示するために準備ができてです。  
  
 これは、最後のページのビュー状態が保存される前に発生するイベントです。  
  
 イベント処理の詳細については、次を参照してください。 [NIB: イベントの利用](http://msdn.microsoft.com/en-us/01e4f1bc-e55e-413f-98c7-6588493e5f67)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviousPage">
      <MemberSignature Language="C#" Value="public System.Web.UI.Page PreviousPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Page PreviousPage" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.PreviousPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Page</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のページにコントロールを転送するページを取得します。</summary>
        <value><see cref="T:System.Web.UI.Page" />現在のページにコントロールを転送するページを表示します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用すると、<xref:System.Web.HttpServerUtility.Transfer%2A>メソッドまたはを使用してページ間に 1 つの ASP.NET ページから別の処理を転送します。 投稿、発生元のページに移動先のページに必要な情報を要求が含まれています。 使用することができます、<xref:System.Web.UI.Page.PreviousPage%2A>プロパティをその情報にアクセスします。  
  
 (、転送や別のページからのクロス post)、直接の要求の結果として、現在のページを表示しているかどうか、<xref:System.Web.UI.Page.PreviousPage%2A>プロパティが含まれます`null`です。  
  
   
  
## Examples  
 次の例では、2 つの部分です。 1 つは、使用する ASP.NET ページ、<xref:System.Web.HttpServerUtility.Transfer%2A>としてページ モデルで公開されるメソッド`Server.Transfer("path")`です。 2 番目の部分は、対象のページを使用して、<xref:System.Web.UI.Page.PreviousPage%2A>最初のページのタイトルを取得するプロパティです。  
  
 [!code-aspx-csharp[System.Web.UI.Page.PreviousPage#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.PreviousPage/CS/Main.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.PreviousPage#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.PreviousPage/VB/Main.aspx#1)]  
  
 [!code-aspx-csharp[System.Web.UI.Page.PreviousPage#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.PreviousPage/CS/Notify.aspx#2)]
 [!code-aspx-vb[System.Web.UI.Page.PreviousPage#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.PreviousPage/VB/Notify.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">現在のユーザーは、前のページへのアクセスは許可されません。  
  
 または  
  
 ASP.NET ルーティングが使用であり、前のページの URL は、ルーティングの URL。 ASP.NET は、アクセス許可をチェックし、URL がファイルへの実際のパスであると見なします。 これは、ルーティングの URL の場合とではありません、ため、確認が失敗します。</exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessRequest">
      <MemberSignature Language="C#" Value="public virtual void ProcessRequest (System.Web.HttpContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ProcessRequest(class System.Web.HttpContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.ProcessRequest(System.Web.HttpContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
      </Parameters>
      <Docs>
        <param name="context"><see cref="T:System.Web.HttpContext" />組み込みサーバー オブジェクトへの参照を提供するオブジェクト (たとえば、 <see cref="P:System.Web.HttpContext.Request" />、 <see cref="P:System.Web.HttpContext.Response" />、および<see cref="P:System.Web.HttpContext.Session" />) HTTP 要求を処理するために使用します。</param>
        <summary>組み込みのサーバー オブジェクトを設定、<see cref="T:System.Web.UI.Page" />などのオブジェクト、 <see cref="P:System.Web.UI.Page.Context" />、 <see cref="P:System.Web.UI.Page.Request" />、 <see cref="P:System.Web.UI.Page.Response" />、および<see cref="P:System.Web.UI.Page.Application" />プロパティです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを呼び出す必要はありません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaisePostBackEvent">
      <MemberSignature Language="C#" Value="protected virtual void RaisePostBackEvent (System.Web.UI.IPostBackEventHandler sourceControl, string eventArgument);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RaisePostBackEvent(class System.Web.UI.IPostBackEventHandler sourceControl, string eventArgument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RaisePostBackEvent(System.Web.UI.IPostBackEventHandler,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceControl" Type="System.Web.UI.IPostBackEventHandler" />
        <Parameter Name="eventArgument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceControl">ポストバックを発生させた、ASP.NET サーバー コントロールには。 このコントロールを実装する必要があります、<see cref="T:System.Web.UI.IPostBackEventHandler" />インターフェイスです。</param>
        <param name="eventArgument">ポストバックの引数。</param>
        <summary>ポストバックを発生させたサーバー コントロールに通知受信ポストバック イベントを処理する必要があります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page>オブジェクトの呼び出し、<xref:System.Web.UI.Page.RaisePostBackEvent%2A>メソッド ポストバックが発生したときにします。 この呼び出しは、読み込みと変更の通知が完了した後は、事前に発生する前に、ページのライフ サイクルで発生します。  
  
   
  
## Examples  
 次の例で、<xref:System.Web.UI.Page.RaisePostBackEvent%2A>ときに、カスタム、ポストバック イベントが発生したことを ASP.NET に通知するメソッド`userButton`サーバー コントロールをクリックします。  
  
 [!code-csharp[Page_RaisePostBackEvent#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RaisePostBackEvent/CS/page_raisepostbackevent.cs.aspx#1)]
 [!code-vb[Page_RaisePostBackEvent#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RaisePostBackEvent/VB/page_raisepostbackevent.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterArrayDeclaration">
      <MemberSignature Language="C#" Value="public void RegisterArrayDeclaration (string arrayName, string arrayValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterArrayDeclaration(string arrayName, string arrayValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterArrayDeclaration(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.RegisterArrayDeclaration(string arrayName, string arrayValue). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrayName" Type="System.String" />
        <Parameter Name="arrayValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="arrayName">値を宣言する配列の名前。</param>
        <param name="arrayValue">配列に代入する値。</param>
        <summary>ページが表示される場合は、ECMAScript 配列の宣言として宣言されている値を宣言します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、クライアント スクリプト ライブラリの同じ型のすべてのコントロールが扱えるように配列内における自体を宣言するスクリプト ベースのコントロールで使用できます。  
  
 <xref:System.Web.UI.Page.RegisterArrayDeclaration%2A> メソッドの使用は推奨されていません。 使用して、<xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A>メソッドで、<xref:System.Web.UI.ClientScriptManager>クラスです。  
  
   
  
## Examples  
 次のコード例では、 <xref:System.Web.UI.Page.RegisterArrayDeclaration%2A> 、配列を宣言するメソッド`myArray`、という 3 つのオブジェクトを格納している`x`、 `y`、および`z`です。 例を定義し、スタートアップ スクリプトを使用して、登録、<xref:System.Web.UI.Page.RegisterStartupScript%2A>メソッドです。 ときに、ECMAScript`doClick`関数はこのコードが含まれるページから呼び出されますが、配列とそのオブジェクトを初期化します。  
  
 [!code-csharp[Page_RegisterArrayDeclaration#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RegisterArrayDeclaration/CS/page_registerarraydeclaration.cs.aspx#1)]
 [!code-vb[Page_RegisterArrayDeclaration#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RegisterArrayDeclaration/VB/page_registerarraydeclaration.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterAsyncTask">
      <MemberSignature Language="C#" Value="public void RegisterAsyncTask (System.Web.UI.PageAsyncTask task);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterAsyncTask(class System.Web.UI.PageAsyncTask task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterAsyncTask(System.Web.UI.PageAsyncTask)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Web.UI.PageAsyncTask" />
      </Parameters>
      <Docs>
        <param name="task">A<see cref="T:System.Web.UI.PageAsyncTask" />非同期タスクを定義します。</param>
        <summary>ページに新しい非同期タスクを登録します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、非同期タスクを定義する、<xref:System.Web.UI.PageAsyncTask>クラスです。 タスクが定義されている場合を使用して、<xref:System.Web.UI.Page.RegisterAsyncTask%2A>ページで、タスクを登録します。 タスクを登録すると、呼び出し、<xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A>メソッドを非同期のタスクを開始します。  
  
 <xref:System.Web.UI.Page.RegisterAsyncTask%2A>メソッドは、同期および非同期の両方のページで使用することができます。  
  
   
  
## Examples  
 使用を次のコード例に示します、<xref:System.Web.UI.Page.AsyncTimeout%2A>を持つプロパティ、<xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A>と<xref:System.Web.UI.Page.RegisterAsyncTask%2A>メソッドです。 先頭、末尾、およびタイムアウト ハンドラーの使用に注意してください。 指定されているタスクの割り当て時刻を超えた場合、非同期タスクのような状況を示す例では、人為的な遅延が導入された、<xref:System.Web.UI.Page.AsyncTimeout%2A>プロパティです。 現実のシナリオで非同期タスクは、データベースの呼び出しまたはイメージの生成を実行するために使用可能性がありますなどとタイムアウト ハンドラーは、一定の時間で、タスクは実行されない場合に下げるを提供します。  
  
 [!code-aspx-csharp[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.aspx#1)]  
  
 [!code-csharp[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.cs#2)]
 [!code-vb[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">非同期タスクが<see langword="null" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public virtual void RegisterClientScriptBlock (string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterClientScriptBlock(string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterClientScriptBlock(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.RegisterClientScriptBlock(Type type, string key, string script). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">スクリプト ブロックを識別する一意のキー。</param>
        <param name="script">クライアントに送信されるスクリプトの内容。</param>
        <summary>応答をクライアント側のスクリプト ブロックを出力します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 開始タグの直後に、クライアント側-スクリプトが生成されます、<xref:System.Web.UI.Page>オブジェクトの`<form runat= server>`要素。 必ず開始タグと終了を`<script>`スクリプトの周りに要素のブロックで指定した文字列、`script`パラメーター。  
  
 このメソッドは、スクリプト ブロックを識別するキーを使用するため、スクリプト ブロックが別のサーバー コントロールのインスタンスから要求されるたびに、出力ストリームに出力する必要はありません。 キーを使用すると、別のコントロールのスクリプト ブロックが互いに干渉する可能性も低下します。  
  
 いずれかのスクリプトで、同じブロック`key`パラメーター値が重複と見なされます。  
  
> [!NOTE]
>  要求側のブラウザーがスクリプトをサポートしていない場合は表示されないように、HTML コメント タグで囲みます、スクリプトを含めるに注意してください。  
  
 <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A> メソッドの使用は推奨されていません。 使用して、<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>メソッドで、<xref:System.Web.UI.ClientScriptManager>クラスの代わりにします。  
  
   
  
## Examples  
 使用を次のコード例に示します、<xref:System.Web.UI.Page.RegisterClientScriptBlock%2A>メソッドと組み合わせて、<xref:System.Web.UI.Page.IsClientScriptBlockRegistered%2A>メソッドです。 宣言のコード ブロックに ECMAScript が既に登録されていない場合、によって決定される<xref:System.Web.UI.Page.IsClientScriptBlockRegistered%2A>、<xref:System.Web.UI.Page.RegisterClientScriptBlock%2A>呼び出しが行われます。  
  
 [!code-aspx-csharp[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/CS/defaultcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/VB/defaultvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterHiddenField">
      <MemberSignature Language="C#" Value="public virtual void RegisterHiddenField (string hiddenFieldName, string hiddenFieldInitialValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterHiddenField(string hiddenFieldName, string hiddenFieldInitialValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterHiddenField(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.RegisterHiddenField(string hiddenFieldName, string hiddenFieldInitialValue). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hiddenFieldName" Type="System.String" />
        <Parameter Name="hiddenFieldInitialValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="hiddenFieldName">描画する隠しフィールドの一意の名前。</param>
        <param name="hiddenFieldInitialValue">非表示の形式で出力する値。</param>
        <summary>サーバー コントロールをフォーム上の隠しフィールドを自動的に登録を許可します。 フィールドに送信される、<see cref="T:System.Web.UI.Page" />オブジェクトときに、<see cref="T:System.Web.UI.HtmlControls.HtmlForm" />サーバー コントロールを表示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.RegisterHiddenField%2A> メソッドの使用は推奨されていません。 使用して、<xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A>メソッドで、<xref:System.Web.UI.ClientScriptManager>クラスです。  
  
   
  
## Examples  
 次のコード例では、 <xref:System.Web.UI.Page.RegisterHiddenField%2A> ECMAScript コードを作成するためにメソッドが要求側のブラウザーに渡されます。 非表示フィールドの名前に設定されている`myHiddenField`し、その値が「を Microsoft にようこそ!」に設定されています。 <xref:System.Web.UI.Page.RegisterStartupScript%2A>メソッドの呼び出し、`myHiddenField`値のユーザーがページ上のボタンをクリックします。  
  
> [!IMPORTANT]
>  この例では、潜在的なセキュリティ上の脅威が、非表示フィールドがあります。 既定では、テキスト ボックスの値と同様、非表示フィールドの値を検証する必要があります。 ASP.NET Web ページは、ユーザー入力にスクリプトまたは HTML 要素が含まれていないことを検証します。 詳細については、次を参照してください。[スクリプト悪用概要](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)です。  
  
 [!code-csharp[Page_RegisterHiddenField#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RegisterHiddenField/CS/page_registerhiddenfield.cs.aspx#1)]
 [!code-vb[Page_RegisterHiddenField#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RegisterHiddenField/VB/page_registerhiddenfield.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterOnSubmitStatement">
      <MemberSignature Language="C#" Value="public void RegisterOnSubmitStatement (string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterOnSubmitStatement(string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterOnSubmitStatement(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.RegisterOnSubmitStatement(Type type, string key, string script). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">スクリプト ブロックを識別する一意のキー。</param>
        <param name="script">クライアントに送信されるクライアント側スクリプトです。</param>
        <summary>により、クライアントへのアクセスにページ<see langword="OnSubmit" />イベント。 スクリプトは、他の場所に登録されたクライアント コードに関数呼び出しをする必要があります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.RegisterOnSubmitStatement%2A> メソッドの使用は推奨されていません。 使用して、<xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A>メソッドで、<xref:System.Web.UI.ClientScriptManager>クラスです。  
  
   
  
## Examples  
 次のコード例では、使用方法を示します、<xref:System.Web.UI.Page.RegisterOnSubmitStatement%2A>クライアント側の送信 ボタンがクリックされたときに応答するスクリプトにアクセスします。 このイベントが発生した、クライアントの登録済みの ECMAScript コードが実行されます。  
  
> [!IMPORTANT]
>  この例では、潜在的なセキュリティ上の脅威が、非表示フィールドがあります。 既定では、テキスト ボックスの値と同様、非表示フィールドの値を検証する必要があります。 ASP.NET Web ページは、ユーザー入力にスクリプトまたは HTML 要素が含まれていないことを検証します。 詳細については、次を参照してください。[スクリプト悪用概要](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)です。  
  
 [!code-csharp[Page_RegisterHiddenField#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RegisterHiddenField/CS/page_registerhiddenfield.cs.aspx#2)]
 [!code-vb[Page_RegisterHiddenField#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RegisterHiddenField/VB/page_registerhiddenfield.vb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterRequiresControlState">
      <MemberSignature Language="C#" Value="public void RegisterRequiresControlState (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterRequiresControlState(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterRequiresControlState(System.Web.UI.Control)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">登録するコントロール。</param>
        <summary>コントロールの状態を永続化する必要がありますとしてコントロールを登録します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロールの状態を使用するカスタムのサーバー コントロールを呼び出す必要があります、<xref:System.Web.UI.Page.RegisterRequiresControlState%2A>メソッド要求のたびにコントロールの状態のための登録が引き継がれません要求からの要求にポストバック イベントの中であるためです。 登録がで実行することをお勧め、<xref:System.Web.UI.Control.Init>イベント。  
  
   
  
## Examples  
 次のコード例は、カスタム サーバー コントロールの呼び出しを示しています、<xref:System.Web.UI.Page.RegisterRequiresControlState%2A>メソッドです。  
  
 [!code-csharp[ControlState#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlState/CS/controlstatecs.aspx#1)]
 [!code-vb[ControlState#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlState/VB/controlstatevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">登録するコントロールは<see langword="null" />します。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Web.UI.Page.RegisterRequiresControlState(System.Web.UI.Control)" />だけ前に、または中に、メソッドを呼び出すことができる、<see cref="E:System.Web.UI.Control.PreRender" />イベント。</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterRequiresPostBack">
      <MemberSignature Language="C#" Value="public void RegisterRequiresPostBack (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterRequiresPostBack(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterRequiresPostBack(System.Web.UI.Control)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">登録するコントロール。</param>
        <summary>ページがサーバーにポストされたときにポストバック処理を必要とする 1 つとして、コントロールを登録します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 登録するコントロールを実装する必要があります、<xref:System.Web.UI.IPostBackDataHandler>インターフェイスまたは<xref:System.Web.HttpException>が発生します。 コントロールで実装された場合、<xref:System.Web.UI.IPostBackDataHandler>ポストバック データの処理や任意の投稿の生成が可能なインターフェイスが変更されたデータ イベントをバックアップします。 サーバー コントロールのイベント モデルの詳細については、次を参照してください。 [ASP.NET Web フォーム サーバー コントロールのイベント モデル](http://msdn.microsoft.com/library/6304bff7-1b0e-4641-8acb-6d3b0badc4a3)です。  
  
 以前のページにコントロールを登録、`Page_PreRender`ページのライフ サイクルのイベントです。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Web.UI.Page.RegisterRequiresPostBack%2A>メソッドをテキスト ボックス コントロールを必要とする`myTextBox`、ポストバックされます、テキスト ボックスに関連付けられているすべてのコードを実行前にします。 <xref:System.Web.UI.WebControls.TextBox>コントロールは、実装、<xref:System.Web.UI.IPostBackDataHandler>インターフェイスです。  
  
> [!IMPORTANT]
>  この例には、ユーザー入力を受け付けるテキスト ボックスがあります。これにより、セキュリティが脆弱になる可能性があります。 既定では、ASP.NET Web ページによって、ユーザー入力にスクリプトまたは HTML 要素が含まれていないかどうかが検証されます。 詳細については、次を参照してください。[スクリプト悪用概要](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)です。  
  
 [!code-csharp[Page_RegisterRequiresPostBack#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RegisterRequiresPostBack/CS/page_registerrequirespostback.cs.aspx#1)]
 [!code-vb[Page_RegisterRequiresPostBack#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RegisterRequiresPostBack/VB/page_registerrequirespostback.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">登録するコントロールを実装しません、<see cref="T:System.Web.UI.IPostBackDataHandler" />インターフェイスです。</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterRequiresRaiseEvent">
      <MemberSignature Language="C#" Value="public virtual void RegisterRequiresRaiseEvent (System.Web.UI.IPostBackEventHandler control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterRequiresRaiseEvent(class System.Web.UI.IPostBackEventHandler control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterRequiresRaiseEvent(System.Web.UI.IPostBackEventHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.IPostBackEventHandler" />
      </Parameters>
      <Docs>
        <param name="control">登録するコントロール。</param>
        <summary>1 つのコントロールが処理されるときに発生するイベントを必要とすると、ASP.NET サーバー コントロールを登録、<see cref="T:System.Web.UI.Page" />オブジェクト。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ページ要求あたり 1 つだけのサーバー コントロールに登録できます。 <xref:System.Web.UI.Page.RegisterRequiresRaiseEvent%2A>コントロールにそのコントロール形式で ID データの投稿にはが含まれていない場合に使用する必要があります。 また、登録されているコントロールを実装する必要があります、<xref:System.Web.UI.IPostBackEventHandler>インターフェイスです。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Web.UI.Page.RegisterRequiresRaiseEvent%2A>を登録するメソッド、 <xref:System.Web.UI.WebControls.Button> Web サーバー コントロールにイベントを発生させる必要であるとします。 最初に登録した後<xref:System.Web.UI.WebControls.Button>コントロール、2 番目になる<xref:System.Web.UI.WebControls.Button>の最初のボタンの結果を投稿するためのコードで宣言されているコントロールがページにイベントをクリックします。  
  
 [!code-csharp[Page_RaisePostBackEvent#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RaisePostBackEvent/CS/page_raisepostbackevent.cs.aspx#1)]
 [!code-vb[Page_RaisePostBackEvent#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RaisePostBackEvent/VB/page_raisepostbackevent.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterRequiresViewStateEncryption">
      <MemberSignature Language="C#" Value="public void RegisterRequiresViewStateEncryption ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterRequiresViewStateEncryption() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterRequiresViewStateEncryption" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ページにコントロールを必要とする 1 つのビュー ステート暗号化として登録します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 機密性の高い情報を処理するカスタム コントロールを開発している場合、<xref:System.Web.UI.Page.RegisterRequiresViewStateEncryption%2A>ページにコントロールを登録し、コントロールは暗号化の表示状態を保証するメソッド。  
  
 場合、ページ全体の状態を暗号化する、<xref:System.Web.UI.Page.ViewStateEncryptionMode%2A>に設定されている<xref:System.Web.UI.ViewStateEncryptionMode.Auto>または<xref:System.Web.UI.ViewStateEncryptionMode.Always>です。  
  
   
  
## Examples  
 ビュー ステートの暗号化モードを設定する次のコード例を示します、<xref:System.Web.UI.Page>オブジェクトおよびからビュー ステートの暗号化を要求している<xref:System.Web.UI.Page.RegisterRequiresViewStateEncryption%2A>です。 この例では、ビュー ステートをデータベースから顧客情報を取得時に暗号化されます。  
  
 [!code-aspx-csharp[System.Web.UI.ViewStateEncryptionMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ViewStateEncryptionMode/CS/encryptViewState.cs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ViewStateEncryptionMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ViewStateEncryptionMode/VB/encryptViewState.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Web.UI.Page.RegisterRequiresViewStateEncryption" />前に、またはページの中に、メソッドを呼び出す必要があります<see langword="PreRender" />ページ ライフ サイクルの段階です。</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public virtual void RegisterStartupScript (string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterStartupScript(string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterStartupScript(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.RegisterStartupScript(Type type, string key, string script). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">スクリプト ブロックを識別する一意のキー。</param>
        <param name="script">クライアントに送信されるスクリプトの内容。</param>
        <summary>ページの応答でクライアント側のスクリプト ブロックを出力します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ような<xref:System.Web.UI.Page.RegisterClientScriptBlock%2A>メソッド、<xref:System.Web.UI.Page.RegisterStartupScript%2A>メソッドの終了タグの直前に、スクリプトの生成、<xref:System.Web.UI.Page>オブジェクトの`<form runat= server>`要素。 必ず開始タグと終了を`<script>`スクリプトの周りに要素のブロックで指定した文字列、`script`パラメーター。  
  
 このメソッドは、スクリプト ブロックを識別するキーを使用するため、スクリプト ブロックを別のサーバー コントロールのインスタンスから要求されるたびに出力ストリームに出力する必要はありません。  
  
 いずれかのスクリプトで、同じブロック`key`パラメーター値が重複と見なされます。  
  
> [!NOTE]
>  要求側のブラウザーがスクリプトをサポートしていない場合は表示されないように、HTML コメント タグで囲みます、スクリプトを含めるに注意してください。  
  
 <xref:System.Web.UI.Page.RegisterStartupScript%2A> メソッドの使用は推奨されていません。 使用して、<xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>メソッドで、<xref:System.Web.UI.ClientScriptManager>クラスの代わりにします。  
  
   
  
## Examples  
 使用を次のコード例に示します、<xref:System.Web.UI.Page.RegisterStartupScript%2A>メソッドと組み合わせて、<xref:System.Web.UI.Page.IsStartupScriptRegistered%2A>メソッドです。 コード宣言ブロックで記述された ECMAScript が既に登録されていない場合、によって決定される、 <xref:System.Web.UI.Page.IsStartupScriptRegistered%2A> 、メソッド、<xref:System.Web.UI.Page.RegisterStartupScript%2A>呼び出しが行われます。  
  
 [!code-aspx-csharp[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/CS/defaultcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/VB/defaultvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterViewStateHandler">
      <MemberSignature Language="C#" Value="public void RegisterViewStateHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterViewStateHandler() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterViewStateHandler" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ページ ビュー状態、永続化するのと呼ばれる場合に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.RegisterViewStateHandler%2A>経由メソッドで自動的に呼び出され、<xref:System.Web.UI.HtmlControls.HtmlForm>サーバー コントロールです。 このメソッドが呼び出されない場合、ページのビュー状態は保持されません。  
  
> [!NOTE]
>  通常、のみ、<xref:System.Web.UI.HtmlControls.HtmlForm>ページのサーバー コントロールは、このメソッドを呼び出します。  
  
   
  
## Examples  
 [!code-csharp[Page_RegisterViewStateHandler#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RegisterViewStateHandler/CS/page_registerviewstatehandler.cs#1)]
 [!code-vb[Page_RegisterViewStateHandler#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RegisterViewStateHandler/VB/page_registerviewstatehandler.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected override void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer"><see cref="T:System.Web.UI.HtmlTextWriter" />ページのコンテンツを受け取る。</param>
        <summary>初期化、<see cref="T:System.Web.UI.HtmlTextWriter" />オブジェクトとの子コントロールでの呼び出し、<see cref="T:System.Web.UI.Page" />をレンダリングします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.Render%2A>メソッドは、テキスト、およびクライアントのブラウザーに送信されるマークアップの作成を担当します。 既定値<xref:System.Web.UI.Page.Render%2A>メソッド呼び出し<xref:System.Web.UI.Control.RenderChildren%2A>テキストと、ページに含まれるコントロールのマークアップを記述します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Request">
      <MemberSignature Language="C#" Value="public System.Web.HttpRequest Request { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpRequest Request" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Request" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpRequest</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要求されたページの <see cref="T:System.Web.HttpRequest" /> オブジェクトを取得します。</summary>
        <value>現在<see cref="T:System.Web.HttpRequest" />ページに関連付けられています。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpRequest> オブジェクトには、現在の HTTP 要求に関する情報が含まれています。  
  
   
  
## Examples  
 次の例では、取得する方法、<xref:System.Web.HttpRequest.Headers%2A>コレクションから、<xref:System.Web.HttpRequest>オブジェクトし、ASP.NET ページへの書き込み。  
  
 [!code-csharp[Classic HttpRequest.Headers Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Headers Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Headers Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Headers Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">発生したときに、<see cref="T:System.Web.HttpRequest" />オブジェクトは使用できません。</exception>
      </Docs>
    </Member>
    <Member MemberName="RequiresControlState">
      <MemberSignature Language="C#" Value="public bool RequiresControlState (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RequiresControlState(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RequiresControlState(System.Web.UI.Control)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control"><see cref="T:System.Web.UI.Control" />コントロールの状態の要件を確認します。</param>
        <summary>決定するかどうか、指定した<see cref="T:System.Web.UI.Control" />コントロール状態管理に参加するオブジェクトを登録します。</summary>
        <returns>
          <see langword="true" />場合、指定した<see cref="T:System.Web.UI.Control" />コントロールが必要です、それ以外の状態<see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロールの状態は、Web サーバー コントロールが機能するために必要なビューステート データの重要なので構成されるオブジェクトこれは通常のビュー状態から別のオブジェクトに含まれています。  
  
 コントロールの状態を使用してカスタム コントロールを呼び出す必要があります、<xref:System.Web.UI.Page.RegisterRequiresControlState%2A>コントロールの状態を保存する前にメソッドです。 使用して、<xref:System.Web.UI.Page.RequiresControlState%2A>コントロールの状態を必要とすると、ページに登録されているコントロールをチェックするメソッド。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Response">
      <MemberSignature Language="C#" Value="public System.Web.HttpResponse Response { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpResponse Response" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Response" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpResponse</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.Page" /> オブジェクトに関連付けられている <see cref="T:System.Web.HttpResponse" /> オブジェクトを取得します。 このオブジェクトでは、HTTP 応答データをクライアントに送信し、その応答に関する情報を含めることができます。</summary>
        <value>現在<see cref="T:System.Web.HttpResponse" />ページに関連付けられています。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例は、cookie を作成してを使用して、ページの HTTP 出力への追加を示しています、<xref:System.Web.HttpResponse>オブジェクト。  
  
 [!code-csharp[Classic HttpResponse.Cookies Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Cookies Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><see cref="T:System.Web.HttpResponse" />オブジェクトは使用できません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResponseEncoding">
      <MemberSignature Language="C#" Value="public string ResponseEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ResponseEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ResponseEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のエンコーディングの言語設定<see cref="T:System.Web.HttpResponse" />オブジェクト。</summary>
        <value>現在のエンコーディングの言語を表す文字列<see cref="T:System.Web.HttpResponse" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ほとんどの状況では、コードでこのプロパティを設定しないでください。 設定、`ResponseEncoding`属性を .aspx ファイルで、ディレクティブを使用する値にします。 ページが要求されると、動的に生成されたクラスは、プロパティを設定します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RouteData">
      <MemberSignature Language="C#" Value="public System.Web.Routing.RouteData RouteData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Routing.RouteData RouteData" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.RouteData" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.Routing.RouteData</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得、 <see cref="P:System.Web.Routing.RequestContext.RouteData" /> 、現在の値<see cref="T:System.Web.Routing.RequestContext" />インスタンス。</summary>
        <value><see cref="P:System.Web.Routing.RequestContext.RouteData" /> 、現在の値<see cref="T:System.Web.Routing.RequestContext" />インスタンス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ページが ASP.NET ルーティングを通じて行われた要求に対する応答で実行されている場合、このプロパティは、ルート データとして渡された URL パラメーター値へのアクセスを提供します。 このプロパティは、実行する場合、ページのルート URL ではなく物理 URL への応答、`null`です。 次の例は、という名前は URL パラメーターの値を抽出する方法を示しています。`year`です。  
  
```vb  
Dim year As Integer = Convert.ToInt32(Page.RouteData.Values("year"))  
```  
  
```csharp  
int year = Convert.ToInt32(Page.RouteData.Values["year"])  
```  
  
 ルートが URL パターンを使用して定義されているかどうかは`{locale}/{year}`ドメインの`contoso.com`、および要求された URL が`contoso.com/US/2010`、 `year` 「2010」このコードを実行すると、値が含まれます。  
  
 ASP.NET ルーティングの詳細については、次を参照してください。 [ASP.NET ルーティング](http://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SavePageStateToPersistenceMedium">
      <MemberSignature Language="C#" Value="protected virtual void SavePageStateToPersistenceMedium (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void SavePageStateToPersistenceMedium(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.SavePageStateToPersistenceMedium(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state"><see cref="T:System.Object" />ビュー ステート情報を格納します。</param>
        <summary>ページのビュー状態とコントロールの状態情報を保存します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.SavePageStateToPersistenceMedium%2A>メソッドを使用、<xref:System.Web.UI.PageStatePersister.Save%2A>のメソッド、<xref:System.Web.UI.PageStatePersister?displayProperty=nameWithType>によって参照されるオブジェクト、<xref:System.Web.UI.Page.PageStatePersister%2A>ページのビュー状態とコントロールの状態情報を格納するプロパティです。  
  
 ASP.NET には 2 つのサブフォルダーが含まれています、<xref:System.Web.UI.PageStatePersister>クラス、 <xref:System.Web.UI.HiddenFieldPageStatePersister> ASP.NET ページに含まれる非表示フィールドの状態情報を保存するクラスと<xref:System.Web.UI.SessionPageStatePersister>で状態を保存するクラス、<xref:System.Web.UI.Page.Session%2A>要求に関連付けられているオブジェクト。 使用すると、<xref:System.Web.UI.SessionPageStatePersister>クラスがポストバックを決定するのに使用と、非表示の VIEWSTATE フィールドは引き続きレンダリングされます。  
  
 任意の場所で状態を保存する必要がありますを作成する新しいの子孫、<xref:System.Web.UI.PageStatePersister>クラスを保存し、任意の永続メディアへの状態を読み込みます。 新たに作成する例については<xref:System.Web.UI.PageStatePersister>オブジェクトを参照してください、<xref:System.Web.UI.PageStatePersister>クラスです。  
  
 .NET Framework version 1.0 または 1.1 では、保存する場合は、このメソッドをオーバーライドを使用している場合、<xref:System.Web.UI.Page>で非表示フィールド以外の何かの状態。 またをオーバーライドする必要があるように選択した場合、<xref:System.Web.UI.Page.LoadPageStateFromPersistenceMedium%2A>メソッドです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveStateComplete">
      <MemberSignature Language="C#" Value="public event EventHandler SaveStateComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SaveStateComplete" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.SaveStateComplete" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページには、すべての状態とコントロールのビューステート情報は、ページの保存が完了した後に発生し、ページで制御します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 後に Web ページ上のコントロールの状態情報が保存された、<xref:System.Web.UI.Page.PreRenderComplete>イベント。 <xref:System.Web.UI.Page.SaveStateComplete>ビュー状態とページのコントロールの状態の後にイベントが発生し、ページ上のコントロールは、永続化に使用するメディアに保存されます。  
  
 これは、最後のページが要求側のブラウザーにレンダリングされる前に発生するイベントです。  
  
 イベント処理の詳細については、次を参照してください。[イベント](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Server">
      <MemberSignature Language="C#" Value="public System.Web.HttpServerUtility Server { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpServerUtility Server" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Server" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpServerUtility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得、<see langword="Server" />インスタンスであるオブジェクトの<see cref="T:System.Web.HttpServerUtility" />クラスです。</summary>
        <value>現在<see langword="Server" />ページに関連付けられているオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、頻繁に使用されるへのアクセスを提供<xref:System.Web.HttpServerUtility.HtmlEncode%2A>と<xref:System.Web.HttpServerUtility.MapPath%2A>の他のメソッドです。  
  
   
  
## Examples  
 次のコード例を使用して、サーバーからエラー情報にアクセスする方法を示しています、`Server`オブジェクト。 具体的から要求された URL の取得の例、`Request`オブジェクトから最新のエラー、`Server`オブジェクト (を使用して、<xref:System.Web.HttpServerUtility.GetLastError%2A>メソッド) と、その両方をクライアントで表示できる文字列に変換します。 1 回、`message`変数が、クライアントに書き込まれるを使用して、エラーを削除、<xref:System.Web.HttpServerUtility.ClearError%2A>メソッドです。  
  
 [!code-csharp[System.Web.UI.Page_Error method#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_Error method/CS/sourcecs.aspx#1)]
 [!code-vb[System.Web.UI.Page_Error method#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_Error method/VB/sourcevb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Session">
      <MemberSignature Language="C#" Value="public virtual System.Web.SessionState.HttpSessionState Session { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.SessionState.HttpSessionState Session" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Session" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.SessionState.HttpSessionState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の取得<see langword="Session" />ASP.NET によって提供されるオブジェクト。</summary>
        <value>現在のセッション状態データ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、現在の要求のセッションに関する情報を提供します。 A `Session` ASP.NET アプリケーションからのページまたはドキュメントを要求するユーザーごとにオブジェクトが保持されます。 格納されている変数、`Session`ユーザーがアプリケーションでページ間を移動すると、オブジェクトが破棄されません。 ユーザーは、アプリケーション内のページにアクセスする限り、代わりに、これらの変数を永続化します。 セッション状態の詳細については、次を参照してください。 [ASP.NET セッション状態の概要](http://msdn.microsoft.com/library/6d60d381-6521-4e1d-9089-da6464f2a9bc)です。  
  
   
  
## Examples  
 次のコード例を作成、 `GetStyle` Web フォーム ページのセッションの状態で格納されているキーを取得し、その値を文字列に変換する関数。  
  
 [!code-csharp[Page.Session_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page.Session_Samples1/CS/sessioncs.aspx#1)]
 [!code-vb[Page.Session_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page.Session_Samples1/VB/sessionvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">セッション情報に設定されているときに発生<see langword="null" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetFocus">
      <MemberSignature Language="C#" Value="public void SetFocus (string clientID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetFocus(string clientID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.SetFocus(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clientID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clientID">フォーカスを設定するコントロールの ID。</param>
        <summary>指定した識別子を持つコントロールには、ブラウザーのフォーカスを設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Web.UI.Page.SetFocus%2A>ブラウザーで表示される Web ページにアクティブなコントロールの文字列を指定した ID を持つコントロールを作成するメソッド。 <xref:System.Web.UI.Page.SetFocus%2A>ページがクライアントに表示用に準備する前に、メソッドを呼び出す必要があります、<xref:System.Web.UI.Control.PreRender>イベント。  
  
> [!NOTE]
>  <xref:System.Web.UI.Page.SetFocus%2A>メソッドがサポートする ECMAScript バージョン 1.3 またはそれ以降のブラウザーでのみ動作します。  
  
   
  
## Examples  
 次のコード例は、Web ページで、2 つ目のテキスト ボックスに、フォーカスを設定します。  
  
> [!IMPORTANT]
>  この例には、ユーザー入力を受け付けるテキスト ボックスがあります。これにより、セキュリティが脆弱になる可能性があります。 既定では、ASP.NET Web ページによって、ユーザー入力にスクリプトまたは HTML 要素が含まれていないかどうかが検証されます。 詳細については、次を参照してください。[スクリプト悪用概要](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)です。  
  
 [!code-aspx-csharp[PageSetFocus#1](~/samples/snippets/csharp/VS_Snippets_WebNet/PageSetFocus/CS/setfocusbyidcs.aspx#1)]
 [!code-aspx-vb[PageSetFocus#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageSetFocus/VB/setfocusbyidvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="clientID" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Web.UI.Page.SetFocus(System.String)" />コントロールは、Web フォーム ページの一部ではないときに呼び出されます。  
  
 \- または  
  
 <see cref="M:System.Web.UI.Page.SetFocus(System.String)" />後に呼び出されます、<see cref="E:System.Web.UI.Control.PreRender" />イベント。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetFocus">
      <MemberSignature Language="C#" Value="public void SetFocus (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetFocus(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.SetFocus(System.Web.UI.Control)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">フォーカスを受け取るコントロール。</param>
        <summary>ブラウザーのフォーカスを、指定したコントロールに設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Web.UI.Page.SetFocus%2A>を指定したコントロール、ブラウザーで表示される Web ページ上のアクティブ コントロールを作成するメソッド。 <xref:System.Web.UI.Page.SetFocus%2A>ページがクライアントに表示用に準備する前に、メソッドを呼び出す必要があります、<xref:System.Web.UI.Control.PreRender>イベント。  
  
> [!NOTE]
>  <xref:System.Web.UI.Page.SetFocus%2A>メソッドがサポートする ECMAScript バージョン 1.3 またはそれ以降のブラウザーでのみ動作します。  
  
   
  
## Examples  
 次のコード例は、Web ページで、2 つ目のテキスト ボックスに、フォーカスを設定します。  
  
> [!IMPORTANT]
>  この例には、ユーザー入力を受け付けるテキスト ボックスがあります。これにより、セキュリティが脆弱になる可能性があります。 既定では、ASP.NET Web ページによって、ユーザー入力にスクリプトまたは HTML 要素が含まれていないかどうかが検証されます。 詳細については、次を参照してください。[スクリプト悪用概要](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)です。  
  
 [!code-aspx-csharp[PageSetFocus#2](~/samples/snippets/csharp/VS_Snippets_WebNet/PageSetFocus/CS/setfocusbycontrolcs.aspx#2)]
 [!code-aspx-vb[PageSetFocus#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageSetFocus/VB/setfocusbycontrolvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="control" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Web.UI.Page.SetFocus(System.Web.UI.Control)" />コントロールは、Web フォーム ページの一部ではないときに呼び出されます。  
  
 \- または  
  
 <see cref="M:System.Web.UI.Page.SetFocus(System.Web.UI.Control)" />後に呼び出されます、<see cref="E:System.Web.UI.Control.PreRender" />イベント。</exception>
      </Docs>
    </Member>
    <Member MemberName="SkipFormActionValidation">
      <MemberSignature Language="C#" Value="public bool SkipFormActionValidation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SkipFormActionValidation" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.SkipFormActionValidation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはクエリ文字列の値を検証するかどうかを示す値を設定します。</summary>
        <value>
          <see langword="true" />クエリ文字列の検証をスキップする必要がある場合 (クエリ文字列を検証しない) です。それ以外の場合、<see langword="false" />クエリ文字列の検証を実行する必要がある場合は、正常に配置します。 既定値は、<see langword="false" /> です。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SmartNavigation">
      <MemberSignature Language="C#" Value="public bool SmartNavigation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SmartNavigation" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.SmartNavigation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is Page.SetFocus and Page.MaintainScrollPositionOnPostBack. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Filterable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スマート移動できるかどうかを示す値を取得または設定します。 このプロパティの使用は推奨されていません。</summary>
        <value>
          スマート移動が有効な場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ほとんどの状況では、コードでこのプロパティを設定しないでください。 設定、`SmartNavigation`属性を`true`.aspx ファイルでは、ディレクティブにします。 ページが要求されたときに、動的に生成されたクラスは、このプロパティを設定します。  
  
> [!NOTE]
>  ASP.NET version 2.0 では、<xref:System.Web.UI.Page.SmartNavigation%2A>プロパティは推奨されなくなりました。 使用して、<xref:System.Web.UI.Page.SetFocus%2A>メソッドおよび<xref:System.Web.UI.Page.MaintainScrollPositionOnPostBack%2A>プロパティ代わりにします。  
  
 Microsoft Internet Explorer 5.5 ブラウザー、または後で、スマート ナビゲーションによってページが要求された場合は、次を実行して、ページのユーザーのエクスペリエンスが向上します。  
  
-   ナビゲーションの原因となった flash を排除します。  
  
-   ページ間を移動するときは、スクロール位置を保持します。  
  
-   ナビゲーションの間で要素のフォーカスを保持します。  
  
-   ブラウザーの履歴の最後のページ状態のみを保持します。  
  
 スマート ナビゲーションは、頻繁なポストバックを必要とする ASP.NET ページではなく、戻り値の大きな変化はない visual のコンテンツを最も効果的です。 このプロパティを設定するかどうかを決定する際に慎重に検討この`true`です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleSheetTheme">
      <MemberSignature Language="C#" Value="public virtual string StyleSheetTheme { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StyleSheetTheme" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.StyleSheetTheme" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Filterable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはページのライフ サイクルの早い段階でのページに適用されているテーマの名前を設定します。</summary>
        <value>ページのライフ サイクルの早い段階でのページに適用されているテーマの名前。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、カスケード スタイル シート (CSS) に直接参照していません。 プロパティには、その中の CSS ファイルを含めることができる ASP.NET のテーマの名前が含まれています。  
  
 <xref:System.Web.UI.Page.StyleSheetTheme%2A>一方、プロパティがページのライフ サイクルの早い段階で、ページに適用されているテーマの名前を指定、<xref:System.Web.UI.Page.Theme%2A>プロパティ ページのライフ サイクルの後半のページに適用されているテーマの名前を指定します。 つまり、ページの設定は優先されるスタイル シートのテーマでの設定。 詳細については、次を参照してください。 [ASP.NET のテーマとスキン](http://msdn.microsoft.com/library/5df3ebbd-d46c-4502-9406-02f9df4ef2c3)です。  
  
 通常、ページ ディレクティブまたはプロパティをオーバーライドすることでは、このプロパティの値を設定します。 については、次のトピックを参照してください。  
  
-   [方法: ASP.NET のテーマを適用](http://msdn.microsoft.com/library/f9d72364-4d77-4b73-84be-7630dc63e0fe)  
  
-   [方法: ASP.NET のテーマをプログラムによって適用](http://msdn.microsoft.com/library/02eed7c3-01e8-4e20-8358-df47dbd4f148))  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">設定しようとしましたが、<see cref="P:System.Web.UI.Page.StyleSheetTheme" />後プロパティ、<see cref="M:System.Web.UI.Page.FrameworkInitialize" />メソッドが呼び出されました。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Web.UI.Page.StyleSheetTheme" />無効なテーマ名に設定されます。 この例外がスローされたときに、<see cref="M:System.Web.UI.Page.FrameworkInitialize" />プロパティ set アクセス操作子ではなく、メソッドが呼び出されます。</exception>
      </Docs>
    </Member>
    <Member MemberName="Theme">
      <MemberSignature Language="C#" Value="public virtual string Theme { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Theme" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Theme" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはページのテーマの名前を設定します。</summary>
        <value>ページのテーマの名前。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.Theme%2A>プロパティ ページを使用するテーマの名前を設定します。 テーマの設定よりも優先する ページで設定する場合は、使用、<xref:System.Web.UI.Page.StyleSheetTheme%2A>プロパティです。 詳細については、次を参照してください。 [ASP.NET のテーマとスキン](http://msdn.microsoft.com/library/5df3ebbd-d46c-4502-9406-02f9df4ef2c3)です。  
  
 <xref:System.Web.UI.Page.Theme%2A>前にプロパティを設定する必要があります、<xref:System.Web.UI.Page.PreInit>イベント以外の設定、<xref:System.Web.UI.Page.Theme%2A>後プロパティ、<xref:System.Web.UI.Page.PreInit>イベントが発生、<xref:System.InvalidOperationException>例外。  
  
 指定されたテーマは、アプリケーションまたはグローバル テーマのいずれかとして存在する必要があります。 テーマが存在しない場合、<xref:System.Web.HttpException>例外がスローされます。  
  
   
  
## Examples  
 次のコード例のセット、<xref:System.Web.UI.Page.Theme%2A>クエリ文字列内の名前プロパティに渡されます。  
  
 [!code-csharp[PageTheme#1](~/samples/snippets/csharp/VS_Snippets_WebNet/PageTheme/CS/pagethemecs.aspx#1)]
 [!code-vb[PageTheme#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageTheme/VB/pagethemevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">設定しようとした<see cref="P:System.Web.UI.Page.Theme" />後、<see cref="E:System.Web.UI.Page.PreInit" />イベントが発生しました。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Web.UI.Page.Theme" />無効なテーマ名に設定されます。</exception>
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Title" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Title" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはページのタイトルを設定します。</summary>
        <value>ページのタイトル。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Web.UI.Page.Title%2A>プロパティを要求元のブラウザーに送信された HTML ヘッダーのページのタイトルを設定します。  
  
> [!NOTE]
>  ページを含める必要があります、`head`要素、属性を持つ`runat="server"`、それ以外の場合、タイトルが表示されません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Web.UI.Page.Title" />プロパティ ページにヘッダー コントロールが必要です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Trace">
      <MemberSignature Language="C#" Value="public System.Web.TraceContext Trace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.TraceContext Trace" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Trace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.TraceContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の Web 要求に対する <see cref="T:System.Web.TraceContext" /> オブジェクトを取得します。</summary>
        <value>データを<see cref="T:System.Web.TraceContext" />の現在の Web 要求のオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 トレースは、追跡し、Web 要求に関する実行の詳細を表示します。 トレース データをページに表示する、ページまたはアプリケーション レベルでトレースを有効にする必要があります。  
  
 既定では、ページのトレースが無効です。 ページのトレースを有効にするには、ディレクティブを使って`<% @ Page trace="true" %>`です。 アプリケーション全体のトレースを有効にするには、アプリケーションの構成ファイル、アプリケーションのルート ディレクトリに配置され、web.config ファイルで有効にする必要があります。 詳細については、次を参照してください。 [ASP.NET のトレースの概要](http://msdn.microsoft.com/library/1552561d-887c-4002-8770-f92662cdf416)です。  
  
   
  
## Examples  
 次のコード例へのアクセスを示しています、<xref:System.Web.TraceContext.IsEnabled%2A?displayProperty=nameWithType>プロパティおよび<xref:System.Web.TraceContext.Write%2A?displayProperty=nameWithType>メソッドによって、<xref:System.Web.UI.Page.Trace%2A>プロパティです。 このコードを呼び出す、<xref:System.Diagnostics.Trace.Write%2A>メソッドをトレースする場合にのみが有効になって、<xref:System.Web.UI.Page>オブジェクト。 これは有効でない場合、このコードは実行されません、アプリケーションのオーバーヘッドの削減に役立ちます。  
  
 [!code-csharp[System.Web.UI.Page.Trace#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Trace/CS/trace1cs.aspx#2)]
 [!code-vb[System.Web.UI.Page.Trace#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Trace/VB/trace1vb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TraceEnabled">
      <MemberSignature Language="C#" Value="public bool TraceEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TraceEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.TraceEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>トレースが有効かどうかを示す値を設定、<see cref="T:System.Web.UI.Page" />オブジェクト。</summary>
        <value>
          <see langword="true" />ページのトレースが有効になっている場合それ以外の場合、<see langword="false" />です。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ほとんどの状況では、コードでこのプロパティを設定しないでください。 設定、`Trace`属性を`true`.aspx ファイルでは、ディレクティブにします。 ページが要求されると、動的に生成されたクラスは、プロパティを設定します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TraceModeValue">
      <MemberSignature Language="C#" Value="public System.Web.TraceMode TraceModeValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.TraceMode TraceModeValue" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.TraceModeValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.TraceMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>トレース ステートメントは、ページに表示されるモードを設定します。</summary>
        <value>1 つ、<see cref="T:System.Web.TraceMode" />列挙型メンバー。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ほとんどの状況では、コードでこのプロパティを設定しないでください。 設定、 `TraceMode` .aspx ファイルでは、ディレクティブの属性です。 ページが要求されると、動的に生成されたクラスは、プロパティを設定します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TransactionMode">
      <MemberSignature Language="C#" Value="protected int TransactionMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TransactionMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.TransactionMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページのサポートのトランザクションのレベルを設定します。</summary>
        <value>いずれかを表す整数、<see cref="T:System.EnterpriseServices.TransactionOption" />列挙型メンバー。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ほとんどの状況では、コードでこのプロパティを設定しないでください。 設定、 `Transaction` .aspx ファイルでは、ディレクティブの属性です。 ページが要求されると、動的に生成されたクラスは、プロパティを設定します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryUpdateModel&lt;TModel&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>値プロバイダー内の値を使用して、指定されたモデル インスタンスを更新します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Web フォーム モデル バインディングの使用に関するチュートリアル シリーズは、次を参照してください。[モデル バインディング機能と Web フォーム](http://go.microsoft.com/fwlink/?LinkId=286117)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryUpdateModel&lt;TModel&gt;">
      <MemberSignature Language="C#" Value="public virtual bool TryUpdateModel&lt;TModel&gt; (TModel model) where TModel : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryUpdateModel&lt;class TModel&gt;(!!TModel model) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.TryUpdateModel``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TModel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="model" Type="TModel" />
      </Parameters>
      <Docs>
        <typeparam name="TModel">モデルの型。</typeparam>
        <param name="model">モデル。</param>
        <summary>データ バインド コントロールからの値を使用して、指定されたモデル インスタンスを更新します。</summary>
        <returns>
          <see langword="true" />モデル バインディングが成功した場合それ以外の場合、<see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、データ バインド コントロールの指定されたメソッドからのみ呼び出す必要があります`UpdateMethod`または`InsertMethod`プロパティです。  
  
 Web フォーム モデル バインディングの使用に関するチュートリアル シリーズは、次を参照してください。[モデル バインディング機能と Web フォーム](http://go.microsoft.com/fwlink/?LinkId=286117)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryUpdateModel&lt;TModel&gt;">
      <MemberSignature Language="C#" Value="public virtual bool TryUpdateModel&lt;TModel&gt; (TModel model, System.Web.ModelBinding.IValueProvider valueProvider) where TModel : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryUpdateModel&lt;class TModel&gt;(!!TModel model, class System.Web.ModelBinding.IValueProvider valueProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.TryUpdateModel``1(``0,System.Web.ModelBinding.IValueProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TModel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="model" Type="TModel" />
        <Parameter Name="valueProvider" Type="System.Web.ModelBinding.IValueProvider" />
      </Parameters>
      <Docs>
        <typeparam name="TModel">モデルの型。</typeparam>
        <param name="model">モデル。</param>
        <param name="valueProvider">値プロバイダー。</param>
        <summary>指定された値プロバイダー内の値を使用してモデル インスタンスを更新します。</summary>
        <returns>
          <see langword="true" />モデル バインディングが成功した場合それ以外の場合、<see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Web フォーム モデル バインディングの使用に関するチュートリアル シリーズは、次を参照してください。[モデル バインディング機能と Web フォーム](http://go.microsoft.com/fwlink/?LinkId=286117)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UICulture">
      <MemberSignature Language="C#" Value="public string UICulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UICulture" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.UICulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザー インターフェイス (UI) の ID を設定、<see cref="T:System.Threading.Thread" />ページに関連付けられているオブジェクト。</summary>
        <value>UI の id。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ショートカットをこのプロパティは、<xref:System.Threading.Thread.CurrentThread%2A>プロパティです。 カルチャは、実行中のスレッドのプロパティ  
  
 設定、 `UICulture` .aspx ファイルでは、ディレクティブの属性です。 ページが要求されたときに、動的に生成されたクラスは、このプロパティの値を設定します。 値を明示的に設定するさらに、<xref:System.Web.UI.Page.UICulture%2A>プロパティに、Web.config ファイルのです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UniqueFilePathSuffix">
      <MemberSignature Language="C#" Value="protected virtual string UniqueFilePathSuffix { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UniqueFilePathSuffix" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.UniqueFilePathSuffix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ブラウザーをキャッシュ ファイルのファイル パスに追加する固有のサフィックスを取得します。</summary>
        <value>ファイルのパスに追加される一意なサフィックス。 既定値は"_ufps ="さらに 6 桁の一意の数字です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.UniqueFilePathSuffix%2A>プロパティ ブラウザーのキャッシュに必要な場合は、ファイル パスの末尾に追加される文字列を返します。 文字列を使用して、特定の要求に関連付けられているファイルのパスを識別します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnobtrusiveValidationMode">
      <MemberSignature Language="C#" Value="public System.Web.UI.UnobtrusiveValidationMode UnobtrusiveValidationMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.UnobtrusiveValidationMode UnobtrusiveValidationMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.UnobtrusiveValidationMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.UnobtrusiveValidationMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはクライアント側の検証の控えめな JavaScript を使用するかどうかを示す値を設定します。</summary>
        <value>
          <see langword="true" />控えめな JavaScript を使用する場合それ以外の場合、<see langword="false" />です。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterRequiresControlState">
      <MemberSignature Language="C#" Value="public void UnregisterRequiresControlState (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterRequiresControlState(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.UnregisterRequiresControlState(System.Web.UI.Control)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control"><see cref="T:System.Web.UI.Control" />コントロールの状態の永続化を停止します。</param>
        <summary>指定したコントロールのコントロールの状態の永続化を停止します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロールの状態を使用するカスタムのサーバー コントロールを呼び出す必要があります、<xref:System.Web.UI.Page.RegisterRequiresControlState%2A>要求のたびに、状態が永続化します。 コントロールの状態のための登録が引き継がれません要求から要求をポストバック時にします。 使用して、<xref:System.Web.UI.Page.UnregisterRequiresControlState%2A>ポストバックの永続化する必要がなくなったコントロールに対して、コントロールの状態が永続化されないことを確認します。  
  
 内部的には、<xref:System.Web.UI.Page.UnregisterRequiresControlState%2A>を使用する場合、メソッドが呼び出され、<xref:System.Web.UI.Control.RemovedControl%2A>コントロールをコントロール コレクションから削除する方法です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="T:System.Web.UI.Control" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="UpdateModel&lt;TModel&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>値プロバイダー内の値を使用して、指定されたモデル インスタンスを更新します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Web フォーム モデル バインディングの使用に関するチュートリアル シリーズは、次を参照してください。[モデル バインディング機能と Web フォーム](http://go.microsoft.com/fwlink/?LinkId=286117)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="UpdateModel&lt;TModel&gt;">
      <MemberSignature Language="C#" Value="public virtual void UpdateModel&lt;TModel&gt; (TModel model) where TModel : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UpdateModel&lt;class TModel&gt;(!!TModel model) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.UpdateModel``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TModel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="model" Type="TModel" />
      </Parameters>
      <Docs>
        <typeparam name="TModel">モデルの型。</typeparam>
        <param name="model">モデル。</param>
        <summary>データ バインド コントロールからの値を使用して、指定されたモデル インスタンスを更新します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、データ バインド コントロールの指定されたメソッドからのみ呼び出す必要があります`UpdateMethod`または`InsertMethod`プロパティです。  
  
 Web フォーム モデル バインディングの使用に関するチュートリアル シリーズは、次を参照してください。[モデル バインディング機能と Web フォーム](http://go.microsoft.com/fwlink/?LinkId=286117)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateModel&lt;TModel&gt;">
      <MemberSignature Language="C#" Value="public virtual void UpdateModel&lt;TModel&gt; (TModel model, System.Web.ModelBinding.IValueProvider valueProvider) where TModel : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UpdateModel&lt;class TModel&gt;(!!TModel model, class System.Web.ModelBinding.IValueProvider valueProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.UpdateModel``1(``0,System.Web.ModelBinding.IValueProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TModel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="model" Type="TModel" />
        <Parameter Name="valueProvider" Type="System.Web.ModelBinding.IValueProvider" />
      </Parameters>
      <Docs>
        <typeparam name="TModel">モデルの型。</typeparam>
        <param name="model">モデル。</param>
        <param name="valueProvider">値プロバイダー。</param>
        <summary>指定された値プロバイダー内の値を使用して、指定されたモデル インスタンスを更新します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Web フォーム モデル バインディングの使用に関するチュートリアル シリーズは、次を参照してください。[モデル バインディング機能と Web フォーム](http://go.microsoft.com/fwlink/?LinkId=286117)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="User">
      <MemberSignature Language="C#" Value="public System.Security.Principal.IPrincipal User { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.IPrincipal User" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.User" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページ要求を出しているユーザーに関する情報を取得します。</summary>
        <value><see cref="T:System.Security.Principal.IPrincipal" />ページ要求を行うユーザーを表すです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.Principal.IPrincipal>オブジェクトが、コードが実行されている、そのユーザーの id を含む、ユーザーとが所属するすべての役割のセキュリティ コンテキストを表します。  
  
 このプロパティを使用して、<xref:System.Web.HttpContext>オブジェクトの<xref:System.Web.HttpContext.User%2A>要求の発生源を決定するプロパティです。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Web.UI.Page.User%2A>プロパティを現在のユーザーの認証と id 情報にアクセスします。 ユーザーが認証されていない場合、ログイン ページにリダイレクトします。  
  
 [!code-csharp[Page_User#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_User/CS/page_user.cs.aspx#1)]
 [!code-vb[Page_User#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_User/VB/page_user.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public virtual void Validate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Validate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.Validate" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>割り当てられている情報を検証するページに含まれるすべての検証コントロールに指示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ユーザーが任意の ASP.NET サーバー コントロールがクリックしたときに、このメソッドが呼び出される、`CausesValidation`プロパティに設定`true`、既定値です。 含まれます、 <xref:System.Web.UI.WebControls.Button>、 <xref:System.Web.UI.WebControls.ImageButton>、および<xref:System.Web.UI.WebControls.LinkButton>Web サーバー コントロールを<xref:System.Web.UI.HtmlControls.HtmlInputButton>、 <xref:System.Web.UI.HtmlControls.HtmlInputImage>、および<xref:System.Web.UI.HtmlControls.HtmlButton>HTML サーバー コントロール、および自動的に投稿できるサーバーに戻すなどのコントロール、 <xref:System.Web.UI.WebControls.TextBox>、 <xref:System.Web.UI.WebControls.CheckBox>、 <xref:System.Web.UI.WebControls.ListControl>、および<xref:System.Web.UI.WebControls.BulletedList>コントロール。  
  
 ボタン コントロールの設定 ページで、ボタン コントロールの検証を無効にするには、`CausesValidation`プロパティを`false`です。  
  
 このメソッドが呼び出されると、反復に含まれている検証コントロール、<xref:System.Web.UI.ValidatorCollection>オブジェクトに関連付けられている、<xref:System.Web.UI.Page.Validators%2A?displayProperty=nameWithType>プロパティし、現在の検証グループ内の各検証コントロールの検証ロジックを呼び出します。 検証グループは、サーバーに、ページのポストバック コントロールによって決定されます。 検証グループが指定されていない場合は、検証グループは使用されません。  
  
> [!NOTE]
>  ページの検証の動作が変更されました。 [!INCLUDE[vstecasplong](~/includes/vstecasplong-md.md)]、不要になった呼び出しの制御、<xref:System.Web.UI.Page.Validate?displayProperty=nameWithType>メソッド以外の場合を使用して、<xref:System.Web.UI.Page.Validate%28System.String%29?displayProperty=nameWithType>メソッド代わりにします。 使用する場合、<xref:System.Web.UI.Page.Validate?displayProperty=nameWithType>メソッドを[!INCLUDE[vstecasplong](~/includes/vstecasplong-md.md)] ページで、検証グループは無視され、すべてのコントロールが検証されます。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Web.UI.Page.Validate%2A>メソッドをいくつかの異なる検証グループのシナリオでのページを定義します。  
  
> [!IMPORTANT]
>  この例には、ユーザー入力を受け付けるテキスト ボックスがあります。これにより、セキュリティが脆弱になる可能性があります。 既定では、ASP.NET Web ページによって、ユーザー入力にスクリプトまたは HTML 要素が含まれていないかどうかが検証されます。 詳細については、次を参照してください。[スクリプト悪用概要](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)です。  
  
 [!code-aspx-csharp[System.Web.UI.Page.Validate2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Validate2/cs/pagevalidatecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.Validate2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Validate2/vb/pagevalidatevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para><see cref="M:System.Web.UI.Page.Validate" />がメソッドを使用していない[!INCLUDE[vstecasplong](~/includes/vstecasplong-md.md)]です。 使用する場合は[!INCLUDE[vstecasplong](~/includes/vstecasplong-md.md)]、オーバーライド、<see cref="M:System.Web.UI.Page.Validate(System.String)" />ページ検証の動作を変更するメソッド。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public virtual void Validate (string validationGroup);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Validate(string validationGroup) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.Validate(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="validationGroup" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="validationGroup">検証するコントロールの検証グループ名。</param>
        <summary>割り当てられている情報を検証する、指定された検証グループの検証コントロールに指示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ユーザーが任意の ASP.NET サーバー コントロールがクリックしたときに、このメソッドが呼び出される、`CausesValidation`プロパティに設定`true`、既定値です。 含まれます、 <xref:System.Web.UI.WebControls.Button>、 <xref:System.Web.UI.WebControls.ImageButton>、および<xref:System.Web.UI.WebControls.LinkButton>Web サーバー コントロールを<xref:System.Web.UI.HtmlControls.HtmlInputButton>、 <xref:System.Web.UI.HtmlControls.HtmlInputImage>、および<xref:System.Web.UI.HtmlControls.HtmlButton>HTML サーバー コントロール、および自動的に投稿できるサーバーに戻すなどのコントロール、 <xref:System.Web.UI.WebControls.TextBox>、 <xref:System.Web.UI.WebControls.CheckBox>、 <xref:System.Web.UI.WebControls.ListControl>、および<xref:System.Web.UI.WebControls.BulletedList>コントロール。  
  
 ボタン コントロールの設定 ページで、ボタン コントロールの検証を無効にするには、`CausesValidation`プロパティを`false`です。  
  
 <xref:System.Web.UI.Page.Validate%2A>メソッドは、指定された検証グループを検証します。 呼び出した後、<xref:System.Web.UI.Page.Validate%2A>検証グループのメソッド、<xref:System.Web.UI.Page.IsValid%2A>メソッドが返す`true`指定された検証グループと、ページがサーバーにポストの原因となったコントロールの検証グループの両方が有効な場合にのみです。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Web.UI.Page.Validate%2A>メソッドをいくつかの異なる検証グループのシナリオでのページを定義します。  
  
> [!IMPORTANT]
>  この例には、ユーザー入力を受け付けるテキスト ボックスがあります。これにより、セキュリティが脆弱になる可能性があります。 既定では、ASP.NET Web ページによって、ユーザー入力にスクリプトまたは HTML 要素が含まれていないかどうかが検証されます。 詳細については、次を参照してください。[スクリプト悪用概要](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)です。  
  
 [!code-aspx-csharp[System.Web.UI.Page.Validate2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Validate2/cs/pagevalidatecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.Validate2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Validate2/vb/pagevalidatevb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateRequestMode">
      <MemberSignature Language="C#" Value="public override System.Web.UI.ValidateRequestMode ValidateRequestMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ValidateRequestMode ValidateRequestMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ValidateRequestMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ValidateRequestMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはページがクライアント ブラウザーからの入力の危険性のある値をチェックするかどうかを示す値を設定します。</summary>
        <value>ページがクライアントの入力を確認するかどうかを示す値。 既定値は、<see cref="F:System.Web.UI.ValidateRequestMode.Enabled" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 値<xref:System.Web.UI.ValidateRequestMode.Inherit>で使用されていない、<xref:System.Web.UI.Page>クラスから継承する項目がないためです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Validators">
      <MemberSignature Language="C#" Value="public System.Web.UI.ValidatorCollection Validators { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ValidatorCollection Validators" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Validators" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ValidatorCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要求されたページに含まれるすべての検証コントロールのコレクションを取得します。</summary>
        <value>検証コントロールのコレクション。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを使用するには、メソッドとプロパティを操作する、<xref:System.Web.UI.ValidatorCollection>オブジェクトに現在関連付けられている<xref:System.Web.UI.Page>インスタンス。 このコレクションには、ページに含まれているすべての検証サーバー コントロールが含まれています。  
  
 呼び出す、<xref:System.Web.UI.Page.Validate%2A?displayProperty=nameWithType>メソッドは、現在の検証グループ内の各検証サーバー コントロールで実行するための検証ロジックをによりします。 これらのコントロールのいずれかに失敗した場合、<xref:System.Web.UI.Page.IsValid%2A?displayProperty=nameWithType>プロパティから返される`false`です。  
  
 検証コントロールの詳細については、次を参照してください。 [ASP.NET の検証コントロール](http://msdn.microsoft.com/library/fa2aa14d-a461-492e-9a79-c990904613ef)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VerifyRenderingInServerForm">
      <MemberSignature Language="C#" Value="public virtual void VerifyRenderingInServerForm (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void VerifyRenderingInServerForm(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.VerifyRenderingInServerForm(System.Web.UI.Control)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">ASP.NET サーバー コントロールで必要な<see cref="T:System.Web.UI.HtmlControls.HtmlForm" />コントロール。</param>
        <summary>いることを確認、<see cref="T:System.Web.UI.HtmlControls.HtmlForm" />実行時に指定された ASP.NET サーバー コントロールにコントロールを表示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 内部にある必要があるコントロール`<form runat=server>`タグの外側に配置されるかどうか、エラー メッセージが表示されるように表示されるか前に、タグはこのメソッドを呼び出すことができます。 ポストバックまたは登録されたスクリプト ブロックに依存しているコントロールのオーバーライドでこのメソッドを呼び出す必要があります、<xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType>メソッドです。 サーバーのフォーム要素の表示方法が異なるページには、さまざまな条件で例外をスローするには、このメソッドをオーバーライドできます。  
  
 それらがで囲まれていない場合、ポストバックまたはクライアント側スクリプトを使用するサーバー コントロールは機能しません、<xref:System.Web.UI.HtmlControls.HtmlForm>サーバー コントロール (<`form runat="server">`) タグ。 囲まれていない、ときに、クリア エラー メッセージを表示するときに、これらのコントロールはこのメソッドを呼び出すことができます、<xref:System.Web.UI.HtmlControls.HtmlForm>コントロール。  
  
 カスタム サーバー コントロールを開発するときにするが一般的をオーバーライドする場合は、このメソッドを呼び出す、 `Render` input タグの任意の種類の方法です。 これは、入力コントロールを呼び出す場合に特に重要<xref:System.Web.UI.Page.GetPostBackEventReference%2A>、またはクライアント スクリプトを出力します。 複合サーバー コントロールは、この呼び出しを行う必要はありません。  
  
   
  
## Examples  
 次のコード例の上書き、<xref:System.Web.UI.Page.Render%2A?displayProperty=nameWithType>カスタム サーバー コントロールのメソッドです。 このコントロールは、ページにそのコンテンツを書き込むを使用して、<xref:System.Web.UI.Page.VerifyRenderingInServerForm%2A>開始タグと終了タグの間、コントロールが表示されることを確認するメソッド、<xref:System.Web.UI.HtmlControls.HtmlForm>コントロール。  
  
 [!code-csharp[System.Web.UI.Page_VerifyRenderingInServerForm#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_VerifyRenderingInServerForm/CS/testlinkbutton.cs#3)]
 [!code-vb[System.Web.UI.Page_VerifyRenderingInServerForm#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_VerifyRenderingInServerForm/vb/testlinkbutton.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">開始タグと終了タグの間、指定されたサーバー コントロールが含まれていない、<see cref="T:System.Web.UI.HtmlControls.HtmlForm" />実行時にサーバー コントロールです。</exception>
        <exception cref="T:System.ArgumentNullException">検証するコントロールは<see langword="null" />します。</exception>
      </Docs>
    </Member>
    <Member MemberName="ViewStateEncryptionMode">
      <MemberSignature Language="C#" Value="public System.Web.UI.ViewStateEncryptionMode ViewStateEncryptionMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ViewStateEncryptionMode ViewStateEncryptionMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ViewStateEncryptionMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ViewStateEncryptionMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはビューステートの暗号化モードを設定します。</summary>
        <value><see cref="T:System.Web.UI.ViewStateEncryptionMode" /> 値のいずれか。 既定値は <see cref="F:System.Web.UI.ViewStateEncryptionMode.Auto" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.ViewStateEncryptionMode%2A>コードでプロパティを設定することはできません。 のみ設定できますディレクティブまたは、< 構成ファイルの要素。 値は、ディレクティブのオーバーライドで、構成ファイルで設定された値を設定します。  
  
 ディレクティブ内でこのプロパティを設定するための構文は次のとおりです。  
  
```vb  
<%@ Page Language="VB" ViewStateEncryptionMode="Always" %>  
```  
  
```csharp  
<%@ Page Language="C#" ViewStateEncryptionMode="Always" %>  
```  
  
 構成ファイルでこのプロパティを設定するための構文は次のとおりです。  
  
```vb  
<system.web>  
  <pages viewStateEncryptionMode="Always" />  
</system.web>  
```  
  
```csharp  
<system.web>  
  <pages viewStateEncryptionMode="Always" />  
</system.web>  
```  
  
 カスタム コントロールの開発者は、コントロールの状態を表示する機密性の高いデータを保存する前にコードでこのプロパティの値を確認してみてください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">設定されている値がのメンバーではない、<see cref="T:System.Web.UI.ViewStateEncryptionMode" />列挙します。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Web.UI.Page.ViewStateEncryptionMode" />でのみ、またはページの前に、プロパティを設定できます<see langword="PreRender" />ページ ライフ サイクルの段階です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ViewStateUserKey">
      <MemberSignature Language="C#" Value="public string ViewStateUserKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ViewStateUserKey" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ViewStateUserKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のページに関連付けられているビュー ステートの変数に個々 のユーザーに id を割り当てます。</summary>
        <value>個々 のユーザーの識別子。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定、<xref:System.Web.UI.Page.ViewStateUserKey%2A>プロパティを使用して、悪意のあるユーザーからアプリケーションへの攻撃を防止できます。 これは、識別子、ビュー ステートを変数に割り当てる各ユーザーの攻撃を生成する、変数が使用できないようにすることによりします。 Web 攻撃およびそれらを防ぐために何ができるについての詳細については、次を参照してください。[かかるの ASP.NET 組み込み機能を利用 Web 攻撃オフ何とか](http://go.microsoft.com/fwlink/?LinkId=163557)です。  
  
 ユーザーに認証された名前など、このプロパティを任意の文字列値に設定することができます、または<xref:System.Web.SessionState.HttpSessionState.SessionID%2A>値。  
  
> [!NOTE]
>  中にこのプロパティを設定する必要があります、`Page_Init`ページ処理の段階です。 中にこのプロパティの設定、`Page_Load`フェーズが例外をスローします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><see cref="P:System.Web.UI.Page.ViewStateUserKey" />ページ処理中にプロパティが遅すぎますアクセスされました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public override bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定を示す値かどうか、<see cref="T:System.Web.UI.Page" />オブジェクトが表示されます。</summary>
        <value>
          <see langword="true" />場合、<see cref="T:System.Web.UI.Page" />レンダリングされた、それ以外には、<see langword="false" />です。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例のセット、<xref:System.Web.UI.Page.Visible%2A>プロパティを`false`ページの表示内容を非表示にします。 このページが最初に要求されたときに、データ ソースが設定され、ページに表示されます。 ユーザーは、ボタンをクリックしたときに、`HideButton_Click`イベント ハンドラーは、レンダリングされたページのコンテンツ全体を非表示にします。  
  
 [!code-csharp[Page_Visible#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_Visible/CS/page_visible.cs.aspx#1)]
 [!code-vb[Page_Visible#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_Visible/VB/page_visible.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
